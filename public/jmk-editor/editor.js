/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./Config.js":
/*!*******************!*\
  !*** ./Config.js ***!
  \*******************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function urlHashGetArguments() {
    var a = {}, b = window.location.hash;
    b && b.substring(1).split("&").forEach(function (b) {
        var c = b.indexOf("=");
        0 <= c ? a[b.substring(0, c)] = b.substring(c + 1) : a[b] = void 0
    });
    return a
}

// kaiwen 20210916,添加Referer获取参数的方法
function refererGetArguments() {
    var a = {}, b = document.referrer;
    b && b.substring(1).split("&").forEach(function (b) {
        var c = b.indexOf("=");
        0 <= c ? a[b.substring(0, c)] = b.substring(c + 1) : a[b] = void 0
    });
    return a
} 

function urlHashContains(b) {
    return b in urlHashGetArguments()
}

function refererContains(b) {
    return b in refererGetArguments()
}

window.JMT = {
    EDIT_MODE: urlHashContains("editor"),
    DEBUG: urlHashContains("debug"),
    DEBUG_SHARED_BUFFERS: urlHashContains("debugbuffers"),
    //ALWAYS_RENDER: !1,
    LOG_INFO: urlHashContains("log"),
    LOG_TO_SERVER: !1,
    LOG_TIME: !1,
    PROGRESSIVE_LOADER_AFTER_SEC: 30,
    CONTEXT_LOST_RESTORE_LIMIT: 4,
    DYNAMIC_LIGHTS: !1,
    HEAD_LIGHT: !1,
    RETRIES_ON_LOAD_ERROR: 3,
    DEFAULT_ANISOTROPY: 4,
    NO_ANISOTROPY: 1,
    FORCE_FXAA: !1,
    FONT_FAMILIES_TO_LOAD: [],
    CAMERA_WALK_NEAR: .1,
    CAMERA_ORBIT_NEAR: .05,
    CAMERA_MIN_FAR: 100,
    SKY_DISTANCE_TO_SCENE: 100,
    CAMERA_DEFAULT_FOV: 70,
    CAMERA_DEFAULT_MOVE_MAX_SPEED: 1.11,
    CAMERA_LOOK_SPEED: Math.PI / 1500,
    CAMERA_ARROWS_TURN_SPEED: Math.PI / 2,
    CAMERA_SCROLL_SPEED: .5,
    CAMERA_FULL_ACCELERATION_TIME: .5,
    CAMERA_FULL_DECELERATION_TIME: .166,
    MAX_GROUND_SEARCH_DEPTH: 5.5,
    COVER_JSON_URL: "cover.json",
    AUTO_TOUR_IN_VIEW_STILL_TIME_MS: 3E3,
    CLICK_MOVE_MIN_DISTANCE_TO_OBSTACLE: .7,
    KEY_MOVE_MIN_DISTANCE_TO_OBSTACLE: .1,
    MIN_DISTANCE_TO_CEILING: .1,
    LIGHT_PROBE_MIRROR_SIZE: 512,
    LIGHT_PROBE_MAX_MIP_SIZE: 128,
    LIGHT_PROBE_MIN_MIP_SIZE: 4,
    LIGHT_PROBE_GLOSS_FOR_MIP: [.99, .9, .85, .7, .4, .25],
    LIGHT_VISIBILITY_MAP_DOWNSAMPLE: 2,
    LIGHT_DISTANCE_PROBE_SIZE: 512,
    DEBUG_LIGHT_PROBE_MIPS: !1,
    ENABLE_AUTO_EXPOSURE_CONTROLS: !1,
    EDITOR_COVER_WIDTH: 1920,
    EDITOR_COVER_HEIGHT: 1080,
    MAX_PANORAMA_SIZE: 8192,
    OBJECT_VISIBILITY_PROBE_SIZE: 128,
    DEFAULT_SKY_NAME: "default",
    EDITOR_CONTROLLED_SKY_NAME: "sky0",
    EDITOR_SELECTION_COLOR: (new THREE.Color(5021401)).convertGammaToLinear(),
    APP_SELECTION_COLOR: (new THREE.Color(0xfefefe)).convertGammaToLinear(),
    ALLOW_MOBILE_VR: !0,
    VR_FALLBACK_CAMERA_HEIGHT: 1.6,
    LOAD_PRIORITY: {
        CORE_RESOURCE: 0,
        COLORMAP: 1,
        UV0: 1,
        DIFFUSE: 2,
        LIGHTMAP: 3,
        SKY: 4,
        SPECULARITY: 5,
        VIDEO: 6
    },
    MERGE_TRANSPARENT_DISABLED: urlHashContains("nomergetransparent"),
    urlHashContains: urlHashContains,
    refererContains: refererContains,
    urlHashGetArgument: function (b) {
        var c = urlHashGetArguments();
        return b in c && void 0 !== c[b] ? decodeURI(c[b]) : null
    },
    refererGetArgument: function (b) {
        var c = refererGetArguments();
        return b in c && void 0 !== c[b] ? decodeURI(c[b]) : null
    },
    urlHashRemoveArgument: function (b) {
        var c = urlHashGetArguments();
        return Object.keys(c).filter(function (a) {
            return a !== b
        }).map(function (a) {
            var b = c[a];
            return a + (void 0 === b ? "" : "=" + b)
        }).join("&")
    },
    isLocalhost: function () {
        return "localhost" === window.location.hostname || "127.0.0.1" === window.location.hostname
    },
    TELEPORT_TO_VIEW_MAX_TIME: 3,
    TELEPORT_TO_POINT_MAX_TIME: 4.5,
    TELEPORT_TO_VIEW_ACCELERATION: 4,
    GAZE_POINTER_SHOW_LOADING_AFTER_S: 2.5,
    GAZE_POINTER_ACTIVATE_AFTER_S: 4.5,
    SPRITE_ANCHOR_FONT_SIZE: 128,
    POINTER_PRIORITY: {
        TRANSFORM_CONTROLS: 1,
        ASSET_ALIGNMENT: 1.5,
        ASSET_SELECTOR: 2,
        EDITOR_SELECTOR: 3,
        INTERACTION_DISPATCHER: 4
    },
    BASIS_DECODE_WORKERS: Math.min(4, navigator.hardwareConcurrency || 4),
    HIDE_MEETING_EXTENSIONS_FROM_EDITOR: !0,
    ASSET_ADSORB: !0
};

let __alwaysRender_ = !1

Object.defineProperty(window.JMT, 'ALWAYS_RENDER', {

    get: ()=> {
        return __alwaysRender_
    },
    set: (value)=> {
        __alwaysRender_ = value
    }
})

window.WebXRConfig = {
    cardboardConfig: {
        ADDITIONAL_VIEWERS: [],
        DEFAULT_VIEWER: "",
        MOBILE_WAKE_LOCK: !0,
        DEBUG: !1,
        DPDB_URL: null,
        CARDBOARD_UI_DISABLED: !1,
        K_FILTER: .98,
        ROTATE_INSTRUCTIONS_DISABLED: !1,
        PREDICTION_TIME_S: .04,
        YAW_ONLY: !1,
        BUFFER_SCALE: 1,
        DIRTY_SUBMIT_FRAME_BINDINGS: !1
    }
};
window.GLC = {
    REPEAT: 10497,
    CLAMP_TO_EDGE: 33071,
    MIRRORED_REPEAT: 33648,
    NEAREST: 9728,
    LINEAR: 9729,
    NEAREST_MIPMAP_NEAREST: 9984,
    LINEAR_MIPMAP_NEAREST: 9985,
    NEAREST_MIPMAP_LINEAR: 9986,
    LINEAR_MIPMAP_LINEAR: 9987,
    BYTE: 5120,
    UNSIGNED_BYTE: 5121,
    SHORT: 5122,
    UNSIGNED_SHORT: 5123,
    INT: 5124,
    UNSIGNED_INT: 5125,
    FLOAT: 5126,
    UNSIGNED_SHORT_4_4_4_4: 32819,
    UNSIGNED_SHORT_5_5_5_1: 32820,
    UNSIGNED_SHORT_5_6_5: 33635,
    DEPTH_COMPONENT: 6402,
    ALPHA: 6406,
    RGB: 6407,
    RGBA: 6408,
    LUMINANCE: 6409,
    LUMINANCE_ALPHA: 6410,
    FUNC_ADD: 32774,
    FUNC_SUBTRACT: 32778,
    FUNC_REVERSE_SUBTRACT: 32779,
    ZERO: 0,
    ONE: 1,
    SRC_COLOR: 768,
    ONE_MINUS_SRC_COLOR: 769,
    SRC_ALPHA: 770,
    ONE_MINUS_SRC_ALPHA: 771,
    DST_ALPHA: 772,
    ONE_MINUS_DST_ALPHA: 773,
    DST_COLOR: 774,
    ONE_MINUS_DST_COLOR: 775,
    SRC_ALPHA_SATURATE: 776,
    CONSTANT_COLOR: 32769,
    ONE_MINUS_CONSTANT_COLOR: 32770,
    CONSTANT_ALPHA: 32771,
    ONE_MINUS_CONSTANT_ALPHA: 32772,
    HALF_FLOAT_OES: 36193,
    COMPRESSED_RGB_S3TC_DXT1_EXT: 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT: 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT: 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT: 33779,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 35840,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 35842,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 35841,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 35843,
    COMPRESSED_RGB_ETC1_WEBGL: 36196,
    COMPRESSED_RGBA_ASTC_4x4_KHR: 37808
};
window.$ = function (a) {
    return document.getElementById(a)
}


window.JMK = window.JMK || window.JMT

window.JMK.VERSION = "3.0.1"
console.log("Renderer Version ", window.JMK.VERSION)


/***/ }),

/***/ "./EditorHooksApi.js":
/*!***************************!*\
  !*** ./EditorHooksApi.js ***!
  \***************************/
/***/ (function() {

/**
 * Created by Kai on 2021/2/22.
 */

class EditorHooksApi {
    // 获取插件管理器
    getExtensionManager() {
        console.assert(!1, "implement not found")
    }

    // 获取相机位置
    getCameraPosition() {
        console.assert(!1, "implement not found")
    }

    // 获取相机旋转角
    getCameraRotation() {
        console.assert(!1, "implement not found")
    }


    // 获取相机对象
    getCamera() {
        console.assert(!1, "implement not found")
    }


    // 获取场景状态
    getSceneStats() {
        console.assert(!1, "implement not found")
    }


    // 获取材质
    getMaterials() {
        console.assert(!1, "implement not found")
    }

    // 获取灯光对象
    getLights() {
        console.assert(!1, "implement not found")
    }


    // 获取反射球对象
    getLightProbes() {
        console.assert(!1, "implement not found")
    }


    // 获取相机体对象
    getCameraVolumes() {
        console.assert(!1, "implement not found")
    }


    // 获取节点对象
    getNodes() {
        console.assert(!1, "implement not found")
    }


    // 获取素材
    getAssets(){
        console.assert(!1, "implement not found")
    }
    ////////////////////////////////////////////////////////
    // 添加光
    addLight(name, type, position) {
        console.assert(!1, "implement not found")
    }


    // 移除光
    removeLight(light) {
        console.assert(!1, "implement not found")
    }


    // 添加光实例
    addLightInstance(light, position) {
        console.assert(!1, "implement not found")
    }


    // 移除光实例
    removeLightInstance(light, instance) {
        console.assert(!1, "implement not found")
    }

    // 创建素材
    createAsset(config){
        console.assert(!1, "implement not found")
    }

    // 添加素材
    addAsset(asset){
        console.assert(!1, "implement not found")
    }

    // 移除素材
    removeAsset(asset){
        console.assert(!1, "implement not found")
    }


    // 添加反射球
    addLightProbe(lightProbe) {
        console.assert(!1, "implement not found")
    }


    // 移除反射球
    removeLightProbe(lightProbe) {
        console.assert(!1, "implement not found")
    }


    // 获取相机体类型
    getCameraVolumeTypes() {
        console.assert(!1, "implement not found")
    }


    // 添加相机体
    addCameraVolume(type, name) {
        console.assert(!1, "implement not found")
    }


    // 移除相机体
    removeCameraVolume(cameraVolume) {
        console.assert(!1, "implement not found")
    }


    // 改变相机体排序
    shiftCameraVolume(cameraVolume, toIndex) {
        console.assert(!1, "implement not found")
    }


    // 获取相机位
    getViews() {
        console.assert(!1, "implement not found")
    }


    // 设置截图区域
    markScreenshotArea(a) {
        console.assert(!1, "implement not found")
    }


    // 取消截图区域设置
    unmarkScreenshotArea() {
        console.assert(!1, "implement not found")
    }


    // 视口缓存
    screenToBuffer(a, b, c) {
        console.assert(!1, "implement not found")
    }


    // 添加相机位
    addViewFromCamera(a, e) {
        console.assert(!1, "implement not found")
    }


    // 重置相机位
    resetViewFromCamera(a) {
        console.assert(!1, "implement not found")
    }


    // 移除相机位
    removeView(a) {
        console.assert(!1, "implement not found")
    }


    // 改变相机位顺序
    shiftView(a, b) {
        console.assert(!1, "implement not found")
    }


    // 激活天空盒
    activateSkyForView(a) {
        console.assert(!1, "implement not found")
    }


    // 切换相机位
    switchToView(a) {
        console.assert(!1, "implement not found")
    }


    // 重命名相机位
    renameView(a, b) {
        console.assert(!1, "implement not found")
    }


    // 更新隐藏Mesh
    updateHiddenMeshes(a) {
        console.assert(!1, "implement not found")
    }


    // 获取天空盒
    getSky() {
        console.assert(!1, "implement not found")
    }


    // 加载纹理
    loadTexture(a) {
        console.assert(!1, "implement not found")
    }


    // 更新材质纹理
    materialTextureUpdated(a, b) {
        console.assert(!1, "implement not found")
    }


    // 改变天空盒纹理
    changeSkyTexture(a) {
        console.assert(!1, "implement not found")
    }


    // 移除天空盒纹理
    removeSkyTexture() {
        console.assert(!1, "implement not found")
    }


    // 获取颜色贴图名称
    getColorMapName() {
        console.assert(!1, "implement not found")
    }


    // 加载颜色纹理
    loadColorMap(a) {
        console.assert(!1, "implement not found")
    }


    // 获取场景Json
    getSceneJson() {
        console.assert(!1, "implement not found")
    }


    // 获取封面Json
    getCoverJson() {
        console.assert(!1, "implement not found")
    }


    // 禁用选择集
    disableSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用材质选择集
    enableMaterialSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用光照选择集
    enableLightSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用发射球选择集
    enableLightProbeSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用插件选择集
    enableExtensionSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用位置选择集
    enablePositionSelection(a) {
        console.assert(!1, "implement not found")
    }


    // 启用节点选择集
    enableNodeSelection() {
        console.assert(!1, "implement not found")
    }


    // 启用相机体选择集
    enableCameraVolumeSelection() {
        console.assert(!1, "implement not found")
    }


    // 选择材质
    selectMaterial(a) {
        console.assert(!1, "implement not found")
    }

    // 替换材质
    replaceMaterial(a, b) {
        console.assert(!1, "implement not found")
    }

    // 选择灯
    selectLight(a) {
        console.assert(!1, "implement not found")
    }

    // 选择灯实例
    selectLightInstance(a) {
        console.assert(!1, "implement not found")
    }


    // 选择反射球
    selectLightProbe(a) {
        console.assert(!1, "implement not found")
    }


    // 选择相机体
    selectCameraVolume(a) {
        console.assert(!1, "implement not found")
    }


    // 选择插件
    selectExtension(a, b) {
        console.assert(!1, "implement not found")
    }


    // 选择节点
    selectNodes(nodesPrimary, nodesSecondary) {
        console.assert(!1, "implement not found")
    }


    // 设置材质选择回调
    setMaterialSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置灯实例选择回调
    setLightInstanceSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置反射球选择回调
    setLightProbeSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置节点选择回调
    setNodeSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置插件选择回调
    setExtensionSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置位置选择回调
    setPositionSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置改变选择回调
    setItemModifiedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 设置相机位选择回调
    setViewSelectedCallback(callback) {
        console.assert(!1, "implement not found")
    }


    // 修改封面
    coverModified(cover) {
        console.assert(!1, "implement not found")
    }


    // 修改导览路径
    autoTourModified() {
        console.assert(!1, "implement not found")
    }


    // 是否存在光照贴图
    hasLightMap() {
        console.assert(!1, "implement not found")
    }

    // 获取导览路径
    getAutoTour() {
        console.assert(!1, "implement not found")
    }


    // 获取是否禁用进度条
    getDisableProgressiveLoader() {
        console.assert(!1, "implement not found")
    }


    // 设置是否禁用进度条
    setDisableProgressiveLoader(loader) {
        console.assert(!1, "implement not found")
    }


    // 获取场景大小改变警告
    getSceneScaleHtmlWarning() {
        console.assert(!1, "implement not found")
    }


    // 获取变换模式
    getTransformMode() {
        console.assert(!1, "implement not found")
    }


    // 设置变换模式
    setTransformMode(mode) {
        console.assert(!1, "implement not found")
    }


    // 获取支持的变化模式
    getSupportedTransformModes() {
        console.assert(!1, "implement not found")
    }


    // 跳转到对象
    seeItem(object) {
        console.assert(!1, "implement not found")
    }

    ////////////////////////////////////////////////////
    // 素材管理
    addAsset(config){
        console.assert(!1, "implement not found")
    }

    getAssets(){
        console.assert(!1, "implement not found")
    }

    removeAsset(asset){
        console.assert(!1, "implement not found")
    }
}


JMK.EditorHooksApi = EditorHooksApi

/***/ }),

/***/ "./SceneLoadConfig.js":
/*!****************************!*\
  !*** ./SceneLoadConfig.js ***!
  \****************************/
/***/ (function() {

/**
 * Created by Kai on 2021/2/21.
 */

var test_config = {
    el: "s3d-canvas",
    toneMapping: {
        whitePoint: 1,
        type: 1,
        exposure: 1
    },
    bb: [
        [-6.831342697143555, -1.5085055828094482, -5.275243282318115],
        [6.831342697143555, 1.5085055828094482, 5.275243282318115]
    ],
    globalEnv: null,
    globalOffset: {
        iblContrast: 0,
        envMapContrast: 0,
        lightMapIntensity: -0.17,
        iblIntensity: 0,
        lightMapContrast: 0.54,
        envMapIntensity: 0
    },
    reflectionProbes: [{
        position: [5.077755928039551, -0.21689745783805847, 3.410093307495117],
        size: [1.5235356092453003, 2.5565390586853027, 1.669382095336914]
    }, {
        position: [-1.4648369550704956, -0.129348024725914, -2.603790760040283],
        size: [4.3158278465271, 2.715106725692749, 5.206568717956543]
    }, {
        position: [2.6222198009490967, -0.12006927281618118, 2.816012144088745],
        size: [7.836654186248779, 2.7431039810180664, 4.8807244300842285]
    }, {
        position: [-3.4398691654205322, -0.10499682277441025, 1.8436989784240723],
        size: [4.120785236358643, 2.778995990753174, 2.7582616806030273]
    }],
    children: [{
        content: 'd.v4d',
        children: []
    }],
    fpsMode: {
        climbing: true
    },
    orbitMode: {
        hiddenNodes: [12],
        crossSection: [8.197611236572266, 8.197611236572266, 1.8102066993713377, 0.978489129278183, 6.3302919387817385, 6.3302919387817385]
    },
    lights: [],
    globalLC: {
        enabled: true,
        intensity: 1.1,
        contrast: 1,
        id: 1
    },
    version: '2.3.0',
    postProcessing: {
        enabled: true,
        bloom: {
            threshold: 0.85,
            enabled: true,
            intensity: 1.07,
            blurriness: 1,
            blend: 16
        },
        ao: {
            enabled: false,
            rings: 5,
            intensity: 1,
            radius: 0.01,
            samples: 32,
            blend: 10
        }
    },
    background: {
        mode: 2,
        src: 'storage/3d/img/station.jpg',
        encoding: 3000,
        bgRadius: 35.04763017993114,
        bgRotation: [0, 0, 0],
        bgBrightness: 1,
        shadowEnabled: true,
        shadowPosition: [0, -1.5185055828094483, 0],
        shadowOpacity: 0.5
    },
    globalIbl: false,
    shadowType: -1,
    gammaFactor: 1,
    defaultView: {
        version: '1.0.0',
        mode: 1,
        spherical: {
            radius: 0.0010000000000012221,
            phi: 1.4325880666526078,
            theta: -2.761104816484233
        },
        camera: {
            fov: 55,
            zoom: 1,
            near: 0.04278525631996904,
            far: 106.9631407999226
        },
        origin: {
            x: -2.5366249978740685,
            y: 0.055505080000000116,
            z: -3.7083890795221968
        }
    }
}

JMK.SceneLoadConfig = function (config = test_config) {
    Object.assign(this, config)
    this.assetsUrl = "data/example-room/";
    //this.assetsUrl = "data/OScene/";
    //this.assetsUrl = "data/untitled/";
    
    
    //this.assetsUrl = "data/jiaoyu02/";
    //this.assetsUrl = "data/untitled2/";
    //this.assetsUrl = "data/0329/";
    //this.assetsUrl = "data/song02/";
    
    
    
    
    
    this.onSceneLoaded = null;
    this.enableCollisions = !0;
    this.forcedInitialCameraRotation = null;
    this.forcedInitialCameraPosition = null

    this.cover = {
        "authorHref": "https://www.3dyunzhan.com",
        "engineLogoOn": true,
        "author": "积木易搭",
        "title": "测试数据",
        "menuOn": true
    }

}


/***/ }),

/***/ "./ViewerApi.js":
/*!**********************!*\
  !*** ./ViewerApi.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ViewerApi": function() { return /* binding */ ViewerApi; }
/* harmony export */ });
/**
 * Created by Kai on 2021/2/14.
 */

class ViewerApi extends THREE.EventDispatcher {

    constructor() {
        super()
    }

    // 跳转到观察对象
    seeItem(object){
        
    }

    // 获取可编辑材质对象
    getEditableMaterials() {
        
    }

    // 获取可编辑节点对象类型
    getEditableNodeTypes() {
        
    }

    // 查找材质对象
    findMaterial() {
        
    }

    // 查找Mesh对象
    findMeshesWithMaterial() {
        
    }

    // 查找节点对象
    findNodesOfType() {
        
    }

    // 获取相机位置对象
    getCameraPosition() {
        
    }

    // 获取相机旋转对象
    getCameraRotation() {
        
    }

    // 获取场景包围盒
    getSceneBoundingBox() {
        
    }

    // 设置节点对象材质
    setMaterialForNode(node, material) {
        
    }

    // 设置Mesh对象材质
    setMaterialForMesh(mesh, material) {
        
    }

    // 切换视角
    switchToView(name, time, isTop) {
        
    }

    // 截图
    // config : {
    //  isPanorama,
    //  width,
    //  height,
    //  toDataUrl
    // }
    captureImage(config) {
        
    }

    // 加载全部素材
    loadAssets(extobj){
        
    }

    // 添加Anchor（热点）
    addAnchor(config, onAnchorClick) {
        
    }

    // 移除Anchor（热点）
    removeAnchor(anchor) {
        
    }

    // 添加化身人
    addAvatar(uuid, config) {
        
    }

    // 移除化身人
    removeAvatar(avatar) {
        
    }

    // 查找化身人
    findAvatar(avatar) {
        
    }

    // 暂停材质动画
    sleepAnimatedMaterials() {
        
    }

    // 唤醒材质动画
    wakeAnimatedMaterials() {
        
    }

    // 打开材质替换窗口（废弃）
    openMaterialPicker(a, b, c, d){
        
    }

    // 移除Anchor可见列表
    removeAnchorsVisibilityChangedListener(a) {
        
    }

    // 打开网页
    openUrl(url, newWindow){
        
    }

    // 页面第一次交互回调
    onPageFirstInteraction(callback){
        
    }

    // ViewerConfig加载回调
    onViewerConfigLoaded(callback){
        
    }

    // 场景是否可以显示
    isSceneReadyToDisplay(callback){
        
    }

    // 场景可显示回调
    onSceneReadyToDisplay(callback){
        
    }

    // 场景加载完毕回调
    onSceneLoadComplete(callback){
        
    }

    // 强刷一帧
    requestFrame(){
        
    }

    // 设置节点可编辑回调
    setNodeTypeEditable(callback){
        
    }

    // 设置材质可编辑回调
    setMaterialEditable(callback) {
        
    }

    // 设置全体材质可编辑
    setAllMaterialsEditable(){
        
    }

    // 添加节点点击事件
    onNodeTypeClicked(a, b) {
        
    }

    // 移除节点点击事件
    removeOnNodeTypeClicked(a, b) {
        
    }

    // 添加材质点击事件
    onMaterialClicked(material, callback){
        
    }

    // 添加材质悬停事件
    onMaterialHoverChanged(material, callback){
        
    }

    // 添加视口开始切换事件
    onViewSwitchStarted(callback){
        
    }

    // 添加视口开始完成事件
    onViewSwitchDone(callback){
        
    }

    // 添加VR模式切换事件
    onVrChange(callback){
        
    }

    // 添加渲染前事件
    onBeforeRender(callback){
        
    }

    // 用HTML Image对象创建纹理
    createTextureFromHtmlImage(image) {
        
    }

    // 用HTML Video对象创建纹理
    createTextureFromHtmlVideo(video){
        
    }

    // 添加热点可见性监听事件
    onAnchorsVisibilityChanged(callback){

    }

    // 移除热点可见性监听事件
    removeAnchorsVisibilityChangedListener(callback){
        
    }

    // 获取场景路径
    getViewerAssetUrl(a) {
        
    }

    // 获取所有View(预设相机位)
    getViews(){
        
    }

    // 获取所有导览路径
    getTours() {
        
    }

    //加载导览路径和视图
    loadViewsAndTours(config) {

    }

    // 获取自动导览对象
    getAutoTour() {
        
    }

    // 添加菜单按钮
    addMenuButton(a) {
        
    }

    // 移除菜单按钮
    removeMenuButton(a) {
        
    }

    // 获取菜单按钮Icon
    getMenuButtonIcon(a) {
        
    }

    // 菜单可见变化响应函数
    onMenuVisibilityChanged(a) {
        
    }

    // 播放场景（废弃）
    play() {
        
    }

    // 暂停场景（废弃）
    pause() {
        
    }

    // Api用户状态改变
    apiUserChangeState(a, b) {
        
    }

    // 移除Api用户状态改变监听
    removeOnApiUserStateChanged(a, b) {
        
    }

    // 获取Api用户状态
    getApiUserState(a) {
        
    }

    // 添加化身人列表改变监听事件
    onAvatarListChanged(callback){
        
    }

    // 移除化身人列表改变监听事件
    removeOnAvatarListChanged(callback){
        
    }

    // 禁用组件
    disableControls() {
        
    }

    // 启用组件
    enableControls() {
        
    }

    // 碰撞检测
    findIntersectionAtPosition(x, y) {

    }

    // 移动并设置相机朝向
    moveAndHeadTo(position, rotation){

    }
}

/***/ }),

/***/ "./animations/Animation.js":
/*!*********************************!*\
  !*** ./animations/Animation.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* binding */ Animation; },
/* harmony export */   "AnimationTrigger": function() { return /* binding */ AnimationTrigger; }
/* harmony export */ });
/* harmony import */ var _assets_Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/Asset.js */ "./assets/Asset.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _src_animation_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/animation/tracks/VectorKeyframeTrack.js */ "./src/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _src_animation_tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/animation/tracks/BooleanKeyframeTrack.js */ "./src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _src_animation_tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../src/animation/tracks/ColorKeyframeTrack.js */ "./src/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _src_animation_tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../src/animation/tracks/NumberKeyframeTrack.js */ "./src/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _src_animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/animation/AnimationClip.js */ "./src/animation/AnimationClip.js");
/* harmony import */ var _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/animation/constants.js */ "./src/animation/constants.js");
/**
 * Created by Kai on 2021/3/23.
 */















var PATH_PROPERTIES = {
    scale: 'scale',
    position: 'position',
    quaternion: 'quaternion',
    weights: 'weights' //'morphTargetInfluences'
};

var INTERPOLATION = {
    CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
                            // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__.InterpolateLinear,
    STEP: _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__.InterpolateDiscrete,
    SMOOTH: _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__.InterpolateSmooth
};


class Channel extends THREE.EventDispatcher {

    constructor(node) {

        super()

        this._node = node

        Object.defineProperty(this, 'node', {
            get: function () {
                return this._node
            }
        })


        Object.defineProperty(this, 'name', {
            get: function () {
                return this._node
            }
        })

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'path')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'times')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'values')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'interpolation')
    }


    _updated(target, propertyName) {

        this.dispatchEvent({'type': 'update', property: propertyName})

    }

    serialize(channels, samplers) {


        let asset = UjP.assetsController.findAsset('uuid', this.node)

        if (asset) {

            let index = samplers.length

            channels.push({
                target: {
                    node: this.node,
                    path: this.path
                },
                sampler: index
            })

            samplers.push({
                input: this.times,
                output: this.values,
                interpolation: this.interpolation || INTERPOLATION.LINEAR
            })
        }

    }

    track() {

            var TypedKeyframeTrack;

        switch (PATH_PROPERTIES[this.path]) {

            case PATH_PROPERTIES.weights:

                TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                break;

            case PATH_PROPERTIES.rotation:
            case PATH_PROPERTIES.quaternion:

                TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                break;

            case PATH_PROPERTIES.position:
            case PATH_PROPERTIES.scale:
            default:
                TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                break;

        }

        var targetName = this.name;

        var interpolation = this.interpolation !== undefined ? INTERPOLATION[this.interpolation] : _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__.InterpolateLinear;

        var track = new TypedKeyframeTrack(
            targetName + '.' + PATH_PROPERTIES[this.path],
            this.times,
            this.values,
            interpolation
        );

        // Override interpolation with custom factory method.
        if (interpolation === 'CUBICSPLINE') {

            let that = this

            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {

                // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                // must be divided by three to get the interpolant's sampleSize argument.

                return new GLTFCubicSplineInterpolant(that.times, that.values, that.getValueSize() / 3, result);

            };

            // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

        }

        return track
    }
}

class AnimationTrigger {

    constructor(animation, config = {}) {

        this._animation = animation
        this._type = config.type || AnimationTrigger.Types.Default
        this._enable = !!config.enable
        this._threshold = config.threshold || [-1, -1]

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'type')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'enable')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'threshold')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'sender')
    }

    start(args) {

        console.assert(this._animation)

        this._animation.play()

    }

    serialize() {
        return {
            type: this.type,
            enable: this.enable,
            threshold: this.threshold
        }
    }

    getPosition() {
        return this._animation.asset.asPosition
    }

    static get Types() {
        return {
            Always: 'Default',
            Time: 'Time',
            Distance: 'Distance',
            Click: 'Click',
            Gaze: 'Gaze',
            Default: 'Default'
        }
    }
}

class Animation extends THREE.EventDispatcher {

    constructor(asset) {
        super()

        if (asset instanceof _assets_Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset) {
            this._asset = asset
        }
        else {
            this._asset = UjP.assetsController.findAsset('uuid', asset)
        }

        this._channels = []
        //this._samples = []
        this._isDoor = false
        this._loop = _src_animation_constants_js__WEBPACK_IMPORTED_MODULE_7__.LoopOnce

        Object.defineProperty(this, 'asset', {
            get: function () {
                return this._asset
            }
        })


        Object.defineProperty(this, 'trigger', {
            get: function () {
                if (!this._trigger) {
                    this._trigger = new AnimationTrigger(this)
                }
                return this._trigger
            }
        })


        Object.defineProperty(this, 'name', {
            get: function () {
                return this.asset.uuid
            }
        })

        Object.defineProperty(this, 'channels', {
            get: function () {
                return this._channels
            }
        })


        Object.defineProperty(this, 'loop', {
            get: function () {
                return this._loop
            },
            set: function(value){
                this._loop = value
            }
        })

        // 上次与相机的距离
        Object.defineProperty(this, 'lastDistanceToCamera', {
            get: function () {
                return this._lastDistance
            },
            set: function(value){
                this._lastDistance = value
            }
        })

        // 是否具有开关状态，如门，窗
        Object.defineProperty(this, 'isDoor', {
            get: ()=>{
                return this._isDoor
            },
            set: value=>{
                this._isDoor = value
            }
        })

        // 重复
        Object.defineProperty(this, 'repetitions', {
            get: function () {
                return this._repetitions
            },
            set: function(value){
                this._repetitions = value
            }
        })

        Object.defineProperty(this, 'duration', {
            get: function () {
                if (this.channels.length <= 0) {
                    return 0
                }
                let dur = [999999, -999999]
                this.channels.forEach(chn=> {

                    chn.times.forEach(t=> {
                        if (t < dur[0]) {
                            dur[0] = t
                        }
                        if (t > dur[1]) {
                            dur[1] = t
                        }
                    })
                })

                return dur[1] - dur[0]
            }
        })

    }



    dispose(mixer){

        if(mixer && this._clip && this._asset){

            mixer.uncacheAction(this._clip, this._asset)

        }

        //this._trigger && this._trigger.dispose()
        //this._clip && this._clip.dispose()
    }

    getClip() {

        if (!this._clip || this.needsUpdate) {

            if (this.channels.length <= 0) {

                return null

            }

            let tracks = []

            this.channels.forEach(chn=> {

                let t = chn.track()

                t && tracks.push(t)

            })

            this._clip = new _src_animation_AnimationClip_js__WEBPACK_IMPORTED_MODULE_6__.AnimationClip(this.name, this.duration, tracks);

            this.needsUpdate = !1
        }

        return this._clip
    }

    addChannel(path, times, values, interpolation) {

        let chn = new Channel(this.name)
        chn.path = path
        chn.times = times
        chn.values = values
        chn.interpolation = interpolation

        let t = this

        chn.addEventListener('update', event=> {

            t.needsUpdate = !0

            this.dispatchEvent({type: 'channelUpdate', channel: chn, property: event.property})

        })

        this.channels.push(chn)

        this.dispatchEvent({type: 'channelAdded', channel: chn})
    }

    removeChannel(channel) {

        Object(_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.removeFromArray)(channel, this.channels)

        this.dispatchEvent({type: 'channelRemoved', channel: channel})
    }

    asynPlay(){

        let t = this

        return new Promise(resolve=>{

            t.play()

            resolve()

        })
    }

    // 播放
    play(){

        let clip = this.getClip()
        console.assert(clip)

        let mixer = UjP.animationsController.mixer
        // TODO： 未来优化，判断当前的clip有没有更新
        mixer.uncacheAction(clip, this.asset)

        let action = mixer.clipAction(clip, this.asset)

        if(action){

            action.reset()

            action.setIsDoor(this.isDoor);
            action.setLoop(this.loop, this.repetitions);
            action.clampWhenFinished = !0; //暂停在最后一帧播放的状态
            //action.setLoop(2200);
            UjP.animationsController.playAction(action)

            this._activeAction = action
        }
    }

    // 停止
    stop(){

        if(this._activeAction){

            this._activeAction.stop()

            this._activeAction = null
        }
    }

    // 还至本处
    restore(){

        if(this._activeAction){
            this._activeAction.stop();
        }
    }

    serialize() {

        let n = this

        let chns = []
        let sams = []

        n.channels.forEach(chn=> {

            chn.serialize(chns, sams)

        })

        let json = {
            channels: chns,
            samplers: sams,
            trigger: n.trigger.serialize(),
            loop : n.loop,
            door: n.isDoor,
            repetitions : n.repetitions
        }

        return json
    }

    //addRotationTrack(times, axis, values = [0, 360]) {
    //
    //    axis = axis || 'x';
    //
    //    var trackName = this.name + '.rotation[' + axis + ']';
    //
    //    var track = new NumberKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //}
    //
    //
    //addScaleAxisTrack(times, axis, values = [0, 1]) {
    //
    //    axis = axis || 'x';
    //
    //    var trackName = this.name + '.scale[' + axis + ']';
    //
    //    var track = new NumberKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //
    //}
    //
    //addShakeTrack(times, frequence, shakeScale) {
    //
    //    var values = [], tmp = new THREE.Vector3();
    //
    //    for (var i = 0; i < duration * 10; i++) {
    //
    //        times.push(i / 10);
    //
    //        tmp.set(Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0).
    //            //multiply( shakeScale ).
    //            multiplyScalar(shakeScale).
    //            toArray(values, values.length);
    //
    //    }
    //
    //    var trackName = this.name + '.position';
    //
    //    var track = new VectorKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //}
    //
    //addPulsationTrack(times, frequence, pulseScale) {
    //
    //    var values = [], tmp = new THREE.Vector3();
    //
    //    for (var i = 0; i < duration * 10; i++) {
    //
    //        times.push(i / 10);
    //
    //        var scaleFactor = Math.random() * pulseScale;
    //        tmp.set(scaleFactor, scaleFactor, scaleFactor).
    //            toArray(values, values.length);
    //
    //    }
    //
    //    var trackName = this.name + '.scale';
    //
    //    var track = new VectorKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //}
    //
    //addVisibilityTrack(times, values) {
    //
    //    var trackName = this.name + '.visible';
    //
    //    var track = new BooleanKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //}
    //
    //addMaterialColorTrack(times, colors) {
    //
    //    var timeStep = duration / colors.length;
    //
    //    for (var i = 0; i <= colors.length; i++) {
    //
    //        times.push(i * timeStep);
    //        values.push(colors[i % colors.length]);
    //
    //    }
    //
    //    var trackName = this.name + '.material[0].color';
    //
    //    var track = new ColorKeyframeTrack(trackName, times, values);
    //
    //    this.tracks.push(track)
    //
    //    return track
    //}

    static fromJSON(animationDef) {

        let {channels,samplers, trigger, loop, door, repetitions} = animationDef

        if (channels && channels.length > 0) {

            if (samplers && samplers.length > 0) {


                let ani = null

                channels.forEach(chn=> {

                    if (samplers.length > chn.sampler && chn.sampler >= 0) {

                        let samp = samplers[chn.sampler]

                        let tgt = chn.target

                        if (!ani) {

                            let asset = UjP.assetsController.findAsset('uuid', tgt.node)

                            if (asset) {
                                ani = new Animation(asset)
                            }
                            else {
                                return null
                            }
                        }

                        let channel = new Channel(tgt.node)

                        channel.path = tgt.path

                        channel.times = [].concat(samp.input)

                        channel.values = [].concat(samp.output)

                        channel.interpolation = samp.interpolation

                        ani._channels.push(channel)
                    }

                })

                ani._trigger = new AnimationTrigger(ani, trigger)
                loop && (ani.loop = Number(loop))
                door && (ani.isDoor = door)
                repetitions && (ani.repetitions = repetitions)

                return ani
            }
        }

        return null
    }
}



/***/ }),

/***/ "./animations/AnimationsController.js":
/*!********************************************!*\
  !*** ./animations/AnimationsController.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationsController": function() { return /* binding */ AnimationsController; }
/* harmony export */ });
/* harmony import */ var _Animation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Animation.js */ "./animations/Animation.js");
/* harmony import */ var _assets_Asset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/Asset.js */ "./assets/Asset.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _src_animation_AnimationMixer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../src/animation/AnimationMixer.js */ "./src/animation/AnimationMixer.js");
/**
 * Created by Kai on 2021/3/23.
 */






class AnimationsController extends THREE.EventDispatcher {

    constructor(app) {

        super()

        let t = this

        t.app = app

        t.animations = []

        this.onUpdate = function () {
            let firstIn = !0

            return function (e) {
                if (firstIn) {
                    firstIn = !1
                }
                //In the animation block of your scene:
                if (t.mixer) {
                    t.mixer.update(e.delta);
                    //t.dispatchEvent({type:'animate', time: time})
                }
            }
        }()

        this.onFinish = function () {

            return function (event) {

                t.onFinished && t.onFinished(event)

                t.mixer.removeEventListener('loop', t.onLoop, !1)

                t.mixer.removeEventListener('finished', t.onFinish, !1)

                UjP.removeEventListener('onRequestFrame', t.onUpdate, !1)

            }

        }()

        this.mixer = new _src_animation_AnimationMixer_js__WEBPACK_IMPORTED_MODULE_3__.AnimationMixer();

    }

    clear(){

        let t = this

        t.animations.forEach(ani=>{

            ani.dispose(this.mixer)

        })
        t.animations = []

        if(this._action){

            this._action = null

        }
    }

    getAssetAction(asset) {

        if (asset instanceof _assets_Asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {

            let animation = this.findAnimation(asset.uuid)

            if (animation) {

                animation.needsUpdate = true

                let clip = null, root = null

                if(animation.getClip){
                    // 自定义动画
                    clip = animation.getClip()
                    root = asset
                }
                else if(animation instanceof THREE.AnimationClip){
                    // 模型自带动画
                    clip = animation
                    root = clip.root
                }


                if (clip) {

                    // TODO： 未来优化，判断当前的clip有没有更新
                    this.mixer.uncacheAction(clip, root)

                    let action = this.mixer.clipAction(clip, root)

                    this._action = action

                    return this._action
                }

            }

        }

        return null
    }

    // 开始结束时间设置为一样，相当于播放时间为0，直接跳转到时间点对应的状态
    jumpTo(asset, time) {

        let action = this.getAssetAction(asset)

        if (!action) {

            console.assert(action)
            return

        }

        if (action.isRunning()) {

            action.stop()

        }

        UjP.removeEventListener('onRequestFrame', this.onUpdate, !1)

        if (action && this.mixer) {

            let clip = action._clip

            let times = clip.tracks[0].times


            if (time < times[times.length - 1]) {

                //action.setLoop(2200,1); //不循环播放
                //action.clampWhenFinished = true; //暂停在最后一帧播放的状态
                // 开始结束时间设置为一样，相当于播放时间为0，直接跳转到时间点对应的状态
                //clip.duration = [time,time];//剪辑对象设置播放结束时间
                action.play(); //开始播放
                //action.startAt(0); //操作对象设置开始播放时间
                this.mixer.setTime(time, true);
                UjP.aniController.requestFrame()
                //action.stop(); //开始播放
                //UjP.removeEventListener('onRequestFrame', this.onUpdate, !1)
            }
        }
    }

    stop(asset) {

        let action = this.getAssetAction(asset)

        if (action) {

            this.onFinish(action)

            action.stop()
        }
    }

    playAction(action){

        let t = this

        if (!action.isRunning()) {

            action.play()

            if (action.loop === 2200) {

                t.mixer.removeEventListener('finished', t.onFinish, !1)
                t.mixer.addEventListener('finished', t.onFinish)

            }
            else if (t.onLoop) {

                t.mixer.removeEventListener('loop', t.onLoop, !1)
                t.mixer.addEventListener('loop', t.onLoop)

            }

            if (t.onUpdated) {

                if (!t.onActionUpdate) {
                    t.onActionUpdate = function () {
                        return function (e) {
                            t.onUpdated(e)
                        }
                    }()
                }

                t.mixer.removeEventListener('updated', t.onActionUpdate, !1)
                t.mixer.addEventListener('updated', t.onActionUpdate)
            }

            UjP.removeEventListener('onRequestFrame', t.onUpdate, !1)
            UjP.addEventListener('onRequestFrame', t.onUpdate)

        }


        action.isRunning() && (JMT.ALWAYS_RENDER = !0 )

        UjP.aniController.requestFrame()
    }

    play(asset, loop, repetitions) {

        let action = this.getAssetAction(asset)

        if (action) {

            action.reset()

            if(loop || repetitions){

                loop || (loop = action.loop)

                repetitions || (repetitions = action.repetitions)

                action.setLoop(loop, repetitions); //不循环播放
            }

            action.clampWhenFinished = !0; //暂停在最后一帧播放的状态

            //this.mixer.setTime(0)

            this.playAction(action, loop)
        }
    }

    createAnimation(asset, triggerType) {

        if (asset instanceof _assets_Asset_js__WEBPACK_IMPORTED_MODULE_1__.Asset) {

            let animation = new _Animation_js__WEBPACK_IMPORTED_MODULE_0__.Animation(asset)

            this.animations.push(animation)

            asset.animations = (asset.animations || []).concat([animation])

            return animation
        }

        return null
    }

    removeAnimation(animation) {

        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.removeFromArray)(animation, this.animations)

        animation.asset.animations && (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.removeFromArray)(animation, animation.asset.animations)

    }

    findAnimation(assetId) {

        let animation = null

        this.animations.some((eff)=> {

            if (eff.asset.uuid === assetId) {

                animation = eff

                return true
            }
        })

        return animation
    }

    getAnimations() {

        return this.animations

    }

    serialize() {

        let anis = []
        this.animations.forEach(eff => {

            if(eff.serialize){
                let ani = eff.serialize()
                ani && anis.push(ani)
            }

        })

        return anis
    }

    solveTriggers(){

        let t = this

        if(JMT.EDIT_MODE && !JMT.DEBUG){

            return

        }

        // 距离触发器
        let distTriggers = t.triggers[_Animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationTrigger.Types.Distance]


        if (distTriggers && distTriggers.length > 0) {

            let fnCallback = function () {

                let distTrigers = t.triggers[_Animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationTrigger.Types.Distance] || []

                distTrigers.forEach(dt=>{

                    let camPos = UjP.controls.cameraWorldPosition(),
                        triPos = new THREE.Vector3().fromArray(dt.asset.asPosition)
                    let dist = camPos.distanceTo(triPos)

                    let thrd = dt.trigger.threshold

                    if(dist>= thrd[0] && dist <= thrd[1]){
                        if(dt.lastDistanceToCamera > thrd[1] || dt.lastDistanceToCamera < thrd[0]){ // 进入
                            dt.asynPlay()
                        }
                    }
                    else {
                        if(dt.lastDistanceToCamera >= thrd[0] && dt.lastDistanceToCamera <= thrd[1]){ // 退出
                            dt.stop()
                            //dt.restore();
                        }
                    }

                    // 记录上次的距离
                    dt.lastDistanceToCamera = dist;
                })

            }

            t.app.viewer.setCamaraPositionRotationChangedCallback(fnCallback)

            fnCallback()

        }

        // 时间触发器
        let timeTriggers = t.triggers[_Animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationTrigger.Types.Time]

        if (timeTriggers && timeTriggers.length > 0) {
            // TODO: 想清楚场景再实现
        }

        // 无触发器一直播
        let defaultTriggers = t.triggers[_Animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationTrigger.Types.Always]

        if (defaultTriggers && defaultTriggers.length > 0) {
            defaultTriggers.forEach(dt=>{

                dt.trigger.enable &&  dt.asynPlay()

            })
        }

        // 点击触发
        let clickTriggers = t.triggers[_Animation_js__WEBPACK_IMPORTED_MODULE_0__.AnimationTrigger.Types.Click]

        if (clickTriggers && clickTriggers.length > 0) {
            clickTriggers.forEach(dt=>{

                if(dt.trigger.enable){

                    let running = false
                    dt.asset.addEventListener('assetClick', ()=>{

                        if(!running){
                            dt.asynPlay()
                        }
                        else {
                            dt.stop()
                        }
                        running = !running
                    })
                }
            })
        }
    }

    deserialize(json = []) {

        let t = this

        console.assert(json, '动画json数据参数错误')

        t.animations = []

        t.triggers = {}

        json.forEach(animationDef=> {

            let animation = _Animation_js__WEBPACK_IMPORTED_MODULE_0__.Animation.fromJSON(animationDef)

            if (animation) {

                t.animations.push(animation)

                let listeners = t.triggers[animation.trigger.type] || []

                t.triggers[animation.trigger.type] = listeners.concat([animation])

            }
        })

        return t.animations
    }
}

/***/ }),

/***/ "./assets/AnchorAsset.js":
/*!*******************************!*\
  !*** ./assets/AnchorAsset.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnchorAsset": function() { return /* binding */ AnchorAsset; }
/* harmony export */ });
/* harmony import */ var _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TextAsset.js */ "./assets/TextAsset.js");
/**
 * Created by Kai on 2021/2/27.
 */


class AnchorAsset extends _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__.TextAsset {
    constructor(config, id) {

        super(config, id)

        let that = this

        this.isAnchor = !0

        this.animate = function(){
            return function(tick) {

                console.assert(that._anchor && that._anchor.material)

                let texture = that._anchor.material.baseColorTexture

                if(texture && texture.update){
                    texture.update(tick.deltaTime)
                }
                else{
                    UjP.assetsController.removeEventListener('animate', that.animate, !1)
                }
            }
        }()
    }

    deserialize(config) {
        let n = this
        _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__.TextAsset.prototype.deserialize.call(n, config)

        this._extdata.info.custom.tag._enable = true
        //let tagConfig = this._extdata.info.custom.tag
        //tagConfig.texture = 'css/image/giphy.gif'
    }

    _initMesh(config) {

        let that = this
        return new Promise(function (resolve) {
            _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__.TextAsset.prototype._initMesh.call(that, config).then(mesh=> {
                mesh.scale.set(0.001, 0.001, 0.001);
                //m.updateMatrixWorld(!0);
                //that.setScale(0.001,0.001,0.001)
                // 屏蔽热点大小设置
                that.setScale = ()=> {
                }

                that.resetAnimate()

                resolve(mesh)
            })
        })

    }

    resetAnimate(){

        let that = this

        let isAnimate = that._anchor.material.baseColorTexture.isAnimate

        if(isAnimate){
            UjP.assetsController.removeEventListener('animate', that.animate, !1)
            UjP.assetsController.addEventListener('animate', that.animate)
        }
        else if(that.animate){
            UjP.assetsController.removeEventListener('animate', that.animate, !1)
        }
    }

    _setHighLight(highlight) {
        if (!UjP.config.mode) {
            return
        }
        if (this._anchor && this._anchor.material) {
            this._anchor.material.highlightMix = highlight
        }
        UjP.aniController.requestFrame()
    }

    onCreateMaterial(material, config) {
        this._text = '  '
        _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__.TextAsset.prototype.onCreateMaterial.call(this, material, config)
    }

    update(position, normal) {
        _TextAsset_js__WEBPACK_IMPORTED_MODULE_0__.TextAsset.prototype.update.call(this, position, normal)

        this.config.stype = 'sphere'
        // TODO: 这个地方禁用可能会导致资源泄露
        //this._disableAnchor()
        //this._enableAnchor()
        this.resetAnimate()
    }
    leave() {
        super.leave()
        if (this.extdata.info.custom.hoverChange) {
            this.scale.set(this.scale.x*0.8,this.scale.y*0.8,this.scale.z*0.8)
            this.updateMatrixWorld(!0)
        }
    }

    hover() {
        super.hover()
        if (this.extdata.info.custom.hoverChange) {
            this.scale.set(this.scale.x*1.25,this.scale.y*1.25,this.scale.z*1.25)
            this.updateMatrixWorld(!0)
        }
    }

    raycast(ray) {

        if (!this._mesh || !this._anchor) return null

        //if (this._anchor instanceof JMT.Anchor)
        console.assert(this._anchor instanceof JMT.Anchor)

        let geom
        let localRay = new THREE.Ray().copy(ray)
        let inverseMatrix = new THREE.Matrix4()

        {

            let c = UjP.controls
            let camera = c.camera instanceof Function ? c.camera() : c.camera

            let modelMatrix = this._anchor.matrixWorld
            let viewMatrix = camera.matrixWorldInverse
            let projMatrix = camera.projectionMatrix
            let modelView = modelMatrix.clone().multiplyMatrices(modelMatrix, viewMatrix)

            //scale.x = length(modelMatrix[0].xyz);
            //scale.y = length(modelMatrix[1].xyz);
            let elem = modelMatrix.elements
            let scale = {x: 0, y: 0}
            let tempP = new THREE.Vector3(0, 0, 0)
            tempP.set(elem[0], elem[1], elem[2])
            scale.x = tempP.length()

            tempP.set(elem[4], elem[5], elem[6])
            scale.y = tempP.length()

            let mvPoint = new THREE.Vector3(0, 0, 0)
            mvPoint.applyMatrix4(modelMatrix).applyMatrix4(viewMatrix)//.applyProjection(projMatrix)

            //to camera-system point
            function makePoint(attribute, i, mvPoint, scale) {

                //view pt
                var v0 = (new THREE.Vector3()).fromBufferAttribute(attribute, i)
                v0.set(v0.x * scale.x, v0.y * scale.y, v0.z)
                v0.set(mvPoint.x + v0.x, mvPoint.y + v0.y, mvPoint.z)

                //v0.applyProjection(projMatrix)
                return v0;
            }

            let box007 = new THREE.Box3()

            //to camera-system point
            var v0 = makePoint(this._anchor.geometry.attributes.position, 0, mvPoint, scale)
            var v1 = makePoint(this._anchor.geometry.attributes.position, 1, mvPoint, scale)
            var v2 = makePoint(this._anchor.geometry.attributes.position, 2, mvPoint, scale)
            var v3 = makePoint(this._anchor.geometry.attributes.position, 3, mvPoint, scale)

            box007.expandByPoint(v0)
            box007.expandByPoint(v1)
            box007.expandByPoint(v2)
            box007.expandByPoint(v3)

            let inverProjMatrix = camera.projectionMatrix.clone()
            inverProjMatrix.copy(camera.projectionMatrix).invert();
            localRay.applyMatrix4(camera.matrixWorldInverse)

            let pt = new THREE.Vector3()
            if (localRay.intersectBox(box007, pt)) {
                pt.applyMatrix4(camera.matrixWorld)
                let dist = pt.distanceTo(ray.origin)
                return {
                    distance: dist,
                    point: pt,
                    object: this
                }

            }

            return null
        }
    }
}

/***/ }),

/***/ "./assets/Asset.js":
/*!*************************!*\
  !*** ./assets/Asset.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Asset": function() { return /* binding */ Asset; }
/* harmony export */ });
/* harmony import */ var _AssetExtData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AssetExtData.js */ "./assets/AssetExtData.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _src_textures_CanvasTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/textures/CanvasTexture.js */ "./src/textures/CanvasTexture.js");
/* harmony import */ var _src_textures_CanvasTexture_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_src_textures_CanvasTexture_js__WEBPACK_IMPORTED_MODULE_2__);
/**
 * Created by Kai on 2021/1/25.
 */





var _lookAtOldMatrix = function() {
    var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
    var matrix = new THREE.Matrix4();
    return function (d, e, g) {
        var f = matrix.elements;
        c.subVectors(d, e).normalize();
        0 === c.length() && (c.z = 1);
        a.crossVectors(g,
            c).normalize();
        0 === a.length() && (c.x += 1E-4, a.crossVectors(g, c).normalize());
        b.crossVectors(c, a);
        f[0] = a.x;
        f[4] = b.x;
        f[8] = c.x;
        f[1] = a.y;
        f[5] = b.y;
        f[9] = c.y;
        f[2] = a.z;
        f[6] = b.z;
        f[10] = c.z;
        return matrix
    }
}()

class Asset extends THREE.Object3D {

    constructor(config, index) {

        super()
        this.config = config
        config.index = config.index || index || 0
        this._textureLoader = config.textureLoader

        this.isAsset = true

        this._defineProperties()

        this._initLock = true
        this.deserialize(config)
        

        let n = this

        n.hasAnchor && n._enableAnchor()
    }


    getVertices() {
        let matrix = this.matrixWorld

        let vs = this._mesh.geometry.attributes.position.array

        let worldVs = {
            leftTop: new THREE.Vector3(vs[0], vs[1], vs[2]).applyMatrix4(matrix),
            rightTop: new THREE.Vector3(vs[3], vs[4], vs[5]).applyMatrix4(matrix),
            leftBottom: new THREE.Vector3(vs[6], vs[7], vs[8]).applyMatrix4(matrix),
            rightBottom: new THREE.Vector3(vs[9], vs[10], vs[11]).applyMatrix4(matrix)
        }

        return worldVs
    }

    getMesh(){
        return this._mesh
    }

    init() {

        let config = this.config

        this._initMesh(config).then(mesh=> {

            this._mesh = mesh

            this.add(this._mesh);

            let normal = config.normal

            let position = config.position

            let scale = config.scale

            let that = this

            let listenFinalLoad = !1

            function update(){

                that.update(position, normal)
                if (scale !== undefined && scale instanceof Array)
                    that.scale.set(scale[0],scale[1],scale[2])

                if (that.type !== Asset.Types.Model) {
                    that.updateMatrixWorld(!0);
                }

                that._assignLight(config)

                that._onReadyToLoad && that._onReadyToLoad()

                if(listenFinalLoad){

                    that.removeEventListener('finalLoaded', update, !1)
                }

                // var enableCollisions = UjP.config.enableCollisions
                // if ((enableCollisions || JMT.EDIT_MODE)) {
                //     let radius = 10
                //     UjP.collider.addStaticObstacle(that._mesh, that.position, radius)
                // }
            }

            if(!this.isAgent){

                update()

            }
            else {

                listenFinalLoad = true

                that.addEventListener('finalLoaded', update)

            }

            //this.dispatchEvent({type: 'assetAdded', target: this})
            //this._videoTexture1 = this._videoTexture0 = this._videoScreenBack = this._videoScreen = null
        })

        return this
    }

    animate(tick) {

    }

    _defineProperties() {

        Object.defineProperty(this, 'boundingSphere', {
            get: function () {
                return this._getBoundinngSphere()
            }
        })

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'normal')

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'stayWhenClick')

        //Object.defineProperty(this, 'matrixWorldNeedsUpdate', {
        //    set: function (value) {
        //        return this.updateMatrixWorld(value)
        //    }
        //})

        ////////////////////////////////////////////////////////////
        // 素材的类型

        Object.defineProperty(this, 'type', {
            get: function () {
                return this._type
            }
        })

        Object.defineProperty(this, 'contentType', {
            get: function () {
                return this._contentType
            }
        })

        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'description')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'enable')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'extdata')
        // 朝向相机位
        Object.defineProperty(this, 'followCamera', {
            get: function () {
                return this._followCamera
            },
            set: function (value) {
                let n = this
                let q = new THREE.Quaternion().setFromAxisAngle({x:0, y:0, z:1}, THREE.Math.degToRad(-90))
                let quat = new THREE.Quaternion() 
                let onCameraChanged = ()=> {
                    let camera = UjP.controls.camera()
                    //camera.updateMatrixWorld(!0)

                    // let cameraPosition = UjP.controls.cameraWorldPosition()
                    // let cameraDir = camera.getWorldDirection()
                    // let e = camera.matrixWorld.elements
                    // let up = new THREE.Vector3(e[4], e[5], e[6])
                    //
                    // n.up.copy(up)
                    // n.lookAt(cameraPosition)
                    // n.updateMatrixWorld(!0)

                    //看向相机 z轴指向了相机
                    camera.getWorldQuaternion(quat)
                    n.quaternion.copy(quat);
                    n.quaternion.multiplyQuaternions(n.quaternion, q)
                    //new THREE.Euler(0,0,THREE.Math.degToRad(90))

                    n.updateMatrixWorld(true)

                }
                if (value) {
                    UjP.controls.camera().addEventListener('positionChanged', onCameraChanged)
                }
                else {
                    UjP.controls.camera().removeEventListener('positionChanged', onCameraChanged, !1)
                }

                this._followCamera = value
            }
        })

        Object.defineProperty(this, 'uuid', {
            get: function () {
                return this._uuid
            }
        })

        // 老数据的关联info
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'info')

        // Obj模型的材质文件
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'mtl')

        // Obj模型的obj文件
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'obj')

        // 音乐
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'music')

        // 素材名称
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'name')

        // 透明度
        Object.defineProperty(this, 'opacity', {
            get: ()=> {
                return this._opacity || 0.99
            },
            set: t=> {
                //this._opacity = t
                if (t < 0 || t > 1) {
                    return
                }
                this._opacity = t
                //t = t / 100.0
                if (this.material) {
                    let texture = this.material.baseColorTexture
                    if (texture) {
                        texture.hasAlpha = this.config.opacity && 1 > this.config.opacity;
                    }
                    this.material.opacity = t
                    this.material.configureTransparency()
                    this._updated(this, 'opacity')
                }
            }
        })

        // 素材在第几张精灵图上
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'packTexture')

        // 素材id
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'picturesId')

        // 素材在展厅的位置
        Object.defineProperty(this, 'asPosition', {
            get: function () {
                return this.position.toArray()
            },
            set: function (array) {
                this.setPosition(array[0], array[1], array[2])
            }
        })

        // 素材位置id
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'positionId')

        // 素材旋转
        Object.defineProperty(this, 'asRotation', {
            get: function () {
                return this.rotation.toArray()
            },
            set: function (array) {
                this.setRotation(array[0], array[1], array[2])
            }
        })

        // 素材旋转id
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'rotationId')

        // 素材旋转四元组
        Object.defineProperty(this, 'asQuaternion', {
            get: function () {
                //return this.rotation.toArray()
                return this.quaternion.toArray()
            },
            set: function (array) {
                //this.setRotation(array[0], array[1], array[2])
                this.quaternion.fromArray(array)
                this._updated(this, 'asQuaternion')
            }
        })

        // 素材旋转四元组id
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'quaternionId')

        // 缩放比
        Object.defineProperty(this, 'asScale', {
            get: function () {
                return this.scale.toArray()
            },
            set: function (array) {
                this.setScale(array[0], array[1], array[2])
            }
        })

        // 缩放比Id
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'scaleId')


        // 素材几何
        // x0	Number	素材在x轴上的起点
        // X1	Number	素材在x轴上的终点
        // y0	Number	素材在y轴上的起点
        // y1	Number	素材在y轴上的终点
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'geometry')

        // 素材地址
        Object.defineProperty(this, 'texture', {
            get: ()=> {
                return this._texture
            }
        })

        // 素材缩略图地址
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'thumb')

        // 是否是漫游角色
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'isRoamCharacter')

        // 素材在相机位是否可见
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'hideInViews')

        // 是否启用素材在相机位是否可见
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'enableHideInViews')

        this._onDefineProperties && this._onDefineProperties()
    }

    _getBoundinngSphere() {
        return this._mesh.geometry.boundingSphere
    }

    _getLightProbe(config) {
        let lightProbe = config.lightProbeId
        if (undefined !== lightProbe) {
            lightProbe = UjP.scene.findLightProbe(lightProbe)
        }
        else if (UjP.scene.lightProbes.length) {
            lightProbe = UjP.scene.lightProbes[0]
        }
        return lightProbe
    }

    _assignLight(config) {
        let mesh = this._mesh

        let lightProbe = this._getLightProbe(config)

        if (lightProbe) {
            mesh.lightProbe = lightProbe
            //mesh.lightProbe = lightProbe
            //mesh.lightMap = config.object.lightMap
            //mesh.lightMapIdx = config.object.lightMapIdx
            //mesh.material.lc = config.object.material.lc
            //mesh.material.lcContrast = config.object.material.lcContrast
            //mesh.material.lcIntensity = config.object.material.lcIntensity
            //mesh.material.envMap = config.object.material.envMap
        }
    }

    _initMesh(config) {

        this.material = this._createMaterial(config)

        let geometry = this._createGeometry(config)

        let mesh = new THREE.Mesh(geometry, this.material)

        // this.axes = new THREE.AxesHelper()
        // this.axes.material.lineWidth = 2;
        // this.axes.material.depthTest = false
        // mesh.add(this.axes);
        

        return Promise.resolve(mesh)
    }

    // intersects
    // [{distance: distance,
    // point: [intersect.x, intersect.y, intersect.z],
    // object: mesh}]

    raycast(ray) {

        if (!this._mesh) return null

        var anchorCast = this._raycastAnchor(ray)
        if (anchorCast)
            return anchorCast

        // let geom = this._mesh.geometry
        //
        // //-----------------
        // if (geom.boundingSphere === null) geom.computeBoundingSphere()
        //
        // let pt = new THREE.Vector3()
        //
        // //----------------------------
        //
        // if (geom.boundingBox === null)
        //     geom.computeBoundingBox()
        //
        // let localRay = new THREE.Ray()
        // let inverseMatrix = new THREE.Matrix4()
        // inverseMatrix.getInverse(this._mesh.matrixWorld)
        // localRay.copy(ray).applyMatrix4(inverseMatrix);
        //
        // if (localRay.intersectBox(geom.boundingBox, pt)) {
        //     // pt.applyMatrix4(this._mesh.matrixWorld)
        //     // let dist = pt.distanceTo(ray.origin)
        //     // return {
        //     //     distance: dist,
        //     //     point: [pt.x, pt.y, pt.z],
        //     //     //normal: [normal.x, normal.y, normal.z],
        //     //     // face: [
        //     //     //     [vA.x, vA.y, vA.z],
        //     //     //     [vB.x, vB.y, vB.z],
        //     //     //     [vC.x, vC.y, vC.z]
        //     //     // ],
        //     //     face: null,
        //     //
        //     //     object: this
        //     // }
        //
        // }

        var intersects = []
        this._intersectObject(this._mesh, ray, intersects)
        return intersects.length > 0 ? intersects[0] : null
    }

    //
    _intersectObject(object, ray, intersects) {

        if (object.visible === false) return null;

        if (object.geometry) {

            if (object.geometry.boundingBox === null) object.geometry.computeBoundingBox()

            let localRay = new THREE.Ray()
            let inverseMatrix = new THREE.Matrix4()
            let pt = new THREE.Vector3()

            //inverseMatrix.getInverse(object.matrixWorld)
            inverseMatrix.copy(object.matrixWorld).invert();
            localRay.copy(ray).applyMatrix4(inverseMatrix);

            if (localRay.intersectBox(object.geometry.boundingBox, pt)) {
                //粗略的
                // pt.applyMatrix4(object.matrixWorld)
                // let dist = pt.distanceTo(ray.origin)
                // return {
                //     distance: dist,
                //     point: pt,
                //     object: this
                // }

                //使用三角形求交
                //let indices = object.geometry.attributes.index && object.geometry.attributes.index.array;
                let indices = object.geometry.index && object.geometry.index.array
                let positions = object.geometry.attributes.position;

                var vA = new THREE.Vector3()
                var vB = new THREE.Vector3()
                var vC = new THREE.Vector3()
                var point = new THREE.Vector3()

                if (indices) {

                    for (let i=0; i<indices.length; i+=3) {

                        vA.fromBufferAttribute(positions, indices[i])
                        vB.fromBufferAttribute(positions, indices[i+1])
                        vC.fromBufferAttribute(positions, indices[i+2])

                        let intersect = localRay.intersectTriangle(vA, vB, vC, false, point);
                        if (intersect === null)
                            continue

                        vA.applyMatrix4(object.matrixWorld)
                        vB.applyMatrix4(object.matrixWorld)
                        vC.applyMatrix4(object.matrixWorld)
                        intersect.applyMatrix4(object.matrixWorld)

                        let distance = intersect.distanceTo(ray.origin)
                        //var normal = THREE.Triangle.normal(vA, vB, vC)
                        var normal = new THREE.Vector3()
                        THREE.Triangle.getNormal(vA, vB, vC, normal)

                        // 判断正反面
                        //let c = UjP.controls;
                        //let campos = new THREE.Vector3()
                        //campos.copy(c.camera().position)
                        //campos.applyMatrix4(c.camera().matrixWorld);

                        //let tempRay = intersect.sub(campos);
                        //tempRay.normalize();

                        var angle = normal.dot(ray.direction);

                        if(angle >= 0){
                            // 拾取到背面
                            continue
                        }

                        // Martian
                        // 防止极值导致的旋转错误，欧拉角互锁；
                        // 失之毫厘，谬以千里；且撸且珍惜！
                        let ROUNDING_f32 = 0.000001
                        if (Math.abs(normal.x)<ROUNDING_f32) normal.x = 0
                        if (Math.abs(normal.y)<ROUNDING_f32) normal.y = 0
                        if (Math.abs(normal.z)<ROUNDING_f32) normal.z = 0

                        var ins = {
                            distance: distance,
                            point: [intersect.x, intersect.y, intersect.z],
                            normal: [normal.x, normal.y, normal.z],
                            face: [
                                [vA.x, vA.y, vA.z],
                                [vB.x, vB.y, vB.z],
                                [vC.x, vC.y, vC.z]
                            ],
                            object: this
                        }

                        intersects.push(ins)

                    }



                }
                else {

                    for (let i=0, pointCount = positions.array.length/3; i<pointCount; i+=3) {

                        vA.fromBufferAttribute(positions, i)
                        vB.fromBufferAttribute(positions, i+1)
                        vC.fromBufferAttribute(positions, i+2)

                        let intersect = localRay.intersectTriangle(vA, vB, vC, false, point);
                        if (intersect === null)
                            continue

                        vA.applyMatrix4(object.matrixWorld)
                        vB.applyMatrix4(object.matrixWorld)
                        vC.applyMatrix4(object.matrixWorld)
                        intersect.applyMatrix4(object.matrixWorld)

                        let distance = intersect.distanceTo(ray.origin)
                        //var normal = THREE.Triangle.normal(vA, vB, vC)
                        var normal = new THREE.Vector3()
                        THREE.Triangle.getNormal(vA, vB, vC, normal)

                        // Martian
                        // 防止极值导致的旋转错误，欧拉角互锁；
                        // 失之毫厘，谬以千里；且撸且珍惜！
                        let ROUNDING_f32 = 0.000001
                        if (Math.abs(normal.x)<ROUNDING_f32) normal.x = 0
                        if (Math.abs(normal.y)<ROUNDING_f32) normal.y = 0
                        if (Math.abs(normal.z)<ROUNDING_f32) normal.z = 0

                        var ins = {
                            distance: distance,
                            point: [intersect.x, intersect.y, intersect.z],
                            normal: [normal.x, normal.y, normal.z],
                            face: [
                                [vA.x, vA.y, vA.z],
                                [vB.x, vB.y, vB.z],
                                [vC.x, vC.y, vC.z]
                            ],
                            object: this
                        }

                        intersects.push(ins)
                    }
                }

            }
        }

        let recursive = true
        if (recursive === true) {

            var children = object.children;

            for (var i = 0, l = children.length; i < l; i++) {

                this._intersectObject(children[i], ray,intersects);

            }
        }

    }

    //选择热点
    _raycastAnchor(ray) {

        if (!this._mesh || !this._anchor || !this._anchor.visible) {
            return null
        }

        //console.assert(this._anchor instanceof JMT.Anchor)

        let geom
        let localRay = new THREE.Ray().copy(ray)
        let inverseMatrix = new THREE.Matrix4()

        {

            let c = UjP.controls
            let camera = c.camera instanceof Function ? c.camera() : c.camera

            let modelMatrix = this._anchor.matrixWorld
            let viewMatrix = camera.matrixWorldInverse
            let projMatrix = camera.projectionMatrix
            let modelView = modelMatrix.clone().multiplyMatrices(modelMatrix, viewMatrix)


            //scale.x = length(modelMatrix[0].xyz);
            //scale.y = length(modelMatrix[1].xyz);
            let elem = modelMatrix.elements
            let scale = {x: 0, y: 0}
            let tempP = new THREE.Vector3(0, 0, 0)
            tempP.set(elem[0], elem[1], elem[2])
            scale.x = tempP.length()

            tempP.set(elem[4], elem[5], elem[6])
            scale.y = tempP.length()

            let mvPoint = new THREE.Vector3(0, 0, 0)
            mvPoint.applyMatrix4(modelMatrix).applyMatrix4(viewMatrix)//.applyProjection(projMatrix)

            //to camera-system point
            function makePoint(attribute, i, mvPoint, scale) {

                //view pt
                var v0 = (new THREE.Vector3()).fromBufferAttribute(attribute, i)
                v0.set(v0.x * scale.x, v0.y * scale.y, v0.z)
                v0.set(mvPoint.x + v0.x, mvPoint.y + v0.y, mvPoint.z)

                //v0.applyProjection(projMatrix)
                return v0;
            }

            let box007 = new THREE.Box3()

            //to camera-system point
            var v0 = makePoint(this._anchor.geometry.attributes.position, 0, mvPoint, scale)
            var v1 = makePoint(this._anchor.geometry.attributes.position, 1, mvPoint, scale)
            var v2 = makePoint(this._anchor.geometry.attributes.position, 2, mvPoint, scale)
            var v3 = makePoint(this._anchor.geometry.attributes.position, 3, mvPoint, scale)

            box007.expandByPoint(v0)
            box007.expandByPoint(v1)
            box007.expandByPoint(v2)
            box007.expandByPoint(v3)

            let inverProjMatrix = camera.projectionMatrix.clone()
            //inverProjMatrix.getInverse(camera.projectionMatrix)
            //inverProjMatrix.copy(camera.projectionMatrix).invert();
            inverProjMatrix.invert();
            localRay.applyMatrix4(camera.matrixWorldInverse)

            let pt = new THREE.Vector3()
            if (localRay.intersectBox(box007, pt)) {
                pt.applyMatrix4(camera.matrixWorld)
                let dist = pt.distanceTo(ray.origin)
                return {
                    distance: dist,
                    point: pt.toArray(),
                    normal:camera.getWorldDirection(inverProjMatrix).toArray(),
                    face:null,
                    object: this,
                    hitAnchor: true
                }

            }

            return null
        }

    }

    _updateWithPositionAndNormal(position, normal) {
        
        normal = new THREE.Vector3().fromArray(normal)
        position = new THREE.Vector3().fromArray(position).addScaledVector(normal, 0.001);
        //position = new THREE.Vector3().copy(normal).multiplyScalar(0.001).add(new THREE.Vector3().fromArray(position))

        if (this._updating(this, 'Pos&Nor', {position: position, normal: normal})) {

            this._pinTo(position, normal)

            //垂直方向纠正
            if (this._mesh) {

                if (this._mesh.updateMatrixWorld) {
                    this._mesh.updateMatrixWorld(!0);

                    var xs = new THREE.Vector3(1, 0, 0)
                    xs.transformDirection(this._mesh.matrixWorld)

                    let angle = THREE.Math.radToDeg(Math.acos(xs.dot({x: 0, y: 0, z: 1})))

                    if (angle < 89) {
                        xs.set(0, 0, 1)
                        let r = new THREE.Quaternion()
                        r.setFromAxisAngle(xs, THREE.Math.degToRad(180))
                        this.quaternion.multiply(r)
                        this.updateMatrixWorld(!0);
                    }

                }

            }

            if (this.hasAnchor) {
                this._enableAnchor()
            } else {
                this._disableAnchor()
            }

            if (this.followCamera) {
                let n = this
                
                let q = new THREE.Quaternion().setFromAxisAngle({x:0, y:0, z:1}, THREE.Math.degToRad(-90))
                let camera = UjP.controls.camera()
                let quat = new THREE.Quaternion()
                camera.getWorldQuaternion(quat)
                n.quaternion.copy(quat);
                n.quaternion.multiplyQuaternions(n.quaternion, q)

                n.updateMatrixWorld(!0)
            }

            this._updated(this, 'asPosition')
        }
    }

    _pinTo(position, normal) {

        this._normal = normal

        this.position.copy(position);

        let n = new THREE.Vector3().copy(normal).multiplyScalar(100).add(position)

        let mat = _lookAtOldMatrix(n, this.position, this.up)
        this.quaternion.setFromRotationMatrix(mat)
        //this.lookAt(n)

        this.updateMatrixWorld(!0);
    }

    update(position, normal) {
        if (this._initLock) {
            this._updatePositionAndRotation(position, normal)
            this._initLock = false
        }
        else if (normal) {
            this._updateWithPositionAndNormal(position, normal)
        }
    }


    _enableAnchor() {

        let n = this

        let tagConfig = n._extdata.info.custom.tag

        let normal = new THREE.Vector3(0, 0, 1)//.fromArray(normal).normalize()


        function addAnchorFromConfig() {

            let offset = tagConfig.length

            if (n.isModel) {

                normal = new THREE.Vector3(0, 1, 0)
                offset += n.boundingSphere.radius

                tagConfig.position = new THREE.Vector3().copy(normal).multiplyScalar(offset).toArray()
            }
            else {
                tagConfig.position = new THREE.Vector3().copy(normal).multiplyScalar(offset).toArray()
            }

            n._anchor = UjP.viewer.addAnchor(tagConfig,
                function (e) {
                    n.dispatchEvent({type: "assetAnchorClick", asset: n, anchor: e})
                }
            )

            n._anchor.addEventListener('centerChanged', event=> {
                //n._line.position.copy({
                //    x : 0,
                //    y : 0,
                //    z : - event.center[1] * n._anchor.scale.y
                //})
                //n._line.updateMatrixWorld(!0)
                //n._anchor.position.set(0,0, offset + n._anchor.scale.y)
                //n._anchor.updateMatrixWorld(!0)
                //posLine.z = -n._anchor.scale.y * event.scale[1]/2
                n._anchor.scale.set(
                    n._anchor.scale.x / n.scale.x,
                    n._anchor.scale.y / n.scale.y,
                    n._anchor.scale.z / n.scale.z
                )
                n._anchor.updateMatrixWorld(!0)
                UjP.aniController.requestFrame()
            })
            //let posLine = new THREE.Vector3().copy(normal).multiplyScalar(-offset / 2 - 0.001)
            //let lineSize = tagConfig.lineSize / 100
            //let geometry = new THREE.CylinderBufferGeometry(lineSize, lineSize, offset, 4, 1, !1);
            //let lineColor = new THREE.Color(tagConfig.lineColor)
            //n._line = new THREE.Mesh(geometry, getLineMaterial(lineColor))
            //n._line.setRotationFromEuler(euler)
            //n._line.position.copy(posLine)
            //n._line.renderOrder = 11
            //n._anchor.add(n._line)

            n._anchor.renderOrder = 12

            //禁用碰撞体
            n._anchor.colliderMesh.name = "__anchor_collider_mesh"
            n._anchor.colliderMesh.visible = false
            //n._anchor.material.baseColorTexture.addLoadedListener(()=>{
                n.add(n._anchor);
                n._anchor.updateMatrixWorld(!0)
            //})
            //n.updateMatrixWorld(!0);

            {

                let isAnimate = n._anchor.material.baseColorTexture.isAnimate

                let act = UjP.assetsController

                if(isAnimate){

                    n.animate = function(){
                        return function(tick) {

                            if(isAnimate){
                                let texture = n._anchor.material.baseColorTexture

                                if(texture && texture.update){
                                    texture.update(tick.deltaTime)
                                }
                                else{
                                    act.removeEventListener('animate', n.animate, !1)
                                }
                            }
                        }
                    }()

                    act.removeEventListener('animate', n.animate, !1)
                    act.addEventListener('animate', n.animate)

                }
                else if(n.animate){
                    act.removeEventListener('animate', n.animate, !1)
                }
            }
        }

        if (!this._anchor) {

            if (JMT.DEBUG) {
                //tagConfig._texture = 'css/image/corner_left_top.png'
                tagConfig._texture = 'css/image/giphy.gif'
                tagConfig._showTitle = !0
            }

            if(n.type === Asset.Types.Anchor){
                n._extdata.info.custom.tag._visible = !0
                tagConfig._texture || (tagConfig._texture = this.texture)
            }

            if (tagConfig.texture) {
                tagConfig._isGIF = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.getExtension)(tagConfig.texture) === 'gif'
                tagConfig.image = tagConfig.texture
            }

            addAnchorFromConfig()
        }
    }

    _disableAnchor() {
        if (this._anchor) {

            if (this._line) {
                this.remove(this._line)
                //this._line.material.dispose()
                this._line = null
            }

            UjP.assetsController.removeEventListener('animate', this.animate)

            this.remove(this._anchor)
            this._anchor.dispose()
            this._anchor = null

            UjP.aniController.requestFrame()
        }
    }

    _createGeometry(config) {
        let size = config.size || 1.0
        let g = new THREE.PlaneBufferGeometry(size, size)
        g.attributes.uv.array = new Float32Array([
            1, 1,
            1, 0,
            0, 1,
            0, 0
        ])

        return g
    }

    _createMaterial(config) {
        let material = new THREE.MeshBasicMaterial();
        this.onCreateMaterial(material, config)

        if (this._initLock) {
            let texture = material.map
            if (texture) {
                texture.hasAlpha = this._opacity && 1 > this._opacity;
            }
            material.opacity = this._opacity
            material.configureTransparency()
        }

        material.setUniforms && material.setUniforms();

        //设置高亮
        {
            material.highlight = JMT.EDIT_MODE ? JMT.EDITOR_SELECTION_COLOR : JMT.APP_SELECTION_COLOR;

            //高亮混合比例
            Object.defineProperty(material, "highlightMix", {
                get: function () {
                    
                    return this._highlightMix
                },

                set: function (value) {

                    if (value !== this._highlightMix) {
                        this._highlightMix = value
                        //this.highlightMix = value

                        if (this._highlightMix) {
                            
                            if (!this.onReplaced_) {
                                this.onBeforeCompile = (parameters)=>{
                            
                                    parameters.uniforms.highlight = {value:material.highlight}
                                    parameters.uniforms.highlightMix = {value: material.highlightMix}

                                    parameters.fragmentShader = parameters.fragmentShader.replace(
                                        "uniform",
                                        "uniform vec3 highlight;\n"+
                                        "uniform float highlightMix;\n"+
                                        'uniform '
                                    )
                                    
                                    parameters.fragmentShader = parameters.fragmentShader.replace(
                                        "#include <dithering_fragment>",
                                        "#include <dithering_fragment>\n"+
                                        "gl_FragColor.rgb = mix(gl_FragColor.rgb, highlight, highlightMix);\n"+
                                        "gl_FragColor.a = mix(gl_FragColor.a, 1.0, highlightMix);\n"
    
                                        //"baseColor = mix(baseColor, highlight, highlightMix);
                                        //alpha = mix(alpha, 1.0, highlightMix);"
                                    )
                                }

                                this.needsUpdate = true;
                                this.onReplaced_ = true;
                            }
                        }
                        else {
                            this.onBeforeCompile = (parameters)=>{}
                            this.needsUpdate = true;
                            this.onReplaced_ = false;
                        }
                    }
                
                }

            });
            

            //material.highlightMix = highlight
            // if (material.isMeshBasicMaterial) {
            //
            //     //替换最后一行，实现高亮
            //     material.onBeforeCompile = (parameters)=>{
            //         console.log(parameters.fragmentShader)
                    
            //         //parameters.uniforms
            //         //#include <dithering_fragment>
            //     }
            // }
        }

        return material
    }


    restoreScale() {

    }

    onCreateMaterial(material, config) {
        material.color.setStyle(config.color).convertGammaToLinear();
        material.disableLightProbe = !0;
        material.opacity = config.opacity
        material.configureTransparency()
        material.specularOff = !1;
        material.headLight = !0;
    }

    hideName() {
        this._displayNameAnchor && (this._displayNameAnchor.visible = !1)
    }

    _updating(target, propertyName, propertyValue) {

        let args = {type: "assetUpdating", asset: this, property: propertyName, value: propertyValue}

        this.dispatchEvent(args)

        return !args.cancel

    }

    _updated(target, propertyName) {

        if (target instanceof _AssetExtData_js__WEBPACK_IMPORTED_MODULE_0__.CustomTag && !this._initLock) {
            if (propertyName === 'enable') {
                this.hasAnchor ? this._enableAnchor() : this._disableAnchor()
            }
            else if (this.hasAnchor) {
                // TODO: 此处可优化，增量刷新
                this._disableAnchor()
                this._enableAnchor()
            }
        }

        this.dispatchEvent({type: "assetUpdated", asset: this, property: propertyName})

        this.updatedCallback && this.updatedCallback(this, propertyName)

        UjP.aniController.requestFrame()
    }

    enableLightProbe() {
        if (this.lightProbe) {
            console.assert(this.lightProbe.texturesReady());
            var a = this.material;
            a.disableLightProbe = !1;
            a.setUniforms()
        }
    }

    _setHighLight(highlight) {
        if (this._mesh && this._mesh.material) {
            this._mesh.material.highlightMix = highlight
        }
        UjP.aniController.requestFrame()
    }

    dispose() {
        if (this._mesh.material) {
            this._mesh.material.dispose()
        }

        this._mesh = null

        this.dispatchEvent({type: "assetDispose", asset: this})
    }

    leave() {
        if (!this._enable) {
            return
        }

        document.getElementById(UjP.config.el).style.cursor = 'default';
        this._setHighLight(0.)
        this.dispatchEvent({type: "assetLeave", asset: this})
    }

    hover() {
        if (!this._enable) {
            return
        }
        document.getElementById(UjP.config.el).style.cursor = 'grab' //'url(css/image/aa.ico),auto'// ;
        this._setHighLight(JMT.EDIT_MODE ? 0.8 : 0.2)
        this.dispatchEvent({type: "assetHover", asset: this})
    }

    select() {
        if (!this._enable) {
            return
        }
        this._setHighLight(JMT.EDIT_MODE ? 0.8 : 0.2)
        this.click()
    }

    click() {
        if (!this._enable) {
            return
        }


        // 留给派生类实现，有机会干预
        this._onclick && this._onclick()

        //if (!this.stayWhenClick) {
        //    UjP.viewer.seeItem(this)
        //}

        this.dispatchEvent({type: 'assetClick', asset: this})
    }

    bindEventCallback(event, callback) {
        this.removeEventListener(event, callback, !1)
        this.addEventListener(event, callback)
    }

    _updateTransformMode() {
        if (UjP.editorSelector) {
            let controls = UjP.editorSelector.transformControls
            if (this._transformMode === -1) {
                controls && controls.disable()
            }
            else {
                controls && controls.enable(this, [this._transformMode])
            }
            UjP.aniController.requestFrame()
        }
    }

    setPosition(x, y, z) {
        let m = this
        m.position.set(x, y, z);
        m.updateMatrixWorld(!0);
        m._updated(this, 'asPosition')
    }

    setRotation(x, y, z) {
        let m = this
        m.rotation.set(x, y, z);
        m.updateMatrixWorld(!0);
        this._updated(this, 'asRotation')
    }

    setScale(x, y, z) {
        let m = this
        m.scale.set(x, y, z);
        m.updateMatrixWorld(!0);

        if (m.hasAnchor) {
            m._disableAnchor()
            m._enableAnchor()
        }

        this._updated(this, 'asScale')
    }

    _onSerialize(dataArray) {

    }

    getGeometryJson() {
        return {
            x0: 0.,
            y0: 0.,
            x1: 0.,
            y1: 0.
        }
    }

    _updatePositionAndRotation(position, normal) {

        let t = this

        let pos = this._position,
            rot = this._rotation,
            sca = this._scale

        if (!rot) {
            // 编辑模式拖进去的素材,初始rotation为空
            t._updateWithPositionAndNormal(position, normal)
        }
        else {
            // 从JSON中创建，rotation不为空
            t.position.set(pos[0], pos[1], pos[2])
            t.rotation.set(rot[0], rot[1], rot[2])
            t.rotation.order = rot[3]
            t.scale.set(sca[0], sca[1], sca[2])
            t.updateMatrixWorld(!0);

            //if (t.hasAnchor) {
            //    t._disableAnchor()
            //    t._enableAnchor()
            //}
        }
    }

    deserialize(config) {

        console.assert(config.type, 'jmk>>type is missing')
        console.assert(config.contentType, 'jmk>>contentType is missing')

        config.contentType = undefined !== config.contentType ? config.contentType : 1
        config.name = config.name || 'asset-' + config.type + '-' + config.contentType + '-' + config.index;

        let n = this
        n._type = config.type
        n._contentType = config.contentType
        n._description = config.discripe
        n._enable = undefined !== config.enable ? config.enable : true
        n._extdata = new _AssetExtData_js__WEBPACK_IMPORTED_MODULE_0__.AssetExtData(this, config.extdata)
        n.followCamera = config.followCamera || false
        n._uuid = n._id = config.id || (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.genUUID)()
        n._info = config.info || {}
        n._mtl = config.mtl || ''
        n._obj = config.obj || ''
        n._music = config.music || ''
        n._name = config.name || ''
        n._opacity = config.opacity || 1.
        n._packTexture = config.packTexture || ''
        n._picturesId = config.picturesId || ''
        n._position = config.position
        n.positionId = config.positionId
        n._rotation = config.rotation
        n.rotationId = config.positionId
        n._quaternion = config.quaternion
        n.quaternionId = config.quaternionId
        n._scale = config.scale
        n.scaleId = config.scaleId
        n._texture = config.texture || config.src || ''
        n.thumb = config.thumb || ''
        n.normal = config.normal
        n.stayWhenClick = config.stayWhenClick

        n.isAnimate = !!config.isAnimate
        n.transformMode = config.transformMode || -1
        n.isRoamCharacter = !!config.isRoamCharacter

        n.enableHideInViews = !!config.enableHideInViews
        n.hideInViews = config.hideInViews || []
    }

    serialize() {
        let n = this

        let data = {
            type: n.type,
            contentType: n.contentType,
            discripe: n.description,
            enable: n.enable,
            extdata: n.extdata ? n.extdata.serialize() : {},
            followCamera: n.followCamera,
            id: n.uuid,
            Info: n._info,
            mtl: n.mtl,
            obj: n.obj,
            music: n.music,
            name: n.name,
            opacity: n.opacity,
            packTexture: n.packTexture,
            picturesId: n.picturesId,
            position: n.asPosition,
            positionId: n.positionId,
            rotation: n.asRotation,
            rotationId: n.rotationId,
            quaternion: n.asQuaternion,
            quaternionId: n.quaternionId,
            scale: n.asScale,
            scaleId: n.scaleId,
            texture: n.texture,
            thumb: n.thumb,
            normal: n.normal,
            stayWhenClick: n.stayWhenClick,

            isAnimate: this.isAnimate,
            transformMode: this.transformMode,
            isRoamCharacter: this.isRoamCharacter,

            enableHideInViews: this.enableHideInViews,
            hideInViews : this.hideInViews
        }

        Object.assign(data, n.getGeometryJson())

        n._onSerialize(data)

        return data
    }
}


Object.defineProperty(Asset.prototype, 'hasAnchor', {
    get: function () {
        return this._extdata.info.custom.tag.enable
    },
    set: function (value) {
        //value ? this._enableAnchor() : this._disableAnchor()
        this._extdata.info.custom.tag.enable = value
    }
})


Object.defineProperty(Asset.prototype, 'transformMode', {
    get: function () {
        return this._transformMode
    },
    set: function (value) {
        if (value) {
            this._transformMode = parseInt(value)
            this._updateTransformMode()
        }
    }
})

Asset.Types = {
    OBJ: 0,
    Image: 1,
    FBX: 2,
    Text: 3,
    Model: 4,
    Water: 5,
    Effect: 8,
    V3D: 9,
    JMODEL: 11,
    Anchor: 12,
    Unknown: 1
}

Asset.ContentTypes = {
    PIC: 1,
    GIF: 2,
    MP4: 3,
    model: 4,
    ZIPGIF: 5,
    PICGIF: 6,
    Flag: 7,
    Fire: 8,
    V3D: 9,
    ConeLight: 10,
    MP3:11,
}


JMT.Asset = Asset


/***/ }),

/***/ "./assets/AssetExtData.js":
/*!********************************!*\
  !*** ./assets/AssetExtData.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssetExtData": function() { return /* binding */ AssetExtData; },
/* harmony export */   "CustomTag": function() { return /* binding */ CustomTag; }
/* harmony export */ });
/**
 * Created by Kai on 2021/2/27.
 */

const DEFINE_PROPERTY = function (n, propertyName) {

    Object.defineProperty(n, propertyName, {
        get: function () {
            return n['_' + propertyName]
        },
        set: function (value) {
            n['_' + propertyName] = value
            if (!n.holder._initLock) {
                n.holder._updated(n, propertyName)
            }
        }
    })

}

class AssetExtData extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        this.deserialize(holder, config)

        // 已废弃？图片的详细类型
        DEFINE_PROPERTY(this, 'contentType')

        // 关联的详情
        DEFINE_PROPERTY(this, 'info')

        // placeholder
        DEFINE_PROPERTY(this, 'placeholder')

        // 素材地址
        DEFINE_PROPERTY(this, 'texture')
    }

    serialize() {
        let n = this
        return {
            contentType: n._contentType,
            Info: n.info.serialize(),
            placeholder: n._placeholder,
            texture: n._texture
        }
    }

    deserialize(holder, config) {
        this.holder = holder
        this._contentType = config.contentType
        this._info = new AssetExtDataInfo(holder, config.Info)
        this._placeholder = config.placeholder
        this._texture = config.texture
    }
}

class AssetExtDataInfo extends THREE.EventDispatcher {

    constructor(holder, config = {}) {
        super()

        this._hasCustom = true

        this.deserialize(holder, config)

        // 是否有详情编辑（非从JSON中导入，仅在内存中维护）
        DEFINE_PROPERTY(this, 'hasCustom')

        // 链接的按钮名称
        DEFINE_PROPERTY(this, 'btnText')

        //关联的素材（图片、视频、模型、音乐、文章、热点等）
        DEFINE_PROPERTY(this, 'custom')

        //discripe
        DEFINE_PROPERTY(this, 'description')

        //hot
        DEFINE_PROPERTY(this, 'anchor')

        //music
        DEFINE_PROPERTY(this, 'music')

        //sweep
        DEFINE_PROPERTY(this, 'sweep')

        //swiperList
        DEFINE_PROPERTY(this, 'swiperList')

        //target
        DEFINE_PROPERTY(this, 'target')
        //target
        DEFINE_PROPERTY(this, 'openLink')

        // 1内链还是2外链
        DEFINE_PROPERTY(this, 'linkType')

        // 链接地址
        DEFINE_PROPERTY(this, 'url')

        // 链接名称
        DEFINE_PROPERTY(this, 'urlName')

        // 服务器价格
        DEFINE_PROPERTY(this, 'serverPrice')
        // 服务器ID
        DEFINE_PROPERTY(this, 'serverId')
        // 服务器材质
        DEFINE_PROPERTY(this, 'serverUnit')
    }

    serialize() {
        let n = this
        return {
            btnText: n._btnText,
            custom: n._custom.serialize(),
            discripe: n._description,
            hot: n._anchor,
            music: n._music,
            sweep: n._sweep,
            swiperList: n._swiperList,
            target: n._target,
            openLink: n._openLink,
            linkType: n._linkType,
            url: n._url,
            urlName: n._urlName,
            serverPrice: n._serverPrice,
            serverId: n._serverId,
            serverUnit: n._serverUnit
        }
    }

    deserialize(holder, config) {
        this._btnText = config.btnText
        this._custom = new AssetExtDataCustomInfo(holder, config.custom)
        this._description = config.discripe
        this._anchor = config.hot
        this._music = config.music
        this._sweep = config.sweep
        this._swiperList = config.swiperList
        this._openLink = config.target || false
        this._target = config.openLink
        this._linkType = config.linkType
        this._url = config.url
        this._urlName = config.urlName
        this._serverPrice = config.serverPrice
        this._serverId = config.serverId
        this._serverUnit = config.serverUnit
        this.holder = holder
    }
}


class AssetExtDataCustomInfo extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()


        this.deserialize(holder, config)

        // 详情
        DEFINE_PROPERTY(this, 'detailAudio')
        // 详情
        DEFINE_PROPERTY(this, 'version')
        // 详情
        DEFINE_PROPERTY(this, 'normal')
        // 详情
        DEFINE_PROPERTY(this, 'detailArticle')
        // 详情
        DEFINE_PROPERTY(this, 'triggerPlay')
        // 详情
        DEFINE_PROPERTY(this, 'detailAlbum')
        // 详情
        DEFINE_PROPERTY(this, 'detailAlbumEye')
        // 详情
        DEFINE_PROPERTY(this, 'tag')
        // 详情
        DEFINE_PROPERTY(this, 'btnColor')
        // 3D播放
        DEFINE_PROPERTY(this, 'inlineplay')

        // 热点关联视频相关
        DEFINE_PROPERTY(this, 'materialSwitch')
        DEFINE_PROPERTY(this, 'materialPicType')
        DEFINE_PROPERTY(this, 'targetMaterial')
        DEFINE_PROPERTY(this, 'replaceMaterial')
        DEFINE_PROPERTY(this, 'eventControl')

        // 场景穿梭
        DEFINE_PROPERTY(this, 'portal')
        DEFINE_PROPERTY(this, 'portalWebsite')
        DEFINE_PROPERTY(this, 'transitVideo')

        // 视频距离触发相关
        DEFINE_PROPERTY(this, 'distanceTrigger')
        DEFINE_PROPERTY(this, 'bgVolume')
        DEFINE_PROPERTY(this, 'playShow')
        // hover 变大
        DEFINE_PROPERTY(this, 'hoverChange')

        // 环拍图
        DEFINE_PROPERTY(this, 'ringShotUrl')
        DEFINE_PROPERTY(this, 'openMode')
        DEFINE_PROPERTY(this, 'openBgOpacity')
        DEFINE_PROPERTY(this, 'openIframeOpacity')
        DEFINE_PROPERTY(this, 'openWidthRatio')
        DEFINE_PROPERTY(this, 'openLinkType')
    }


    addCustomAlbum() {
        let ca = new CustomAlbum(this.holder)
        this._detailAlbum.push(ca)
        return ca
    }

    serialize() {
        let n = this
        return {
            detail_audio: n._detailAudio.serialize(),
            version: n._version,
            normal: n._normal,
            'detail_article': n._detailArticle.serialize(),
            'trigger_alay': n._triggerPlay.serialize(),
            'detail_album': n._detailAlbum.map(album => {
                return album.serialize ? album.serialize() : album
            }),
            detailAlbumEye: n._detailAlbumEye,
            tag: n._tag.serialize(),
            btnColor: n._btnColor,
            inlineplay: n._inlineplay,
            materialSwitch: n._materialSwitch,
            materialPicType: n._materialPicType,
            targetMaterial: n._targetMaterial,
            replaceMaterial: n._replaceMaterial,
            eventControl: n._eventControl,
            portal: n._portal,
            portalWebsite: n._portalWebsite,
            transitVideo: n._transitVideo,
            // 视频距离触发相关
            distanceTrigger: n._distanceTrigger,
            // hover 变大
            hoverChange: n._hoverChange,
            ringShotUrl: n._ringShotUrl,
            // 打开方式
            openMode: n._openMode,
            //弹出网页时背景透明度
            openBgOpacity: n._openBgOpacity,
            //弹出网页时iframe透明度
            openIframeOpacity: n._openIframeOpacity,
            //弹出网页时宽高比
            openWidthRatio: n._openWidthRatio,
            openLinkType: n._openLinkType,
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n._detailAudio = new CustomAudio(holder, config['detail_audio'])
        n._version = config.version
        n._normal = config.normal
        n._detailArticle = new CustomArticle(holder, config['detail_article'])
        n._triggerPlay = new CustomTriggerPlay(holder, config['trigger_alay'])
        n._detailAlbum = (config['detail_album'] || []).map(item => {
            return new CustomAlbum(holder, item)
        })
        n._detailAlbumEye = config.detailAlbumEye
        n._tag = new CustomTag(holder, config['tag'])
        n._btnColor = config.btnColor
        n._inlineplay = !!config.inlineplay
        n._materialSwitch = !!config.materialSwitch
        n._materialPicType = config.materialPicType
        n._targetMaterial = config.targetMaterial
        n._replaceMaterial = config.replaceMaterial
        n._eventControl = config.eventControl
        n._portal = !!config.portal
        n._portalWebsite = config.portalWebsite
        n._transitVideo = config.transitVideo
        // 视频距离触发相关
        n._distanceTrigger = !!config.distanceTrigger
        // hover 变大
        n._hoverChange = !!config.hoverChange
        n._ringShotUrl = config.ringShotUrl
        n._openMode = config.openMode || "openInfo"
        n._openBgOpacity = config.openBgOpacity || 1
        n._openIframeOpacity = config.openIframeOpacity || 1
        n._openWidthRatio = config.openWidthRatio
        n._openLinkType = config.openLinkType || false
    }
}

class CustomTag extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        this.isTag = !0

        // enable
        DEFINE_PROPERTY(this, 'enable')

        // length
        DEFINE_PROPERTY(this, 'length')

        // visible
        DEFINE_PROPERTY(this, 'visible')

        // texture
        DEFINE_PROPERTY(this, 'texture')

        // showTitle
        DEFINE_PROPERTY(this, 'showTitle')

        // size
        DEFINE_PROPERTY(this, 'size')

        // title
        DEFINE_PROPERTY(this, 'title')

        // color
        DEFINE_PROPERTY(this, 'color')

        // fontSize
        DEFINE_PROPERTY(this, 'fontSize')

        // fontFamily
        DEFINE_PROPERTY(this, 'fontFamily')

        // textBaseline
        DEFINE_PROPERTY(this, 'textBaseline')

        // shadowColor
        DEFINE_PROPERTY(this, 'shadowColor')

        // shadowBlur
        DEFINE_PROPERTY(this, 'shadowBlur')

        // offsetH
        DEFINE_PROPERTY(this, 'offsetH')

        // opacity
        DEFINE_PROPERTY(this, 'opacity')

        // radius
        DEFINE_PROPERTY(this, 'radius')

        // textMargin
        DEFINE_PROPERTY(this, 'textMargin')

        // isGIF
        DEFINE_PROPERTY(this, 'isGIF')

        // lineSize
        DEFINE_PROPERTY(this, 'lineSize')

        // lineColor
        DEFINE_PROPERTY(this, 'lineColor')

        // style
        DEFINE_PROPERTY(this, 'style')

        // height
        DEFINE_PROPERTY(this, 'height')

        // fillColor
        DEFINE_PROPERTY(this, 'fillColor')

        // textAlign
        DEFINE_PROPERTY(this, 'textAlign')

        Object.defineProperty(this, 'text', {
            get: () => {
                return this.title || this.holder.name || 'N/A'
            }
        })

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            enable: n.enable,
            length: n.length,
            visible: n.visible,
            texture: n.texture,
            showTitle: n.showTitle,
            size: n.size,
            title: n.title,
            color: n.color,
            fontSize: n.fontSize,
            fontFamily: n.fontFamily,
            textBaseline: n.textBaseline,
            shadowColor: n.shadowColor,
            shadowBlur: n.shadowBlur,
            offsetH: n.offsetH,
            opacity: n.opacity,
            radius: n.radius,
            textMargin: n.textMargin,
            lineSize: n.lineSize,
            lineColor: n.lineColor,
            style: n.style,
            height: n.height,
            fillColor: n.fillColor,
            textAlign: n.textAlign
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n.enable = config.enable || false // 给属性赋值，触发开启热点
        n.length = config.length || 0.1
        n.visible = config.visible
        n.texture = config.texture
        n.showTitle = config.showTitle
        n.size = config.size || .1
        n.title = config.title || 'NONAME'
        n.color = config.color || "#ffffff"
        n.fontSize = config.fontSize || 60
        n.fontFamily = config.fontFamily || "Noto Sans"
        n.textBaseline = config.textBaseline || "middle"
        n.shadowColor = config.shadowColor || "black"
        n.shadowBlur = config.shadowBlur || 16
        n.offsetH = config.offsetH || 0
        n.opacity = config.opacity || 1
        n.radius = config.radius || 0.05
        n.textMargin = config.textMargin || 10
        n.lineSize = config.lineSize || 5
        n.lineColor = config.lineColor || 65280
        n.style = config.style || "sprite"
        n.height = config.height || .5
        n.fillColor = config.fillColor || "#4c9ed9"
        n.textAlign = config.textAlign || "center"
    }
}

class CustomDelay extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        // delay
        DEFINE_PROPERTY(this, 'delay')

        // width
        DEFINE_PROPERTY(this, 'width')

        // height
        DEFINE_PROPERTY(this, 'height')

        // extension
        DEFINE_PROPERTY(this, 'extension')

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            delay: n._delay,
            width: n._width,
            height: n._height,
            extension: n._extension
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n._delay = config.delay || []
        n._width = config.w
        n._height = config.h
        n._extension = config.ext

    }
}


class CustomAlbum extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        // extension
        DEFINE_PROPERTY(this, 'picPathCompre')

        // extension
        DEFINE_PROPERTY(this, 'fileType')

        // picId
        DEFINE_PROPERTY(this, 'picId')

        // picPath
        DEFINE_PROPERTY(this, 'picPath')

        // delay
        DEFINE_PROPERTY(this, 'delay')

        // link
        DEFINE_PROPERTY(this, 'link')

        // videoThumb
        DEFINE_PROPERTY(this, 'videoThumb')

        // videoThumbName
        DEFINE_PROPERTY(this, 'videoThumbName')

        DEFINE_PROPERTY(this, 'modelFile')

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            picPathCompre: n._picPathCompre,
            fileType: n._fileType,
            picId: n._picId,
            picPath: n._picPath,
            delay: n._delay.serialize(),
            link: n._link,
            videoThumb: n._videoThumb,
            videoThumbName: n._videoThumbName,
            modelFile: n._modelFile
        }
    }

    deserialize(holder, config) {
        let n = this

        n._picPathCompre = config.picPathCompre
        n._fileType = config.fileType
        n._picId = config.picId
        n._picPath = config.picPath
        n._delay = new CustomDelay(config.delay)
        n._link = config.link
        n._videoThumb = config.videoThumb
        n._videoThumbName = config.videoThumbName
        n._modelFile = config.modelFile
        n.holder = holder
    }
}

class CustomArticle extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        // id
        DEFINE_PROPERTY(this, 'id')

        // title
        DEFINE_PROPERTY(this, 'title')

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            id: n._id,
            title: n._title
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n._id = config.id
        n._title = config.title

    }
}

class CustomTriggerPlay extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        // 是否循环播放
        DEFINE_PROPERTY(this, 'isLoop')
        // 是否添加解说员
        DEFINE_PROPERTY(this, 'isShowNarrator')
        // 解说员地址
        DEFINE_PROPERTY(this, 'narratorUrl')
        // 解说员尺寸
        DEFINE_PROPERTY(this, 'narratorSize')
        // 解说词
        DEFINE_PROPERTY(this, 'narratorLyrics')
        // 解说词
        DEFINE_PROPERTY(this, 'narratorLyricsName')
        // 解说词文件
        DEFINE_PROPERTY(this, 'narratorLyricsUrl')

        // 音量
        DEFINE_PROPERTY(this, 'volume')
        // 触发方式（距离触发、范围触发）
        DEFINE_PROPERTY(this, 'triggerType');
        // 触发距离（仅距离触发有效）
        DEFINE_PROPERTY(this, 'distance');
        // 范围列表（仅范围触发有效）
        DEFINE_PROPERTY(this, 'ranges');
        // 可见范围内播放
        DEFINE_PROPERTY(this, 'visiblePlay');
        // 距离最近播放
        DEFINE_PROPERTY(this, 'nearestPlay');
        // 调节背景音
        DEFINE_PROPERTY(this, 'bgVolume');
        // 播放时显示
        DEFINE_PROPERTY(this, 'playShow');

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            isLoop: n._isLoop,
            isShowNarrator: n._isShowNarrator,
            narratorUrl: n._narratorUrl,
            narratorSize: n._narratorSize,
            narratorLyrics: n._narratorLyrics,
            narratorLyricsUrl: n._narratorLyricsUrl,
            narratorLyricsName: n._narratorLyricsName,
            volume: n._volume,
            triggerType: n._triggerType,
            distance: n._distance,
            ranges: n._ranges,
            visiblePlay: n._visiblePlay,
            nearestPlay: n._nearestPlay,
            bgVolume: n._bgVolume,
            playShow: n._playShow,
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n._isLoop = config.isLoop || false
        n._isShowNarrator = config.isShowNarrator || false
        n._narratorUrl = config.narratorUrl
        n._narratorSize = config.narratorSize
        n._narratorLyrics = config.narratorLyrics || false
        n._narratorLyricsUrl = config.narratorLyricsUrl
        n._narratorLyricsName = config.narratorLyricsName
        n._volume = config.volume || 0.5
        n._triggerType = config.triggerType || 1
        n._distance = config.distance || 10
        n._ranges = config.ranges || []
        n._visiblePlay = config.visiblePlay || false
        n._nearestPlay = config.nearestPlay || false
        n._bgVolume = config.bgVolume || 1
        n._playShow = config.playShow || false

    }
}

class CustomAudio extends THREE.EventDispatcher {
    constructor(holder, config = {}) {
        super()

        // name
        DEFINE_PROPERTY(this, 'name')

        // musicFile
        DEFINE_PROPERTY(this, 'musicFile')

        this.deserialize(holder, config)
    }


    serialize() {
        let n = this
        return {
            name: n._name,
            musicFile: n._musicFile
        }
    }

    deserialize(holder, config) {
        let n = this
        n.holder = holder
        n._name = config.name
        n._musicFile = config.musicFile

    }
}

/***/ }),

/***/ "./assets/AssetPointerEventHelper.js":
/*!*******************************************!*\
  !*** ./assets/AssetPointerEventHelper.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AssetPointerEventHelper": function() { return /* binding */ AssetPointerEventHelper; }
/* harmony export */ });
/* harmony import */ var _src_utils_PointerEventHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/utils/PointerEventHelper.js */ "./src/utils/PointerEventHelper.js");
/**
 * Created by Kai on 2021/3/5.
 */



class AssetPointerEventHelper extends _src_utils_PointerEventHelper_js__WEBPACK_IMPORTED_MODULE_0__.PointerEventHelper{

    constructor(pointerEventDispatcher, priorty){

        super(pointerEventDispatcher, priorty)

        if(pointerEventDispatcher.isEditor){

            function ondefault() {
                return !1
            }


            this.callbacks.onDragging = ondefault
            this.callbacks.onDrop = ondefault

            let t = this

            function onDragging(x, y, event){

                var c = t.callbacks.onDragging(x, y, event);

                return c
            }

            function onDrop(x, y, event){

                var c = t.callbacks.onDrop(x, y, event);

                return c
            }

            this.onEnable = function(){
                pointerEventDispatcher.addPointerDraggingListener(onDragging, priorty)
                pointerEventDispatcher.addPointerDropListener(onDrop, priorty)
            }


            this.onDisable = function(){
                pointerEventDispatcher.removePointerDraggingListener(onDragging)
                pointerEventDispatcher.removePointerDropListener(onDrop)
            }
        }
    }
}

/***/ }),

/***/ "./assets/AssetsController.js":
/*!************************************!*\
  !*** ./assets/AssetsController.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _ImageAsset_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ImageAsset.js */ "./assets/ImageAsset.js");
/* harmony import */ var _GIFAsset_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GIFAsset.js */ "./assets/GIFAsset.js");
/* harmony import */ var _VideoAsset_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./VideoAsset.js */ "./assets/VideoAsset.js");
/* harmony import */ var _TextAsset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TextAsset.js */ "./assets/TextAsset.js");
/* harmony import */ var _ModelAsset_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ModelAsset.js */ "./assets/ModelAsset.js");
/* harmony import */ var _FlagAsset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./FlagAsset.js */ "./assets/FlagAsset.js");
/* harmony import */ var _FireAsset_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./FireAsset.js */ "./assets/FireAsset.js");
/* harmony import */ var _AnchorAsset_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AnchorAsset.js */ "./assets/AnchorAsset.js");
/* harmony import */ var _ConeLightAsset_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ConeLightAsset.js */ "./assets/ConeLightAsset.js");
/* harmony import */ var _AssetPointerEventHelper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./AssetPointerEventHelper.js */ "./assets/AssetPointerEventHelper.js");
/* harmony import */ var _utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/interactionDetector.js */ "./utils/interactionDetector.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _AudioAsset_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./AudioAsset.js */ "./assets/AudioAsset.js");
/**
 * Created by Kai on 2021/1/25.
 */
















function err(e) {
    JMT.USER_MSG.info(e);
}

function getTextureLoader(onload, onerror) {
    return new JMT.j3dTextureLoader(
        "./",
        JMT.DETECTOR,
        function (a) {
            onload(a)
        },
        onerror,
        onerror,
        !0
    )
}


const MUTE_DIST = JMT.VIDEO_MUTE_THRSHOLD || 3

function setVideoVolume(va, camera) {

    //let cPos = camera.getWorldPosition()
    let cPos = new THREE.Vector3()
    camera.getWorldPosition(cPos)

    let dist = va.position.distanceTo(cPos)

    //console.log(dist);

    if (dist < MUTE_DIST) {
        let volume = (MUTE_DIST - dist) / MUTE_DIST
        //va.setVolume( volume )
        va.setVolume(1)
    } else {
        va.setVolume(0)
    }
}

class AssetsController extends THREE.EventDispatcher {

    constructor(app) {

        super()

        this.app = app

        app.assetsController = this

        this._assets = new Set

        //this._materials = {}

        this._selected = null

        this._hovered = null

        this._animatedAssets = []

        this.textureLoader = getTextureLoader(() => {

            UjP.aniController.requestFrame()

        }, err)

        let n = this

        Object.defineProperty(n, 'assetsCount', {
            get: function () {
                return n._assets.size
            }
        })

        Object.defineProperty(n, 'assets', {
            get: function () {
                return n._assets
            }
        })


        Object.defineProperty(n, 'selectedAsset', {
            get: function () {
                return this._selected
            },
            set: function (asset) {

                if (asset === n._selected) {
                    return
                }

                if (n._selected) {
                    n._selected.leave()
                    n._selected = null
                    n.disableTransformControl()
                }

                if (asset && asset.isAsset) {
                    n._selected = asset
                    asset.select()

                    n.enableTransforControl()
                }
            }
        })

        Object.defineProperty(n, 'hoveredAsset', {
            get: function () {
                return this._hovered
            },
            set: function (asset) {
                if (n._hovered) {
                    n._hovered.leave()
                    n._hovered = null
                }

                if (asset && asset.isAsset) {
                    n._hovered = asset
                    asset.hover()
                }
            }
        })

        this._initCameraUpdatedCallback(app)


        // 移动时候取消鼠标捕捉，以提升性能
        app.addEventListener('activateDirectionFromSource', () => {
            n.disableSelect = !0
        })

        app.addEventListener('deactivateDirectionFromSource', () => {
            n.hoveredAsset = null
            n.disableSelect = !1
        })
    }

    _initCameraUpdatedCallback(app) {
        let that = this

        let camera = app.controls.camera()

        function onCameraUpdated(event) {
            //console.log(event.target);
            camera = event.target

            that._animatedAssets.forEach(va => {

                if ((0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_12__.isVisible)(va._mesh, camera)) {

                    //setVideoVolume(va, camera)
                    va.setVolume(1)
                } else {

                    va.setVolume(0)
                    //va.pause()
                }

            })
        }

        camera.addEventListener('rotationChanged', onCameraUpdated)
        camera.addEventListener('positionChanged', onCameraUpdated)
    }


    //addMaterial(asset, index, material){
    //
    //    let arrMat = this._materials[asset.uuid]
    //
    //    if(!arrMat){
    //
    //        arrMat = [material]
    //
    //    }
    //    else {
    //
    //        arrMat.splice(index, 0, material)
    //
    //    }
    //
    //    this._materials[assets.uuid] = arrMat
    //
    //    console.log(this._materials);
    //}
    //
    //getMaterials(asset){
    //
    //    return this._materials ? this._materials[asset.uuid] : []
    //
    //}

    enableSelection() {
        if (JMT.EDIT_MODE) {
            this._transformControls = this.app.editorHooks.transformControls
            this._alignControls = new JMT.j3dAlignControls(this)
        }
        this.eventHelper.enable()
    }

    disableSelection() {
        this.eventHelper.disable()
        if (JMT.EDIT_MODE) {
            this._transformControls && this._transformControls.disable()
            this._alignControls && this._alignControls.disable()
        }
    }

    initPointerEventHelper(pointerEventDispatcher) {

        var a = new _AssetPointerEventHelper_js__WEBPACK_IMPORTED_MODULE_10__.AssetPointerEventHelper(pointerEventDispatcher, JMT.POINTER_PRIORITY.ASSET_SELECTOR);

        a.callbacks.onClick = this.onClick.bind(this)

        a.callbacks.onPointerMove = this.onPointerMove.bind(this)

        a.callbacks.onPointerDown = this.onPointerDown.bind(this)

        a.callbacks.onPointerUp = this.onPointerUp.bind(this)

        if (pointerEventDispatcher.isEditor) {

            a.callbacks.onDragging = this.onDragging.bind(this)

            a.callbacks.onDrop = this.onDrop.bind(this)
        }

        this.eventHelper = a
    }


    onClick(x, y, event) {

        let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.findIntersectionAtPosition)({x: x, y: y}, this.assets)

        if (!b) {

            this.disableTransformControl()

            this.app.viewer.dispatchEvent({type: 'assetClick', asset: null})

        } else {

            //和场景求交点，根据交点距离判断素材是否被场景遮挡
            let intersect = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.detectIntersect)(event)
            if (intersect) {

                // let deviationDistance = intersect.distance

                // //浏览模式下场景数据只存在于GPU
                // //GPU选择和CPU选择存在误差
                // //这里暂时将交点距离扩大，减少误差
                // if (!intersect.face || intersect.face[0] == -1) {
                //     let c = UjP.controls
                //     let camera = c.camera instanceof Function ? c.camera() : c.camera
                //     deviationDistance = (1 + 1/(camera.far-camera.near)) * intersect.distance
                // }
                

                if (intersect.distance < b.distance) {

                    this.disableTransformControl()
                    this.app.viewer.dispatchEvent({type: 'assetClick', asset: null})
                    return false
                }

            }

            let asset = b.object

            if (this.selectedAsset !== asset) {
                this.selectedAsset = asset

            } else if (asset) {
                asset.click()
            }

            this.enableTransforControl()

            return true   // 阻止继续碰撞
        }

        return false

    }

    onPointerUp(x, y) {
        let n = this
        if (n._dragged) {
            n.enableTransforControl()
            n._dragged = false
            n._alignControls.onDrop(n.selectedAsset)
        }

        if (n.selectedAsset) {
            document.getElementById(UjP.config.el).style.cursor = 'grab'//'url(css/image/bb.ico),auto'//
        }

        n.disableSelect = !1
    }

    enableTransforControl() {
        let n = this
        let asset = n.hoveredAsset || n.selectedAsset
        if (asset) {
            n._transformControls && n._transformControls.enable(asset, [
                JMT.TRANSFORM_MODE.TRANSLATE,
                JMT.TRANSFORM_MODE.ROTATE,
                JMT.TRANSFORM_MODE.SCALE
            ])
        }
    }

    disableTransformControl() {
        this._transformControls && this._transformControls.disable()
    }

    onPointerDown(x, y, e) {

        let n = this

        e.button === 2 || (n.disableSelect = !0)

        let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.findIntersectionAtPosition)({x: x, y: y}, n.assets)

        if (!b) {

            return
        }

        //如果素材没被场景遮挡 直接返回
        if (b.object) {
            let a = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.detectIntersect)(e)
            if (!a || a.distance < b.distance)
                return;
        }


        let asset = b.object
        let hitAnchor = b.hitAnchor
        if (hitAnchor) {
            asset.dispatchEvent({type: "assetAnchorClick", asset: asset, anchor: asset._anchor})
        } else {
            if (asset.enable) {


                document.getElementById(UjP.config.el).style.cursor = 'grabbing' //'url(css/image/aa.ico),auto'//


                //if (e.button === 0) {
                //    n.selectedAsset = asset
                //} else
                if (e.button === 2) {
                    n.hoveredAsset = asset
                    if (n._alignControls) n._dragged = true
                }
            }
        }
    }

    onPointerMove(x, y, e) {

        let n = this

        if (n.disableSelect) {
            return
        }


        if (n._dragged) {
            if (n.hoveredAsset) {
                let asset = n.hoveredAsset

                if (asset.enable) {
                    //禁止捕捉当前素材
                    let assets_ = new Set()
                    for (var v of n.assets) {
                        if (v !== n.hoveredAsset)
                            assets_.add(v)
                    }
                    let a = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.findIntersectionAtPosition)({x: x, y: y}, assets_, false)
                    let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.detectIntersect)(e)
                    let c
                    if (a && b) c = a.distance < b.distance ? a : b
                    else if (a && !b) c = a
                    else if (!a && b) c = b

                    if (c) {
                        asset.update(b.point, b.normal)
                        UjP.aniController.requestFrame()
                    }

                }

                this.disableTransformControl()

            }

            // 判断临近，以便吸附
        } else {
            let asset = null
            let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.findIntersectionAtPosition)({x: x, y: y}, n.assets)
            if (b && b.object) {
                
                // 判断是否被场景遮挡
                //hover的时候只需粗略判断
                if( b.distance < UjP.lastMouseDistance || Math.abs(b.distance - UjP.lastMouseDistance) < 0.02) {
                    asset = b.object
                }
            }
            n.hoveredAsset = asset
        }
    }

    addAssetWithConfig(config, resolve) {
        this._target = config
        this._addedResolve = resolve
    }

    _getAsset(event) {
        //if(!this.selectedAsset){
        let asset = null

        let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.detectIntersect)(event)

        let tag = this._target

        if (b) {

            let config = {
                position: b.point,
                normal: b.normal,
                object: b.object,
                radius: 0.07,
                color: "#4c9ed9",
                scale: 1,
                style: "sphere",
                width: 512,
                height: 512,
                creating: !0
            }

            b.object.lightProbe && (config.lightProbeId = b.object.lightProbe.id)

            tag && (config = Object.assign(config, tag))

            asset = this.createAsset(config)

            this._addedResolve && this._addedResolve(asset)

            this._target = null

        }
        //}

        return asset
    }

    async onDragging(x, y, e) {

        e.stopPropagation();
        //阻止浏览器默认打开文件的操作
        e.preventDefault();

        let n = this
        let asset = this.hoveredAsset

        if (n._target) {
            //n._target
            asset = n._getAsset(e)
            this.hoveredAsset = asset
            this._dragged = !0
        } else {
            asset = this.hoveredAsset
            if (asset) {


                let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_11__.detectIntersect)(e)

                if (b) {

                    asset.update(b.point, b.normal)

                    UjP.aniController && UjP.aniController.requestFrame()
                }
            }
        }


        //let out = e.dataTransfer.items
        //else if (out.length > 0) {
        //    out = out[0]
        //
        //    if (out.kind === 'file') {
        //        // Process all of the items.
        //        for (const item of e.dataTransfer.items) {
        //            // kind will be 'file' for file/directory entries.
        //            if (item.kind === 'file') {
        //                const entry = await item.getAsFileSystemHandle();
        //                if (entry.kind === 'file') {
        //                    // run code for if entry is a file
        //                } else if (entry.kind === 'directory') {
        //                    // run code for is entry is a directory
        //                }
        //            }
        //        }
        //    }
        //}
    }

    onDrop(x, y, e) {
        e.stopPropagation();
        //阻止浏览器默认打开文件的操作
        e.preventDefault();

        let n = this
        n._alignControls.onDrop(n.selectedAsset)

        n.selectedAsset = null
        n.hoveredAsset = null
        n._dragged = !1
        n._target = null

        UjP.aniController.requestFrame()
    }

    update(tick) {
        //this._assets.forEach(asItem=> {
        //    asItem.animate(tick)
        //})
        this.dispatchEvent({type: 'animate', deltaTime: tick})
    }

    createAsset(config) {

        let type = config.type

        let contentType = config.contentType

        let t = _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.Types

        let ct = _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes

        let asset = null

        config.textureLoader = this.textureLoader

        let index = this.assetsCount

        switch (type) {
            case t.Model:
                asset = new _ModelAsset_js__WEBPACK_IMPORTED_MODULE_5__.ModelAsset(config, index)
                break
            case t.Text:
                asset = new _TextAsset_js__WEBPACK_IMPORTED_MODULE_4__.TextAsset(config, index)
                break
            case t.Effect:
                switch (contentType) {
                    case _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.Flag:
                        asset = new _FlagAsset_js__WEBPACK_IMPORTED_MODULE_6__.FlagAsset(config, index)
                        break
                    case _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.Fire:
                        asset = new _FireAsset_js__WEBPACK_IMPORTED_MODULE_7__.FireAsset(config, index)
                        break
                    case _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.ConeLight:
                        asset = new _ConeLightAsset_js__WEBPACK_IMPORTED_MODULE_9__.ConeLightAsset(config, index)
                        break
                    default :
                        break
                }
                break
            case t.Anchor:
                asset = new _AnchorAsset_js__WEBPACK_IMPORTED_MODULE_8__.AnchorAsset(config, index)
                break
            case t.Image:
                switch (contentType) {
                    case ct.PIC:
                        asset = new _ImageAsset_js__WEBPACK_IMPORTED_MODULE_1__.ImageAsset(config, index)
                        break
                    case ct.GIF:
                        asset = new _GIFAsset_js__WEBPACK_IMPORTED_MODULE_2__.GIFAsset(config, index)
                        break
                    case ct.MP4:
                        asset = new _VideoAsset_js__WEBPACK_IMPORTED_MODULE_3__.VideoAsset(config, index)
                        break
                    case ct.MP3:
                        asset = new _AudioAsset_js__WEBPACK_IMPORTED_MODULE_13__["default"](config, index)
                        break
                }
                break
            default :
                break
        }
        if (!asset) {
            JMT.USER_MSG('unknown asset type(' + type + ')/contentType(' + contentType + ')')
            return null
        }

        return this.addAsset(asset)
    }

    addAsset(asset) {


        let viewer = this.app.viewer

        let t = this

        asset.bindEventCallback('assetAdded', () => {

            viewer.dispatchEvent({type: 'assetAdded', asset: asset})

        })

        asset.bindEventCallback('assetHover', () => {

            viewer.dispatchEvent({type: 'assetHover', asset: asset})

        })

        asset.bindEventCallback('assetLeave', () => {

            viewer.dispatchEvent({type: 'assetLeave', asset: asset})

        })

        asset.bindEventCallback('assetClick', () => {

            viewer.dispatchEvent({type: 'assetClick', asset: asset})

        })

        asset.bindEventCallback('assetAnchorClick', () => {

            viewer.dispatchEvent({type: 'assetAnchorClick', asset: asset})

        })

        asset.bindEventCallback('assetUpdating', (event) => {

            if (t._addSilence) {
                return
            }

            let args = {
                type: 'assetUpdating',
                asset: asset,
                property: event.property,
                value: event.value,
                cancel: !1
            }

            viewer.dispatchEvent(args)

            event.cancel = args.cancel

        })


        asset.bindEventCallback('assetUpdated', (event) => {

            viewer.dispatchEvent({type: 'assetUpdated', asset: asset, property: event.property})

        })

        asset.isVideo && asset.bindEventCallback('videoPlaying', (event) => {

            let camera = UjP.controls.camera()

            setVideoVolume(event.target, camera)

        })

        asset.init()

        this._assets.add(asset)

        this.app.scene.addAuxiliaryObject(asset, asset.isAnimate)

        asset.isVideo && this._animatedAssets.push(asset)

        if (!this._addSilence) {

            this.app.scene._onSceneChanged()

        }

        return asset
    }

    removeAsset(asset) {

        if (asset === this.selectedAsset) {

            this.selectedAsset = null

        }

        this._assets.delete(asset)

        asset.isVideo && (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_12__.removeFromArray)(asset, this._animatedAssets)

        this.app.scene.removeAuxiliaryObject(asset)

        this.app.scene._onSceneChanged()

        this.app.dispatchEvent({type: 'assetRemoved', asset: asset})

        asset.dispose()
    }

    clear() {
        let t = this
        let e = $jscomp.makeIterator(t._assets);
        for (let f = e.next(); !f.done; f = e.next()) {
            t.removeAsset(f.value)
        }

        t._materials = {}
    }

    findAsset(propertyName, value) {
        let asset = null

        this._assets.forEach(ass => {
            if (ass[propertyName] === value) {
                asset = ass
                return asset
            }
        })

        return asset
    }

    deserialize(extobjs, onAssetCreate) {

        this._addSilence = true

        let pending = []

        let n = this
        let index = 0
        if (extobjs && extobjs.length) {
            extobjs.forEach(item => {

                pending.push(new Promise(resolve => {

                    let asset = n.createAsset(item)

                    onAssetCreate && onAssetCreate(asset)

                    asset.addEventListener('assetLoaded', event => {

                        index++

                        n.app.viewer.dispatchEvent({
                            type: 'assetLoadingProgress',
                            data: {
                                current: index,
                                total: extobjs.length,
                                name: event.target.type + '/' + event.target.contentType
                            }
                        })

                        //console.log(event.target.name, event.target.texture);

                        resolve()

                    })
                }))
            })
        } else {
            n.app.viewer.dispatchEvent({
                type: 'assetLoadingProgress',
                data: {
                    current: 1,
                    total: 1
                }
            })
        }


        Promise.all(pending).finally((() => {

            this.dispatchEvent({type: 'assetsLoaded'})

            UjP.teleport.updateFromAssets(this.assets)

            this._addSilence = false

        }))
    }

    serialize() {
        let n = this
        let assets = []
        if (n.assetsCount) {
            n._assets.forEach(item => {

                assets.push(item.serialize())
            })
        }
        return assets
    }
}


JMT.AssetsController = AssetsController


/***/ }),

/***/ "./assets/AudioAsset.js":
/*!******************************!*\
  !*** ./assets/AudioAsset.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders/GLTFLoader.js */ "./loaders/GLTFLoader.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Create by LiZhiHui on 2021/7/13
 */





var t0, t1, t2, uv, uv2, uv2Mod;

class AudioAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id);

        this.isAudio = JMT.ALWAYS_RENDER = true

        if (!t0) {
            t0 = new THREE.InstancedBufferAttribute(new Float32Array([1, 0, 0, 0]), 4);
            t1 = new THREE.InstancedBufferAttribute(new Float32Array([0, 1, 0, 0]), 4);
            t2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1, 0]), 4);

            // //uv2Mod
            // var uv = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
            // var uv2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
            // var uv2Mod = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1 / 65535, 1 / 65535]), 4);
        }
        
    }
    _onDefineProperties() {  
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.defineProperty)(this, "audioTime");
    }

    _initMesh(config) {
        let material2 = this._createMaterial2(config)
        let geometry2 = this._createGeometry2(config)
        geometry2.setAttribute("t0", t0)
        geometry2.setAttribute("t1", t1)
        geometry2.setAttribute("t2", t2)

        let mesh2 = new THREE.Mesh(geometry2, material2)
        if(JMT.EDIT_MODE) {
            let material1 = this._createMaterial1(config)

            let geometry1 = this._createGeometry1(config)
            geometry1.setAttribute("t0", t0)
            geometry1.setAttribute("t1", t1)
            geometry1.setAttribute("t2", t2)
    
            let mesh1 = new THREE.Mesh(geometry1, material1)
            
            mesh2.add(mesh1)
        }

        

        return Promise.resolve(mesh2)
    }

    _createGeometry1(config) {

        const geometry = new THREE.IcosahedronBufferGeometry(0.5, 1)

        geometry.addTriangleOrderAttribute()

        geometry.convertNormalsToSpherical()

        return geometry;
    }
    _createGeometry2(config) {

        let size = config.size || 1.0
        let g = new THREE.PlaneBufferGeometry(0.5, 0.5)
        g.attributes.uv.array = new Float32Array([
            1, 1,
            1, 0,
            0, 1,
            0, 0
        ])
        g.convertNormalsToSpherical()
        return g;
    }

    _createMaterial1(config) {
        const material = JMT.createBoundingBoxMaterial();
        return material;
    }
    _createMaterial2(config) {
        let g = new JMT.j3dStandardMaterial;
        this.onCreateMaterial(g, config)

        if (this._initLock) {
            let texture = g.baseColorTexture
            if (texture) {
                texture.hasAlpha = this._opacity && 1 > this._opacity;
            }
            g.opacity = this._opacity
            g.configureTransparency()
        }

        g.setUniforms && g.setUniforms();
        return g
    }
    onCreateMaterial(material, config) {
        //var texture = "http://192.168.20.59:5432/webwalk/img/music.png"
        var texture = config.thumb
        if (texture) {
            let rawExt = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.getExtension)(texture);
            let alpha = config.hasAlpha || rawExt === "png";
            let n = this;
            let param = {
                alpha: alpha,
                id: this.uuid,
                name: config.name,
                rawExt: rawExt,
                stdExt: "jpg",
                url: texture,
                webFormats: [
                    //"small/std", "large/dxt", "small/pvr", "small/etc1"
                ],
            };

            let t = this._textureLoader.load(
                JMT.LOAD_PRIORITY.CORE_RESOURCE,
                param,
                !0,
                !0,
                JMT.DEFAULT_ANISOTROPY
            );
            // TODO: 是否从编辑模式进来？
            t.fromEditor = !0;
            

            t.addLoadingListener(() => {
                n._originImg = t.image;
                // t.scale.set(0.3, 0.3, 0.3);
                // if (config.creating) {
                //    
                //     n.updateMatrixWorld(!0);
                //     config.creating = !1;
                // }
                t.hasAlpha = alpha;
                if (alpha) {
                    material.configureTransparency();
                }
                n.dispatchEvent({
                    type: "assetLoaded"
                });
            });
            material.baseColorTexture = t;
            material.doubleSided = !0;
            this.material = material;
        }
    }
    deserialize(config) {
        let n = this;
        let time = config.time || {};
        n._audioTime = time.audioTime;
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config);
    }

    _onSerialize(data) {
        let n = this;

        data["time"] = {
            audioTime: n.audioTime
        };
    }
}

JMT.AudioAsset = AudioAsset;

/* harmony default export */ __webpack_exports__["default"] = (AudioAsset);


/***/ }),

/***/ "./assets/ConeLightAsset.js":
/*!**********************************!*\
  !*** ./assets/ConeLightAsset.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConeLightAsset": function() { return /* binding */ ConeLightAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _effect_coneLight_ConeLight_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effect/coneLight/ConeLight.js */ "./effect/coneLight/ConeLight.js");
/**
 * Created by Kai on 2021/4/14.
 */



class ConeLightAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset{

    constructor(config, id) {

        super(config, id)

        this._contentType = _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.ConeLight

        this.isEffect = !0
    }


    _initMesh(config) {

        let that = this

        let coneLight = new _effect_coneLight_ConeLight_js__WEBPACK_IMPORTED_MODULE_1__.ConeLight()
        that._mesh = coneLight
        that._mesh.position.set(0, 0, 0.5)

        return Promise.resolve(coneLight)
    }

    _onReadyToLoad() {
        this.dispatchEvent({type: 'assetLoaded'})
    }
}

/***/ }),

/***/ "./assets/FireAsset.js":
/*!*****************************!*\
  !*** ./assets/FireAsset.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FireAsset": function() { return /* binding */ FireAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _effect_fire_Fire_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effect/fire/Fire.js */ "./effect/fire/Fire.js");
/**
 * Created by Kai on 2021/3/5.
 */




class FireAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {

        super(config, id)

        this._contentType = _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.Fire

        this.isEffect = !0
    }


    _initMesh(config) {


        let that = this
        let url = config.texture

        let param = {
            alpha: true,
            id: url,
            name: '__fire_texture',
            rawExt: "png",
            stdExt: "png",
            url: url,
            //noCache: !0,
            webFormats: [
                //"small/std", "large/dxt", "small/pvr", "small/etc1"
            ]
        }

        let t = that._textureLoader.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, param, !0, !0, JMT.DEFAULT_ANISOTROPY)

        let fire = (0,_effect_fire_Fire_js__WEBPACK_IMPORTED_MODULE_1__.createFireMesh)(t)

        t.debug = !0

        t.addLoadingListener((tex)=> {

            //console.log(tex, t);

            that._mesh = fire
            that._mesh.position.set(0, 0, 0.5)


            that.dispatchEvent({type: 'assetLoaded'})
            JMT.ALWAYS_RENDER = true

        })

        function animate(time) {
            fire.update(performance.now() / 1E3)
            //fire.update(time.deltaTime)
        }

        UjP.assetsController.addEventListener('animate', animate)

        return Promise.resolve(fire)
    }

    deserialize(config) {
        let n = this
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config)

        let scale = config.scale
        
        if (scale !== undefined && scale[2]) {
            n.scale.set(scale[0],scale[1],scale[2])
        }
        
    }

    update(position, normal) {

        if (normal) {
            this.config.normal = normal
            normal = new THREE.Vector3().fromArray(normal)

            if (position) {
                this.config.position = position
                position = new THREE.Vector3().copy(normal).multiplyScalar(0.001).add(new THREE.Vector3().fromArray(position))
                this.position.copy(position);
                this.updateMatrixWorld(!0);
            }
            //this._mesh && this._mesh.lookAt(normal)

            this._updated()
        }
    }

}

/***/ }),

/***/ "./assets/FlagAsset.js":
/*!*****************************!*\
  !*** ./assets/FlagAsset.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FlagAsset": function() { return /* binding */ FlagAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effect/FlagMesh.js */ "./effect/FlagMesh.js");
/* harmony import */ var _effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");


//import '../loaders/GLTFLoader.js'





class FlagAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id)

        this.isEffect = !0
    }

    _onDefineProperties() {
        Object.defineProperty(this, 'poleH', {
            get: function(){
                return this._poleH
            },
            set: function(value){

                this._poleH = value
                if (this._mesh) this._mesh.poleH = value

            }
        })

        Object.defineProperty(this, 'flagW', {
            get: function(){
                return this._flagW
            },
            set: function(value){

                this._flagW = value
                if (this._mesh) this._mesh.flagW = value

            }
        })

        Object.defineProperty(this, 'flagH', {
            get: function(){
                return this._flagH
            },
            set: function(value){

                this._flagH = value
                if (this._mesh) this._mesh.flagH = value

            }
        })

        Object.defineProperty(this, 'amplitude', {
            get: function(){
                return this._amplitude
            },
            set: function(value){

                this._amplitude = value
                if (this._mesh) this._mesh._amplitude = value

            }
        })

        Object.defineProperty(this, 'speed', {
            get: function(){
                return this._speed
            },
            set: function(value){

                this._speed = value
                if (this._mesh) this._mesh._speed = value

            }
        })

        Object.defineProperty(this, 'flagColor', {
            get: function(){
                return this._flagColor
            },
            set: function(value){

                this._flagColor = value
                if (this._mesh) this._mesh.flagColor = value

            }
        })

        Object.defineProperty(this, 'poleColor', {
            get: function(){
                return this._poleColor
            },
            set: function(value){

                this._poleColor = value
                if (this._mesh) this._mesh.poleColor = value

            }
        })

        // defineProperty(this, 'flagColor')
        // defineProperty(this, 'poleColor')

    }

    _initMesh(config) {
        JMT.ALWAYS_RENDER = true

        let mesh = new JMT.FlagMesh(config)
        this._mesh = mesh

        this.flagW = config.flagW || mesh._flagW;
        this.flagH = config.flagH || mesh._flagH;
        this.poleH = config.poleH || mesh._poleH;
        this.amplitude = config.amplitude || mesh._amplitude;
        this.speed = config.speed || mesh._speed;
        this.flagColor = config.flagColor || mesh._flagColor;
        this.poleColor = config.poleColor || mesh._poleColor;

        mesh.rotateX(THREE.Math.degToRad(90))

        let n = this


        n.animate = function (){
            return function(tick){
                mesh.update()
            }
        }()

        UjP.assetsController.addEventListener('animate', n.animate)


        n._mesh = mesh

        n._mesh.addEventListener('loaded', () => {
            n.dispatchEvent({type: 'assetLoaded'})
        })


        return Promise.resolve(mesh)
    }

    _updateLocalParameter(config) {
        this._mesh.traverse(mesh=> {
            if (mesh instanceof THREE.Mesh) {
                mesh.lightProbe = config.object.lightProbe
                //mesh.lightMap = config.object.lightMap
                //mesh.lightMapIdx = config.object.lightMapIdx

                if (mesh.material.baseColorTexture && mesh.material.baseColorTexture.notifyLoaded) {
                    mesh.material.baseColorTexture.notifyLoaded()
                }

                mesh.material.lc = config.object.material.lc
                mesh.material.lcContrast = config.object.material.lcContrast
                mesh.material.lcIntensity = config.object.material.lcIntensity
                mesh.material.envMap = config.object.material.envMap
            }
        })
    }

    _getBoundinngSphere() {
        let c = new THREE.Vector3()

        let sphere = new THREE.Sphere(c, 0.1)
        return sphere
    }

    update(position, normal) {
        if (normal) {
            this.config.normal = normal
            normal = new THREE.Vector3().fromArray(normal)

            if (position) {
                this.config.position = position
                position = new THREE.Vector3().copy(normal).multiplyScalar(0.001).add(new THREE.Vector3().fromArray(position))
                this.position.copy(position);
                this.updateMatrixWorld(!0);
            }
            //this._mesh && this._mesh.lookAt(normal)

            this._updated()
        }
    }

    _setHighLight(highlight) {
        this._mesh.traverse(mesh=> {
            if (mesh.isMesh) {
                mesh.material.highlightMix = highlight
            }
        })
        UjP.aniController.requestFrame()
    }

    raycast(ray) {

        if (this._mesh instanceof JMT.FlagMesh) {

            let items = [this._mesh._flagMesh, this._mesh._poleMesh]

            for (let i=0; i<items.length; i++) {

                let item = items[i]
                if (item.geometry.boundingBox === null)
                    item.geometry.computeBoundingBox()

                // let box = new THREE.Box3()
                // box.copy( this._mesh._flagMesh.geometry.boundingBox );
                // box.applyMatrix4( this._mesh._flagMesh.matrixWorld );

                let localRay = new THREE.Ray()
                let inverseMatrix = new THREE.Matrix4()
                //inverseMatrix.getInverse(item.matrixWorld)
                inverseMatrix.copy(item.matrixWorld).invert();
                localRay.copy(ray).applyMatrix4(inverseMatrix);

                let pt = new THREE.Vector3()
                if (localRay.intersectBox(item.geometry.boundingBox, pt)) {
                    pt.applyMatrix4(item.matrixWorld)
                    let dist = pt.distanceTo(ray.origin)
                    return {
                        distance: dist,
                        point: pt,
                        object: this
                    }
                }
            }
        }

        return null
    }

    deserialize(config) {                                     //取出

        let n = this
        n._poleH=config.poleH;
        n._flagW=config.flagW;
        n._flagH=config.flagH;
        n._amplitude=config.amplitude;
        n._speed=config.speed;
        n._flagColor=config.flagColor;
        n._poleColor=config.poleColor;
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config)
    }

    _onSerialize(data) {                                      //存入

        let n = this
      
        data.poleH=n.poleH,
        data.flagW=n.flagW,
        data.flagH=n.flagH,
        data.amplitude=n.amplitude,
        data.speed=n.speed,
        data.flagColor = (n.flagColor instanceof THREE.Color) ? '#'+n.flagColor.getHexString() : n.flagColor,
        data.poleColor = (n.poleColor instanceof THREE.Color) ? '#'+n.poleColor.getHexString() : n.poleColor

    }
}

JMT.FlagAsset = FlagAsset

/***/ }),

/***/ "./assets/GIFAsset.js":
/*!****************************!*\
  !*** ./assets/GIFAsset.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GIFAsset": function() { return /* binding */ GIFAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _src_extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/extend/texture/j3dGIFTexture.js */ "./src/extend/texture/j3dGIFTexture.js");
/**
 * Created by Kai on 2021/1/26.
 */



const GIF_MAX_FRAME = 7;
class GIFAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id)

        JMT.ALWAYS_RENDER = true
    }

    _onDefineProperties(){
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'delay')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'width')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'height')
    }


    onCreateMaterial(material, config) {
        if (this.texture) {

            let THIS = this
            if (THIS.gif || (config.delayImage && config.delay)) {
                THIS._fromSequenceFrames(material, config)
            }
            else {
           
                THIS._fromGif(material, config)
            }
        }
    }

    _fromGif(material, config) {

        let n = this
        ;(0,_src_extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_2__.j3dGIFLoader)(this.texture, gif=> {

            let texture = new _src_extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_2__.j3dGIFTexture(gif)
            //texture.fromEditor = true;
            texture.format = THREE.RGBAFormat;
            texture.hasAlpha = true;
            texture.needsUpdate = true
            texture.generateMipmaps = false;
            texture.magFilter = THREE.LinearFilter
            texture.minFilter = THREE.LinearFilter
            texture.needsUpdate = true;

            material.map = texture
            material.side = THREE.DoubleSide;
            material.needsUpdate = true;

            n.animate = function (tick) {
                texture.update(tick.deltaTime)
            }

            UjP.assetsController.addEventListener('animate', n.animate)

            if(config.creating){
                n.scale.set(1, gif.canvas.width/gif.canvas.height, 1)
                n.updateMatrixWorld(true)
                config.creating = false
            }

            n.dispatchEvent({type:'assetLoaded'})
        })
    }

    //from 3dyunzhan
    _fromSequenceFrames(material, config) {

        let n = this;
        if (n.gif && n.gif.delay && n.gif.delay.length > 2) {
            //in 100ths of a second

            if (n.gif.delay[0] == 0 && n.gif.delay[1] == 0 && n.gif.delay[2] == 0) {
                for (var i = 0; i < this.gif.delay.length; i++) {
                    this.gif.delay[i] = 5; //百分之一秒
                }
            }
        }

        let imgUrl = n.gif.delayImage
        let rawExt = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.getExtension)(imgUrl);

        let alpha = true//config.hasAlpha || rawExt === "png";

        let param = {
            alpha: alpha,
            id: this.uuid,
            name: config.name,
            rawExt: rawExt,
            stdExt: "gif",
            url: imgUrl,
            webFormats: [
                //"small/std", "large/dxt", "small/pvr", "small/etc1"
            ],
        };

        let t = this._textureLoader.load(
            JMT.LOAD_PRIORITY.CORE_RESOURCE,
            param,
            !0,
            !1,
            1//JMT.DEFAULT_ANISOTROPY
        );
        // TODO: 是否从编辑模式进来？
        t.fromEditor = !0;
        

        t.addLoadingListener(() => {
            
            n._originImg = t.image;
            n.origin = {
                width: t.image.width,
                height: t.image.height,
            };
            
            if (config.creating) {

                let scale = 1;
                var asp = t.image.height / t.image.width;
                if (n.gif && n.gif.delay) {
                    asp = t.image.height / t.image.width * Math.min(n.gif.delay.length, GIF_MAX_FRAME) / Math.ceil(n.gif.delay.length / GIF_MAX_FRAME);
                }
                n.scale.set(1 * scale, asp * scale, 1);
                //n.scale.set(1, t.image.width / t.image.height, 1);

                n.updateMatrixWorld(!0);
                config.creating = !1;
            }

            t.hasAlpha = alpha;
            if (alpha) {
                material.configureTransparency && material.configureTransparency();
            }

            if (n.gif && n.gif.delay) {
                t.offset = new THREE.Vector2(1 / Math.min(n.gif.delay.length, GIF_MAX_FRAME) * 0, 0);
                t.repeat = new THREE.Vector2(1 / Math.min(n.gif.delay.length, GIF_MAX_FRAME), 1 / Math.ceil(n.gif.delay.length / GIF_MAX_FRAME));
                n.gif.index = 0;
                n.gif.dur = -1;

                material.setUvOffsetAndScale && material.setUvOffsetAndScale(t.offset.x, t.offset.y, t.repeat.x, t.repeat.y);
                material.setUniforms && material.setUniforms();

                n.origin.width = n.origin.width / Math.min(n.gif.delay.length, GIF_MAX_FRAME);
            }

            //animation
            n.animate = function (tick) {

                if (!n.gif || !n.gif.delay || !n.material || !n.material.map) {
                    return;
                }
        
                if (n.gif.dur == -1) {
                    n.gif.dur = 0;
                    return;
                }
                n.gif.dur += tick.deltaTime;

                // 10
                if (n.gif.dur  >= n.gif.delay[n.gif.index]*0.01) {

                    var tilesAmountVertically = Math.ceil(n.gif.delay.length / GIF_MAX_FRAME);
                    var tilesAmountHorizontally = Math.min(n.gif.delay.length, GIF_MAX_FRAME);
                    const tileHeight = 1 / tilesAmountVertically;
    
                    const currentColumn = n.gif.index % tilesAmountHorizontally;
                    const currentRow = Math.floor(n.gif.index / tilesAmountHorizontally);
    
                    t.offset.x = currentColumn / tilesAmountHorizontally;
                    t.offset.y = 1 - currentRow / tilesAmountVertically - tileHeight;
                    if (t.offset.y < 0) 
                        t.offset.y = 0;
                    material.setUvOffsetAndScale && material.setUvOffsetAndScale(t.offset.x, t.offset.y, t.repeat.x, t.repeat.y);
                    material.setUniforms && material.setUniforms();
    
    
                    //https://github.com/MaciejWWojcik/three-plain-animator/blob/master/src/plain-animator.ts
    
                    n.gif.index++;
    
                    if (n.gif.index >= n.gif.delay.length) n.gif.index = 0;
    
                    n.gif.dur = 0;
                }

            }
            UjP.assetsController.addEventListener('animate', n.animate)

            n.dispatchEvent({
                type: "assetLoaded"
            });
        });

        material.map = t;
        //material.doubleSided = !0;
        material.side = THREE.doubleSide;
        
        this.material = material;
    }

    deserialize(config) {                                     //取出

        let n = this
        if (config.gif) {
            n.gif = config.gif
        }
        else if (config.delay && config.delayImage){
            n.gif = {
                delay:config.delay,
                delayImage:config.delayImage
            }
        }
        
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config)
    }


    restoreScale(){
        if(this.material && this.material.map){
            let t = this.material.map
            // 保持素材宽高比

            // 保持素材宽高比
            let scale = t.gif.canvas.height / t.gif.canvas.width
            this.setScale(scale, 1,  1);
        }
    }

    _onSerialize(dataArray) {
        dataArray['delay'] = this.delay
        dataArray['width'] = this.width
        dataArray['height'] = this.height

        if (!!this.gif) {
            dataArray['gif'] = this.gif
        }
    }
}



JMT.GIFAsset = GIFAsset

/***/ }),

/***/ "./assets/ImageAsset.js":
/*!******************************!*\
  !*** ./assets/ImageAsset.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageAsset": function() { return /* binding */ ImageAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/1/25.
 */



class ImageAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, index) {
        super(config, index);
    }

    _onDefineProperties() {
        /**
         * 画框是否显示
         */
        Object.defineProperty(this, "frameVisible", {
            get: function () {
                return this._frameVisible;
            },
            set: function (value) {
                if (this._frameVisible !== value) {
                    this._frameVisible = value;

                    this._updateTexture();
                }
            },
        });

        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, "frameId");
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, "cornerImage");
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, "bannerImage");
    }

   
    /**
     * 创建材质
     * @param material
     * @param config
     */
    onCreateMaterial(material, config) {
        if (this.texture) {
            let rawExt = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.getExtension)(this.texture);

            let alpha = config.hasAlpha || rawExt === "png";

            let param = {
                alpha: alpha,
                id: this.uuid,
                name: config.name,
                rawExt: rawExt,
                stdExt: "jpg",
                url: this.texture,
                webFormats: [
                    //"small/std", "large/dxt", "small/pvr", "small/etc1"
                ],
            };

            let t = this._textureLoader.load(
                JMT.LOAD_PRIORITY.CORE_RESOURCE,
                param,
                true,
                true,
                JMT.DEFAULT_ANISOTROPY
            );

            // TODO: 是否从编辑模式进来？
            t.fromEditor = !0;
            let n = this;

            t.addLoadingListener(() => {
              
                n._originImg = t.image;
                
                if (config.creating) {
                    n.scale.set(1, t.image.width / t.image.height, 1);
                    n.updateMatrixWorld(!0);
                    config.creating = !1;
                }
                t.hasAlpha = alpha;
                if (alpha) {
                    material.configureTransparency && material.configureTransparency();
                }
                n._updateTexture(t);

                n.dispatchEvent({
                    type: "assetLoaded"
                });
            });
            material.map = t
            //material.doubleSided = true;
            material.side = THREE.DoubleSide;
            this.material = material;
        }
    }

    restoreScale() {
        if (this.material && this.material.baseColorTexture) {
            let t = this._originImg;
            // 保持素材宽高比
            let scale = t.height / t.width;
            this.setScale(scale, 1, 1);
        }
    }

    updateFrame(wScal, hScal, meshobj) {
      
        this.material.baseColorTexture.dispose();
        var canvas = document.getElementById("anchor-canvas");
        if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.id = "anchor-canvas";
        }

        let self = this;
        var cornerImg = new Image();
        var bannerImg = new Image();

        cornerImg.onload = function () {
            bannerImg.onload = function () {
                canvas.width = cornerImg.width * 2 + self._originImg.width * wScal;
                canvas.height = cornerImg.height * 2 + self._originImg.height * hScal;

                if (canvas.width > 15564) {
                    canvas.width = 15564;
                }
                if (canvas.height > 4524) {
                    canvas.width = 4524;
                }

                var ctx = canvas.getContext("2d");

                ctx.save(); //左上
                ctx.translate(0, -0);
                ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                ctx.restore();

                var WidthNum = (canvas.width - cornerImg.width * 2) / bannerImg.width;
                var widthnum2 = WidthNum.toString().split(".")[0];
                var widthnum3 = "0." + WidthNum.toString().split(".")[1];
                // console.log('nwnwnwnwnwnwnwnwnwnwnwnwnwnwnwwnwnw');
                // console.log(WidthNum,widthnum2,widthnum3);
                // console.log('nwnwnwnwnwnwnwnwnwnwnwnwnwnwnwwnwnw');
                for (var i = 0; i < widthnum2; i++) {
                    ctx.drawImage(
                        bannerImg,
                        cornerImg.width + bannerImg.width * i,
                        0,
                        bannerImg.width,
                        bannerImg.height
                    );
                }
                ctx.drawImage(
                    bannerImg,
                    cornerImg.width + bannerImg.width * widthnum2,
                    0,
                    bannerImg.width * widthnum3,
                    bannerImg.height
                );

                ctx.save(); //右上
                let x =
                    cornerImg.width +
                    bannerImg.width * widthnum2 +
                    bannerImg.width * widthnum3 +
                    cornerImg.width / 2;
                ctx.translate(x, 0);
                ctx.scale(-1, 1);
                ctx.translate(-x, 0);
                ctx.drawImage(
                    cornerImg,
                    cornerImg.width +
                    bannerImg.width * widthnum2 +
                    bannerImg.width * widthnum3,
                    0,
                    cornerImg.width,
                    cornerImg.height
                );
                ctx.restore();

                var HeightNum =
                    (canvas.height - cornerImg.height * 2) / bannerImg.width;
                var Heightnum2 = HeightNum.toString().split(".")[0];
                var Heightnum3 = "0." + HeightNum.toString().split(".")[1];
                // console.log('nwnwnwnwnwnwnwnwnwnwnwnwnwnwnwwnwnw');
                // console.log(HeightNum,Heightnum2,Heightnum3);
                // console.log('nwnwnwnwnwnwnwnwnwnwnwnwnwnwnwwnwnw');

                for (var i = 1; i <= Heightnum2; i++) {
                    ctx.save();
                    ctx.translate(0, cornerImg.height + bannerImg.width * i);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                    ctx.restore();
                }
                ctx.save();
                ctx.translate(
                    0,
                    cornerImg.height +
                    bannerImg.width * Heightnum2 +
                    bannerImg.width * Heightnum3,
                    bannerImg.width,
                    bannerImg.height
                );
                ctx.rotate((-90 * Math.PI) / 180);
                ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                ctx.restore();

                for (var i = 0; i < Heightnum2; i++) {
                    ctx.save();
                    ctx.translate(
                        cornerImg.width * 2 +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3,
                        cornerImg.height + bannerImg.width * i
                    );
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                    ctx.restore();
                }
                ctx.save();
                ctx.translate(
                    cornerImg.width * 2 +
                    bannerImg.width * widthnum2 +
                    bannerImg.width * widthnum3,
                    cornerImg.height + bannerImg.width * Heightnum2
                );
                ctx.rotate((90 * Math.PI) / 180);
                ctx.drawImage(
                    bannerImg,
                    0,
                    0,
                    bannerImg.width * Heightnum3,
                    bannerImg.height
                );
                ctx.restore();

                ctx.save();
                ctx.translate(
                    0,
                    cornerImg.height * 2 +
                    bannerImg.width * Heightnum2 +
                    bannerImg.width * Heightnum3
                );
                ctx.rotate((-90 * Math.PI) / 180);
                ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                ctx.restore();

                for (var i = 1; i <= widthnum2; i++) {
                    ctx.save();
                    ctx.translate(
                        cornerImg.width + bannerImg.width * i,
                        cornerImg.height * 2 +
                        bannerImg.width * Heightnum2 +
                        bannerImg.width * Heightnum3
                    );
                    ctx.rotate((-180 * Math.PI) / 180);
                    ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                    ctx.restore();
                }
                ctx.save();
                ctx.translate(
                    cornerImg.width +
                    bannerImg.width * widthnum2 +
                    bannerImg.width * widthnum3,
                    cornerImg.height * 2 +
                    bannerImg.width * Heightnum2 +
                    bannerImg.width * Heightnum3
                );
                ctx.rotate((-180 * Math.PI) / 180);
                ctx.drawImage(
                    bannerImg,
                    0,
                    0,
                    bannerImg.width * widthnum3,
                    bannerImg.height
                );
                ctx.restore();

                ctx.save();
                ctx.translate(
                    cornerImg.width * 2 +
                    bannerImg.width * widthnum2 +
                    bannerImg.width * widthnum3,
                    cornerImg.height * 2 +
                    bannerImg.width * Heightnum2 +
                    bannerImg.width * Heightnum3
                );
                ctx.rotate((180 * Math.PI) / 180);
                ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                ctx.restore();

                ctx.save();
                ctx.translate(0, 0);
                var imgW5 = self._originImg.width * wScal; //+cornerImg.width*1;
                var imgH5 = self._originImg.height * hScal; //-cornerImg.height*1;
                ctx.drawImage(
                    self._originImg,
                    cornerImg.width,
                    cornerImg.height,
                    imgW5,
                    imgH5
                );
                ctx.restore();

                let texture = new JMT.Texture(canvas);
                texture.width = canvas.width;
                texture.height = canvas.height;
                texture.hasAlpha = true;
                texture.minFilter = GLC.LINEAR;
                texture.loaded = !0;
                texture.needsUpdate = !0;
                self.material.baseColorTexture = texture;
            };
        };
        cornerImg.src = this.cornerImage;
        bannerImg.src = this.bannerImage;
    }

    /**
     * 旋转图片
     * @param {*} img 
     * @param {*} callback 
     */
    _rotateImage(img, callback) {
        let cvs = document.createElement("canvas");
        let ctx = cvs.getContext("2d");

        // 将参照点移动到画板的中心点；
        ctx.translate(ctx.width / 2, ctx.height / 2);
        // 旋转画板；
        ctx.rotate = 180;
        // 绘制图片；
        ctx.drawImage(img, 0, 0);
        // 导出得到旋转后的图片；

        var newImg = new Image();
        newImg.onload = function () {
            callback(newImg);
        };

        newImg.src = cvs.toDataURL();
    }

    /**
     * 画图片和画框
     * @param canvas
     * @param config
     * @private
     */
    _draw(t, canvas, config) {
        let self = this;
        let mainWidth = self.material.baseColorTexture.width; //self.material.baseColorTexture 图片纹理
        let mainHeight = self.material.baseColorTexture.height;

        var ctx = canvas.getContext("2d");

        var cornerImg = new Image();
        var bannerImg = new Image();
        cornerImg.src = this.cornerImage;
        bannerImg.src = this.bannerImage;

        cornerImg.onload = function () {
            bannerImg.onload = function () {
                canvas.width = cornerImg.width * 2 + self._originImg.width;
                canvas.height = cornerImg.height * 2 + self._originImg.height;

                var ctx = canvas.getContext("2d");

                //#region 左上角/////////////////////////////////////////////////////////////
                ctx.save(); //左上
                ctx.translate(0, -0);
                ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                ctx.restore();
                //#endregion 左上角/////////////////////////////////////////////////////////////

                //#region 上中横梁/////////////////////////////////////////////////////////////
                var widthnum2 = "";
                var widthnum3 = "";
                var Heightnum2 = "";
                var Heightnum3 = "";

                var WidthNum = (canvas.width - cornerImg.width * 2) / bannerImg.width;
                widthnum2 = WidthNum.toString().split(".")[0];
                widthnum3 = "0." + WidthNum.toString().split(".")[1];

                if (WidthNum > 1) {// 至少需要铺一张
                    //上中

                    // 先铺整张
                    for (var i = 0; i < widthnum2; i++) {
                        ctx.drawImage(
                            bannerImg,
                            cornerImg.width + bannerImg.width * i,
                            0,
                            bannerImg.width,
                            bannerImg.height
                        );
                    }

                    // 剩下的铺一张有多的，铺一部分
                    ctx.drawImage(
                        bannerImg,
                        cornerImg.width + bannerImg.width * widthnum2,
                        0,
                        bannerImg.width * widthnum3,
                        bannerImg.height
                    );
                } else { // 铺一张还有多的
                    ctx.drawImage(
                        bannerImg,
                        cornerImg.width,
                        0,
                        bannerImg.width * WidthNum,
                        bannerImg.height
                    );
                }
                //#endregion 上中横梁/////////////////////////////////////////////////////////////

                //#region 下中横梁/////////////////////////////////////////////////////////////
                if (WidthNum > 1) {// 至少需要铺一张
                    //下中

                    // 先铺整张
                    for (var i = 0; i <= widthnum2; i++) {
                        ctx.save();
                        ctx.translate(cornerImg.width + bannerImg.width * i, canvas.height);
                        ctx.rotate((-180 * Math.PI) / 180);
                        ctx.drawImage(
                            bannerImg,
                            0,
                            0,
                            bannerImg.width,
                            bannerImg.height
                        );

                        ctx.restore();
                    }

                    // 剩下的铺一张有多的，铺一部分
                    ctx.save();
                    ctx.translate(cornerImg.width +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3, canvas.height);
                    ctx.rotate((-180 * Math.PI) / 180);
                    ctx.drawImage(
                        bannerImg,
                        0,
                        0,
                        bannerImg.width * widthnum3,
                        bannerImg.height
                    );
                    ctx.restore();

                } else { // 铺一张还有多的
                    ctx.drawImage(
                        bannerImg,
                        cornerImg.width,
                        0,
                        bannerImg.width * WidthNum,
                        bannerImg.height
                    );
                }
                //#endregion 下中横梁/////////////////////////////////////////////////////////////

                //#region 右上角/////////////////////////////////////////////////////////////
                if (WidthNum > 1) {
                    ctx.save(); //右上
                    let x =
                        cornerImg.width +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3 +
                        cornerImg.width / 2;
                    ctx.translate(x, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(-x, 0);
                    ctx.drawImage(
                        cornerImg,
                        cornerImg.width +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3,
                        0,
                        cornerImg.width,
                        cornerImg.height
                    );
                    ctx.restore();
                } else {
                    ctx.save();
                    let x =
                        cornerImg.width + bannerImg.width * WidthNum + cornerImg.width / 2;
                    ctx.translate(x, 0);
                    ctx.scale(-1, 1);
                    ctx.translate(-x, 0);
                    ctx.drawImage(
                        cornerImg,
                        cornerImg.width + bannerImg.width * WidthNum,
                        0,
                        cornerImg.width,
                        cornerImg.height
                    );
                    ctx.restore();
                }
                //#endregion 右上角/////////////////////////////////////////////////////////////

                //#region 左中竖梁/////////////////////////////////////////////////////////////
                var HeightNum =
                    (canvas.height - cornerImg.height * 2) / bannerImg.width;
                Heightnum2 = HeightNum.toString().split(".")[0];
                Heightnum3 = "0." + HeightNum.toString().split(".")[1];

                if (HeightNum > 1) {
                    //左中

                    for (var i = 1; i <= Heightnum2; i++) {
                        ctx.save();
                        ctx.translate(0, cornerImg.height + bannerImg.width * i);
                        ctx.rotate((-90 * Math.PI) / 180);
                        ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                        ctx.restore();
                    }
                    ctx.save();
                    ctx.translate(
                        0,
                        cornerImg.height +
                        bannerImg.width * Heightnum2 +
                        bannerImg.width * Heightnum3
                    );
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(0, cornerImg.height + bannerImg.width * HeightNum);
                    ctx.rotate((-90 * Math.PI) / 180);
                    ctx.drawImage(
                        bannerImg,
                        0,
                        0,
                        bannerImg.width * HeightNum,
                        bannerImg.height
                    );
                    ctx.restore();
                }
                //#endregion 左中竖梁/////////////////////////////////////////////////////////////

                //#region 右中竖梁/////////////////////////////////////////////////////////////
                if (HeightNum > 1) {
                    //右中
                    for (var i = 0; i < Heightnum2; i++) {
                        ctx.save();
                        ctx.translate(
                            cornerImg.width * 2 +
                            bannerImg.width * widthnum2 +
                            bannerImg.width * widthnum3,
                            cornerImg.height + bannerImg.width * i
                        );
                        ctx.rotate((90 * Math.PI) / 180);
                        ctx.drawImage(bannerImg, 0, 0, bannerImg.width, bannerImg.height);
                        ctx.restore();
                    }
                    ctx.save();
                    ctx.translate(
                        cornerImg.width * 2 +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3,
                        cornerImg.height + bannerImg.width * Heightnum2
                    );
                    ctx.rotate((90 * Math.PI) / 180);
                    ctx.drawImage(
                        bannerImg,
                        0,
                        0,
                        bannerImg.width * Heightnum3,
                        bannerImg.height
                    );
                    ctx.restore();
                } else {
                    ctx.save();
                    ctx.translate(cornerImg.width * 2 + bannerImg.width * widthnum2 + bannerImg.width * widthnum3, cornerImg.height + bannerImg.width * HeightNum);
                    ctx.rotate(90 * Math.PI / 180);
                    ctx.drawImage(bannerImg, 0, 0, bannerImg.width * HeightNum, bannerImg.height);
                    ctx.restore();
                }
                //#endregion右中竖梁/////////////////////////////////////////////////////////////

                //#region 右下角/////////////////////////////////////////////////////////////
                if (WidthNum > 1 && HeightNum > 1) {
                    //右下
                    ctx.save();
                    ctx.translate(
                        cornerImg.width * 2 +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3,
                        cornerImg.height * 2 +
                        bannerImg.width * Heightnum2 +
                        bannerImg.width * Heightnum3
                    );
                    ctx.rotate((180 * Math.PI) / 180);
                    ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                    ctx.restore();
                }

                if (WidthNum > 1 && HeightNum < 1) {
                    //右下
                    ctx.save();
                    ctx.translate(
                        cornerImg.width * 2 +
                        bannerImg.width * widthnum2 +
                        bannerImg.width * widthnum3,
                        cornerImg.height * 2 + bannerImg.width * HeightNum
                    );
                    ctx.rotate((180 * Math.PI) / 180);
                    ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                    ctx.restore();
                }
                //#endregion 右下角/////////////////////////////////////////////////////////////

                //#region 左下角/////////////////////////////////////////////////////////////
                if (WidthNum > 1 && HeightNum > 1) {
                    //左下
                    ctx.save();
                    ctx.translate(
                        0,
                        cornerImg.height * 2 +
                        bannerImg.width * Heightnum2 +
                        bannerImg.width * Heightnum3
                    );
                    ctx.rotate((180 * Math.PI) / 180);
                    ctx.scale(-1, 1);
                    ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                    ctx.restore();
                }

                if (WidthNum > 1 && HeightNum < 1) {
                    //左下
                    ctx.save();
                    ctx.translate(
                        0,
                        cornerImg.height * 2 + bannerImg.width * HeightNum
                    );
                    ctx.rotate((180 * Math.PI) / 180);
                    ctx.scale(-1, 1);
                    ctx.drawImage(cornerImg, 0, 0, cornerImg.width, cornerImg.height);
                    ctx.restore();
                }
                //#endregion 左下角/////////////////////////////////////////////////////////////

                //#region 原图片/////////////////////////////////////////////////////////////
                ctx.save();
                ctx.translate(cornerImg.width, cornerImg.height);
                ctx.drawImage(
                    self._originImg,
                    0,
                    0,
                    self._originImg.width,
                    self._originImg.height
                );
                ctx.restore();
                //#endregion 原图片/////////////////////////////////////////////////////////////

                let texture = new JMT.Texture(canvas);
                texture.width = canvas.width;
                texture.height = canvas.height;
                texture.hasAlpha = true;
                texture.minFilter = GLC.LINEAR;
                texture.loaded = !0;
                texture.needsUpdate = !0;
                self.material.baseColorTexture = texture;
            }
        }
    }

    /**
     * 删除画框
     * @private
     */
    _removeFrame() {
        this.material.map.dispose();
        var canvas = document.getElementById("anchor-canvas");
        if (!canvas) {
            canvas = document.createElement("canvas");
            canvas.id = "anchor-canvas";
        }

        canvas.width = this._originImg.width;
        canvas.height = this._originImg.height;

        var ctx = canvas.getContext("2d");

        ctx.save();
        ctx.translate(0, 0);
        ctx.drawImage(
            this._originImg,
            0,
            0,
            this._originImg.width,
            this._originImg.height
        );
        ctx.restore();

        let texture = new JMT.j3dTexture(canvas);
        texture.width = canvas.width;
        texture.height = canvas.height;
        texture.hasAlpha = true;
        texture.minFilter = THREE.LinearFilter
        texture.loaded = !0;
        texture.needsUpdate = !0;
        this.material.map = texture;
    }

    /**
     * 刷新纹理
     * @param {} t 
     */
    _updateTexture(t) {
        if (this.frameVisible) {
            var w = document.getElementById("anchor-canvas");
            if (!w) {
                w = document.createElement("canvas");
                w.id = "anchor-canvas";
            }
            this._draw(t, w);
        } else {
            this._removeFrame();
        }
    }

    /**
     * 反序列化
     * @param {*} config 
     */
    deserialize(config) {
        let n = this;
        let frame = config.frame || {};

        //n.cornerImage = frame.corner || "css/image/corner_left_top.png";
        //n.bannerImage = frame.banner || "css/image/banner_top.png";
        n.cornerImage = frame.corner;
        n.bannerImage = frame.banner;
        n._frameVisible = !!frame.visible;
        n._frameId = frame.id;
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config);
    }

    /**
     * 序列化
     * @param {} data 
     */
    _onSerialize(data) {
        let n = this;

        data["frame"] = {
            visible: n.frameVisible,
            id: n.frameId,
            corner: n.cornerImage,
            banner: n.bannerImage,
        };
    }
}

JMT.ImageAsset = ImageAsset;

/***/ }),

/***/ "./assets/ModelAsset.js":
/*!******************************!*\
  !*** ./assets/ModelAsset.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModelAsset": function() { return /* binding */ ModelAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _loaders_GLTFLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders/GLTFLoader.js */ "./loaders/GLTFLoader.js");
/* harmony import */ var _loaders_MaterialExchangeExtension_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../loaders/MaterialExchangeExtension.js */ "./loaders/MaterialExchangeExtension.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/2/4.
 */









//import {MaterialExchangeExtension} from '../loaders/MaterialExchangeExtension.js'


//平面默认法线状态
var v0 = new THREE.Vector3(0, 1, 0);
//四元数对象
var quaternion = new THREE.Quaternion();
JMT.MODEL_SCALE_BASE = 1 //config.scaleBase || 0.001 //config.scale

class ModelAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id)

        this._contentType = _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.ContentTypes.model
        this.isModel = !0

        this._materials = []
    }

    get materials(){

        return this._materials
    }

    update(position, normal) {

        if (this._initLock) {

            let t = this

            let pos = this._position,
                rot = this._rotation,
                sca = this._scale

            if (!rot) {
                // 编辑模式拖进去的素材,初始rotation为空
                t._updateWithPositionAndNormal(position, normal)
            }
            else {
                // 从JSON中创建，rotation不为空
                t.position.set(pos[0], pos[1], pos[2])
                t.rotation.set(rot[0], rot[1], rot[2])
                t.rotation.order = rot[3]
                t.scale.set(sca[0], sca[1], sca[2])

                this.updateMatrixWorld(!0);

                if (t.hasAnchor) {
                    t._disableAnchor()
                    t._enableAnchor()
                }

                if (t.followCamera) {
                    let cameraPosition = UjP.controls.cameraWorldPosition()
                    t.lookAt(cameraPosition)
                }

            }
            this._initLock = false

            t.dispatchEvent({type: 'assetLoaded'})
        }
        else if (normal) {

            this.config.normal = normal

            normal = new THREE.Vector3().fromArray(normal)

            if (position) {
                this.config.position = position
                position = new THREE.Vector3().copy(normal).multiplyScalar(0.001).add(new THREE.Vector3().fromArray(position))
                this.position.copy(position);
            }
            // 处理旋转
            quaternion.setFromUnitVectors(v0, normal);
            this.setRotationFromQuaternion(quaternion)
            this.updateMatrixWorld(!0);

            //if (this.hasAnchor) {
            //    this._disableAnchor()
            //    this._enableAnchor()
            //}

            if (this.followCamera) {
                let cameraPosition = UjP.controls.cameraWorldPosition()
                this.lookAt(cameraPosition)
            }

            this._normal = normal
            this._updated()
        }
    }

    restoreScale() {
        this.setScale(1, 1, 1);
    }

    deserialize(config) {
        let n = this
        n._normal = config.normal
        n.scaleBase = config.scaleBase
        n._materialState = config.materials || []
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config)
    }

    _onSerialize(data) {
        data.normal = this.normal
        if(this.scaleBase !== undefined){
            data.scaleBase = this.scaleBase
        }
        data.materials = this._materials.map(m=>{
            return m.serialize(!0)
        })

        console.log('ssssss', data.materials.length);
    }



    _initMesh(config) {
        let n = this
        return new Promise(function (resolve, reject) {

            if (n.texture) {

                if(JMT.EDIT_MODE){
                    function createAgent(){

                        let geometry = new THREE.BoxBufferGeometry(1, 1, 1);
                        geometry.addTriangleOrderAttribute();
                        geometry.convertNormalsToSpherical();

                        var material = JMT.createBoundingBoxMaterial()

                        let boxMesh = new THREE.Mesh(geometry, material);
                        boxMesh.visibilityId = null;
                        boxMesh.position.y = .5

                        return boxMesh
                    }

                    let agent = createAgent()

                    n.isAgent = !0

                    n._loadModel(config, resolve, agent)

                    // 先把占位符返回
                    resolve(agent)


                }
                else {

                    n._loadModel(config, resolve)

                }



            }
        })
    }

    _updateMaterialWithState(material, materialIndex){

        if(this._materialState.length && materialIndex < this._materialState.length){

            let state = this._materialState[materialIndex]

            material.deserialize(state, this.config.textureLoader)

            console.log('>>' + materialIndex);

            //console.log(material, state);

        }
    }

    _loadModel(config, resolve, agent){

        let n = this

        let modelLoader = new THREE.GLTFLoader()

        let tmpMaterials =

        modelLoader.onMaterialLoaded =  function ( event ) {

            let material = event.material
            let materialIndex = event.materialIndex

            n._updateMaterialWithState(material, materialIndex)

            material.materialIndex = materialIndex

            // 添加到材质列表
            //n._materials.splice(materialIndex, 0 , material)
            n._materials.push(material)
        }

        modelLoader.load(n.texture, model=> {

            //console.log(n._materials);

            n._materials.sort((a,b)=>{
                return a.materialIndex - b.materialIndex
            })

            let defaultScale = config.scaleBase || 0.001

            let scene = model.scene || model

            let animations = model.animations


            animations.forEach(an=>{

                an.root = scene

                an.asset = n

                UjP.animationsController.animations.push(an)

            })

            let bbox = new THREE.Box3()

            scene.traverse(mesh=> {

                if (mesh instanceof THREE.Mesh || mesh instanceof THREE.SkinnedMesh) {

                    let geometry = mesh.geometry

                    let attrs = geometry.attributes

                    for(let key in attrs){

                        if(attrs[key].buffer){

                            attrs[key].buffer = null
                        }

                    }
                    //atts.position.buffer = null
                    //atts.normal.buffer = null
                    //atts.uv.buffer = null
                    //atts.index && (atts.index.buffer = null)
                    //geometry.addTriangleOrderAttribute()
                    if (geometry.attributes.normal)
                        geometry.convertNormalsToSpherical()

                    bbox.union(geometry.boundingBox)

                    if( mesh instanceof THREE.SkinnedMesh){
                        // 使动画生效，以后在loader
                        mesh.material&& mesh.material.condDefine(mesh.material.skinning, "USE_SKINNING")
                    }

                    if (mesh.material && mesh.material.baseColorTexture) {

                        let texture = mesh.material.baseColorTexture



                        if (texture) {

                            texture.addLoadedListener(()=>{

                                // texture.wrapS = GLC.CLAMP_TO_EDGE
                                // texture.wrapT = GLC.CLAMP_TO_EDGE
                                // texture.magFilter = GLC.LINEAR
                                // texture.minFilter = GLC.NEAREST_MIPMAP_LINEAR

                                //if (textureNeedsPowerOfTwo(texture))
                                {

                                    var c = THREE.Math.isPowerOfTwo(texture.image.width) && THREE.Math.isPowerOfTwo(texture.image.height)
                                    if (!c) {
                                        texture.image = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.resizeImage)(texture.image, true, 0, 4096)
                                        texture.width = texture.image.width
                                        texture.height = texture.image.height

                                    }
                                }
                            })
                        }

                    }

                    //防止变黑
                    if (mesh.material instanceof JMT.StandardMaterial) {
                        if (mesh.material.metallic === undefined)
                            mesh.material.metallic = 0
                        if (mesh.material.roughness === undefined)
                            mesh.material.roughness = 0.99
                    }

                    UjP.onMeshBuffersLoaded && UjP.onMeshBuffersLoaded(mesh)
                }
            })


            n._bbox = bbox
            //mesh.scale.fromArray([0.001, 0.001, 0.001])

            if(!agent){

                resolve(scene)

            }
            else {

                n.remove(agent)

                n.add(scene)

                n._mesh = scene

                //let lightProbe = agent.lightProbe
                //
                //n._assignLight(config,lightProbe)

                this.isAgent = !1

            }

            bbox.min.multiplyScalar(defaultScale)
            bbox.max.multiplyScalar(defaultScale)
            scene.scale.set(defaultScale, defaultScale, defaultScale)
            scene.updateMatrixWorld(!0)

            n.dispatchEvent({type:'finalLoaded'})

        }, !1, err=> {
            console.log(err);
        })
    }


    _getBoundinngSphere() {

        let sphere = new THREE.Sphere()
        return this._bbox.getBoundingSphere(sphere)
    }

    //粗略求交
    raycast(ray) {

        if (!this._mesh || !this.visible) return null

        // let pt = new THREE.Vector3()
        // let sphere = new THREE.Sphere()
        // sphere.copy(this.boundingSphere);
        // sphere.applyMatrix4(this._mesh.matrixWorld);
        // if (ray.intersectSphere(sphere, pt)) {
        //     //pt.applyMatrix4(this._mesh.matrixWorld)
        //     let dist = pt.distanceTo(ray.origin)
        //     return {
        //         distance: dist,
        //         point: pt,
        //         object: this
        //     }
        // }

        var intersects = []
        this._intersectObject(this._mesh, ray, intersects)

        if (intersects.length > 0) {

            var ret_ins = intersects[0]

            for (let j = 0, len = intersects.length; j < len; j++) {

                if (ret_ins.distance > intersects[j].distance)
                    ret_ins = intersects[j]
            }

            return ret_ins
        }
        else {
            return null
        }
    }

    _assignLight(config, probe) {
        let lightProbe = probe || this._getLightProbe(config)
        this._mesh.traverse(mesh=> {
            if (mesh instanceof THREE.Mesh || mesh instanceof THREE.SkinnedMesh) {
                mesh.lightProbe = lightProbe
                let texture = mesh.material.baseColorTexture
                if (texture && texture.image && texture.notifyLoaded) {
                    texture.notifyLoaded()
                }
            }
        })
    }

    //updateLocalParameterteLocalParameter(config) {
    //    this._mesh.traverse(mesh=> {
    //        if (mesh instanceof THREE.Mesh) {
    //            mesh.lightProbe = config.object.lightProbe
    //            //mesh.lightMap = config.object.lightMap
    //            //mesh.lightMapIdx = config.object.lightMapIdx
    //
    //            if (mesh.material.baseColorTexture.notifyLoaded) {
    //                mesh.material.baseColorTexture.notifyLoaded()
    //            }
    //
    //            //mesh.material.baseColorTexture = config.object.material.baseColorTexture
    //
    //            mesh.material.lc = config.object.material.lc
    //            mesh.material.lcContrast = config.object.material.lcContrast
    //            mesh.material.lcIntensity = config.object.material.lcIntensity
    //            mesh.material.envMap = config.object.material.envMap
    //        }
    //    })
    //}

    _setHighLight(highlight) {
        if (!UjP.config.mode) {
            return
        }
        if (this._mesh) {
            this._mesh.traverse(mesh=> {
                if (mesh instanceof THREE.Mesh) {
                    mesh.material.highlightMix = highlight
                }
            })
        }
        UjP.aniController.requestFrame()
    }
}

JMT.ModelAsset = ModelAsset

/***/ }),

/***/ "./assets/TextAsset.js":
/*!*****************************!*\
  !*** ./assets/TextAsset.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextAsset": function() { return /* binding */ TextAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/1/27.
 */




const DEFAULT_TEXT = '点击输入文字...'
const DEFAULT_FONT_FAMILY = "Noto Sans"
const DEFAULT_FONT_COLOR = "#4c9ed9"
const DEFAULT_FONT_OPACITY = 1
const DEFAULT_FONT_SIZE = -1

class TextAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id)
    }

    _onDefineProperties() {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'textAlign')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fillStyle')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontFamily')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontSize')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontStyle')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontVariant')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontWeight')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'lineSpacing')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'shadow')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'strokeStyle')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'strokeWidth')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'text')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'url')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'fontBold')
    }

    deserialize(config) {
        let n = this
        let text = config.text || {}
        n._textAlign = text.align || 'center'
        n._fillStyle = text.fillStyle || "#ffffff"
        n._fontStyle = text.fontStyle || "normal"
        n._fontFamily = text.fontFamily || DEFAULT_FONT_FAMILY
        n._fontSize = text.fontSize || DEFAULT_FONT_SIZE
        n._fontVariant = text.fontVariant
        n._fontWeight = text.fontWeight
        n._lineSpacing = text.lineSpacing || 1
        n._shadow = text.shadow
        n._strokeStyle = text.strokeStyle || "#ffffff"
        n._url = text.url
        n._fontBold = text.fontBold
        n._opacit = text.opacity || 1
        n._text = text.text || DEFAULT_TEXT
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.deserialize.call(n, config)
    }

    _onSerialize(data) {

        let n = this
        data['text'] = {
            align: n.textAlign,
            fillStyle: n.fillStyle,
            fontFamily: n.fontFamily,
            fontSize: n.fontSize,
            fontStyle: n.fontStyle,
            fontVariant: n.fontVariant,
            fontWeight: n.fontWeight,
            lineSpacing: n.lineSpacing,
            shadow: n.shadow,
            strokeStyle: n.strokeStyle,
            url: n.url,
            fontBold: n.fontBold,
            opacity: n.opacity,
            text: n.text
        }
    }

    onCreateMaterial(material, config) {
        material.doubleSided = true
        material.transparent = true;
        material.map = this.createTexture(this);
        UjP.aniController.requestFrame()
    }

    _onReadyToLoad() {
        this.dispatchEvent({
            type: 'assetLoaded'
        })
        this.material.map.hasAlpha = !0;
        this.material.configureTransparency()
        this._initLock = false
    }


    createTexture(config) {

        var w = document.getElementById("anchor-canvas");

        if (!w) {
            w = document.createElement("canvas")

            w.id = "anchor-canvas"
        }

        this._draw(w)

        let texture = new THREE.Texture(w);//new JMT.Texture(w);
        texture.width = w.width;
        texture.height = w.height;
        texture.hasAlpha = true;
        texture.minFilter = THREE.LinearFilter;//GLC.LINEAR;
        texture.loaded = !0;
        texture.needsUpdate = !0;


        return texture
    }

    _updated(holder, propertyName) {

        if (this.material) {

            this.material.map.dispose()

            this.material.map = this.createTexture(this.config)
        }

        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype._updated.call(this, holder, propertyName)
    }

    _draw(canvas) {

        var d = this.icon && JMT.ICONS[this.icon]
        var e = this.text
        var f = this.fontFamily;
        var g = this.fillStyle;
        var h = this.opacity;
        var fontSize = this.fontSize * 1
        var fontBold = this.fontBold ? 700 : ''
        var rowSpacing = this.lineSpacing || 1
        var fillBackground = this.fillBackground || false


        if (!(void 0 === h || 1 <= h)) {
            let k = new THREE.Color()
            k.setStyle(g)
            g = "rgba(" + (255 * k.r | 0) + "," + (255 * k.g | 0) + "," + (255 * k.b | 0) + "," + h + ")"
        }


        var p = g;

        h = this.fontStyle;

        g = void 0 !== this.opacity && 1 > this.opacity;

        var t = "sphere" === this.type
        var v = t || void 0 === this.textMargin ? 20 : this.textMargin;

        d = [d || "", e, f, p, t, v, this.borderRadius || 0, g].join("_");

        let arr = this.arrangeText(f, e)
        e = getLongest(arr)

        var c = 512
        if (t) {
            c = 512 - 2 * Math.floor(512 * (.5 - .5 * Math.sin(70 / 180 * Math.PI / 2)))
        }
        t = canvas
        t.width = 512
        t.height = 512
        t = t.getContext("2d")
        if (fontSize <= 0) {
            fontSize = 128
            // 字体大小自适应
            t.font = h + " " + fontBold + " " + fontSize + "px " + f
            fontSize = t.measureText(e).width

            fontSize = Math.floor(c / fontSize * 128)
            fontSize = Math.min(fontSize, c)

            let th = fontSize * (1 + rowSpacing) * arr.length - fontSize * rowSpacing
            if (th > 512) {
                fontSize = (512 + rowSpacing * fontSize) / (1 + arr.length) / (1 + rowSpacing)
            }

            t.font = h + " " + fontBold + " " + fontSize + "px " + f
        } else {
            t.font = h + " " + fontBold + " " + fontSize + "px " + f
        }


        f = t

        f.fillStyle = p;

        if (this.borderRadius) {
            p = f
            t = canvas.width
            v = canvas.height
            b = .5 * this.borderRadius * Math.min(t, fontSize)
            p.beginPath()
            p.moveTo(0 + b, 0)
            p.lineTo(0 + t - b, 0)
            p.quadraticCurveTo(0 + t, 0, 0 + t, 0 + b)
            p.lineTo(0 + t, 0 + fontSize - b)
            p.quadraticCurveTo(0 + t, 0 + v, 0 + t - b, 0 + fontSize)
            p.lineTo(0 + b, 0 + fontSize)
            p.quadraticCurveTo(0, 0 + fontSize, 0, 0 + fontSize - b)
            p.lineTo(0, 0 + b)
            p.quadraticCurveTo(0, 0, 0 + b, 0)
            p.closePath()
            p.fill()
        } else if (fillBackground) {
            //f.fillRect(0, 0, canvas.width, canvas.height);
        }

        f.fillStyle = h;
        f.textAlign = this.textAlign;
        f.textBaseline = "middle";
        f.shadowColor = "black";
        f.shadowBlur = 16;


        let half = arr.length / 2

        let odd = !!(arr.length % 2)

        rowSpacing *= fontSize

        let halfSpace = rowSpacing / 2

        let halfHeight = canvas.height / 2,
            halfWidth = canvas.width / 2

        if (f.textAlign === 'left') {
            halfWidth = 0
        } else if (f.textAlign === 'right') {
            halfWidth = canvas.width
        }

        if (arr.length == 1) {
            f.fillText(e, halfWidth, halfHeight);
        } else {
            let firstH
            let unitH = fontSize + rowSpacing
            if (odd) {
                firstH = halfHeight + fontSize / 2 - unitH * half
            } else {
                firstH = halfHeight + fontSize / 2 + halfSpace - unitH * half
            }
            arr.some((e, index) => {
                f.fillText(e, halfWidth, firstH + index * unitH);
            })
        }
    }


    arrangeText(context, text) {
        let arr = text.split('\n')
        return arr
    }

}

function getLongest(arr) {
    let l = -1
    let i = -1
    arr.some((str, index) => {
        if (str.length > l) {
            l = str.length
            i = index
        }
    })
    return arr[i]
}

JMT.TextAsset = TextAsset

/***/ }),

/***/ "./assets/VideoAsset.js":
/*!******************************!*\
  !*** ./assets/VideoAsset.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VideoAsset": function() { return /* binding */ VideoAsset; }
/* harmony export */ });
/* harmony import */ var _Asset_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Asset.js */ "./assets/Asset.js");
/**
 * Created by Kai on 2021/1/27.
 */



function err() {
    JMT.USER_MSG.info("Failed to load texture")
}

class VideoAsset extends _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset {
    constructor(config, id) {
        super(config, id)

        this.isVideo = JMT.ALWAYS_RENDER = true
    }

    onCreateMaterial(material, config) {
        if (config.texture) {
            let n = this

            let ext = this.texture.substr(this.texture.lastIndexOf('.') + 1, 4) || 'mp4'

            let param = {
                alpha: ext === 'webm',
                id: this.id,
                name: this.name,
                rawExt: ext,
                stdExt: "mp4",
                video: true,
                url: this.texture,
                webFormats: [
                    //"small/std", "large/dxt", "small/pvr", "small/etc1"
                ]
            }

            let videoTexture = this._textureLoader.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, param, !0, !0, JMT.DEFAULT_ANISOTROPY)
            // TODO: 是否从编辑模式进来？
            videoTexture.fromEditor = !0;
            videoTexture.addLoadedListener(video=> {
                videoTexture.muted = !1;
                videoTexture.pause()
                if(config.creating){
                    let v = videoTexture.video
                    n.scale.set(1, v.videoWidth/v.videoHeight, 1)
                    n.updateMatrixWorld(!0)
                    config.creating = !1
                }

                n.dispatchEvent({type:'assetLoaded'})
            })
            
            material.map = videoTexture;
            Object.defineProperty(material, 'baseColorTexture', {
                get: function () {
                    return material.map
                }
            })

            // if(param.alpha){
            //     videoTexture.isCutout = !0
            // }
            
            material.side = THREE.DoubleSide;
        }
    }

    restoreScale(){
        if(this.material && this.material.baseColorTexture){
            let video = this.material.baseColorTexture
            // 保持素材宽高比
            let scale = video.image.videoHeight / video.image.videoWidth
            this.setScale(scale, 1,  1);
        }
    }

    _onclick() {
        let isPlay = (this.material.map && this.material.map.isPlaying)

        isPlay ? this.pause() : this.play()
    }

    play(){
        this.dispatchEvent({type:'videoPlaying'})
        this.material.map.play()

    }

    pause(){

        this.material.map.pause()

    }

    setVolume(volumeScale){
        if(this.material.map.video){
            this.material.map.video.volume = volumeScale
        }
    }

    setMute(ismute){

        this.material.map.muted = ismute

    }

    _animate() {
        UjP.aniController.requestFrame()
    }

    dispose(){

        let video = this.material.map
        video.pause()
        _Asset_js__WEBPACK_IMPORTED_MODULE_0__.Asset.prototype.dispose.call(this)
    }
}


JMT.VideoAsset = VideoAsset

/***/ }),

/***/ "./effect/FlagMesh.js":
/*!****************************!*\
  !*** ./effect/FlagMesh.js ***!
  \****************************/
/***/ (function() {

/**
 * FlagMesh
 * @author Martian - JMYD. 2021/6/25
 *
 */

 const [flagW, flagH, segW, segH] = [1, 1, 32, 20]; //旗的大小，分割数
 const poleH = 1

 class FlagMesh extends THREE.Object3D {

     constructor(config) {

         super();

         this._flagW = 1
         this._flagH = 0.8
         this._poleH = 2
         this._amplitude = 0.01
         this._speed = 0.5
         this._flagColor = '#ffffff'
         this._poleColor = '#af2032'

         this._flagMesh = null
         this._poleMesh = null

         Object.defineProperty(this, 'flagW', {
             get: function () {
                 return this._flagW
             },
             set: function (value) {
                 if (this._flagW !== value) {
                     this._flagW = value
                     this._updateSize()
                 }
             }
         })

         Object.defineProperty(this, 'flagH', {
             get: function () {
                 return this._flagH
             },
             set: function (value) {
                 if (this._flagH !== value) {
                     this._flagH = value
                     this._updateSize()
                 }
             }
         })

         Object.defineProperty(this, 'poleH', {
             get: function () {
                 return this._poleH
             },
             set: function (value) {
                 if (this._poleH !== value) {
                     this._poleH = value
                     this._updateSize()
                 }
             }
         })

         Object.defineProperty(this, 'flagColor', {
             get: function () {
                 return this._flagColor
             },
             set: function (value) {
                 if (this._flagColor !== value) {
                     this._flagColor = value

                     this._flagMesh && this._flagMesh.material.baseColor.set(this._flagColor)
                 }
             }
         })

         Object.defineProperty(this, 'poleColor', {
             get: function () {
                 return this._poleColor
             },
             set: function (value) {
                 if (this._poleColor !== value) {
                     this._poleColor = value

                     this._poleMesh && this._poleMesh.material.baseColor.set(this._poleColor)
                 }
             }
         })

         var that = this;
         function _init () {

             function err() {
                 JMK.USER_MSG.info("Failed to load texture")
             }

             //Pole
             var pole_geometry = new THREE.CylinderBufferGeometry(0.01, 0.01, poleH, 16, 1, !1)
             //pole_geometry.convertNormalsToSpherical()
             //var pole_material = new JMT.j3dStandardMaterial()
            // pole_material.hideFromLightProbes = false;
            // pole_material.baseColor = new THREE.Color(that._poleColor)
            // pole_material.specularOff = 1

            var pole_material = new THREE.MeshBasicMaterial({color:that._poleColor});

             var pole = new THREE.Mesh(pole_geometry, pole_material)
             pole.name = "poleMesh"
             pole.position.set(0, that._poleH * poleH / 2, 0)
             pole.scale.set(1, that._poleH, 1)
             that._poleMesh = pole
             that.add(pole)

             //
             var geometry = new THREE.PlaneBufferGeometry(flagW, flagH, segW, segH);
             //geometry.convertNormalsToSpherical()
             //var material = new JMT.j3dStandardMaterial()
            //  material.side = THREE.DoubleSide;
            //  material.hideFromLightProbes = !0;
            //  material.baseColor = new THREE.Color(that._flagColor);
            //  material.specularOff = 1;

            var material= new THREE.MeshBasicMaterial({color:that._flagColor, side:THREE.DoubleSide});
            //material.side = THREE.DoubleSide;

             if (config.texture) {

                 let param = {
                     alpha: false,
                     id: "css/image/flag1.jpg",
                     name: "test",
                     rawExt: "jpg",
                     stdExt: "jpg",
                     url: config.texture,
                     webFormats: [
                         //"small/std", "large/dxt", "small/pvr", "small/etc1"
                     ]
                 }

                 let loader = (config && config.textureLoader) ? config.textureLoader :
                     new JMT.j3dTextureLoader("./",
                         JMT.DETECTOR,
                         function (a) {
                             UjP.aniController.requestFrame()
                         }, err, err, !0)

                 let t = loader.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, param, !0, !0, JMT.DEFAULT_ANISOTROPY)
                 t.fromEditor = !0;
                 material.map = t;

                 
                 t.addLoadingListener(() => {
                    that.dispatchEvent({
                         type: "loaded"
                     });
                 });

             } 
             else {

                 
                 let renderInterval1 = setTimeout(function () {
                    that.dispatchEvent({
                         type: "loaded"
                     });

                 }, 1000)
             }

             var flagMesh = new THREE.Mesh(geometry, material);
             flagMesh.name = "flagMesh"

             //设置相对位置和大小
             flagMesh.scale.set(that._flagW, that._flagH, 1)
             flagMesh.position.set(that._flagW * flagW / 2, that._poleH * poleH - that._flagH * flagH / 2, 0);
             that._flagMesh = flagMesh
             that.add(flagMesh)
         }

         _init()
     }

   

    update (time) {

        if (this._flagMesh) {
            //水平方向、垂直方向、振幅、速度的初始值
            // const [h, v, w, s] = [0.5, 0.3, 0.01, 0.5];
            const [h, v] = [0.5, 0.3];
            var w=this._amplitude;
            var s=this._speed;
            time = time || Date.now() * s / 50;

            for (let y = 0; y < segH + 1; y++) {
                for (let x = 0; x < segW + 1; x++) {
                    let index = x + y * (segW + 1);
                    index = index * 3 + 2
                    //let vertex = flag.geometry.attributes.position.array[index];
                    const time = Date.now() * s / 50;
                    //vertex = Math.sin(h * x + v * y - time) * w * x / 4;
                    this._flagMesh.geometry.attributes.position.array[index] = Math.sin(h * x + v * y - time) * w * x / 4;

                }
            }

            //flag.geometry.verticesNeedUpdate = true;
            this._flagMesh.geometry.attributes.position.needsUpdate = true
            //this._flagMesh.geometry.attributes.position.buffer = null
            //UjP.webGLRenderer.uploadBuffers(this._flagMesh)
            //UjP.webGLRenderer.uploadNewBuffers(this._flagMesh)
        }
    }

    setFlagSize (w, h) {
        this._flagW = w
        this._flagH = h

        this._updateSize()
    }

    setPoleHeight (h) {

        this._poleH = h
        this._updateSize()
    }

    _updateSize () {

        this._flagMesh.scale.set(this._flagW, this._flagH, 1)
        this._flagMesh.position.set(this._flagW * flagW/2, this._poleH * poleH - this._flagH * flagH/2, 0);

        this._poleMesh.position.set(0, this._poleH * poleH/2, 0)
        this._poleMesh.scale.set(1, this._poleH, 1)

        this.updateMatrixWorld(!0)
    }

}

//JMT.FlagMesh.prototype = Object.create(THREE.Object3D.prototype);
//JMT.FlagMesh.prototype.constructor = THREE.FlagMesh;
JMT.FlagMesh = FlagMesh


JMT.FlagMgr = function () {

    this.FlagMeshes = []

    this.createFlag = function () {
        var obj = new JMT.FlagMesh()
        this.FlagMeshes.push(obj)
        return  obj
    }

    this.update = function (time) {
        this.FlagMeshes.forEach( function(flag){

            flag.update(time)

        })
    }
}

//window.FlagMgr = new JMT.FlagObj
//window.FlagMgr = new JMT.FlagMgr


/***/ }),

/***/ "./effect/coneLight/ConeLight.js":
/*!***************************************!*\
  !*** ./effect/coneLight/ConeLight.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConeLight": function() { return /* binding */ ConeLight; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/4/14.
 */



let HEXAGON_RADIUS = 0.5;

class ConeLight extends THREE.Object3D {
  constructor() {
    super();

    this.name = "ConeLight"
    this.type = "ConeLight"
    //let material = new JMT.StandardMaterial();
    let material = new THREE.MeshBasicMaterial()
    material.disableLightProbe = false;
    material.transparent = true;
    material.specularOff = true;
    material.headLight = false;
    material.side = THREE.DoubleSide;
    material.configureTransparency();
    material.blending = THREE.AdditiveBlending;
    material.depthWrite = false;
    material.mk = true;

    let index = Math.ceil(Math.random() * 2) % 2;
    console.log(index);
    //material.baseColorTexture = getTexture(index);
    material.map = getTexture(index);

    let height = Math.random() * 0.5;

    let geometry = new THREE.PlaneBufferGeometry(HEXAGON_RADIUS * 2, height);
    geometry.attributes.uv.array = new Float32Array([1, 1, 1, 0, 0, 1, 0, 0]);

    let plane1 = new THREE.Mesh(geometry, material);

    let matrix1 = new THREE.Matrix4();
    matrix1.makeRotationY(-Math.PI / 2);
    matrix1.setPosition(new THREE.Vector3(0, 0, 0));
    geometry.applyMatrix4(matrix1);

    let plane2 = plane1.clone();
    plane2.rotation.z = Math.PI / 2;
    plane1.add(plane2);

    this.add(plane1);
  }
}

function getTexture(index) {
  let key = "default_" + index;

  let texture = ConeLight.cache[key];

  if (!texture) {
    let image = new Image();

    image.src = ConeLight.RAY[index];

    texture = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.createTextureFromHtmlImage)(image);

    texture.wrapS = texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.magFilter = texture.minFilter = THREE.LinearFilter;

    ConeLight.cache[key] = texture;
  }
  console.log(texture);
  return texture;
}

ConeLight.cache = {};

ConeLight.RAY = [
  "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QAWRXhpZgAATU0AKgAAAAgAAAAAAAD/7AARRHVja3kAAQAEAAAAPAAA/+IMWElDQ19QUk9GSUxFAAEBAAAMSExpbm8CEAAAbW50clJHQiBYWVogB84AAgAJAAYAMQAAYWNzcE1TRlQAAAAASUVDIHNSR0IAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1IUCAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARY3BydAAAAVAAAAAzZGVzYwAAAYQAAABsd3RwdAAAAfAAAAAUYmtwdAAAAgQAAAAUclhZWgAAAhgAAAAUZ1hZWgAAAiwAAAAUYlhZWgAAAkAAAAAUZG1uZAAAAlQAAABwZG1kZAAAAsQAAACIdnVlZAAAA0wAAACGdmlldwAAA9QAAAAkbHVtaQAAA/gAAAAUbWVhcwAABAwAAAAkdGVjaAAABDAAAAAMclRSQwAABDwAAAgMZ1RSQwAABDwAAAgMYlRSQwAABDwAAAgMdGV4dAAAAABDb3B5cmlnaHQgKGMpIDE5OTggSGV3bGV0dC1QYWNrYXJkIENvbXBhbnkAAGRlc2MAAAAAAAAAEnNSR0IgSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAADzUQABAAAAARbMWFlaIAAAAAAAAAAAAAAAAAAAAABYWVogAAAAAAAAb6IAADj1AAADkFhZWiAAAAAAAABimQAAt4UAABjaWFlaIAAAAAAAACSgAAAPhAAAts9kZXNjAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAABZJRUMgaHR0cDovL3d3dy5pZWMuY2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAuSUVDIDYxOTY2LTIuMSBEZWZhdWx0IFJHQiBjb2xvdXIgc3BhY2UgLSBzUkdCAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGRlc2MAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAACxSZWZlcmVuY2UgVmlld2luZyBDb25kaXRpb24gaW4gSUVDNjE5NjYtMi4xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB2aWV3AAAAAAATpP4AFF8uABDPFAAD7cwABBMLAANcngAAAAFYWVogAAAAAABMCVYAUAAAAFcf521lYXMAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAKPAAAAAnNpZyAAAAAAQ1JUIGN1cnYAAAAAAAAEAAAAAAUACgAPABQAGQAeACMAKAAtADIANwA7AEAARQBKAE8AVABZAF4AYwBoAG0AcgB3AHwAgQCGAIsAkACVAJoAnwCkAKkArgCyALcAvADBAMYAywDQANUA2wDgAOUA6wDwAPYA+wEBAQcBDQETARkBHwElASsBMgE4AT4BRQFMAVIBWQFgAWcBbgF1AXwBgwGLAZIBmgGhAakBsQG5AcEByQHRAdkB4QHpAfIB+gIDAgwCFAIdAiYCLwI4AkECSwJUAl0CZwJxAnoChAKOApgCogKsArYCwQLLAtUC4ALrAvUDAAMLAxYDIQMtAzgDQwNPA1oDZgNyA34DigOWA6IDrgO6A8cD0wPgA+wD+QQGBBMEIAQtBDsESARVBGMEcQR+BIwEmgSoBLYExATTBOEE8AT+BQ0FHAUrBToFSQVYBWcFdwWGBZYFpgW1BcUF1QXlBfYGBgYWBicGNwZIBlkGagZ7BowGnQavBsAG0QbjBvUHBwcZBysHPQdPB2EHdAeGB5kHrAe/B9IH5Qf4CAsIHwgyCEYIWghuCIIIlgiqCL4I0gjnCPsJEAklCToJTwlkCXkJjwmkCboJzwnlCfsKEQonCj0KVApqCoEKmAquCsUK3ArzCwsLIgs5C1ELaQuAC5gLsAvIC+EL+QwSDCoMQwxcDHUMjgynDMAM2QzzDQ0NJg1ADVoNdA2ODakNww3eDfgOEw4uDkkOZA5/DpsOtg7SDu4PCQ8lD0EPXg96D5YPsw/PD+wQCRAmEEMQYRB+EJsQuRDXEPURExExEU8RbRGMEaoRyRHoEgcSJhJFEmQShBKjEsMS4xMDEyMTQxNjE4MTpBPFE+UUBhQnFEkUahSLFK0UzhTwFRIVNBVWFXgVmxW9FeAWAxYmFkkWbBaPFrIW1hb6Fx0XQRdlF4kXrhfSF/cYGxhAGGUYihivGNUY+hkgGUUZaxmRGbcZ3RoEGioaURp3Gp4axRrsGxQbOxtjG4obshvaHAIcKhxSHHscoxzMHPUdHh1HHXAdmR3DHeweFh5AHmoelB6+HukfEx8+H2kflB+/H+ogFSBBIGwgmCDEIPAhHCFIIXUhoSHOIfsiJyJVIoIiryLdIwojOCNmI5QjwiPwJB8kTSR8JKsk2iUJJTglaCWXJccl9yYnJlcmhya3JugnGCdJJ3onqyfcKA0oPyhxKKIo1CkGKTgpaymdKdAqAio1KmgqmyrPKwIrNitpK50r0SwFLDksbiyiLNctDC1BLXYtqy3hLhYuTC6CLrcu7i8kL1ovkS/HL/4wNTBsMKQw2zESMUoxgjG6MfIyKjJjMpsy1DMNM0YzfzO4M/E0KzRlNJ402DUTNU01hzXCNf02NzZyNq426TckN2A3nDfXOBQ4UDiMOMg5BTlCOX85vDn5OjY6dDqyOu87LTtrO6o76DwnPGU8pDzjPSI9YT2hPeA+ID5gPqA+4D8hP2E/oj/iQCNAZECmQOdBKUFqQaxB7kIwQnJCtUL3QzpDfUPARANER0SKRM5FEkVVRZpF3kYiRmdGq0bwRzVHe0fASAVIS0iRSNdJHUljSalJ8Eo3Sn1KxEsMS1NLmkviTCpMcky6TQJNSk2TTdxOJU5uTrdPAE9JT5NP3VAnUHFQu1EGUVBRm1HmUjFSfFLHUxNTX1OqU/ZUQlSPVNtVKFV1VcJWD1ZcVqlW91dEV5JX4FgvWH1Yy1kaWWlZuFoHWlZaplr1W0VblVvlXDVchlzWXSddeF3JXhpebF69Xw9fYV+zYAVgV2CqYPxhT2GiYfViSWKcYvBjQ2OXY+tkQGSUZOllPWWSZedmPWaSZuhnPWeTZ+loP2iWaOxpQ2maafFqSGqfavdrT2una/9sV2yvbQhtYG25bhJua27Ebx5veG/RcCtwhnDgcTpxlXHwcktypnMBc11zuHQUdHB0zHUodYV14XY+dpt2+HdWd7N4EXhueMx5KnmJeed6RnqlewR7Y3vCfCF8gXzhfUF9oX4BfmJ+wn8jf4R/5YBHgKiBCoFrgc2CMIKSgvSDV4O6hB2EgITjhUeFq4YOhnKG14c7h5+IBIhpiM6JM4mZif6KZIrKizCLlov8jGOMyo0xjZiN/45mjs6PNo+ekAaQbpDWkT+RqJIRknqS45NNk7aUIJSKlPSVX5XJljSWn5cKl3WX4JhMmLiZJJmQmfyaaJrVm0Kbr5wcnImc951kndKeQJ6unx2fi5/6oGmg2KFHobaiJqKWowajdqPmpFakx6U4pammGqaLpv2nbqfgqFKoxKk3qamqHKqPqwKrdavprFys0K1ErbiuLa6hrxavi7AAsHWw6rFgsdayS7LCszizrrQltJy1E7WKtgG2ebbwt2i34LhZuNG5SrnCuju6tbsuu6e8IbybvRW9j74KvoS+/796v/XAcMDswWfB48JfwtvDWMPUxFHEzsVLxcjGRsbDx0HHv8g9yLzJOsm5yjjKt8s2y7bMNcy1zTXNtc42zrbPN8+40DnQutE80b7SP9LB00TTxtRJ1MvVTtXR1lXW2Ndc1+DYZNjo2WzZ8dp22vvbgNwF3IrdEN2W3hzeot8p36/gNuC94UThzOJT4tvjY+Pr5HPk/OWE5g3mlucf56noMui86Ubp0Opb6uXrcOv77IbtEe2c7ijutO9A78zwWPDl8XLx//KM8xnzp/Q09ML1UPXe9m32+/eK+Bn4qPk4+cf6V/rn+3f8B/yY/Sn9uv5L/tz/bf///9sAQwACAQECAQECAgICAgICAgMFAwMDAwMGBAQDBQcGBwcHBgcHCAkLCQgICggHBwoNCgoLDAwMDAcJDg8NDA4LDAwM/9sAQwECAgIDAwMGAwMGDAgHCAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwM/8AAEQgBAAAgAwEiAAIRAQMRAf/EAB8AAAEFAQEBAQEBAAAAAAAAAAABAgMEBQYHCAkKC//EALUQAAIBAwMCBAMFBQQEAAABfQECAwAEEQUSITFBBhNRYQcicRQygZGhCCNCscEVUtHwJDNicoIJChYXGBkaJSYnKCkqNDU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6g4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2drh4uPk5ebn6Onq8fLz9PX29/j5+v/EAB8BAAMBAQEBAQEBAQEAAAAAAAABAgMEBQYHCAkKC//EALURAAIBAgQEAwQHBQQEAAECdwABAgMRBAUhMQYSQVEHYXETIjKBCBRCkaGxwQkjM1LwFWJy0QoWJDThJfEXGBkaJicoKSo1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoKDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uLj5OXm5+jp6vLz9PX29/j5+v/aAAwDAQACEQMRAD8A/L79hPxZqHgjxhDeaXN9munTymby1b5T/vV+xn7OHjCHxbpemxypfTXU21ZG+Xbu/wC+a/FX9kvUPsviC2/36/ZX9gPxhcRax4es1uY4bWa5Xcr7e9AHT/tQeILP4cxutxbat8kO/wDdbf8A2Za/IX9uT9ojxR48j1LQ7jUt+gzTb47d44920N8u5lUV+vX/AAVE+LGoeEvFF5Y6bfx/ZZrBUbZtbqrbq/Eb9piT7TrEzf71AGJ+zncfZdXhav1T/wCCffjiGX4oeErW68v7LNfxpIr/AHdtflZ8A4/9Mhr9C/2M9QW1+JHhj7RbSX8X2yPdbp96dd33aAPfv+Cul5Y2vxourXS/LSz+wQOvlf8AAq/Jf9oSz/0yZq/Ur/gpzo9ro3x4vrOzsJNNt4bCD9y/uu7dX5oftGWa/aJqAOJ/Z7j828hr9Av2Q7i3sPib4Va6huZrdL+DzI4vmlkXd/DX5/8A7On/AB9w19+/sp3i2HxI8K3DTSQrDfwO0kUe5o/mX7q0Ae6/8FVLyzv/ANpzVWs7a6trf7Bbfu7iNlbd5f8AtV+aH7SEfledX6X/APBVHVY9U/ag1WWK4ubxfsFonmXEflN/q/7tfmt+0z/y2/GgDzH9nO4/4mENfoF+yfeNYfEvwlKr2yMmpWzq0v8Aqo/3i/er88f2d7j/AImENfoF+ynZw6z8RPCtrcSeXb3OpW0Un+6ZFoA+hP8AgrBqcmqftWarNJNYzN9gtE3WnzL/AKuvzN/acf8A11fpV/wVg0Kz8L/tWaxa2D7oPsFo/wDe+by/9mvzM/aYuP3k1AHkv7Pdx/plt/wGvv8A/ZjksZfGHhtdSk8mw+3wfaJE/wCWcfmLur88f2f7jyry2r9AP2VtUWw8c+GLhrb7YsOpWztbpHu8/Ei/LtoA+gP+Cng0W1/ac1hdBuZLmw+x23zPIzfN5K7vvV+bP7Slx+8mr9I/+CqmuQ69+1ZrVxb6bJpS/Y7RPs7x+U3+pX+GvzN/aUuP3k1AHlHwHuMXkNffn7K9xcf8Jp4Z+y/Pdf2lbeTs+X5vMXbX57/A59t9HX3t+y3cSf8ACT+G/KuPscv2+223D/8ALD94vzf8BoA+lv8Agq5cal/w1jr39qJIl19jtNyvJubb5K/3a/Mf9pS4/eTV+lH/AAVYkuP+GsPEP2rVY9bk+zWn+lRbdr/uV/u1+ZH7Slz/AKRNQB5j8E58arD/AL9fe37Lm2XxR4eVvLRXv7ZG3/d/1i/er4A+Dcnlaon+/X3n+y/tl8SaCjJHMr3kG5X+6/7xfloA+mf+CtFlHpf7XHieKKa2mRLa0+a3RVX/AI91/u1+X37Slz/pE1fpx/wVks49L/a48VRRW1tZqkNp+5t5Ny/8e61+Xf7Skn+kXVAHnHwkfGsr/vrX3r+y35cviDQVlTdE95BuVP8AlovmLXwJ8LJfK1f/AIGtfdn7M3mXWoaOtu+24kuYEjb/AJ5tuXbQB9P/APBWW3tbD9rTxVFZ20lnbpDabYZfvR/6PFX5cftKyf6Rc1+in7fGnaxoPx48SWviDUpNV1SHy/OupZNzSfuV2/Nx/DX5v/tH3Gb6agDgfhvJ5euJX3H+zPPNLqOjrbv5Nw9zCkbf8823Ltr4S8CS+XriV9q/s1zwyXGlLcP5NvJNH5kifL5a7vmoA+hP29LTXNG+OniS38TX1rqusp5f2i6ij2rJ+5Xb/wCO1+cX7Q9xu1Gb/fr9Av24LPRfDnxk8RWfhzVJNY0mHy/JupZ/tDSZjXd89fnf8fJ/N1R/9+gDi/CEnla3HX2H+zlqcNrJprXHz26TR+Yv+zu+avjbQJPL1SGvq79n/VPs32CTbv8AJmV9v0agD379tzxJ4b1n4wa9deErb7HoLpH9nh8jyvL/AHK7vl/3q+APjZP5usSf79fdX7cnj/8A4WD8ZNe1ZbD+yvtKQf6L/wA88Qqv8NfBXxYuPO1n/gdAHNaR/wAhGKvpz4F6g0Vvbt/FG6vXzBpj7bxK+kPgXcMsdtt/vrtoA9v/AG2fFl14n+LmvXl59hS6mSDd9i3Nb8Qqvy7q+G/iRJ5usV9pftqaxeX/AMYPEMt/Z29hdfu/Mt7eTzYo8Qr91q+J/Hknm65JQBkWX/HylfQ3wLk/d2v8Xzr8tfOsX+sX61798C7ji2b+46/MlAHrX7XkkkXxM8RLLYf2VKjrutfM83yP3a/xV8c+L5PN1uSvrf8Aa11yHWfiR4hure5ubyGZ12zXce2WT92v3lr5G8USebq8lAGfF/rF+te3/Au8WKS23fd3ru/3d1eHV6/8F7xYpIdyb/nX5f8Anp81AHsf7ZGuaXqfxU8Q3GjPH/Zc0y/Z/K+Vdvlr/wCzV8k623m6nM3vX03+1nrsOqfEjXri30qTRI3ddtjLHtaD92vy7a+YNS/5CM3+/QBXr0j4T6g1rJCy/eR1da83rsvh/ceVQB69+1Z4g1LWPiRrd1qyRw6jM6vMsMm5f9Wu3b/wGvnW8/4+5P8Aer2j9oi4uovGF/8AbLn7TdbI3kkT5fM/crXilx/rm+tADK6bwZcVzNdB4Pk/eUAd/wDtAaeujeML+1V5HVEj+Z/mbmNWryKX79ewftMP/wAXE1L/AHIP/RK147QAVr+F7lYrj5qyKdHJsNAHqn7SmqQ3XxEv2ifeuyD/ANErXlNXNV1WbVLp5Zm3s+P04qnQB//Z",
  "data:image/jpeg;base64,/9j/4QAYRXhpZgAASUkqAAgAAAAAAAAAAAAAAP/sABFEdWNreQABAAQAAAA8AAD/4gxYSUNDX1BST0ZJTEUAAQEAAAxITGlubwIQAABtbnRyUkdCIFhZWiAHzgACAAkABgAxAABhY3NwTVNGVAAAAABJRUMgc1JHQgAAAAAAAAAAAAAAAAAA9tYAAQAAAADTLUhQICAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABFjcHJ0AAABUAAAADNkZXNjAAABhAAAAGx3dHB0AAAB8AAAABRia3B0AAACBAAAABRyWFlaAAACGAAAABRnWFlaAAACLAAAABRiWFlaAAACQAAAABRkbW5kAAACVAAAAHBkbWRkAAACxAAAAIh2dWVkAAADTAAAAIZ2aWV3AAAD1AAAACRsdW1pAAAD+AAAABRtZWFzAAAEDAAAACR0ZWNoAAAEMAAAAAxyVFJDAAAEPAAACAxnVFJDAAAEPAAACAxiVFJDAAAEPAAACAx0ZXh0AAAAAENvcHlyaWdodCAoYykgMTk5OCBIZXdsZXR0LVBhY2thcmQgQ29tcGFueQAAZGVzYwAAAAAAAAASc1JHQiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAABJzUkdCIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWFlaIAAAAAAAAPNRAAEAAAABFsxYWVogAAAAAAAAAAAAAAAAAAAAAFhZWiAAAAAAAABvogAAOPUAAAOQWFlaIAAAAAAAAGKZAAC3hQAAGNpYWVogAAAAAAAAJKAAAA+EAAC2z2Rlc2MAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAFklFQyBodHRwOi8vd3d3LmllYy5jaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABkZXNjAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAC5JRUMgNjE5NjYtMi4xIERlZmF1bHQgUkdCIGNvbG91ciBzcGFjZSAtIHNSR0IAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZGVzYwAAAAAAAAAsUmVmZXJlbmNlIFZpZXdpbmcgQ29uZGl0aW9uIGluIElFQzYxOTY2LTIuMQAAAAAAAAAAAAAALFJlZmVyZW5jZSBWaWV3aW5nIENvbmRpdGlvbiBpbiBJRUM2MTk2Ni0yLjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHZpZXcAAAAAABOk/gAUXy4AEM8UAAPtzAAEEwsAA1yeAAAAAVhZWiAAAAAAAEwJVgBQAAAAVx/nbWVhcwAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAo8AAAACc2lnIAAAAABDUlQgY3VydgAAAAAAAAQAAAAABQAKAA8AFAAZAB4AIwAoAC0AMgA3ADsAQABFAEoATwBUAFkAXgBjAGgAbQByAHcAfACBAIYAiwCQAJUAmgCfAKQAqQCuALIAtwC8AMEAxgDLANAA1QDbAOAA5QDrAPAA9gD7AQEBBwENARMBGQEfASUBKwEyATgBPgFFAUwBUgFZAWABZwFuAXUBfAGDAYsBkgGaAaEBqQGxAbkBwQHJAdEB2QHhAekB8gH6AgMCDAIUAh0CJgIvAjgCQQJLAlQCXQJnAnECegKEAo4CmAKiAqwCtgLBAssC1QLgAusC9QMAAwsDFgMhAy0DOANDA08DWgNmA3IDfgOKA5YDogOuA7oDxwPTA+AD7AP5BAYEEwQgBC0EOwRIBFUEYwRxBH4EjASaBKgEtgTEBNME4QTwBP4FDQUcBSsFOgVJBVgFZwV3BYYFlgWmBbUFxQXVBeUF9gYGBhYGJwY3BkgGWQZqBnsGjAadBq8GwAbRBuMG9QcHBxkHKwc9B08HYQd0B4YHmQesB78H0gflB/gICwgfCDIIRghaCG4IggiWCKoIvgjSCOcI+wkQCSUJOglPCWQJeQmPCaQJugnPCeUJ+woRCicKPQpUCmoKgQqYCq4KxQrcCvMLCwsiCzkLUQtpC4ALmAuwC8gL4Qv5DBIMKgxDDFwMdQyODKcMwAzZDPMNDQ0mDUANWg10DY4NqQ3DDd4N+A4TDi4OSQ5kDn8Omw62DtIO7g8JDyUPQQ9eD3oPlg+zD88P7BAJECYQQxBhEH4QmxC5ENcQ9RETETERTxFtEYwRqhHJEegSBxImEkUSZBKEEqMSwxLjEwMTIxNDE2MTgxOkE8UT5RQGFCcUSRRqFIsUrRTOFPAVEhU0FVYVeBWbFb0V4BYDFiYWSRZsFo8WshbWFvoXHRdBF2UXiReuF9IX9xgbGEAYZRiKGK8Y1Rj6GSAZRRlrGZEZtxndGgQaKhpRGncanhrFGuwbFBs7G2MbihuyG9ocAhwqHFIcexyjHMwc9R0eHUcdcB2ZHcMd7B4WHkAeah6UHr4e6R8THz4faR+UH78f6iAVIEEgbCCYIMQg8CEcIUghdSGhIc4h+yInIlUigiKvIt0jCiM4I2YjlCPCI/AkHyRNJHwkqyTaJQklOCVoJZclxyX3JicmVyaHJrcm6CcYJ0kneierJ9woDSg/KHEooijUKQYpOClrKZ0p0CoCKjUqaCqbKs8rAis2K2krnSvRLAUsOSxuLKIs1y0MLUEtdi2rLeEuFi5MLoIuty7uLyQvWi+RL8cv/jA1MGwwpDDbMRIxSjGCMbox8jIqMmMymzLUMw0zRjN/M7gz8TQrNGU0njTYNRM1TTWHNcI1/TY3NnI2rjbpNyQ3YDecN9c4FDhQOIw4yDkFOUI5fzm8Ofk6Njp0OrI67zstO2s7qjvoPCc8ZTykPOM9Ij1hPaE94D4gPmA+oD7gPyE/YT+iP+JAI0BkQKZA50EpQWpBrEHuQjBCckK1QvdDOkN9Q8BEA0RHRIpEzkUSRVVFmkXeRiJGZ0arRvBHNUd7R8BIBUhLSJFI10kdSWNJqUnwSjdKfUrESwxLU0uaS+JMKkxyTLpNAk1KTZNN3E4lTm5Ot08AT0lPk0/dUCdQcVC7UQZRUFGbUeZSMVJ8UsdTE1NfU6pT9lRCVI9U21UoVXVVwlYPVlxWqVb3V0RXklfgWC9YfVjLWRpZaVm4WgdaVlqmWvVbRVuVW+VcNVyGXNZdJ114XcleGl5sXr1fD19hX7NgBWBXYKpg/GFPYaJh9WJJYpxi8GNDY5dj62RAZJRk6WU9ZZJl52Y9ZpJm6Gc9Z5Nn6Wg/aJZo7GlDaZpp8WpIap9q92tPa6dr/2xXbK9tCG1gbbluEm5rbsRvHm94b9FwK3CGcOBxOnGVcfByS3KmcwFzXXO4dBR0cHTMdSh1hXXhdj52m3b4d1Z3s3gReG54zHkqeYl553pGeqV7BHtje8J8IXyBfOF9QX2hfgF+Yn7CfyN/hH/lgEeAqIEKgWuBzYIwgpKC9INXg7qEHYSAhOOFR4Wrhg6GcobXhzuHn4gEiGmIzokziZmJ/opkisqLMIuWi/yMY4zKjTGNmI3/jmaOzo82j56QBpBukNaRP5GokhGSepLjk02TtpQglIqU9JVflcmWNJaflwqXdZfgmEyYuJkkmZCZ/JpomtWbQpuvnByciZz3nWSd0p5Anq6fHZ+Ln/qgaaDYoUehtqImopajBqN2o+akVqTHpTilqaYapoum/adup+CoUqjEqTepqaocqo+rAqt1q+msXKzQrUStuK4trqGvFq+LsACwdbDqsWCx1rJLssKzOLOutCW0nLUTtYq2AbZ5tvC3aLfguFm40blKucK6O7q1uy67p7whvJu9Fb2Pvgq+hL7/v3q/9cBwwOzBZ8Hjwl/C28NYw9TEUcTOxUvFyMZGxsPHQce/yD3IvMk6ybnKOMq3yzbLtsw1zLXNNc21zjbOts83z7jQOdC60TzRvtI/0sHTRNPG1EnUy9VO1dHWVdbY11zX4Nhk2OjZbNnx2nba+9uA3AXcit0Q3ZbeHN6i3ynfr+A24L3hROHM4lPi2+Nj4+vkc+T85YTmDeaW5x/nqegy6LzpRunQ6lvq5etw6/vshu0R7ZzuKO6070DvzPBY8OXxcvH/8ozzGfOn9DT0wvVQ9d72bfb794r4Gfio+Tj5x/pX+uf7d/wH/Jj9Kf26/kv+3P9t////7gAmQWRvYmUAZMAAAAABAwAVBAMGCg0AABA+AAAQ+gAAEscAABVC/9sAhAAGBAQEBQQGBQUGCQYFBgkLCAYGCAsMCgoLCgoMEAwMDAwMDBAMDg8QDw4MExMUFBMTHBsbGxwfHx8fHx8fHx8fAQcHBw0MDRgQEBgaFREVGh8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx//wgARCAEAACADAREAAhEBAxEB/8QAtwAAAwADAQEAAAAAAAAAAAAABAUGAQIDBwABAAMBAQAAAAAAAAAAAAAAAAABAgMEEAACAQQBAgUCBwAAAAAAAAAAAQMQMQIEBRE0IBIyIyQTM0BwIRQVJTURAAECBAUFAAMBAAAAAAAAAAEAAhAgEQMhMYGxckFRYXESoTJSIxIBAAAAAAAAAAAAAAAAAAAAcBMBAAICAQMDBAMBAAAAAAAAAQARITEQIEFxUWGBkaGxwTBA8GD/2gAMAwEAAhEDEQAAAZLA9VzZdLyihYz0/A7B5TsuDLvmCBef7vkyr5pZDidjhbqeWWo4rYG0dTyy1HF7AmjqeWW44nYD0dVyy2bitgLR1PLLYcXsBauq5ZbDitgLV1PJLccVuB6Oj5JcS47qYllHypxBG9TE0KPkTmCM62LZR8icwRnWxdCi5ExlSnVQ1lDypjClOqh7b7mlhBL9T4W3nNJ8k10vhTc88sJJvofKm2wk+Sd6Hzba4I5Kf3rShngjJSLorVjHFGSkm9asPxRqEmz1Ydki0J9XhheaLQq1eAIhEoX6PAdpRKAbeA6yFJAW/g6IKSBp/BkMhqH/2gAIAQEAAQUC42TLDPQnTNzbjiOS3JszSy6ZcbsZ4nKz+XLbfV676PjZfe5vL5U5Cce/kc1+m7OQGh3HOd/OQGj3HN9/sEBo9xznf7BAaPcc53+wQml0+vzfT+QnITRfyOcf9hOQmi/f5z/QnITW9fL95ORX1vXy/eTkV9b1cv3k5HfW9XL9P3k5HfXvvrNTzmF9e+/51POYX1zdWCmmvjeBm7lG5pbq8DN2TzzSXV4TdyeUud0Qm439bO5Cbf3crkJtPrJlchNt4uV3IjafWR0jNp5OSmBsdfPTEnXTOmJs/cpibD9yrfWn/9oACAECAAEFAmIbEM6jEOjuh0d0Ojuh0d8R0d8R0d0OjEOjEOqGMQhjEIYxCGMQhjohjoqOio6KjoqOio/A/A/A/A/A/wAP/9oACAEDAAEFAvyA/9oACAECAgY/AgD/2gAIAQMCBj8CAP/aAAgBAQEGPwKrc0ARWueCLQz2aJ1v6/zPRBNaDgc1cH1pG2PITwI2uQVyNrkFcja5BXNI2uQT9I2uQ3VzSNqv9DdXKRtchurkbXIbq5pFnTEYp2NcBjpFnsJ/obRb7CfptFvsJ9PG0Wp4efp3eLU8PNXdTEJwYfpveITjbwZ0iE51KeJHE/iR1RQ9pHYU8SOOfuR3z+vSR2Hz4kcXZyGuchEhkM3/2gAIAQEDAT8hJvSxCV+8o5hBN0lD7Q9MjYLxrPAGKJykUyjWAXfrLWVMyrTIyBuzcm0LNHzCCCu/1hyzYiC/X7ojAVgv6cdo6f8A3cd+L8OGxHX+/MX09PHBZIBN0zAKu4n6RbjyT2tnjevS/NR7jySpavtxZhrX4j3NiUP6TJbfDxUe5sRuBt8TMtlvgPfF/pesIEI+hDy8H+Z6w0YBjA8Ju8Vc+v2QitRWHwm7wXat2VKCJVrxN3ivgw2VAUsdHiLPCi74LLZU5KpN9vWPhFd9WXCl0Uqu3NUW9Gd5uvs5halJFtezXFtFqNUsFjJrhNzslstvyrHOtQxlD321yLUe9zp45nqGsq9fbE24dVMJDq68R3wosheFvxHn8Qfjo/g/jlZhNHt+OhFbx//aAAgBAgMBPyGXwHiUZty9+g+/Qffovv0T36J79F95tz95tzu47/qZERDohxeBxeBweB0B0BDkQ5EOR0DoHLDlhyw5YdX/2gAIAQMDAT8h/pPQ9D0PQ9D0PQ9D0PQ/8N//2gAMAwEAAhEDEQAAEGOAUTOFZw9wcB1s4dc4Y64XwGGrFPuqDOH9N4YdY0bcrhvBKBpo5o1I2ISIvIDIJP/aAAgBAQMBPxCrDLtDh8wgIBvYD1TBEPBkAFVeEs7WDEFdgEzL1gdyzA39YvXGIFrAt4xFXvLHVAW8Aj5ihFBbXq3LrPGQNGNG2xKyvC90XfIJiK5Ib1iSSmV3e4h3NcBRQMhl1hUFaDJVeyd0ckWIJmdax29GiP2e8e+C1KG/RP38Axk4U1crMe1IhksZ/YsmbgAJUDu14YhUnULZV0MzNDhQDVm9dkWchLLvTUzQpekkF7GfiLFtS1pM0PDzKJNAg3rTcJQGUAaenEOh5lU0Ebh04YgEKZyyDg8fMsAWrg7lIALj1uDi/vlAdO96NlRuVA61xrOO0UnUpk7SXo2VBQrBUONfaZvmKhGm7e0UXmJj2mWxcWLzFRgUNmh7XmWoQ7EwvHmK35joy1VdDXhnal+Oido7+c1RwfcSU3yvm4kxcdzpja7sqb1CGijpjtTRH55MfMQCmS79h3iyhsm56Jkj8wKKlhsizhuGN9WX4uMMUOwVT9xWuDGxeTHrmNXdKKnBipt4dI2IkP0UirNKr4m7iqB18gxeE2eHCOVAycuQx3wsz7b8fIGUY1ZX4+RqPUtf1x//2gAIAQIDAT8QNkoarEEaCBvgmCUX5j4OkWXmKKOkeXmPg6TZ55+ybPPL2TZ55XSbPPMxv88zG/z0Q7fnm35dZvy69F1m/LpN4OOkOYM8dYcwZmk0hzBmazSHMGZpGHMGZpGbzaax47zTnvNODDmGuDDmHAgh/PQHV//aAAgBAwMBPxA5Xm+biwjw7hHjaEeNoR42hHjaEeNoR42hHjaEeNoRjNoRjNoRjNoRjwRjwcPBw8HDwcPBw8HD0PQ9D0PQ9D/P/9k=",
];


/***/ }),

/***/ "./effect/fire/Fire.js":
/*!*****************************!*\
  !*** ./effect/fire/Fire.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "createFireMesh": function() { return /* binding */ createFireMesh; }
/* harmony export */ });
/* harmony import */ var _FireShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FireShader.js */ "./effect/fire/FireShader.js");
/* harmony import */ var _FireShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_FireShader_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * @author mattatz / http://github.com/mattatz
 *
 * Ray tracing based real-time procedural volumetric fire object for three.js
 */


function cloneUniforms( src ) {

    const dst = {};

    for ( const u in src ) {

        dst[ u ] = {};

        for ( const p in src[ u ] ) {

            const property = src[ u ][ p ];

            if (property && ( property.isColor ||
                property.isMatrix3 || property.isMatrix4 ||
                property.isVector2 || property.isVector3 || property.isVector4 ||
                property.isTexture || property.isQuaternion ) ) {

                dst[ u ][ p ] = property.clone();

            }
            else if (property && property.clone) {
                dst[ u ][ p ] = property.clone();
            }
            else if ( Array.isArray( property ) ) {

                dst[ u ][ p ] = property.slice();

            } else {

                dst[ u ][ p ] = property;

            }

        }

    }

    return dst;

}

function createFireMesh(fireTex, color){


    // let fireMaterial = new JMT.BaseMaterial(
    //     {id: '_FIRE_VERT_', code: THREE.FireShader.vertexShader},
    //     {id: '_FIRE_FRAG_', code: THREE.FireShader.fragmentShader}
    // )

    let fireMaterial = new THREE.ShaderMaterial( {
        vertexShader: THREE.FireShader.vertexShader,
        fragmentShader: THREE.FireShader.fragmentShader
    })

    //Object.assign(fireMaterial.uniforms, THREE.FireShader.uniforms)
    fireMaterial.uniforms = cloneUniforms(THREE.FireShader.uniforms)
    fireMaterial.uniforms.fireTex.value = fireTex;
    fireMaterial.uniforms.color.value = color || new THREE.Color(0xeeeeee);
    fireMaterial.uniforms.invModelMatrix.value = new THREE.Matrix4();
    fireMaterial.uniforms.scale.value = new THREE.Vector3(1, 1, 10);
    fireMaterial.uniforms.seed.value = Math.random() * 19.19;


    fireMaterial.mk = !0    // 为了透明
    //fireMaterial.addDefine('ITERATIONS 20')
    //fireMaterial.addDefine('OCTIVES 5')
    fireMaterial.defines['ITERATIONS 20']=''
    fireMaterial.defines['OCTIVES 5']=''
    fireMaterial.transparent = true
    fireMaterial.depthWrite = false


    let geometry = new THREE.BoxBufferGeometry(1.0, 1.0, 1.0)
    geometry.computeBoundingSphere()

    let fire = new THREE.Mesh(geometry, fireMaterial)

    fire.rotateX(THREE.Math.degToRad(90))

    fire.update = function(mesh){

        return function (time) {

            var invModelMatrix = mesh.material.uniforms.invModelMatrix.value;

            mesh.updateMatrixWorld();
            //invModelMatrix.getInverse(mesh.matrixWorld);
            invModelMatrix.copy(mesh.matrixWorld).invert();

            if (time !== undefined) {
                mesh.material.uniforms.time.value = time;
            }

            mesh.material.uniforms.invModelMatrix.value = invModelMatrix;

            mesh.material.uniforms.scale.value = mesh.scale;

        }
    }(fire);

    fire.updatePosition = function (mesh) {

        return function(position){
            if (!THREE.ShaderMaterial) {
                mesh.position.fromArray([
                    position[0],
                    position[1],
                    position[2] + mesh.geometry.boundingSphere.radius / 2
                ])
            }
            else {
                mesh.position.fromArray([
                    position[0],
                    position[1] + mesh.geometry.boundingSphere.radius / 2,
                    position[2]
                ])
            }
        }
    }(fire)

    return fire
}
//
//THREE.Fire = function (fireTex, color) {
//
//    var fireMaterial = null
//
//    //if (THREE.ShaderMaterial) {
//    //    fireMaterial = new THREE.ShaderMaterial({
//    //        defines: THREE.FireShader.defines,
//    //        //uniforms: THREE.UniformsUtils.clone(THREE.FireShader.uniforms),
//    //        vertexShader: THREE.FireShader.vertexShader,
//    //        fragmentShader: THREE.FireShader.fragmentShader,
//    //        transparent: true,
//    //        depthWrite: !0,
//    //        depthTest: !0
//    //    });
//    //
//    //
//    //    fireTex.format = THREE.RGBAFormat
//    // initialize uniforms
//    //fireTex.magFilter = fireTex.minFilter = THREE.LinearFilter
//    //fireTex.wrapS = fireTex.wrapT = THREE.ClampToEdgeWrapping
//
//    //
//    //    Object.assign(fireMaterial.uniforms, THREE.FireShader.uniforms)
//    //}
//    //else {
//    fireMaterial = new JMT.BaseMaterial(
//        {id: '_FIRE_VERT_', code: THREE.FireShader.vertexShader},
//        {id: '_FIRE_FRAG_', code: THREE.FireShader.fragmentShader}
//    )
//    Object.assign(fireMaterial.uniforms, THREE.FireShader.uniforms)
//    //fireMaterial.transparent = !0
//    //fireMaterial.opacity = 0.1
//    //fireMaterial.depthWrite = !0
//    //fireMaterial.depthTest = !0
//    //fireMaterial.blending = 2 //THREE.NormalBlending
//    fireMaterial.mk = !0
//    fireMaterial.addDefine('ITERATIONS 20')
//    fireMaterial.addDefine('OCTIVES 3')
//    //}
//
//    fireMaterial.uniforms.fireTex.value = fireTex;
//    fireMaterial.uniforms.color.value = color || new THREE.Color(0xeeeeee);
//    fireMaterial.uniforms.invModelMatrix.value = new THREE.Matrix4();
//    fireMaterial.uniforms.scale.value = new THREE.Vector3(1, 1, 10);
//    fireMaterial.uniforms.seed.value = Math.random() * 19.19;
//
//    let geometry = new THREE.BoxBufferGeometry(1.0, 1.0, 1.0)
//    geometry.computeBoundingSphere()
//    //console.log(geometry.attributes.uv.array);
//
//    THREE.Mesh.call(this, geometry, fireMaterial);
//};
//
//THREE.Fire.prototype = Object.create(THREE.Mesh.prototype);
//THREE.Fire.prototype.constructor = THREE.Fire;
//
//THREE.Fire.prototype.update = function (time) {
//
//    var invModelMatrix = this.material.uniforms.invModelMatrix.value;
//
//    this.updateMatrixWorld();
//    invModelMatrix.getInverse(this.matrixWorld);
//
//    if (time !== undefined) {
//        this.material.uniforms.time.value = time;
//    }
//
//    this.material.uniforms.invModelMatrix.value = invModelMatrix;
//
//    this.material.uniforms.scale.value = this.scale;
//
//};


//THREE.Fire.prototype.updatePosition = function (position) {
//
//
//    if (!THREE.ShaderMaterial) {
//        this.position.fromArray([
//            position[0],
//            position[1],
//            position[2] + this.geometry.boundingSphere.radius / 2
//        ])
//    }
//    else {
//        this.position.fromArray([
//            position[0],
//            position[1] + this.geometry.boundingSphere.radius / 2,
//            position[2]
//        ])
//    }
//
//};



/***/ }),

/***/ "./effect/fire/FireShader.js":
/*!***********************************!*\
  !*** ./effect/fire/FireShader.js ***!
  \***********************************/
/***/ (function() {

/**
 * @author mattatz / http://mattatz.github.io
 *
 * Ray tracing based real-time procedural volumetric fire shader.
 *
 * Based on
 * Alfred et al. Real-Time procedural volumetric fire / http://dl.acm.org/citation.cfm?id=1230131
 * and
 * webgl-noise / https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl
 * and
 * primitive: blog | object space raymarching / https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl
 */

THREE.FireShader = {

    defines: {
        "ITERATIONS": "20",
        "OCTIVES": "3"
    },

    uniforms: {
        "fireTex": {type: "t", value: null},
        "color": {type: "c", value: null},
        "time": {type: "f", value: 0.0},
        "seed": {type: "f", value: 0.0},
        "invModelMatrix": {type: "m4", value: null},
        "scale": {type: "v3", value: null},

        "noiseScale": {type: "v4", value: new THREE.Vector4(1, 2, 1, 0.3)},
        "magnitude": {type: "f", value: 1.3},
        "lacunarity": {type: "f", value: 2.0},
        "gain": {type: "f", value: 0.5}
    },

    vertexShader: [
        "varying vec3 vWorldPos;",
        "void main() {",
        "gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);",
        "vWorldPos = (modelMatrix * vec4(position, 1.0)).xyz;",
        "}"
    ].join("\n"),

    fragmentShader: [
        "uniform vec3 color;",
        "uniform float time;",
        "uniform float seed;",
        "uniform mat4 invModelMatrix;",
        "uniform vec3 scale;",

        "uniform vec4 noiseScale;",
        "uniform float magnitude;",
        "uniform float lacunarity;",
        "uniform float gain;",

        "uniform sampler2D fireTex;",

        "varying vec3 vWorldPos;",

        // GLSL simplex noise function by ashima / https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl
        // -------- simplex noise
        "vec3 mod289(vec3 x) {",
        "return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",

        "vec4 mod289(vec4 x) {",
        "return x - floor(x * (1.0 / 289.0)) * 289.0;",
        "}",

        "vec4 permute(vec4 x) {",
        "return mod289(((x * 34.0) + 1.0) * x);",
        "}",

        "vec4 taylorInvSqrt(vec4 r) {",
        "return 1.79284291400159 - 0.85373472095314 * r;",
        "}",

        "float snoise(vec3 v) {",
        "const vec2 C = vec2(1.0 / 6.0, 1.0 / 3.0);",
        "const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);",

        // First corner
        "vec3 i  = floor(v + dot(v, C.yyy));",
        "vec3 x0 = v - i + dot(i, C.xxx);",

        // Other corners
        "vec3 g = step(x0.yzx, x0.xyz);",
        "vec3 l = 1.0 - g;",
        "vec3 i1 = min(g.xyz, l.zxy);",
        "vec3 i2 = max(g.xyz, l.zxy);",

        //   x0 = x0 - 0.0 + 0.0 * C.xxx;
        //   x1 = x0 - i1  + 1.0 * C.xxx;
        //   x2 = x0 - i2  + 2.0 * C.xxx;
        //   x3 = x0 - 1.0 + 3.0 * C.xxx;
        "vec3 x1 = x0 - i1 + C.xxx;",
        "vec3 x2 = x0 - i2 + C.yyy;", // 2.0*C.x = 1/3 = C.y
        "vec3 x3 = x0 - D.yyy;",      // -1.0+3.0*C.x = -0.5 = -D.y

        // Permutations
        "i = mod289(i); ",
        "vec4 p = permute(permute(permute( ",
        "i.z + vec4(0.0, i1.z, i2.z, 1.0))",
        "+ i.y + vec4(0.0, i1.y, i2.y, 1.0)) ",
        "+ i.x + vec4(0.0, i1.x, i2.x, 1.0));",

        // Gradients: 7x7 points over a square, mapped onto an octahedron.
        // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
        "float n_ = 0.142857142857;", // 1.0/7.0
        "vec3  ns = n_ * D.wyz - D.xzx;",

        "vec4 j = p - 49.0 * floor(p * ns.z * ns.z);", //  mod(p,7*7)

        "vec4 x_ = floor(j * ns.z);",
        "vec4 y_ = floor(j - 7.0 * x_);", // mod(j,N)

        "vec4 x = x_ * ns.x + ns.yyyy;",
        "vec4 y = y_ * ns.x + ns.yyyy;",
        "vec4 h = 1.0 - abs(x) - abs(y);",

        "vec4 b0 = vec4(x.xy, y.xy);",
        "vec4 b1 = vec4(x.zw, y.zw);",

        //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
        //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
        "vec4 s0 = floor(b0) * 2.0 + 1.0;",
        "vec4 s1 = floor(b1) * 2.0 + 1.0;",
        "vec4 sh = -step(h, vec4(0.0));",

        "vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;",
        "vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;",

        "vec3 p0 = vec3(a0.xy, h.x);",
        "vec3 p1 = vec3(a0.zw, h.y);",
        "vec3 p2 = vec3(a1.xy, h.z);",
        "vec3 p3 = vec3(a1.zw, h.w);",

        //Normalise gradients
        "vec4 norm = taylorInvSqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));",
        "p0 *= norm.x;",
        "p1 *= norm.y;",
        "p2 *= norm.z;",
        "p3 *= norm.w;",

        // Mix final noise value
        "vec4 m = max(0.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.0);",
        "m = m * m;",
        "return 42.0 * dot(m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));",
        "}",
        // simplex noise --------

        "float turbulence(vec3 p) {",
        "float sum = 0.0;",
        "float freq = 1.0;",
        "float amp = 1.0;",

        "for(int i = 0; i < OCTIVES; i++) {",
        "sum += abs(snoise(p * freq)) * amp;",
        "freq *= lacunarity;",
        "amp *= gain;",
        "}",

        "return sum;",
        "}",

        "vec4 samplerFire (vec3 p, vec4 scale) {",
        "vec2 st = vec2(sqrt(dot(p.xz, p.xz)), p.y);",

        "if(st.x <= 0.0 || st.x >= 1.0 || st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);",

        "p.y -= (seed + time) * scale.w;",
        "p *= scale.xyz;",

        "st.y += sqrt(st.y) * magnitude * turbulence(p);",

        "if(st.y <= 0.0 || st.y >= 1.0) return vec4(0.0);",

        "return texture2D(fireTex, st);",
        "}",

        "vec3 localize(vec3 p) {",
        "return (invModelMatrix * vec4(p, 1.0)).xyz;",
        "}",

        "void main() { ",

        //"gl_FragColor = vec4(1.,1.,0.,1.);",

        "vec3 rayPos = vWorldPos;",
        "vec3 rayDir = normalize(rayPos - cameraPosition);",
        "float rayLen = 0.0288 * length(scale.xyz);",

        "vec4 col = vec4(0.0);",

        "for(int i = 0; i < ITERATIONS; i++) {",
        "rayPos += rayDir * rayLen;",

        "vec3 lp = localize(rayPos);",

        "lp.y += 0.5;",
        "lp.xz *= 2.0;",
        "col += samplerFire(lp, noiseScale);",
        "}",

        "col.a = col.r;",

        "gl_FragColor = col;",
        "}",

    ].join("\n")

};


/***/ }),

/***/ "./extensions/Extensions.js":
/*!**********************************!*\
  !*** ./extensions/Extensions.js ***!
  \**********************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function ondefault() {
}


var c = {
    "\uf2b9": "address-book",
    "\uf2bb": "address-card",
    "\uf1fe": "area-chart",
    "\uf047": "arrows",
    "\uf062": "arrow-up",
    "\uf063": "arrow-down",
    "\uf2a2": "assistive-listening-systems",
    "\uf069": "asterisk",
    "\uf29e": "audio-description",
    "\uf1fa": "at",
    "\uf0c9": "bars",
    "\uf0f3": "bell",
    "\uf02d": "book",
    "\uf02e": "bookmark",
    "\uf0a1": "bullhorn",
    "\uf1ec": "calculator",
    "\uf030": "camera",
    "\uf080": "chart-bar",
    "\uf200": "chart-pie",
    "\uf0c2": "cloud",
    "\uf013": "cog",
    "\uf075": "comment",
    "\uf14e": "compass",
    "\uf09d": "credit-card",
    "\uf05b": "crosshairs",
    "\uf019": "download",
    "\uf0e0": "envelope",
    "\uf08e": "external-link",
    "\uf06e": "eye",
    "\uf1fb": "eye-dropper",
    "\uf008": "film",
    "\uf024": "flag",
    "\uf07b": "folder",
    "\uf06b": "gift",
    "\uf025": "headphones",
    "\uf015": "home",
    "\uf03e": "image",
    "\uf090": "sign-in",
    "\uf129": "info",
    "\uf0eb": "lightbulb",
    "\uf0d0": "magic",
    "\uf076": "magnet",
    "\uf041": "map-marker",
    "\uf276": "map-pin",
    "\uf277": "map-signs",
    "\uf1fc": "paint-brush",
    "\uf040": "pencil",
    "\uf095": "phone",
    "\uf128": "question",
    "\uf064": "share",
    "\uf1e0": "share-alt",
    "\uf07a": "shopping-cart",
    "\uf1de": "sliders",
    "\uf005": "star",
    "\uf0e4": "tachometer",
    "\uf02b": "tag",
    "\uf03d": "video",
    "\uf0ad": "wrench",
    "\uf04b": "play",
    "\uf16a": "youtube",
    "\uf27d": "vimeo",
    "\uf09a": "facebook",
    "\uf099": "twitter",
    "\uf16d": "instagram"
};

class Extensions {
    constructor(config) {
        var g = this;
        this.triggers = [];
        this.f = [];
        this.definition = this.constructor.definition;
        this.viewerApi = JMT.getViewer ? JMT.getViewer() : deQ;
        this.running = !1;
        this.h = [];
        this.config = JMT.readOnlyCopy(function (a) {
            a = JMT.cloneObject(a);
            if (void 0 !== a.anchor && void 0 === a.trigger && !d("anchor") && d("trigger")) {
                var b = a.anchor;
                b.icon && b.icon.font && (b.icon = c[b.icon.value]);
                a.trigger = b;
                a.anchor = void 0
            }
            b = $jscomp.makeIterator(g.definition.properties);
            for (var e = b.next(); !e.done; e = b.next()){
                e = e.value
                if(void 0 === a[e.id] && void 0 !== e.defaultValue){
                    a[e.id] = e.defaultValue
                }
            }
            return a
        }(config));

        Object.defineProperty(this, "name", {
            get: function () {
                return this.config.name
            }
        });

        this.doStop = this.doStart = ondefault;

        this.viewerApi.onVrChange && this.viewerApi.onVrChange(this._vrChanged.bind(this))
    }


    cloneConfig() {
        return JMT.cloneObject(this.config)
    }


    updateConfig(a) {
        this.stop();
        this.config = JMT.readOnlyCopy(a);
        this.start()
    }


    start() {
        this.running || (this.doStart(), this.running = !0)
    }


    stop() {
        if (this.running) {
            this.doStop();
            var a = $jscomp.makeIterator(this.f)
            for (var b = a.next(); !b.done; b = a.next()){
                this.viewerApi.removeAnchor(b.value);
            }
            a = $jscomp.makeIterator(this.h);
            for (b = a.next(); !b.done; b = a.next()){
                b = b.value
                this.viewerApi.removeOnNodeTypeClicked(b[0], b[1]);
            }
            this.h.length = 0;
            this.triggers.length = 0;
            this.f.length = 0;
            this.running = !1
        }
    }


    _vrChanged(a) {
        if(a && !this.definition.vrCompatible){
            this.stop()
        }
        else {
            a || this.definition.vrCompatible || this.start()
        }
    }


    addTrigger(a, b) {
        function c(a, c, d) {
            b(a, c, d);
            return !0
        }

        if("node" === a.type){
            a = a.nodeType
            this.h.push([a, c])
            this.viewerApi.onNodeTypeClicked(a, c)
            this.triggers.push.apply(this.triggers, $jscomp.arrayFromIterable(this.viewerApi.findNodesOfType(a)))
        }
        else {
            a = this.viewerApi.addAnchor(a, b)
            a.extension = this
            this.f.push(a)
            this.triggers.push(a)
        }
    }

    d(a) {
        return this.g.definition.properties.some(function (b) {
            return b.id === a
        })
    }
}


JMT.Extensions = Extensions


/***/ }),

/***/ "./extensions/ExtensionsManager.js":
/*!*****************************************!*\
  !*** ./extensions/ExtensionsManager.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Extensions.js */ "./extensions/Extensions.js");
/* harmony import */ var _Extensions_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Extensions_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */




//JMT.Extensions = JMT.Extensions || {}
class ExtensionsManager {
    constructor() {
        this.extensionTypes = JMT.Extensions

        this.updateConfig(UjP.extensions || []);
    }


    updateConfig(a) {
        this.extensions = [];
        a = $jscomp.makeIterator(a);
        for (var b = a.next(); !b.done; b = a.next()) {
            this._createExtensionFromConfig(b.value)
        }
    }


    _createExtensionFromConfig(a) {
        function b(b, c) {
            return b.some(function (b) {
                return b.name === c && b.config.type === a.type
            })
        }

        a.name = a.name.toString();
        for (var c = a.name, d = 2; b(this.extensions, a.name);) {
            a.name = c + d.toString()
            d += 1;
        }
        c = new this.extensionTypes[a.type](a);
        this.extensions.push(c);
        return c
    }


    startExtensions() {
        var a = this;
        this._loadFontAwesomeIfNeeded(function () {
            for (var b = 0; b < a.extensions.length; b += 1)a.extensions[b].start()
        })
    }

    _loadFontAwesomeIfNeeded(a) {
        var b = this, c = this.extensions.map(function (a) {
            return b._getFonts(a.config)
        }).concat(JMT.FONT_FAMILIES_TO_LOAD).reduce(function (a, b) {
            return a.concat(b)
        }, []).filter(function (a, b, c) {
            return b === c.indexOf(a)
        });
        0 < c.length && !JMT.EDIT_MODE ?
            JMT.loadFontFamilies(c, a) : a()
    }


    _getFonts(a) {
        return this.extensionTypes[a.type].definition.properties.map(function (b) {
            return "trigger" === b.type && a[b.id] && a[b.id].icon && JMT.ICONS[a[b.id].icon].fontFamily
        }).filter(function (a) {
            return a
        })
    }


    stopExtensions() {
        for (var a = 0; a < this.extensions.length; a += 1)this.extensions[a].stop()
    }


    getEditableExtensionDefinitions() {
        for (var a = [], b = $jscomp.makeIterator(Object.entries(this.extensionTypes || {})), c = b.next(); !c.done; c = b.next()) {
            var d = $jscomp.makeIterator(c.value);
            c = d.next().value;
            d = d.next().value;
            d.definition.hideFromEditor || a.push({type: c, definition: d.definition})
        }
        return a
    }


    getEditableExtensions() {
        for (var a = [], b = $jscomp.makeIterator(this.extensions), c = b.next(); !c.done; c = b.next())c = c.value, c.definition.hideFromEditor || a.push(c);
        return a
    }


    addExtension(a) {
        a = this._createExtensionFromConfig(a);
        a.start();
        return a
    }


    removeExtension(a) {
        a.stop();
        for (var b = 0; b < this.extensions.length; b += 1) {
            if (this.extensions[b] === a) {
                this.extensions.splice(b, 1);
                break
            }
        }
    }


    getConfig() {
        return this.extensions.map(function (a) {
            return a.config
        })
    }
}


JMT.ExtensionsManager = ExtensionsManager

/***/ }),

/***/ "./loaders/GLTFLoader.js":
/*!*******************************!*\
  !*** ./loaders/GLTFLoader.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_animation_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/animation/index.js */ "./src/animation/index.js");
/* harmony import */ var _src_objects_bone_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/objects/bone/index.js */ "./src/objects/bone/index.js");
/* harmony import */ var _src_math_Math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../src/math/Math.js */ "./src/math/Math.js");
// Characters [].:/ are reserved for track binding syntax.





var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');
function sanitizeNodeName(name) {

    return name.replace(/\s/g, '_').replace(_reservedRe, '');

}

/**
 * Replaces spaces with underscores and removes unsupported characters from
 * node names, to ensure compatibility with parseTrackName().
 *
 * @param {string} name Node name to be sanitized.
 * @return {string}
 */

if (!THREE.Loader) {

    _src_animation_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].inject(THREE)
    _src_objects_bone_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].inject(THREE)

    THREE.MathUtils = _src_math_Math_js__WEBPACK_IMPORTED_MODULE_2__.JMTMath


    THREE.Matrix4.prototype.fromArrayEx = function (array, offset) {

        if (offset === undefined) offset = 0;

        for (let i = 0; i < 16; i++) {

            this.elements[i] = array[i + offset];

        }

        return this;

    }


    THREE.Matrix4.prototype.toArrayEx = function (array, offset) {

        if (array === undefined) array = [];
        if (offset === undefined) offset = 0;

        const te = this.elements;

        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];

        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];

        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];

        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];

        return array;

    }

    THREE.FileLoader = function (manager) {

        this.load = function (url, onLoad, onProgress, onError) {
            let priorty = JMT.LOAD_PRIORITY.CORE_RESOURCE

            JMT.queueAjaxGet(priorty, url, true, e=> {
                onLoad(e);
            })
        }

        this.setPath = _=> {
        }
        this.setResponseType = _=> {
        }
        this.setRequestHeader = _=> {
        }
    }

    var Loader = function (manager) {
        this.manager = {
            itemStart: _=> {
            },
            itemError: _=> {
            },
            itemEnd: _=> {
            }
        }
        this.setCrossOrigin = _=> {
        }

    }

    THREE.Loader = Loader

    THREE.CanvasTexture = JMT.CanvasTexture


    THREE.LoaderUtils = {

        decodeText: function (array) {

            if (typeof TextDecoder !== 'undefined') {

                return new TextDecoder().decode(array);

            }

            // Avoid the String.fromCharCode.apply(null, array) shortcut, which
            // throws a "maximum call stack size exceeded" error for large arrays.

            var s = '';

            for (var i = 0, il = array.length; i < il; i++) {

                // Implicitly assumes little-endian.
                s += String.fromCharCode(array[i]);

            }

            try {

                // merges multi-byte utf-8 characters.

                return decodeURIComponent(escape(s));

            } catch (e) { // see #16358

                return s;

            }

        },

        extractUrlBase: function (url) {

            var index = url.lastIndexOf('/');

            if (index === -1) {
                return './';
            }

            return url.substr(0, index + 1);

        }

    };

    function ImageBitmapLoader(manager) {

        if (typeof createImageBitmap === 'undefined') {

            console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');

        }

        if (typeof fetch === 'undefined') {

            console.warn('THREE.ImageBitmapLoader: fetch() not supported.');

        }

        Loader.call(this, manager);

        this.options = {premultiplyAlpha: 'none'};

    }

    ImageBitmapLoader.prototype = Object.assign(Object.create(Loader.prototype), {

        constructor: ImageBitmapLoader,

        isImageBitmapLoader: true,

        setOptions: function setOptions(options) {

            this.options = options;

            return this;

        },

        load: function (url, onLoad, onProgress, onError) {

            if (url === undefined) {
                url = '';
            }

            if (this.path !== undefined) {
                url = this.path + url;
            }

            //url = this.manager.resolveURL( url );

            var scope = this;

            var cached = undefined //Cache.get( url );

            if (cached !== undefined) {

                scope.manager.itemStart(url);

                setTimeout(function () {

                    if (onLoad) {
                        onLoad(cached);
                    }

                    scope.manager.itemEnd(url);

                }, 0);

                return cached;

            }

            fetch(url).then(function (res) {

                return res.blob();

            }).then(function (blob) {

                return createImageBitmap(blob, scope.options);

            }).then(function (imageBitmap) {

                //Cache.add( url, imageBitmap );

                if (onLoad) {
                    onLoad(imageBitmap);
                }

                scope.manager.itemEnd(url);

            }).catch(function (e) {

                if (onError) {
                    onError(e);
                }

                scope.manager.itemError(url);
                scope.manager.itemEnd(url);

            });

            scope.manager.itemStart(url);

        }

    });

    THREE.ImageBitmapLoader = ImageBitmapLoader

    THREE.Group = THREE.Object3D
}

if (!THREE.MeshStandardMaterial) {
    THREE.MeshStandardMaterial = JMT.StandardMaterial


    /**
     * Abstract base class of interpolants over parametric samples.
     *
     * The parameter domain is one dimensional, typically the time or a path
     * along a curve defined by the data.
     *
     * The sample values can have any dimensionality and derived classes may
     * apply special interpretations to the data.
     *
     * This class provides the interval seek in a Template Method, deferring
     * the actual interpolation to derived classes.
     *
     * Time complexity is O(1) for linear access crossing at most two points
     * and O(log N) for random access, where N is the number of positions.
     *
     * References:
     *
     *        http://www.oodesign.com/template-method-pattern.html
     *
     */

    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        this.parameterPositions = parameterPositions;
        this._cachedIndex = 0;

        this.resultBuffer = resultBuffer !== undefined ?
            resultBuffer : new sampleValues.constructor(sampleSize);
        this.sampleValues = sampleValues;
        this.valueSize = sampleSize;

    }

    Object.assign(Interpolant.prototype, {

        evaluate: function (t) {

            var pp = this.parameterPositions;
            var i1 = this._cachedIndex,
                t1 = pp[i1],
                t0 = pp[i1 - 1];

            validate_interval: {

                seek: {

                    var right;

                    linear_scan: {

                        //- See http://jsperf.com/comparison-to-undefined/3
                        //- slower code:
                        //-
                        //- 				if ( t >= t1 || t1 === undefined ) {
                        forward_scan: if (!( t < t1 )) {

                            for (var giveUpAt = i1 + 2; ;) {

                                if (t1 === undefined) {

                                    if (t < t0) {
                                        break forward_scan;
                                    }

                                    // after end

                                    i1 = pp.length;
                                    this._cachedIndex = i1;
                                    return this.afterEnd_(i1 - 1, t, t0);

                                }

                                if (i1 === giveUpAt) {
                                    break;
                                } // this loop

                                t0 = t1;
                                t1 = pp[++i1];

                                if (t < t1) {

                                    // we have arrived at the sought interval
                                    break seek;

                                }

                            }

                            // prepare binary search on the right side of the index
                            right = pp.length;
                            break linear_scan;

                        }

                        //- slower code:
                        //-					if ( t < t0 || t0 === undefined ) {
                        if (!( t >= t0 )) {

                            // looping?

                            var t1global = pp[1];

                            if (t < t1global) {

                                i1 = 2; // + 1, using the scan for the details
                                t0 = t1global;

                            }

                            // linear reverse scan

                            for (var giveUpAt$1 = i1 - 2; ;) {

                                if (t0 === undefined) {

                                    // before start

                                    this._cachedIndex = 0;
                                    return this.beforeStart_(0, t, t1);

                                }

                                if (i1 === giveUpAt$1) {
                                    break;
                                } // this loop

                                t1 = t0;
                                t0 = pp[--i1 - 1];

                                if (t >= t0) {

                                    // we have arrived at the sought interval
                                    break seek;

                                }

                            }

                            // prepare binary search on the left side of the index
                            right = i1;
                            i1 = 0;
                            break linear_scan;

                        }

                        // the interval is valid

                        break validate_interval;

                    } // linear scan

                    // binary search

                    while (i1 < right) {

                        var mid = ( i1 + right ) >>> 1;

                        if (t < pp[mid]) {

                            right = mid;

                        } else {

                            i1 = mid + 1;

                        }

                    }

                    t1 = pp[i1];
                    t0 = pp[i1 - 1];

                    // check boundary cases, again

                    if (t0 === undefined) {

                        this._cachedIndex = 0;
                        return this.beforeStart_(0, t, t1);

                    }

                    if (t1 === undefined) {

                        i1 = pp.length;
                        this._cachedIndex = i1;
                        return this.afterEnd_(i1 - 1, t0, t);

                    }

                } // seek

                this._cachedIndex = i1;

                this.intervalChanged_(i1, t0, t1);

            } // validate_interval

            return this.interpolate_(i1, t0, t, t1);

        },

        settings: null, // optional, subclass-specific settings structure
        // Note: The indirection allows central control of many interpolants.

        // --- Protected interface

        DefaultSettings_: {},

        getSettings_: function () {

            return this.settings || this.DefaultSettings_;

        },

        copySampleValue_: function (index) {

            // copies a sample value to the result buffer

            var result = this.resultBuffer,
                values = this.sampleValues,
                stride = this.valueSize,
                offset = index * stride;

            for (var i = 0; i !== stride; ++i) {

                result[i] = values[offset + i];

            }

            return result;

        },

        // Template methods for derived classes:

        interpolate_: function (/* i1, t0, t, t1 */) {

            throw new Error('call to abstract method');
            // implementations shall return this.resultBuffer

        },

        intervalChanged_: function (/* i1, t0, t1 */) {

            // empty

        }

    });

    // DECLARE ALIAS AFTER assign prototype
    Object.assign(Interpolant.prototype, {

        //( 0, t, t0 ), returns this.resultBuffer
        beforeStart_: Interpolant.prototype.copySampleValue_,

        //( N-1, tN-1, t ), returns this.resultBuffer
        afterEnd_: Interpolant.prototype.copySampleValue_,

    });

    THREE.Interpolant = Interpolant
}


THREE.GLTFLoader = (function () {

    function GLTFLoader(manager) {

        THREE.Loader.call(this, manager);

        this.dracoLoader = null;
        this.ddsLoader = null;
        this.ktx2Loader = null;

        this.pluginCallbacks = [];

        this.register(function (parser) {

            return new GLTFMaterialsClearcoatExtension(parser);

        });
        this.register(function (parser) {

            return new GLTFTextureBasisUExtension(parser);

        });

        this.register(function (parser) {

            return new GLTFMaterialsTransmissionExtension(parser);

        });

    }

    GLTFLoader.prototype = Object.assign(Object.create(THREE.Loader.prototype), {

        constructor: GLTFLoader,

        load: function (url, onLoad, onProgress, onError) {

            var scope = this;

            var resourcePath;

            if (this.resourcePath !== '') {

                resourcePath = this.resourcePath;

            } else if (this.path !== '') {

                resourcePath = this.path;

            } else {

                resourcePath = THREE.LoaderUtils.extractUrlBase(url);

            }

            // Tells the LoadingManager to track an extra item, which resolves after
            // the model is fully loaded. This means the count of items loaded will
            // be incorrect, but ensures manager.onLoad() does not fire early.
            scope.manager.itemStart(url);

            var _onError = function (e) {

                if (onError) {

                    onError(e);

                } else {

                    console.error(e);

                }

                scope.manager.itemError(url);
                scope.manager.itemEnd(url);

            };

            var loader = new THREE.FileLoader(scope.manager);

            loader.setPath(this.path);
            loader.setResponseType('arraybuffer');
            loader.setRequestHeader(this.requestHeader);

            if (scope.crossOrigin === 'use-credentials') {

                loader.setWithCredentials(true);

            }

            loader.load(url, function (data) {

                try {

                    scope.parse(data, resourcePath, function (gltf) {

                        onLoad(gltf);

                        scope.manager.itemEnd(url);

                    }, _onError);

                } catch (e) {

                    _onError(e);

                }

            }, onProgress, _onError);

        },

        setDRACOLoader: function (dracoLoader) {

            this.dracoLoader = dracoLoader;
            return this;

        },

        setDDSLoader: function (ddsLoader) {

            this.ddsLoader = ddsLoader;
            return this;

        },

        setKTX2Loader: function (ktx2Loader) {

            this.ktx2Loader = ktx2Loader;
            return this;

        },

        register: function (callback) {

            if (this.pluginCallbacks.indexOf(callback) === -1) {

                this.pluginCallbacks.push(callback);

            }

            return this;

        },

        unregister: function (callback) {

            if (this.pluginCallbacks.indexOf(callback) !== -1) {

                this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);

            }

            return this;

        },

        parse: function (data, path, onLoad, onError) {

            var content;
            var extensions = {};
            var plugins = {};

            if (typeof data === 'string') {

                content = data;

            } else {

                var magic = THREE.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

                if (magic === BINARY_EXTENSION_HEADER_MAGIC) {

                    try {

                        extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);

                    } catch (error) {

                        if (onError) onError(error);
                        return;

                    }

                    content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;

                } else {

                    content = THREE.LoaderUtils.decodeText(new Uint8Array(data));

                }

            }

            var json = JSON.parse(content);

            if (json.asset === undefined || json.asset.version[0] < 2) {

                if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
                return;

            }

            var parser = new GLTFParser(json, {

                path: path || this.resourcePath || '',
                crossOrigin: this.crossOrigin,
                manager: this.manager,
                ktx2Loader: this.ktx2Loader

            });

            parser.onMaterialLoaded = this.onMaterialLoaded

            parser.fileLoader.setRequestHeader(this.requestHeader);

            for (var i = 0; i < this.pluginCallbacks.length; i++) {

                var plugin = this.pluginCallbacks[i](parser);
                plugins[plugin.name] = plugin;

                // Workaround to avoid determining as unknown extension
                // in addUnknownExtensionsToUserData().
                // Remove this workaround if we move all the existing
                // extension handlers to plugin system
                extensions[plugin.name] = true;

            }

            if (json.extensionsUsed) {

                for (var i = 0; i < json.extensionsUsed.length; ++i) {

                    var extensionName = json.extensionsUsed[i];
                    var extensionsRequired = json.extensionsRequired || [];

                    switch (extensionName) {

                        case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
                            extensions[extensionName] = new GLTFLightsExtension(json);
                            break;

                        case EXTENSIONS.KHR_MATERIALS_UNLIT:
                            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
                            break;

                        case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
                            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
                            break;

                        case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
                            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
                            break;

                        case EXTENSIONS.MSFT_TEXTURE_DDS:
                            extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
                            break;

                        case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
                            extensions[extensionName] = new GLTFTextureTransformExtension();
                            break;

                        case EXTENSIONS.KHR_MESH_QUANTIZATION:
                            extensions[extensionName] = new GLTFMeshQuantizationExtension();
                            break;

                        default:

                            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === undefined) {

                                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');

                            }

                    }

                }

            }

            parser.setExtensions(extensions);
            parser.setPlugins(plugins);
            parser.parse(onLoad, onError);

        }

    });

    /* GLTFREGISTRY */

    function GLTFRegistry() {

        var objects = {};

        return {

            get: function (key) {

                return objects[key];

            },

            add: function (key, object) {

                objects[key] = object;

            },

            remove: function (key) {

                delete objects[key];

            },

            removeAll: function () {

                objects = {};

            }

        };

    }

    /*********************************/
    /********** EXTENSIONS ***********/
    /*********************************/

    var EXTENSIONS = {
        KHR_BINARY_GLTF: 'KHR_binary_glTF',
        KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
        KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
        KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
        KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
        KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
        KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
        KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
        KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
        KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
        MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
    };

    /**
     * DDS Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
     *
     */
    function GLTFTextureDDSExtension(ddsLoader) {

        if (!ddsLoader) {

            throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing THREE.DDSLoader');

        }

        this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
        this.ddsLoader = ddsLoader;

    }

    /**
     * Punctual Lights Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
     */
    function GLTFLightsExtension(json) {

        this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;

        var extension = ( json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] ) || {};
        this.lightDefs = extension.lights || [];

    }

    GLTFLightsExtension.prototype.loadLight = function (lightIndex) {

        var lightDef = this.lightDefs[lightIndex];
        var lightNode;

        var color = new THREE.Color(0xffffff);
        if (lightDef.color !== undefined) color.fromArray(lightDef.color);

        var range = lightDef.range !== undefined ? lightDef.range : 0;

        switch (lightDef.type) {

            case 'directional':
                lightNode = new THREE.DirectionalLight(color);
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;

            case 'point':
                lightNode = new THREE.PointLight(color);
                lightNode.distance = range;
                break;

            case 'spot':
                lightNode = new THREE.SpotLight(color);
                lightNode.distance = range;
                // Handle spotlight properties.
                lightDef.spot = lightDef.spot || {};
                lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
                lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
                lightNode.angle = lightDef.spot.outerConeAngle;
                lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
                lightNode.target.position.set(0, 0, -1);
                lightNode.add(lightNode.target);
                break;

            default:
                throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');

        }

        // Some lights (e.g. spot) default to a position other than the origin. Reset the position
        // here, because node-level parsing will only override position if explicitly specified.
        lightNode.position.set(0, 0, 0);

        lightNode.decay = 2;

        if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;

        lightNode.name = lightDef.name || ( 'light_' + lightIndex );

        return Promise.resolve(lightNode);

    };

    /**
     * Unlit Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
     */
    function GLTFMaterialsUnlitExtension() {

        this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;

    }

    GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {

        return THREE.MeshBasicMaterial;

    };

    GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {

        var pending = [];

        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;

        var metallicRoughness = materialDef.pbrMetallicRoughness;

        if (metallicRoughness) {

            if (Array.isArray(metallicRoughness.baseColorFactor)) {

                var array = metallicRoughness.baseColorFactor;

                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];

            }

            if (metallicRoughness.baseColorTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));

            }

        }

        return Promise.all(pending);

    };

    /**
     * Clearcoat Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_clearcoat
     */
    function GLTFMaterialsClearcoatExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;

    }

    GLTFMaterialsClearcoatExtension.prototype.getMaterialType = function (/* materialIndex */) {

        return THREE.MeshPhysicalMaterial;

    };

    GLTFMaterialsClearcoatExtension.prototype.extendMaterialParams = function (materialIndex, materialParams) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) {

            return Promise.resolve();

        }

        var pending = [];

        var extension = materialDef.extensions[this.name];

        if (extension.clearcoatFactor !== undefined) {

            materialParams.clearcoat = extension.clearcoatFactor;

        }

        if (extension.clearcoatTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatMap', extension.clearcoatTexture));

        }

        if (extension.clearcoatRoughnessFactor !== undefined) {

            materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;

        }

        if (extension.clearcoatRoughnessTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatRoughnessMap', extension.clearcoatRoughnessTexture));

        }

        if (extension.clearcoatNormalTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'clearcoatNormalMap', extension.clearcoatNormalTexture));

            if (extension.clearcoatNormalTexture.scale !== undefined) {

                var scale = extension.clearcoatNormalTexture.scale;

                materialParams.clearcoatNormalScale = new THREE.Vector2(scale, scale);

            }

        }

        return Promise.all(pending);

    };

    /**
     * Transmission Materials Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_transmission
     * Draft: https://github.com/KhronosGroup/glTF/pull/1698
     */
    function GLTFMaterialsTransmissionExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;

    }

    GLTFMaterialsTransmissionExtension.prototype.getMaterialType = function (/* materialIndex */) {

        return THREE.MeshPhysicalMaterial;

    };

    GLTFMaterialsTransmissionExtension.prototype.extendMaterialParams = function (materialIndex, materialParams) {

        var parser = this.parser;
        var materialDef = parser.json.materials[materialIndex];

        if (!materialDef.extensions || !materialDef.extensions[this.name]) {

            return Promise.resolve();

        }

        var pending = [];

        var extension = materialDef.extensions[this.name];

        if (extension.transmissionFactor !== undefined) {

            materialParams.transmission = extension.transmissionFactor;

        }

        if (extension.transmissionTexture !== undefined) {

            pending.push(parser.assignTexture(materialParams, 'transmissionMap', extension.transmissionTexture));

        }

        return Promise.all(pending);

    };

    /**
     * BasisU Texture Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_basisu
     * (draft PR https://github.com/KhronosGroup/glTF/pull/1751)
     */
    function GLTFTextureBasisUExtension(parser) {

        this.parser = parser;
        this.name = EXTENSIONS.KHR_TEXTURE_BASISU;

    }

    GLTFTextureBasisUExtension.prototype.loadTexture = function (textureIndex) {

        var parser = this.parser;
        var json = parser.json;

        var textureDef = json.textures[textureIndex];

        if (!textureDef.extensions || !textureDef.extensions[this.name]) {

            return null;

        }

        var extension = textureDef.extensions[this.name];
        var source = json.images[extension.source];
        var loader = parser.options.ktx2Loader;

        if (!loader) {

            throw new Error('THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures');

        }

        return parser.loadTextureImage(textureIndex, source, loader);

    };

    /* BINARY EXTENSION */
    var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
    var BINARY_EXTENSION_HEADER_LENGTH = 12;
    var BINARY_EXTENSION_CHUNK_TYPES = {JSON: 0x4E4F534A, BIN: 0x004E4942};

    function GLTFBinaryExtension(data) {

        this.name = EXTENSIONS.KHR_BINARY_GLTF;
        this.content = null;
        this.body = null;

        var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);

        this.header = {
            magic: THREE.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
            version: headerView.getUint32(4, true),
            length: headerView.getUint32(8, true)
        };

        if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {

            throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');

        } else if (this.header.version < 2.0) {

            throw new Error('THREE.GLTFLoader: Legacy binary file detected.');

        }

        var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
        var chunkIndex = 0;

        while (chunkIndex < chunkView.byteLength) {

            var chunkLength = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;

            var chunkType = chunkView.getUint32(chunkIndex, true);
            chunkIndex += 4;

            if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {

                var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
                this.content = THREE.LoaderUtils.decodeText(contentArray);

            } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {

                var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
                this.body = data.slice(byteOffset, byteOffset + chunkLength);

            }

            // Clients must ignore chunks with unknown types.

            chunkIndex += chunkLength;

        }

        if (this.content === null) {

            throw new Error('THREE.GLTFLoader: JSON content not found.');

        }

    }

    /**
     * DRACO Mesh Compression Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
     */
    function GLTFDracoMeshCompressionExtension(json, dracoLoader) {

        if (!dracoLoader) {

            throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');

        }

        this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
        this.json = json;
        this.dracoLoader = dracoLoader;
        this.dracoLoader.preload();

    }

    GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {

        var json = this.json;
        var dracoLoader = this.dracoLoader;
        var bufferViewIndex = primitive.extensions[this.name].bufferView;
        var gltfAttributeMap = primitive.extensions[this.name].attributes;
        var threeAttributeMap = {};
        var attributeNormalizedMap = {};
        var attributeTypeMap = {};

        for (var attributeName in gltfAttributeMap) {

            var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

            threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];

        }

        for (attributeName in primitive.attributes) {

            var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

            if (gltfAttributeMap[attributeName] !== undefined) {

                var accessorDef = json.accessors[primitive.attributes[attributeName]];
                var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

                attributeTypeMap[threeAttributeName] = componentType;
                attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;

            }

        }

        return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {

            return new Promise(function (resolve) {

                dracoLoader.decodeDracoFile(bufferView, function (geometry) {

                    for (var attributeName in geometry.attributes) {

                        var attribute = geometry.attributes[attributeName];
                        var normalized = attributeNormalizedMap[attributeName];

                        if (normalized !== undefined) attribute.normalized = normalized;

                    }

                    resolve(geometry);

                }, threeAttributeMap, attributeTypeMap);

            });

        });

    };

    /**
     * Texture Transform Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
     */
    function GLTFTextureTransformExtension() {

        this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;

    }

    GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {

        texture = texture.clone();

        if (transform.offset !== undefined) {

            texture.offset.fromArray(transform.offset);

        }

        if (transform.rotation !== undefined) {

            texture.rotation = transform.rotation;

        }

        if (transform.scale !== undefined) {

            texture.repeat.fromArray(transform.scale);

        }

        if (transform.texCoord !== undefined) {

            console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');

        }

        texture.needsUpdate = true;

        return texture;

    };

    /**
     * Specular-Glossiness Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
     */

    /**
     * A sub class of THREE.StandardMaterial with some of the functionality
     * changed via the `onBeforeCompile` callback
     * @pailhead
     */

    function GLTFMeshStandardSGMaterial(params) {

        THREE.MeshStandardMaterial.call(this);

        this.isGLTFSpecularGlossinessMaterial = true;

        //various chunks that need replacing
        var specularMapParsFragmentChunk = [
            '#ifdef USE_SPECULARMAP',
            '	uniform sampler2D specularMap;',
            '#endif'
        ].join('\n');

        var glossinessMapParsFragmentChunk = [
            '#ifdef USE_GLOSSINESSMAP',
            '	uniform sampler2D glossinessMap;',
            '#endif'
        ].join('\n');

        var specularMapFragmentChunk = [
            'vec3 specularFactor = specular;',
            '#ifdef USE_SPECULARMAP',
            '	vec4 texelSpecular = texture2D( specularMap, vUv );',
            '	texelSpecular = sRGBToLinear( texelSpecular );',
            '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '	specularFactor *= texelSpecular.rgb;',
            '#endif'
        ].join('\n');

        var glossinessMapFragmentChunk = [
            'float glossinessFactor = glossiness;',
            '#ifdef USE_GLOSSINESSMAP',
            '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
            '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
            '	glossinessFactor *= texelGlossiness.a;',
            '#endif'
        ].join('\n');

        var lightPhysicalFragmentChunk = [
            'PhysicalMaterial material;',
            'material.diffuseColor = diffuseColor.rgb;',
            'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
            'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
            'material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 );// 0.0525 corresponds to the base mip of a 256 cubemap.',
            'material.specularRoughness += geometryRoughness;',
            'material.specularRoughness = min( material.specularRoughness, 1.0 );',
            'material.specularColor = specularFactor.rgb;',
        ].join('\n');

        var uniforms = {
            specular: {value: new THREE.Color().setHex(0xffffff)},
            glossiness: {value: 1},
            specularMap: {value: null},
            glossinessMap: {value: null}
        };

        this._extraUniforms = uniforms;

        // please see #14031 or #13198 for an alternate approach
        this.onBeforeCompile = function (shader) {

            for (var uniformName in uniforms) {

                shader.uniforms[uniformName] = uniforms[uniformName];

            }

            shader.fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;');
            shader.fragmentShader = shader.fragmentShader.replace('uniform float metalness;', 'uniform float glossiness;');
            shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk);
            shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk);
            shader.fragmentShader = shader.fragmentShader.replace('#include <roughnessmap_fragment>', specularMapFragmentChunk);
            shader.fragmentShader = shader.fragmentShader.replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk);
            shader.fragmentShader = shader.fragmentShader.replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);

        };

        /*eslint-disable*/
        Object.defineProperties(
            this,
            {
                specular: {
                    get: function () {
                        return uniforms.specular.value;
                    },
                    set: function (v) {
                        uniforms.specular.value = v;
                    }
                },
                specularMap: {
                    get: function () {
                        return uniforms.specularMap.value;
                    },
                    set: function (v) {
                        uniforms.specularMap.value = v;
                    }
                },
                glossiness: {
                    get: function () {
                        return uniforms.glossiness.value;
                    },
                    set: function (v) {
                        uniforms.glossiness.value = v;
                    }
                },
                glossinessMap: {
                    get: function () {
                        return uniforms.glossinessMap.value;
                    },
                    set: function (v) {

                        uniforms.glossinessMap.value = v;
                        //how about something like this - @pailhead
                        if (v) {

                            this.defines.USE_GLOSSINESSMAP = '';
                            // set USE_ROUGHNESSMAP to enable vUv
                            this.defines.USE_ROUGHNESSMAP = '';

                        } else {

                            delete this.defines.USE_ROUGHNESSMAP;
                            delete this.defines.USE_GLOSSINESSMAP;

                        }

                    }
                }
            }
        );

        /*eslint-enable*/
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;

        this.setValues(params);

    }

    GLTFMeshStandardSGMaterial.prototype = Object.create(THREE.MeshStandardMaterial.prototype);
    GLTFMeshStandardSGMaterial.prototype.constructor = GLTFMeshStandardSGMaterial;

    GLTFMeshStandardSGMaterial.prototype.copy = function (source) {

        THREE.MeshStandardMaterial.prototype.copy.call(this, source);
        this.specularMap = source.specularMap;
        this.specular.copy(source.specular);
        this.glossinessMap = source.glossinessMap;
        this.glossiness = source.glossiness;
        delete this.metalness;
        delete this.roughness;
        delete this.metalnessMap;
        delete this.roughnessMap;
        return this;

    };

    function GLTFMaterialsPbrSpecularGlossinessExtension() {

        return {

            name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,

            specularGlossinessParams: [
                'color',
                'map',
                'lightMap',
                'lightMapIntensity',
                'aoMap',
                'aoMapIntensity',
                'emissive',
                'emissiveIntensity',
                'emissiveMap',
                'bumpMap',
                'bumpScale',
                'normalMap',
                'normalMapType',
                'displacementMap',
                'displacementScale',
                'displacementBias',
                'specularMap',
                'specular',
                'glossinessMap',
                'glossiness',
                'alphaMap',
                'envMap',
                'envMapIntensity',
                'refractionRatio',
            ],

            getMaterialType: function () {

                return GLTFMeshStandardSGMaterial;

            },

            extendParams: function (materialParams, materialDef, parser) {

                var pbrSpecularGlossiness = materialDef.extensions[this.name];

                materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
                materialParams.opacity = 1.0;

                var pending = [];

                if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {

                    var array = pbrSpecularGlossiness.diffuseFactor;

                    materialParams.color.fromArray(array);
                    materialParams.opacity = array[3];

                }

                if (pbrSpecularGlossiness.diffuseTexture !== undefined) {

                    pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));

                }

                materialParams.emissive = new THREE.Color(0.0, 0.0, 0.0);
                materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
                materialParams.specular = new THREE.Color(1.0, 1.0, 1.0);

                if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {

                    materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);

                }

                if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {

                    var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
                    pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
                    pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));

                }

                return Promise.all(pending);

            },

            createMaterial: function (materialParams) {

                var material = new GLTFMeshStandardSGMaterial(materialParams);
                material.fog = true;

                material.color = materialParams.color;

                material.map = materialParams.map === undefined ? null : materialParams.map;

                material.lightMap = null;
                material.lightMapIntensity = 1.0;

                material.aoMap = materialParams.aoMap === undefined ? null : materialParams.aoMap;
                material.aoMapIntensity = 1.0;

                material.emissive = materialParams.emissive;
                material.emissiveIntensity = 1.0;
                material.emissiveMap = materialParams.emissiveMap === undefined ? null : materialParams.emissiveMap;

                material.bumpMap = materialParams.bumpMap === undefined ? null : materialParams.bumpMap;
                material.bumpScale = 1;

                material.normalMap = materialParams.normalMap === undefined ? null : materialParams.normalMap;
                material.normalMapType = THREE.TangentSpaceNormalMap;

                if (materialParams.normalScale) material.normalScale = materialParams.normalScale;

                material.displacementMap = null;
                material.displacementScale = 1;
                material.displacementBias = 0;

                material.specularMap = materialParams.specularMap === undefined ? null : materialParams.specularMap;
                material.specular = materialParams.specular;

                material.glossinessMap = materialParams.glossinessMap === undefined ? null : materialParams.glossinessMap;
                material.glossiness = materialParams.glossiness;

                material.alphaMap = null;

                material.envMap = materialParams.envMap === undefined ? null : materialParams.envMap;
                material.envMapIntensity = 1.0;

                material.refractionRatio = 0.98;

                return material;

            },

        };

    }

    /**
     * Mesh Quantization Extension
     *
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
     */
    function GLTFMeshQuantizationExtension() {

        this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;

    }

    /*********************************/
    /********** INTERPOLATION ********/
    /*********************************/

    // Spline Interpolation
    // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation
    function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {

        THREE.Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);

    }

    GLTFCubicSplineInterpolant.prototype = Object.create(THREE.Interpolant.prototype);
    GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

    GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {

        // Copies a sample value to the result buffer. See description of glTF
        // CUBICSPLINE values layout in interpolate_() function below.

        var result = this.resultBuffer,
            values = this.sampleValues,
            valueSize = this.valueSize,
            offset = index * valueSize * 3 + valueSize;

        for (var i = 0; i !== valueSize; i++) {

            result[i] = values[offset + i];

        }

        return result;

    };

    GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

    GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {

        var result = this.resultBuffer;
        var values = this.sampleValues;
        var stride = this.valueSize;

        var stride2 = stride * 2;
        var stride3 = stride * 3;

        var td = t1 - t0;

        var p = ( t - t0 ) / td;
        var pp = p * p;
        var ppp = pp * p;

        var offset1 = i1 * stride3;
        var offset0 = offset1 - stride3;

        var s2 = -2 * ppp + 3 * pp;
        var s3 = ppp - pp;
        var s0 = 1 - s2;
        var s1 = s3 - pp + p;

        // Layout of keyframe output values for CUBICSPLINE animations:
        //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]
        for (var i = 0; i !== stride; i++) {

            var p0 = values[offset0 + i + stride]; // splineVertex_k
            var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)
            var p1 = values[offset1 + i + stride]; // splineVertex_k+1
            var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

            result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;

        }

        return result;

    };

    /*********************************/
    /********** INTERNALS ************/
    /*********************************/

    /* CONSTANTS */

    var WEBGL_CONSTANTS = {
        FLOAT: 5126,
        //FLOAT_MAT2: 35674,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    };

    var WEBGL_COMPONENT_TYPES = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    };

    var WEBGL_FILTERS = {
        9728: THREE.NearestFilter || GLC.NEAREST,
        9729: THREE.LinearFilter || GLC.LINEAR,
        9984: THREE.NearestMipmapNearestFilter || GLC.NEAREST_MIPMAP_NEAREST,
        9985: THREE.LinearMipmapNearestFilter || GLC.LINEAR_MIPMAP_NEAREST,
        9986: THREE.NearestMipmapLinearFilter || GLC.NEAREST_MIPMAP_LINEAR,
        9987: THREE.LinearMipmapLinearFilter || GLC.LINEAR_MIPMAP_LINEAR
    };

    var WEBGL_WRAPPINGS = {
        33071: THREE.ClampToEdgeWrapping || GLC.CLAMP_TO_EDGE,
        33648: THREE.MirroredRepeatWrapping || GLC.MIRRORED_REPEAT,
        10497: THREE.RepeatWrapping || GLC.REPEAT
    };

    var WEBGL_TYPE_SIZES = {
        'SCALAR': 1,
        'VEC2': 2,
        'VEC3': 3,
        'VEC4': 4,
        'MAT2': 4,
        'MAT3': 9,
        'MAT4': 16
    };

    var ATTRIBUTES = {
        POSITION: 'position',
        NORMAL: 'normal',
        TANGENT: 'tangent',
        TEXCOORD_0: 'uv',
        TEXCOORD_1: 'uv2',
        COLOR_0: 'color',
        WEIGHTS_0: 'skinWeight',
        JOINTS_0: 'skinIndex',
    };

    var PATH_PROPERTIES = {
        scale: 'scale',
        translation: 'position',
        rotation: 'quaternion',
        weights: 'morphTargetInfluences'
    };

    var INTERPOLATION = {
        CUBICSPLINE: undefined, // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
                                // keyframe track will be initialized with a default interpolation type, then modified.
        LINEAR: THREE.InterpolateLinear,
        STEP: THREE.InterpolateDiscrete
    };

    var ALPHA_MODES = {
        OPAQUE: 'OPAQUE',
        MASK: 'MASK',
        BLEND: 'BLEND'
    };

    /* UTILITY FUNCTIONS */

    function resolveURL(url, path) {

        // Invalid URL
        if (typeof url !== 'string' || url === '') return '';

        // Host Relative URL
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {

            path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');

        }

        // Absolute URL http://,https://,//
        if (/^(https?:)?\/\//i.test(url)) return url;

        // Data URI
        if (/^data:.*,.*$/i.test(url)) return url;

        // Blob URL
        if (/^blob:.*$/i.test(url)) return url;

        // Relative URL
        return path + url;

    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
     */
    function createDefaultMaterial(cache) {

        if (cache['DefaultMaterial'] === undefined) {

            cache['DefaultMaterial'] = new THREE.MeshStandardMaterial({
                color: 0xFFFFFF,
                emissive: 0x000000,
                metalness: 1,
                roughness: 1,
                transparent: false,
                depthTest: true,
                side: THREE.FrontSide
            });

        }

        return cache['DefaultMaterial'];

    }

    function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {

        // Add unknown glTF extensions to an object's userData.

        for (var name in objectDef.extensions) {

            if (knownExtensions[name] === undefined && object.userData) {

                object.userData.gltfExtensions = object.userData.gltfExtensions || {};
                object.userData.gltfExtensions[name] = objectDef.extensions[name];

            }

        }

    }

    /**
     * @param {THREE.Object3D|THREE.Material|THREE.BufferGeometry} object
     * @param {GLTF.definition} gltfDef
     */
    function assignExtrasToUserData(object, gltfDef) {

        if (gltfDef.extras !== undefined) {

            if (typeof gltfDef.extras === 'object') {

                object.userData = object.userData || {}

                Object.assign(object.userData, gltfDef.extras);

            } else {

                console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);

            }

        }

    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
     *
     * @param {THREE.BufferGeometry} geometry
     * @param {Array<GLTF.Target>} targets
     * @param {GLTFParser} parser
     * @return {Promise<THREE.BufferGeometry>}
     */
    function addMorphTargets(geometry, targets, parser) {

        var hasMorphPosition = false;
        var hasMorphNormal = false;

        for (var i = 0, il = targets.length; i < il; i++) {

            var target = targets[i];

            if (target.POSITION !== undefined) hasMorphPosition = true;
            if (target.NORMAL !== undefined) hasMorphNormal = true;

            if (hasMorphPosition && hasMorphNormal) break;

        }

        if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);

        var pendingPositionAccessors = [];
        var pendingNormalAccessors = [];

        for (var i = 0, il = targets.length; i < il; i++) {

            var target = targets[i];

            if (hasMorphPosition) {

                var pendingAccessor = target.POSITION !== undefined
                    ? parser.getDependency('accessor', target.POSITION)
                    : geometry.attributes.position;

                pendingPositionAccessors.push(pendingAccessor);

            }

            if (hasMorphNormal) {

                var pendingAccessor = target.NORMAL !== undefined
                    ? parser.getDependency('accessor', target.NORMAL)
                    : geometry.attributes.normal;

                pendingNormalAccessors.push(pendingAccessor);

            }

        }

        return Promise.all([
            Promise.all(pendingPositionAccessors),
            Promise.all(pendingNormalAccessors)
        ]).then(function (accessors) {

            var morphPositions = accessors[0];
            var morphNormals = accessors[1];

            if (hasMorphPosition) {
                geometry.morphAttributes = geometry.morphAttributes || {}
                geometry.morphAttributes.position = morphPositions;
            }
            if (hasMorphNormal) {
                geometry.morphAttributes = geometry.morphAttributes || {}
                geometry.morphAttributes.normal = morphNormals;
            }
            geometry.morphTargetsRelative = true;

            return geometry;

        });

    }

    /**
     * @param {THREE.Mesh} mesh
     * @param {GLTF.Mesh} meshDef
     */
    function updateMorphTargets(mesh, meshDef) {

        mesh.morphTargets || (mesh.morphTargets = [])
        mesh.morphTargetInfluences || (mesh.morphTargetInfluences = [])

        mesh.updateMorphTargets();

        if (meshDef.weights !== undefined) {

            for (var i = 0, il = meshDef.weights.length; i < il; i++) {

                mesh.morphTargetInfluences[i] = meshDef.weights[i];

            }

        }

        // .extras has user-defined data, so check that .extras.targetNames is an array.
        if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {

            var targetNames = meshDef.extras.targetNames;

            if (mesh.morphTargetInfluences.length === targetNames.length) {

                mesh.morphTargetDictionary = {};

                for (var i = 0, il = targetNames.length; i < il; i++) {

                    mesh.morphTargetDictionary[targetNames[i]] = i;

                }

            } else {

                console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');

            }

        }

    }

    function createPrimitiveKey(primitiveDef) {

        var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
        var geometryKey;

        if (dracoExtension) {

            geometryKey = 'draco:' + dracoExtension.bufferView
                + ':' + dracoExtension.indices
                + ':' + createAttributesKey(dracoExtension.attributes);

        } else {

            geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;

        }

        return geometryKey;

    }

    function createAttributesKey(attributes) {

        var attributesKey = '';

        var keys = Object.keys(attributes).sort();

        for (var i = 0, il = keys.length; i < il; i++) {

            attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';

        }

        return attributesKey;

    }

    /* GLTF PARSER */

    function GLTFParser(json, options) {

        this.json = json || {};
        this.extensions = {};
        this.plugins = {};
        this.options = options || {};

        // loader object cache
        this.cache = new GLTFRegistry();

        // associations between Three.js objects and glTF elements
        this.associations = new Map();

        // BufferGeometry caching
        this.primitiveCache = {};

        // Object3D instance caches
        this.meshCache = {refs: {}, uses: {}};
        this.cameraCache = {refs: {}, uses: {}};
        this.lightCache = {refs: {}, uses: {}};

        // Use an ImageBitmapLoader if imageBitmaps are supported. Moves much of the
        // expensive work of uploading a texture to the GPU off the main thread.
        if (typeof createImageBitmap !== 'undefined' && /Firefox/.test(navigator.userAgent) === false) {

            this.textureLoader = new THREE.ImageBitmapLoader(this.options.manager);

        } else {

            this.textureLoader = new THREE.TextureLoader(this.options.manager);

        }

        this.textureLoader.setCrossOrigin(this.options.crossOrigin);

        this.fileLoader = new THREE.FileLoader(this.options.manager);
        this.fileLoader.setResponseType('arraybuffer');

        if (this.options.crossOrigin === 'use-credentials') {

            this.fileLoader.setWithCredentials(true);

        }

    }

    GLTFParser.prototype.setExtensions = function (extensions) {

        this.extensions = extensions;

    };

    GLTFParser.prototype.setPlugins = function (plugins) {

        this.plugins = plugins;

    };

    GLTFParser.prototype.parse = function (onLoad, onError) {

        var parser = this;
        var json = this.json;
        var extensions = this.extensions;

        // Clear the loader cache
        this.cache.removeAll();

        // Mark the special nodes/meshes in json for efficient parse
        this._markDefs();

        Promise.all([

            this.getDependencies('scene'),
            this.getDependencies('animation'),
            this.getDependencies('camera'),

        ]).then(function (dependencies) {

            var result = {
                scene: dependencies[0][json.scene || 0],
                scenes: dependencies[0],
                animations: dependencies[1],
                cameras: dependencies[2],
                asset: json.asset,
                parser: parser,
                userData: {}
            };

            addUnknownExtensionsToUserData(extensions, result, json);

            assignExtrasToUserData(result, json);

            onLoad(result);

        }).catch(onError);

    };

    /**
     * Marks the special nodes/meshes in json for efficient parse.
     */
    GLTFParser.prototype._markDefs = function () {

        var nodeDefs = this.json.nodes || [];
        var skinDefs = this.json.skins || [];
        var meshDefs = this.json.meshes || [];

        // Nothing in the node definition indicates whether it is a Bone or an
        // Object3D. Use the skins' joint references to mark bones.
        for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {

            var joints = skinDefs[skinIndex].joints;

            for (var i = 0, il = joints.length; i < il; i++) {

                nodeDefs[joints[i]].isBone = true;

            }

        }

        // Iterate over all nodes, marking references to shared resources,
        // as well as skeleton joints.
        for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {

            var nodeDef = nodeDefs[nodeIndex];

            if (nodeDef.mesh !== undefined) {

                this._addNodeRef(this.meshCache, nodeDef.mesh);

                // Nothing in the mesh definition indicates whether it is
                // a SkinnedMesh or Mesh. Use the node's mesh reference
                // to mark SkinnedMesh if node has skin.
                if (nodeDef.skin !== undefined) {

                    meshDefs[nodeDef.mesh].isSkinnedMesh = true;

                }

            }

            if (nodeDef.camera !== undefined) {

                this._addNodeRef(this.cameraCache, nodeDef.camera);

            }

            if (nodeDef.extensions
                && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]
                && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {

                this._addNodeRef(this.lightCache, nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light);

            }

        }

    };

    /**
     * Counts references to shared node / Object3D resources. These resources
     * can be reused, or "instantiated", at multiple nodes in the scene
     * hierarchy. Mesh, Camera, and Light instances are instantiated and must
     * be marked. Non-scenegraph resources (like Materials, Geometries, and
     * Textures) can be reused directly and are not marked here.
     *
     * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
     */
    GLTFParser.prototype._addNodeRef = function (cache, index) {

        if (index === undefined) return;

        if (cache.refs[index] === undefined) {

            cache.refs[index] = cache.uses[index] = 0;

        }

        cache.refs[index]++;

    };

    /** Returns a reference to a shared resource, cloning it if necessary. */
    GLTFParser.prototype._getNodeRef = function (cache, index, object) {

        if (cache.refs[index] <= 1) return object;

        var ref = object.clone();

        ref.name += '_instance_' + ( cache.uses[index]++ );

        return ref;

    };

    GLTFParser.prototype._invokeOne = function (func) {

        var extensions = Object.values(this.plugins);
        extensions.push(this);

        for (var i = 0; i < extensions.length; i++) {

            var result = func(extensions[i]);

            if (result) return result;

        }

    };

    GLTFParser.prototype._invokeAll = function (func) {

        var extensions = Object.values(this.plugins);
        extensions.unshift(this);

        var pending = [];

        for (var i = 0; i < extensions.length; i++) {

            pending.push(func(extensions[i]));

        }

        return Promise.all(pending);

    };

    /**
     * Requests the specified dependency asynchronously, with caching.
     * @param {string} type
     * @param {number} index
     * @return {Promise<THREE.Object3D|THREE.Material|THREE.Texture|THREE.AnimationClip|ArrayBuffer|Object>}
     */
    GLTFParser.prototype.getDependency = function (type, index) {

        var cacheKey = type + ':' + index;
        var dependency = this.cache.get(cacheKey);

        if (!dependency) {

            switch (type) {

                case 'scene':
                    dependency = this.loadScene(index);
                    break;

                case 'node':
                    dependency = this.loadNode(index);
                    break;

                case 'mesh':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadMesh && ext.loadMesh(index);

                    });
                    break;

                case 'accessor':
                    dependency = this.loadAccessor(index);
                    break;

                case 'bufferView':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadBufferView && ext.loadBufferView(index);

                    });
                    break;

                case 'buffer':
                    dependency = this.loadBuffer(index);
                    break;

                case 'material':
                    let n = this
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadMaterial ? ext.loadMaterial(index) : n.loadMaterial(index);

                    });
                    break;

                case 'texture':
                    dependency = this._invokeOne(function (ext) {

                        return ext.loadTexture && ext.loadTexture(index);

                    });
                    break;

                case 'skin':
                    dependency = this.loadSkin(index);
                    break;

                case 'animation':
                    dependency = this.loadAnimation(index);
                    break;

                case 'camera':
                    dependency = this.loadCamera(index);
                    break;

                case 'light':
                    dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
                    break;

                default:
                    throw new Error('Unknown type: ' + type);

            }

            this.cache.add(cacheKey, dependency);

        }

        return dependency;

    };

    /**
     * Requests all dependencies of the specified type asynchronously, with caching.
     * @param {string} type
     * @return {Promise<Array<Object>>}
     */
    GLTFParser.prototype.getDependencies = function (type) {

        var dependencies = this.cache.get(type);

        if (!dependencies) {

            var parser = this;
            var defs = this.json[type + ( type === 'mesh' ? 'es' : 's' )] || [];

            dependencies = Promise.all(defs.map(function (def, index) {

                return parser.getDependency(type, index);

            }));

            this.cache.add(type, dependencies);

        }

        return dependencies;

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferIndex
     * @return {Promise<ArrayBuffer>}
     */
    GLTFParser.prototype.loadBuffer = function (bufferIndex) {

        var bufferDef = this.json.buffers[bufferIndex];
        var loader = this.fileLoader;

        if (bufferDef.type && bufferDef.type !== 'arraybuffer') {

            throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');

        }

        // If present, GLB container is required to be the first buffer.
        if (bufferDef.uri === undefined && bufferIndex === 0) {

            return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);

        }

        var options = this.options;

        return new Promise(function (resolve, reject) {

            loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {

                reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));

            });

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
     * @param {number} bufferViewIndex
     * @return {Promise<ArrayBuffer>}
     */
    GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {

        var bufferViewDef = this.json.bufferViews[bufferViewIndex];

        return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {

            var byteLength = bufferViewDef.byteLength || 0;
            var byteOffset = bufferViewDef.byteOffset || 0;
            return buffer.slice(byteOffset, byteOffset + byteLength);

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
     * @param {number} accessorIndex
     * @return {Promise<THREE.BufferAttribute|THREE.InterleavedBufferAttribute>}
     */
    GLTFParser.prototype.loadAccessor = function (accessorIndex) {

        var parser = this;
        var json = this.json;

        var accessorDef = this.json.accessors[accessorIndex];

        if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {

            // Ignore empty accessors, which may be used to declare runtime
            // information about attributes coming from another source (e.g. Draco
            // compression extension).
            return Promise.resolve(null);

        }

        var pendingBufferViews = [];

        if (accessorDef.bufferView !== undefined) {

            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));

        } else {

            pendingBufferViews.push(null);

        }

        if (accessorDef.sparse !== undefined) {

            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
            pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));

        }

        return Promise.all(pendingBufferViews).then(function (bufferViews) {

            var bufferView = bufferViews[0];

            var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
            var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];

            // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.
            var elementBytes = TypedArray.BYTES_PER_ELEMENT;
            var itemBytes = elementBytes * itemSize;
            var byteOffset = accessorDef.byteOffset || 0;
            var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
            var normalized = accessorDef.normalized === true;
            var array, bufferAttribute;

            // The buffer is not interleaved if the stride is the item size in bytes.
            if (byteStride && byteStride !== itemBytes) {

                // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
                // This makes sure that IBA.count reflects accessor.count properly
                var ibSlice = Math.floor(byteOffset / byteStride);
                var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
                var ib = parser.cache.get(ibCacheKey);

                if (!ib) {

                    array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);

                    // Integer parameters to IB/IBA are in array elements, not bytes.
                    ib = new THREE.InterleavedBuffer(array, byteStride / elementBytes);

                    parser.cache.add(ibCacheKey, ib);

                }

                bufferAttribute = new THREE.InterleavedBufferAttribute(ib, itemSize, ( byteOffset % byteStride ) / elementBytes, normalized);

            } else {

                if (bufferView === null) {

                    array = new TypedArray(accessorDef.count * itemSize);

                } else {

                    array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);

                }

                bufferAttribute = new THREE.BufferAttribute(array, itemSize, normalized);

            }

            // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors
            if (accessorDef.sparse !== undefined) {

                var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
                var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];

                var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
                var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;

                var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
                var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

                if (bufferView !== null) {

                    // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
                    bufferAttribute = new THREE.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);

                }

                for (var i = 0, il = sparseIndices.length; i < il; i++) {

                    var index = sparseIndices[i];

                    bufferAttribute.setX(index, sparseValues[i * itemSize]);
                    if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
                    if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
                    if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
                    if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');

                }

            }

            return bufferAttribute;

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
     * @param {number} textureIndex
     * @return {Promise<THREE.Texture>}
     */
    GLTFParser.prototype.loadTexture = function (textureIndex) {

        var parser = this;
        var json = this.json;
        var options = this.options;

        var textureDef = json.textures[textureIndex];

        var textureExtensions = textureDef.extensions || {};

        var source;

        if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {

            source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];

        } else {

            source = json.images[textureDef.source];

        }

        var loader;

        if (source.uri) {

            if (!options.manager.getHandler) {

                options.manager.getHandler = function (file) {

                    return null;

                }
            }

            loader = options.manager.getHandler(source.uri);

        }

        if (!loader) {

            loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]
                ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader
                : this.textureLoader;

        }

        return this.loadTextureImage(textureIndex, source, loader);

    };

    GLTFParser.prototype.loadTextureImage = function (textureIndex, source, loader) {

        var parser = this;
        var json = this.json;
        var options = this.options;

        var textureDef = json.textures[textureIndex];

        var URL = self.URL || self.webkitURL;

        var sourceURI = source.uri;
        var isObjectURL = false;
        var hasAlpha = true;

        if (source.mimeType === 'image/jpeg') hasAlpha = false;

        if (source.bufferView !== undefined) {

            // Load binary image data from bufferView, if provided.

            sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {

                if (source.mimeType === 'image/png') {

                    // https://en.wikipedia.org/wiki/Portable_Network_Graphics#File_header
                    hasAlpha = new DataView(bufferView, 25, 1).getUint8(0, false) === 6;

                }

                isObjectURL = true;
                var blob = new Blob([bufferView], {type: source.mimeType});
                sourceURI = URL.createObjectURL(blob);
                return sourceURI;

            });

        }

        return Promise.resolve(sourceURI).then(function (sourceURI) {

            return new Promise(function (resolve, reject) {

                var onLoad = resolve;

                if (loader.isImageBitmapLoader === true) {

                    onLoad = function (imageBitmap) {

                        imageBitmap.imageOrientation = "flipY"
                        let texture = new THREE.CanvasTexture(imageBitmap)
                        texture.id = sourceURI
                        resolve(texture);

                    };
                }

                loader.load(resolveURL(sourceURI, options.path), onLoad, undefined, reject);

            });

        }).then(function (texture) {

            // Clean up resources and configure Texture.

            if (isObjectURL === true) {

                URL.revokeObjectURL(sourceURI);

            }

            if (texture instanceof ImageBitmap) {

                let imageBitmap = texture

                var canvas = document.getElementById("anchor-canvas");

                if (!canvas) {
                    canvas = document.createElement("canvas")

                    canvas.id = "anchor-canvas"
                }
                //

                canvas.width = imageBitmap.width;
                canvas.height = imageBitmap.height;
                //
                let context = canvas.getContext('2d');
                context.drawImage(imageBitmap, 0, 0, imageBitmap.width, imageBitmap.height)

                texture = new THREE.CanvasTexture(canvas)
                // When there is definitely no alpha channel in the texture, set RGBFormat to save space.
                if (!hasAlpha) {
                    texture.format = THREE.RGBFormat;
                }

                var samplers = json.samplers || {};
                var sampler = samplers[textureDef.sampler] || {};

                texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || THREE.LinearFilter;
                texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || THREE.LinearMipmapLinearFilter;
                texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || THREE.RepeatWrapping;
                texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || THREE.RepeatWrapping;
            }
            else {

                if (hasAlpha) {
                    texture.format = GLC.RGBA
                }
                else {
                    texture.format = GLC.RGB
                }

                texture.magFilter = GLC.LINEAR;
                texture.minFilter = GLC.LINEAR_MIPMAP_LINEAR;
                texture.wrapS = GLC.REPEAT;
                texture.wrapT = GLC.REPEAT;

            }

            texture.flipY = false;

            if (textureDef.name) texture.name = textureDef.name;

            parser.associations.set(texture, {
                type: 'textures',
                index: textureIndex
            });

            return texture;

        });

    };

    /**
     * Asynchronously assigns a texture to the given material parameters.
     * @param {Object} materialParams
     * @param {string} mapName
     * @param {Object} mapDef
     * @return {Promise}
     */
    GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {

        var parser = this;

        return this.getDependency('texture', mapDef.index).then(function (texture) {

            // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
            // However, we will copy UV set 0 to UV set 1 on demand for aoMap
            if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !( mapName === 'aoMap' && mapDef.texCoord == 1 )) {

                console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');

            }

            if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {

                var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

                if (transform) {

                    var gltfReference = parser.associations.get(texture);
                    texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
                    parser.associations.set(texture, gltfReference);

                }

            }

            materialParams[mapName] = texture;

        });

    };

    /**
     * Assigns final material to a Mesh, Line, or Points instance. The instance
     * already has a material (generated from the glTF material options alone)
     * but reuse of the same glTF material may require multiple threejs materials
     * to accomodate different primitive types, defines, etc. New materials will
     * be created if necessary, and reused from a cache.
     * @param  {THREE.Object3D} mesh Mesh, Line, or Points instance.
     */
    GLTFParser.prototype.assignFinalMaterial = function (mesh) {

        var geometry = mesh.geometry;
        var material = mesh.material;

        var useVertexTangents = geometry.attributes.tangent !== undefined;
        var useVertexColors = geometry.attributes.color !== undefined;
        var useFlatShading = geometry.attributes.normal === undefined;
        var useSkinning = mesh.isSkinnedMesh === true;
        var useMorphTargets = false //Object.keys( geometry.morphAttributes ).length > 0;
        var useMorphNormals = false //useMorphTargets && geometry.morphAttributes.normal !== undefined;

        if (mesh.isPoints) {

            let id = material.uuid || material.id

            var cacheKey = 'PointsMaterial:' + id;

            var pointsMaterial = this.cache.get(cacheKey);

            if (!pointsMaterial) {

                pointsMaterial = new THREE.PointsMaterial();
                THREE.Material.prototype.copy.call(pointsMaterial, material);
                pointsMaterial.color.copy(material.color);
                pointsMaterial.map = material.map;
                pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

                this.cache.add(cacheKey, pointsMaterial);

            }

            material = pointsMaterial;

        } else if (mesh.isLine) {

            let id = material.uuid || material.id

            var cacheKey = 'LineBasicMaterial:' + id;

            var lineMaterial = this.cache.get(cacheKey);

            if (!lineMaterial) {

                lineMaterial = new THREE.LineBasicMaterial();
                THREE.Material.prototype.copy.call(lineMaterial, material);
                lineMaterial.color.copy(material.color);

                this.cache.add(cacheKey, lineMaterial);

            }

            material = lineMaterial;

        }

        // Clone the material if it will be modified
        if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {

            let id = material.uuid || material.id

            var cacheKey = 'ClonedMaterial:' + id + ':';

            if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
            if (useSkinning) cacheKey += 'skinning:';
            if (useVertexTangents) cacheKey += 'vertex-tangents:';
            if (useVertexColors) cacheKey += 'vertex-colors:';
            if (useFlatShading) cacheKey += 'flat-shading:';
            if (useMorphTargets) cacheKey += 'morph-targets:';
            if (useMorphNormals) cacheKey += 'morph-normals:';

            var cachedMaterial = this.cache.get(cacheKey);

            if (!cachedMaterial) {

                cachedMaterial = material.clone();

                if (useSkinning) cachedMaterial.skinning = true;
                if (useVertexTangents) cachedMaterial.vertexTangents = true;
                if (useVertexColors) cachedMaterial.vertexColors = true;
                if (useFlatShading) cachedMaterial.flatShading = true;
                if (useMorphTargets) cachedMaterial.morphTargets = true;
                if (useMorphNormals) cachedMaterial.morphNormals = true;

                this.cache.add(cacheKey, cachedMaterial);

                this.associations.set(cachedMaterial, this.associations.get(material));

            }

            material = cachedMaterial;

        }

        // workarounds for mesh and geometry


        if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {

            geometry.setAttribute('uv2', geometry.attributes.uv);

        }

        // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
        if (material.normalScale && !useVertexTangents) {

            material.normalScale.y = -material.normalScale.y;

        }

        if (material.clearcoatNormalScale && !useVertexTangents) {

            material.clearcoatNormalScale.y = -material.clearcoatNormalScale.y;

        }


        //UjP.dispatchEvent({
        //    type: 'materialLoaded',
        //    material: material,
        //    materialIndex: material.materialIndex
        //})

        //this.onMaterialLoaded && this.onMaterialLoaded({
        //    material: material,
        //    materialIndex: material.materialIndex
        // })

        mesh.material = material;

    };

    GLTFParser.prototype.getMaterialType = function (/* materialIndex */) {

        return THREE.MeshStandardMaterial;

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
     * @param {number} materialIndex
     * @return {Promise<THREE.Material>}
     */
    GLTFParser.prototype.loadMaterial = function (materialIndex) {

        var parser = this;
        var json = this.json;
        var extensions = this.extensions;
        var materialDef = json.materials[materialIndex];

        var materialType;
        var materialParams = {};
        var materialExtensions = materialDef.extensions || {};

        var pending = [];

        if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {

            var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
            materialType = sgExtension.getMaterialType();
            pending.push(sgExtension.extendParams(materialParams, materialDef, parser));

        } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {

            var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
            materialType = kmuExtension.getMaterialType();
            pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));

        } else {

            // Specification:
            // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material

            var metallicRoughness = materialDef.pbrMetallicRoughness || {};

            materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
            materialParams.opacity = 1.0;

            if (Array.isArray(metallicRoughness.baseColorFactor)) {

                var array = metallicRoughness.baseColorFactor;

                materialParams.color.fromArray(array);
                materialParams.opacity = array[3];

            }

            if (metallicRoughness.baseColorTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));

            }

            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

            if (metallicRoughness.metallicRoughnessTexture !== undefined) {

                pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
                pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));

            }

            materialType = this._invokeOne(function (ext) {

                return ext.getMaterialType && ext.getMaterialType(materialIndex);

            });

            pending.push(this._invokeAll(function (ext) {

                return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);

            }));

        }


        materialType = JMT.StandardMaterial

        if (materialDef.doubleSided === true) {

            materialParams.side = THREE.DoubleSide;

        }

        var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

        if (alphaMode === ALPHA_MODES.BLEND) {

            materialParams.transparent = true;

            // See: https://github.com/mrdoob/three.js/issues/17706
            materialParams.depthWrite = false;

        } else {

            materialParams.transparent = false;

            if (alphaMode === ALPHA_MODES.MASK) {

                materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;

            }

        }

        if (materialDef.normalTexture !== undefined) { // && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));

            materialParams.normalScale = new THREE.Vector2(1, 1);

            if (materialDef.normalTexture.scale !== undefined) {

                materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);

            }

        }

        if (materialDef.occlusionTexture !== undefined) { // && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

            if (materialDef.occlusionTexture.strength !== undefined) {

                materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;

            }

        }

        if (materialDef.emissiveFactor !== undefined) { // && materialType !== THREE.MeshBasicMaterial) {

            materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);

        }

        if (materialDef.emissiveTexture !== undefined) { // && materialType !== THREE.MeshBasicMaterial) {

            pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));

        }

        return Promise.all(pending).then(function () {

            var material;

            if (materialType === GLTFMeshStandardSGMaterial) {

                material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);

            }

            else if (materialType === JMT.StandardMaterial) {
                if (window.JMT) {
                    material = new materialType();

                    material.fromGLTF(materialParams, materialIndex)


                    parser.onMaterialLoaded && parser.onMaterialLoaded({
                        material: material,
                        materialIndex: materialIndex
                    })

                }
                else {
                    material = new materialType(materialParams);
                }
            }
            else {

                material = new materialType(materialParams);

            }

            if (materialDef.name) material.name = materialDef.name;

            // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
            if (material.map) material.map.encoding = THREE.sRGBEncoding;
            if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;

            assignExtrasToUserData(material, materialDef);

            parser.associations.set(material, {type: 'materials', index: materialIndex});

            if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);

            return material;

        });

    };

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     */
    function computeBounds(geometry, primitiveDef, parser) {

        var attributes = primitiveDef.attributes;

        var box = new THREE.Box3();

        if (attributes.POSITION !== undefined) {

            var accessor = parser.json.accessors[attributes.POSITION];

            var min = accessor.min;
            var max = accessor.max;

            // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

            if (min !== undefined && max !== undefined) {

                box.set(
                    new THREE.Vector3(min[0], min[1], min[2]),
                    new THREE.Vector3(max[0], max[1], max[2]));

            } else {

                console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');

                return;

            }

        } else {

            return;

        }

        var targets = primitiveDef.targets;

        if (targets !== undefined) {

            var maxDisplacement = new THREE.Vector3();
            var vector = new THREE.Vector3();

            for (var i = 0, il = targets.length; i < il; i++) {

                var target = targets[i];

                if (target.POSITION !== undefined) {

                    var accessor = parser.json.accessors[target.POSITION];
                    var min = accessor.min;
                    var max = accessor.max;

                    // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

                    if (min !== undefined && max !== undefined) {

                        // we need to get max of absolute components because target weight is [-1,1]
                        vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
                        vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
                        vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));

                        // Note: this assumes that the sum of all weights is at most 1. This isn't quite correct - it's more conservative
                        // to assume that each target can have a max weight of 1. However, for some use cases - notably, when morph targets
                        // are used to implement key-frame animations and as such only two are active at a time - this results in very large
                        // boxes. So for now we make a box that's sometimes a touch too small but is hopefully mostly of reasonable size.
                        maxDisplacement.max(vector);

                    } else {

                        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');

                    }

                }

            }

            // As per comment above this box isn't conservative, but has a reasonable size for a very large number of morph targets.
            box.expandByVector(maxDisplacement);

        }

        let scale = JMT.MODEL_SCALE_BASE

        box.min.fromArray([box.min.x * scale, box.min.y * scale, box.min.z * scale])
        box.max.fromArray([box.max.x * scale, box.max.y * scale, box.max.z * scale])

        geometry.boundingBox = box;

        var sphere = new THREE.Sphere();

        box.getCenter ? box.getCenter(sphere.center) : sphere.center.copy(box.center());
        sphere.radius = box.min.distanceTo(box.max) / 2;

        geometry.boundingSphere = sphere;

    }

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {GLTF.Primitive} primitiveDef
     * @param {GLTFParser} parser
     * @return {Promise<THREE.BufferGeometry>}
     */
    function addPrimitiveAttributes(geometry, primitiveDef, parser) {

        var attributes = primitiveDef.attributes;

        var pending = [];

        function assignAttributeAccessor(accessorIndex, attributeName) {

            let scale = 1.0

            if (attributeName === 'position') {
                scale = JMT.MODEL_SCALE_BASE//THREE.GLTFLoader.SCALE_BASE
            }

            return parser.getDependency('accessor', accessorIndex)
                .then(function (accessor) {

                    let array = accessor.array

                    let cnt = array.length / 3

                    for (let i = 0; i < cnt; i++) {
                        //let tmp = array[i * 3 + 2]
                        //array[i * 3 + 2] = array[i * 3 + 1] * scale
                        //array[i * 3 + 1] = tmp * scale
                        //array[i * 3] *= scale
                        array[i * 3] *= scale
                        array[i * 3 + 1] *= scale
                        array[i * 3 + 2] *= scale
                    }

                    geometry.setAttribute
                        ? geometry.setAttribute(attributeName, accessor)
                        : geometry.addAttribute(attributeName, accessor);

                });

        }

        for (var gltfAttributeName in attributes) {

            var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();

            // Skip attributes already provided by e.g. Draco extension.
            if (threeAttributeName in geometry.attributes) continue;

            pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));

        }

        if (primitiveDef.indices !== undefined && !geometry.index) {

            var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {

                geometry.setIndex ? geometry.setIndex(accessor) : geometry.addAttribute('index', accessor);

            });

            pending.push(accessor);

        }

        assignExtrasToUserData(geometry, primitiveDef);

        computeBounds(geometry, primitiveDef, parser);

        return Promise.all(pending).then(function () {

            return primitiveDef.targets !== undefined
                ? addMorphTargets(geometry, primitiveDef.targets, parser)
                : geometry;

        });

    }

    /**
     * @param {THREE.BufferGeometry} geometry
     * @param {Number} drawMode
     * @return {THREE.BufferGeometry}
     */
    function toTrianglesDrawMode(geometry, drawMode) {

        var index = geometry.getIndex();

        // generate index if not present

        if (index === null) {

            var indices = [];

            var position = geometry.getAttribute('position');

            if (position !== undefined) {

                for (var i = 0; i < position.count; i++) {

                    indices.push(i);

                }

                geometry.setIndex(indices);
                index = geometry.getIndex();

            } else {

                console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
                return geometry;

            }

        }

        //

        var numberOfTriangles = index.count - 2;
        var newIndices = [];

        if (drawMode === THREE.TriangleFanDrawMode) {

            // gl.TRIANGLE_FAN

            for (var i = 1; i <= numberOfTriangles; i++) {

                newIndices.push(index.getX(0));
                newIndices.push(index.getX(i));
                newIndices.push(index.getX(i + 1));

            }

        } else {

            // gl.TRIANGLE_STRIP

            for (var i = 0; i < numberOfTriangles; i++) {

                if (i % 2 === 0) {

                    newIndices.push(index.getX(i));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i + 2));


                } else {

                    newIndices.push(index.getX(i + 2));
                    newIndices.push(index.getX(i + 1));
                    newIndices.push(index.getX(i));

                }

            }

        }

        if (( newIndices.length / 3 ) !== numberOfTriangles) {

            console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');

        }

        // build final geometry

        var newGeometry = geometry.clone();
        newGeometry.setIndex(newIndices);

        return newGeometry;

    }

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
     *
     * Creates BufferGeometries from primitives.
     *
     * @param {Array<GLTF.Primitive>} primitives
     * @return {Promise<Array<THREE.BufferGeometry>>}
     */
    GLTFParser.prototype.loadGeometries = function (primitives) {

        var parser = this;
        var extensions = this.extensions;
        var cache = this.primitiveCache;

        function createDracoPrimitive(primitive) {

            return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
                .decodePrimitive(primitive, parser)
                .then(function (geometry) {

                    return addPrimitiveAttributes(geometry, primitive, parser);

                });

        }

        var pending = [];

        for (var i = 0, il = primitives.length; i < il; i++) {

            var primitive = primitives[i];
            var cacheKey = createPrimitiveKey(primitive);

            // See if we've already created this geometry
            var cached = cache[cacheKey];

            if (cached) {

                // Use the cached geometry if it exists
                pending.push(cached.promise);

            } else {

                var geometryPromise;

                if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {

                    // Use DRACO geometry if available
                    geometryPromise = createDracoPrimitive(primitive);

                } else {

                    // Otherwise create a new geometry
                    geometryPromise = addPrimitiveAttributes(new THREE.BufferGeometry(), primitive, parser);

                }

                // Cache this geometry
                cache[cacheKey] = {primitive: primitive, promise: geometryPromise};

                pending.push(geometryPromise);

            }

        }

        return Promise.all(pending);

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
     * @param {number} meshIndex
     * @return {Promise<THREE.Group|THREE.Mesh|THREE.SkinnedMesh>}
     */
    GLTFParser.prototype.loadMesh = function (meshIndex) {

        var parser = this;
        var json = this.json;

        var meshDef = json.meshes[meshIndex];
        var primitives = meshDef.primitives;

        var pending = [];

        for (var i = 0, il = primitives.length; i < il; i++) {

            var material = primitives[i].material === undefined
                ? createDefaultMaterial(this.cache)
                : this.getDependency('material', primitives[i].material);

            pending.push(material);

        }

        pending.push(parser.loadGeometries(primitives));

        return Promise.all(pending).then(function (results) {

            var materials = results.slice(0, results.length - 1);
            var geometries = results[results.length - 1];

            var meshes = [];

            for (var i = 0, il = geometries.length; i < il; i++) {

                var geometry = geometries[i];
                var primitive = primitives[i];

                // 1. create Mesh

                var mesh;

                var material = materials[i];

                if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
                    primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
                    primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
                    primitive.mode === undefined) {

                    // .isSkinnedMesh isn't in glTF spec. See ._markDefs()
                    mesh = meshDef.isSkinnedMesh === true
                        ? new THREE.SkinnedMesh(geometry, material)
                        : new THREE.Mesh(geometry, material);

                    if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {

                        // we normalize floating point skin weight array to fix malformed assets (see #15319)
                        // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
                        mesh.normalizeSkinWeights();

                    }

                    if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {

                        mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleStripDrawMode);

                    } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {

                        mesh.geometry = toTrianglesDrawMode(mesh.geometry, THREE.TriangleFanDrawMode);

                    }

                } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {

                    mesh = new THREE.LineSegments(geometry, material);

                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {

                    mesh = new THREE.Line(geometry, material);

                } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {

                    mesh = new THREE.LineLoop(geometry, material);

                } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {

                    mesh = new THREE.Points(geometry, material);

                } else {

                    throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);

                }

                //
                if (mesh.geometry.morphAttributes && Object.keys(mesh.geometry.morphAttributes).length > 0) {

                    updateMorphTargets(mesh, meshDef);

                }

                mesh.name = meshDef.name || ( 'mesh_' + meshIndex );

                if (geometries.length > 1) mesh.name += '_' + i;

                assignExtrasToUserData(mesh, meshDef);

                parser.assignFinalMaterial(mesh);

                meshes.push(mesh);

            }

            var group = new THREE.Group();

            for (var i = 0, il = meshes.length; i < il; i++) {

                group.add(meshes[i]);

            }
            return group;

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
     * @param {number} cameraIndex
     * @return {Promise<THREE.Camera>}
     */
    GLTFParser.prototype.loadCamera = function (cameraIndex) {

        var camera;
        var cameraDef = this.json.cameras[cameraIndex];
        var params = cameraDef[cameraDef.type];

        if (!params) {

            console.warn('THREE.GLTFLoader: Missing camera parameters.');
            return;

        }

        if (cameraDef.type === 'perspective') {

            camera = new THREE.PerspectiveCamera(THREE.Math.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);

        } else if (cameraDef.type === 'orthographic') {

            camera = new THREE.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);

        }

        if (cameraDef.name) camera.name = cameraDef.name;

        assignExtrasToUserData(camera, cameraDef);

        return Promise.resolve(camera);

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
     * @param {number} skinIndex
     * @return {Promise<Object>}
     */
    GLTFParser.prototype.loadSkin = function (skinIndex) {

        var skinDef = this.json.skins[skinIndex];

        var skinEntry = {joints: skinDef.joints};

        if (skinDef.inverseBindMatrices === undefined) {

            return Promise.resolve(skinEntry);

        }

        return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {

            skinEntry.inverseBindMatrices = accessor;

            return skinEntry;

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
     * @param {number} animationIndex
     * @return {Promise<THREE.AnimationClip>}
     */
    GLTFParser.prototype.loadAnimation = function (animationIndex) {

        var json = this.json;

        var animationDef = json.animations[animationIndex];

        var pendingNodes = [];
        var pendingInputAccessors = [];
        var pendingOutputAccessors = [];
        var pendingSamplers = [];
        var pendingTargets = [];

        for (var i = 0, il = animationDef.channels.length; i < il; i++) {

            var channel = animationDef.channels[i];
            var sampler = animationDef.samplers[channel.sampler];
            var target = channel.target;
            var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.
            var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
            var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;

            pendingNodes.push(this.getDependency('node', name));
            pendingInputAccessors.push(this.getDependency('accessor', input));
            pendingOutputAccessors.push(this.getDependency('accessor', output));
            pendingSamplers.push(sampler);
            pendingTargets.push(target);

        }

        return Promise.all([

            Promise.all(pendingNodes),
            Promise.all(pendingInputAccessors),
            Promise.all(pendingOutputAccessors),
            Promise.all(pendingSamplers),
            Promise.all(pendingTargets)

        ]).then(function (dependencies) {

            var nodes = dependencies[0];
            var inputAccessors = dependencies[1];
            var outputAccessors = dependencies[2];
            var samplers = dependencies[3];
            var targets = dependencies[4];

            var tracks = [];

            for (var i = 0, il = nodes.length; i < il; i++) {

                var node = nodes[i];
                var inputAccessor = inputAccessors[i];
                var outputAccessor = outputAccessors[i];
                var sampler = samplers[i];
                var target = targets[i];

                if (node === undefined) continue;

                node.updateMatrix();
                node.matrixAutoUpdate = true;

                var TypedKeyframeTrack;

                switch (PATH_PROPERTIES[target.path]) {

                    case PATH_PROPERTIES.weights:

                        TypedKeyframeTrack = THREE.NumberKeyframeTrack;
                        break;

                    case PATH_PROPERTIES.rotation:

                        TypedKeyframeTrack = THREE.QuaternionKeyframeTrack;
                        break;

                    case PATH_PROPERTIES.position:
                    case PATH_PROPERTIES.scale:
                    default:

                        TypedKeyframeTrack = THREE.VectorKeyframeTrack;
                        break;

                }

                var targetName = node.name ? node.name : node.uuid ? node.uuid : node.id;

                var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : THREE.InterpolateLinear;

                var targetNames = [];

                if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {

                    // Node may be a THREE.Group (glTF mesh with several primitives) or a THREE.Mesh.
                    node.traverse(function (object) {

                        if (object.isMesh === true && object.morphTargetInfluences) {

                            targetNames.push(object.name ? object.name : object.uuid ? object.uuid : object.id);

                        }

                    });

                } else {

                    targetNames.push(targetName);

                }

                var outputArray = outputAccessor.array;

                if (outputAccessor.normalized) {

                    var scale;

                    if (outputArray.constructor === Int8Array) {

                        scale = 1 / 127;

                    } else if (outputArray.constructor === Uint8Array) {

                        scale = 1 / 255;

                    } else if (outputArray.constructor == Int16Array) {

                        scale = 1 / 32767;

                    } else if (outputArray.constructor === Uint16Array) {

                        scale = 1 / 65535;

                    } else {

                        throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');

                    }

                    var scaled = new Float32Array(outputArray.length);

                    for (var j = 0, jl = outputArray.length; j < jl; j++) {

                        scaled[j] = outputArray[j] * scale;

                    }

                    outputArray = scaled;

                }

                for (var j = 0, jl = targetNames.length; j < jl; j++) {

                    var track = new TypedKeyframeTrack(
                        targetNames[j] + '.' + PATH_PROPERTIES[target.path],
                        inputAccessor.array,
                        outputArray,
                        interpolation
                    );

                    // Override interpolation with custom factory method.
                    if (sampler.interpolation === 'CUBICSPLINE') {

                        track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {

                            // A CUBICSPLINE keyframe in glTF has three output values for each input value,
                            // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
                            // must be divided by three to get the interpolant's sampleSize argument.

                            return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);

                        };

                        // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.
                        track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;

                    }

                    tracks.push(track);

                }

            }

            var name = animationDef.name ? animationDef.name : 'animation_' + animationIndex;

            return new THREE.AnimationClip(name, undefined, tracks);

        });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
     * @param {number} nodeIndex
     * @return {Promise<THREE.Object3D>}
     */
    GLTFParser.prototype.loadNode = function (nodeIndex) {

        var json = this.json;
        var extensions = this.extensions;
        var parser = this;

        var nodeDef = json.nodes[nodeIndex];

        return ( function () {

            var pending = [];

            if (nodeDef.mesh !== undefined) {

                pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {

                    var node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);

                    // if weights are provided on the node, override weights on the mesh.
                    if (nodeDef.weights !== undefined) {

                        node.traverse(function (o) {

                            if (!o.isMesh) return;

                            for (var i = 0, il = nodeDef.weights.length; i < il; i++) {

                                o.morphTargetInfluences[i] = nodeDef.weights[i];

                            }

                        });

                    }

                    return node;

                }));

            }

            if (nodeDef.camera !== undefined) {

                pending.push(parser.getDependency('camera', nodeDef.camera).then(function (camera) {

                    return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);

                }));

            }

            if (nodeDef.extensions
                && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL]
                && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {

                var lightIndex = nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light;

                pending.push(parser.getDependency('light', lightIndex).then(function (light) {

                    return parser._getNodeRef(parser.lightCache, lightIndex, light);

                }));

            }

            return Promise.all(pending);

        }() ).then(function (objects) {

                var node;

                // .isBone isn't in glTF spec. See ._markDefs
                if (nodeDef.isBone === true) {

                    node = new THREE.Bone();

                } else if (objects.length > 1) {

                    node = new THREE.Group();

                } else if (objects.length === 1) {

                    node = objects[0];

                } else {

                    node = new THREE.Object3D();

                }

                if (node !== objects[0]) {

                    for (var i = 0, il = objects.length; i < il; i++) {

                        node.add(objects[i]);

                    }

                }

                if (nodeDef.name) {

                    node.userData.name = nodeDef.name;

                    let sanitize = THREE.PropertyBinding ? THREE.PropertyBinding.sanitizeNodeName : sanitizeNodeName

                    node.name = sanitize(nodeDef.name);

                }

                assignExtrasToUserData(node, nodeDef);

                if (nodeDef.extensions) {
                    addUnknownExtensionsToUserData(extensions, node, nodeDef);
                }

                if (nodeDef.matrix !== undefined) {

                    var matrix = new THREE.Matrix4();
                    matrix.fromArray(nodeDef.matrix);
                    if (node.applyMatrix4) {
                        node.applyMatrix4(matrix);
                    }
                    else {
                        node.matrix.copy(matrix)
                        node.matrix.decompose(node.position, node.quaternion, node.scale);
                    }

                } else {

                    if (nodeDef.translation !== undefined) {

                        node.position.fromArray(nodeDef.translation);

                    }

                    if (nodeDef.rotation !== undefined) {

                        node.quaternion.fromArray(nodeDef.rotation);

                    }

                    if (nodeDef.scale !== undefined) {

                        node.scale.fromArray(nodeDef.scale);

                    }

                }

                parser.associations.set(node, {type: 'nodes', index: nodeIndex});

                return node;

            });

    };

    /**
     * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
     * @param {number} sceneIndex
     * @return {Promise<THREE.Group>}
     */
    GLTFParser.prototype.loadScene = function () {

        // scene node hierachy builder

        function buildNodeHierachy(nodeId, parentObject, json, parser) {

            var nodeDef = json.nodes[nodeId];

            return parser.getDependency('node', nodeId).then(function (node) {

                if (nodeDef.skin === undefined) {

                    return node;

                }

                // build skeleton here as well

                var skinEntry;

                return parser.getDependency('skin', nodeDef.skin).then(function (skin) {

                    skinEntry = skin;

                    var pendingJoints = [];

                    for (var i = 0, il = skinEntry.joints.length; i < il; i++) {

                        pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));

                    }

                    return Promise.all(pendingJoints);

                }).then(function (jointNodes) {

                    node.traverse(function (mesh) {

                        //if (!mesh.isMesh) return;

                        if (!(mesh instanceof THREE.Mesh)) {

                            return

                        }

                        var bones = [];
                        var boneInverses = [];

                        for (var j = 0, jl = jointNodes.length; j < jl; j++) {

                            var jointNode = jointNodes[j];

                            if (jointNode) {

                                bones.push(jointNode);

                                var mat = new THREE.Matrix4();

                                if (skinEntry.inverseBindMatrices !== undefined) {

                                    mat.fromArrayEx(skinEntry.inverseBindMatrices.array, j * 16);

                                }

                                boneInverses.push(mat);

                            } else {

                                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);

                            }

                        }

                        mesh.bind(new THREE.Skeleton(bones, boneInverses), mesh.matrixWorld);

                    });

                    return node;

                });

            }).then(function (node) {

                // build node hierachy

                parentObject.add(node);

                var pending = [];

                if (nodeDef.children) {

                    var children = nodeDef.children;

                    for (var i = 0, il = children.length; i < il; i++) {

                        var child = children[i];

                        pending.push(buildNodeHierachy(child, node, json, parser));

                    }

                }

                return Promise.all(pending);

            });

        }

        return function loadScene(sceneIndex) {

            var json = this.json;
            var extensions = this.extensions;
            var sceneDef = this.json.scenes[sceneIndex];
            var parser = this;

            // Loader returns Group, not Scene.
            // See: https://github.com/mrdoob/three.js/issues/18342#issuecomment-578981172
            var scene = new THREE.Group();
            if (sceneDef.name) scene.name = sceneDef.name;

            assignExtrasToUserData(scene, sceneDef);

            if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);

            var nodeIds = sceneDef.nodes || [];

            var pending = [];

            for (var i = 0, il = nodeIds.length; i < il; i++) {

                pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));

            }

            return Promise.all(pending).then(function () {

                return scene;

            });

        };

    }();

    return GLTFLoader;

})();


//THREE.GLTFLoader.SCALE_BASE = 0.001


/***/ }),

/***/ "./loaders/MaterialExchangeExtension.js":
/*!**********************************************!*\
  !*** ./loaders/MaterialExchangeExtension.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialExchangeExtension": function() { return /* binding */ MaterialExchangeExtension; }
/* harmony export */ });
/**
 * Created by Kai on 2021/5/28.
 */

//import {getFileExt, getFileTitle} from '../util/merge.js'

const ALPHA_MODES = THREE.ALPHA_MODES;
const EXTENSIONS = THREE.EXTENSIONS;
const GLTFMeshStandardSGMaterial = THREE.GLTFMeshStandardSGMaterial;
const assignExtrasToUserData = THREE.assignExtrasToUserData
const addUnknownExtensionsToUserData = THREE.addUnknownExtensionsToUserData


class MaterialExchangeExtension {

    constructor(parser, modelUri, state) {

        this.parser = parser;
        this.name = 'JM_material_exchange';

        let json = parser.json
        this.textureCounter = Array.isArray(json.textures) ? json.textures.length : 0
        this.imageCounter = Array.isArray(json.images) ? json.images.length : 0


        if(state.oldVersion){

            this.stateMaterials = state.material

            let json = this.parser.json

            this.getMaterialState = (index)=>{

                let matName = json.materials[index].name

                let curState = null

                this.stateMaterials.some(sm=>{

                    if(sm.name === matName){

                        curState = sm

                        return true
                    }

                })


                return curState
            }
        }
        else{

            this.stateMaterials = (state.material || []).reverse()

            this.getMaterialState = (index)=>{

                return this.stateMaterials[index]

            }
        }
    }


    solveMap(materialParams, stateMaterialParams, srcMap, destMap, parser, pending) {

        let map = !!stateMaterialParams[destMap] && stateMaterialParams[destMap].trim().length ? stateMaterialParams.map.trim() : null


        let ext = getFileExt(map)

        if (map && ext) {

            let json = parser.json

            let name = getFileTitle(map)

            json.textures = json.textures || []

            json.textures.push({
                name: name,
                sampler: 0,
                source: this.textureCounter
            })

            ext = ext === 'jpg' ? 'jpeg' : ext

            json.images = json.images || []
            json.images.push({
                name: name,
                mimeType: "image/" + ext,
                uri: map
            })

            pending.push(parser.assignTexture(materialParams, destMap, {
                index: this.textureCounter
            }));

            this.textureCounter++
            this.imageCounter++

        }
        else if (srcMap !== undefined) {

            pending.push(parser.assignTexture(materialParams, destMap, srcMap));

        }
    }

    extendMaterialParams(materialIndex, materialParams){

        console.log(materialIndex, materialParams);

    }
    //loadMaterial(materialIndex) {
    //
    //    const parser = this.parser;
    //    const json = parser.json;
    //
    //    console.assert(json.materials.length === json.materials.length)
    //
    //    const extensions = this.extensions;
    //    const materialDef = json.materials[materialIndex];
    //
    //    console.log(materialDef);
    //
    //    let materialType;
    //    const materialParams = {};
    //    const materialExtensions = materialDef.extensions || {};
    //    const pending = [];
    //
    //    let stateMaterialParams = {}
    //    let needsUpdate = !1
    //
    //    // envMap - 环境光
    //    let materialState = this.getMaterialState(materialIndex)
    //
    //    if (materialState) {
    //
    //        stateMaterialParams = materialState.uniforms
    //
    //        materialDef.saveMatName = stateMaterialParams.saveMatName
    //
    //        needsUpdate = !0
    //    }
    //
    //    console.log(stateMaterialParams);
    //
    //    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
    //
    //        const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
    //        materialType = sgExtension.getMaterialType();
    //        pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    //
    //    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
    //
    //        const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
    //        materialType = kmuExtension.getMaterialType();
    //        pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    //
    //    } else {
    //
    //        // Specification:
    //        // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
    //        const metallicRoughness = materialDef.pbrMetallicRoughness || {};
    //        materialParams.color = new THREE.Color(1.0, 1.0, 1.0);
    //        materialParams.opacity = 1.0;
    //
    //        if (needsUpdate) {
    //            materialParams.color.setHex(parseInt(stateMaterialParams.color.substr(1), 16))
    //            materialParams.opacity = stateMaterialParams.opacity
    //        }
    //        else if (Array.isArray(metallicRoughness.baseColorFactor)) {
    //
    //            const array = metallicRoughness.baseColorFactor;
    //            materialParams.color.fromArray(array);
    //            materialParams.opacity = array[3];
    //
    //        }
    //
    //
    //        this.solveMap(materialParams, stateMaterialParams, metallicRoughness.baseColorTexture, 'map', parser, pending)
    //
    //        materialDef.uvdata = stateMaterialParams.uvdata
    //
    //        if (needsUpdate) {
    //            materialParams.metalness = stateMaterialParams.metalness !== undefined ? stateMaterialParams.metalness : 1.0;
    //            materialParams.roughness = stateMaterialParams.roughness !== undefined ? stateMaterialParams.roughness : 1.0;
    //        }
    //        else {
    //            materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
    //            materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;
    //        }
    //
    //
    //        //pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
    //        //pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
    //        this.solveMap(materialParams, stateMaterialParams, metallicRoughness.metallicRoughnessTexture, 'metalnessMap', parser, pending)
    //        this.solveMap(materialParams, stateMaterialParams, metallicRoughness.metallicRoughnessTexture, 'roughnessMap', parser, pending)
    //
    //        materialType = parser._invokeOne(function (ext) {
    //
    //            return ext.getMaterialType && ext.getMaterialType(materialIndex);
    //
    //        });
    //
    //        pending.push(Promise.all(parser._invokeAll(function (ext) {
    //
    //            return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
    //
    //        })));
    //
    //    }
    //
    //    if (materialDef.doubleSided === true) {
    //
    //        materialParams.side = THREE.DoubleSide;
    //
    //    }
    //
    //    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    //
    //    if (alphaMode === ALPHA_MODES.BLEND) {
    //
    //        materialParams.transparent = needsUpdate ?  stateMaterialParams.opacity < 1 : true; // See: https://github.com/mrdoob/three.js/issues/17706
    //
    //        materialParams.depthWrite = false;
    //
    //    } else {
    //
    //        materialParams.transparent = needsUpdate ?  stateMaterialParams.opacity < 1 : false;
    //
    //        if (alphaMode === ALPHA_MODES.MASK) {
    //
    //            materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
    //
    //        }
    //
    //    }
    //
    //    if (materialDef.normalTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
    //
    //        //pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture)); // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995
    //        this.solveMap(materialParams, stateMaterialParams, materialDef.normalTexture, 'normalMap', parser, pending)
    //
    //
    //        materialParams.normalScale = new THREE.Vector2(1, -1);
    //
    //        if (materialDef.normalTexture.scale !== undefined) {
    //
    //            materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);
    //
    //        }
    //
    //    }
    //
    //    if (materialDef.occlusionTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
    //
    //        //pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));
    //        this.solveMap(materialParams, stateMaterialParams, materialDef.occlusionTexture, 'aoMap', parser, pending)
    //
    //        if (materialDef.occlusionTexture.strength !== undefined) {
    //
    //            materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
    //
    //        }
    //
    //    }
    //
    //    if (materialDef.emissiveFactor !== undefined && materialType !== THREE.MeshBasicMaterial) {
    //
    //        materialParams.emissive = new THREE.Color().fromArray(materialDef.emissiveFactor);
    //
    //    }
    //
    //    if (materialDef.emissiveTexture !== undefined && materialType !== THREE.MeshBasicMaterial) {
    //
    //        //pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
    //        this.solveMap(materialParams, stateMaterialParams, materialDef.emissiveTexture, 'emissiveMap', parser, pending)
    //
    //    }
    //
    //
    //    // Update parameter session
    //
    //    if(JMK.App.config.state.lights.enableHDR){
    //
    //        parser._invokeOne(function (ext) {
    //
    //            if(ext.attachEnvMap){
    //                pending.push(ext.attachEnvMap(materialParams, materialDef));
    //            }
    //
    //        })
    //    }
    //
    //
    //
    //    return Promise.all(pending).then(function () {
    //
    //        let material;
    //
    //        if (materialType === GLTFMeshStandardSGMaterial) {
    //
    //            material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
    //
    //        } else {
    //
    //            material = new materialType(materialParams);
    //
    //        }
    //
    //        if (materialDef.saveMatName) material.saveMatName = materialDef.saveMatName
    //
    //        if (materialDef.name) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.
    //
    //        if (material.map) {
    //
    //            //material.map.encoding = THREE.sRGBEncoding;
    //
    //            let texture = material.map
    //            texture.textureEncoding = materialDef.textureEncoding ? materialDef.textureEncoding : THREE.sRGBEncoding;
    //            texture.anisotropy = 2;
    //            texture.premultiplyAlpha = false
    //
    //            let uvdata = materialDef.uvdata
    //
    //            if(uvdata){
    //                texture.repeat.set(uvdata[1], uvdata[1]); // 缩放
    //                texture.offset.set(uvdata[2], uvdata[3]); // 平移
    //                texture.rotation = (uvdata[4] / 360) * 2 * Math.PI; // 旋转 rotation is around [ 0.5, 0.5 ]
    //
    //                texture.matrixAutoUpdate = true;
    //            }
    //        }
    //
    //        if (material.emissiveMap) material.emissiveMap.encoding = THREE.sRGBEncoding;
    //
    //        //if(material.envMap) material.reflectivity = 0
    //
    //        assignExtrasToUserData(material, materialDef);
    //
    //        parser.associations.set(material, {
    //            type: 'materials',
    //            index: materialIndex
    //        });
    //
    //        if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
    //
    //        UjP.assetsController.addMaterial(materialIndex, material)
    //
    //        return material;
    //
    //    });
    //}
}


/***/ }),

/***/ "./objects/AutoTour.js":
/*!*****************************!*\
  !*** ./objects/AutoTour.js ***!
  \*****************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

class AutoTour extends THREE.EventDispatcher {
    constructor(scene, teleport) {
        super()
        this._isRunning = !1

        let n = this
        teleport.addEventListener("teleportDone", function () {
          if (n._isRunning) {
            JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS? setTimeout(n.notify.bind(n), JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS):window.requestAnimationFrame(n.notify.bind(n))
          }
        });

        this.teleport = teleport
    }

    isRunning() {
        return this._isRunning
    }

    start(index = -1) {
        console.assert(!this._isRunning);
        this._isRunning = !0;
        this.teleport.isAutoRunning = !0;
        this.dispatchEvent({type: "tourStarted"});
        this.index = index
        this.notify(index)
    }

    stop() {
        console.assert(this._isRunning);
        this._isRunning = !1;
        this.teleport.isAutoRunning = !1;
        //this.teleport.switchToView(this.teleport.lastDestinationView, 0);
        this.teleport.cancelSwitchToView();
        this.dispatchEvent({type: "tourStopped"});
        JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS = 3E3
    }

    notify() {
        this._isRunning && this.teleport.switchToNextVisibleView(4, this.index)
    }
}


JMT.AutoTour = AutoTour


/***/ }),

/***/ "./objects/Scene.js":
/*!**************************!*\
  !*** ./objects/Scene.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": function() { return /* binding */ Scene; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _src_extend_material_j3dStandardMaterialWater_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../src/extend/material/j3dStandardMaterialWater.js */ "./src/extend/material/j3dStandardMaterialWater.js");
/**
 * Created by Kai on 2021/2/14.
 */

//import '../src/materials/StandardMaterialWater.js'


function has(a, b, c) {   // a
    c = c || "id";
    for (var d = 0; d < a.length; d += 1) {
        if (a[d].hasOwnProperty(c) && a[d][c] === b) {
            return !1;
        }
    }
    return !0
}

function findBy(a, b, c) {    //  b
    c = c || "id";

    if(c === "id")
    {
        b = parseInt(b);
    }

    for (var d = 0; d < a.length; d += 1) {
        if (a[d][c] === b) {
            return a[d];
        }
    }
    return null
}

function stringCompare(a, b) {  // c
    a = a.name.toUpperCase();
    b = b.name.toUpperCase();
    return a < b ? -1 : a > b ? 1 : 0
}

function shift(a, b, c) {   //d
    var d = a[b]
    var e = c > b ? 1 : -1
    for (; b !== c; b += e) {
        a[b] = a[b + e];
    }
    a[c] = d
}

var _ORG_ID = 0;

class Scene extends THREE.EventDispatcher {

    constructor(camera) {
        super()
        this.id = _ORG_ID++;
        this._headLight = !1;

        this.threeScene = new THREE.Scene;
        this.threeScene.background = new THREE.Color(3355443)

        this.autoAddLightProbes = !0;

        this.autoTour = {
            disabled: !1,
            startOnLoad: !1
        };


        this.disableProgressiveLoader = !1;
        this.camera = camera;
        this._initCameraEvents(camera)

        this._colorMap = null;
        this.materials = [];
        this._mainAnimatedMaterials = new Set;
        this._animatedMeshes = [];
        this._disabledMaterials = [];
        this._sortedMaterials = null;
        this.nodeConfigs = [];
        this._nodeConfigsLookup = {};
        this.nodes = [];
        this._nodeLookup = {};
        this.gpuMeshes = [];
        this.mirrors = [];
        this._animatableAuxiliaryObjects = new Set;
        this.boundingBox = new THREE.Box3;
        this._sumLogicalMeshCenter = new THREE.Vector3;
        this._logicalNonemptyMeshCount = 0;
        this._center = new THREE.Vector3;
        this.skyMeshes = [];
        this.hideViewsMenu = !1;
        this.views = [];
        this.lights = [];
        this.lightProbes = [];
        this.cameraVolumes = [];

        this.tours = []

        // getAnimatedMaterials
        this._notMeet = !1
        this._animatedMaterials = new Map;

        //_updateSceneCenterWithGpuMesh
        this._sceneCenterWithGpuMesh = new THREE.Vector3();

    }

    clearAll() {

        this.threeScene.background = new THREE.Color(3355443)
        this.threeScene.children = []

        this.tours.forEach(tour=> {
            this.removeTour(tour)
        })
        this.tours = []

        this.cameraVolumes.forEach(cv=> {
            this.removeCameraVolume(cv)
        })
        this.cameraVolumes = []

        this.lightProbes.forEach(lp=> {
            this.removeLightProbe(lp)
        })
        this.lightProbes = []

        this.lights.forEach(l=> {
            this.removeLight(l)
        })
        this.lights = []

        this.views.forEach(v=> {
            this.removeView(v)
        })
        this.views = []

        //this.skyMeshes.forEach(sk=> {
        //    if(sk.name !== JMT.EDITOR_CONTROLLED_SKY_NAME){
        //        this.removeSkyMesh(sk)
        //    }
        //})
        //this.skyMeshes = []

        this.mirrors.forEach(m=> {
            // TODO: How to remove ?
        })
        this.mirrors = []

        this.gpuMeshes.forEach(g=> {
            // TODO: How to remove ?
        })
        this.gpuMeshes = []

        //this._nodeLookup.forEach(n=>{
        //    // TODO: How to remove ?
        //})
        this._nodeLookup = {}

        this.nodes.forEach(g=> {
            // TODO: How to remove ?
        })
        this.nodes = []

        //this._nodeConfigsLookup.forEach(n=>{
        //    // TODO: How to remove ?
        //})
        this._nodeConfigsLookup = {};

        this.nodeConfigs.forEach(g=> {
            // TODO: How to remove ?
        })
        this.nodeConfigs = [];


        this._sortedMaterials = null;


        this._disabledMaterials.forEach(g=> {
            // TODO: How to remove ?
        })
        this._disabledMaterials = [];


        this._animatedMeshes.forEach(g=> {
            // TODO: How to remove ?
        })
        this._animatedMeshes = [];

        // TODO: How to remove ?
        this._mainAnimatedMaterials = new Set;

        this.materials.forEach(m=> {
            // TODO: How to remove ?
            m.dispose()
        })
        this.materials = [];

        // TODO: How to remove ?
        this._colorMap = null;


        this.autoTour = {
            disabled: !1,
            startOnLoad: !1
        };


        this.autoAddLightProbes = !0;

        this._headLight = !1;


    }

    canStartAutoTour() {

        return !this.autoTour.disabled && 1 < this.visibleViews().length

    }

    startAutoTourOnLoad() {

        return this.canStartAutoTour() && this.autoTour.startOnLoad

    }

    _initCameraEvents(camera) {

        let l = this
        camera.addEventListener("cameraUpdated", l._onSceneChanged.bind(l));

        camera.addEventListener("exposureUpdated", function (a) {
            var b = camera.exposure;
            l.materials.forEach(function (a) {
                void 0 !== a.cameraExposure && (a.cameraExposure = b)
            });
            l.skyMeshes.forEach(function (a) {
                a = a.material;
                void 0 !== a.cameraExposure && (a.cameraExposure = b)
            })
        });

        camera.addEventListener("gammaUpdated", function (a) {
            var b = camera.gamma;
            l.materials.forEach(function (a) {
                void 0 !== a.cameraGamma && (a.cameraGamma = b)
            });
            l.skyMeshes.forEach(function (a) {
                a = a.material;
                void 0 !== a.cameraGamma && (a.cameraGamma = b)
            })
        })

        camera.addEventListener("colorMapUpdated", function () {
            var a = camera.colorMap;
            l.materials.forEach(function (b) {
                void 0 !== b.colorMap && (b.colorMap = a);
                b.setUniforms()
            });
            l.skyMeshes.forEach(function (b) {
                b.material.colorMap = a
            });
            l._onSceneChanged();
        });
    }

    _onSceneChanged() { // f
        this.dispatchEvent({type: "sceneChanged"})
    }

    _onViewUpdated() {  // h
        this.dispatchEvent({type: "anyViewUpdated"});

        this._onSceneChanged();
    }

    _onMaterialUpdated(a) { // k
        let l = this
        a = a.target;
        var b = l._mainAnimatedMaterials.has(a);

        if (a.isAnimated && !b) {
            l._mainAnimatedMaterials.add(a)
        }
        else {
            !a.isAnimated && b && l._mainAnimatedMaterials.delete(a);
        }

        //this._onSceneChanged();
    }

    _onConfigUpdated() { //n
        let l = this
        l._animatedMeshes.length = 0;

        for (var a = $jscomp.makeIterator(l.gpuMeshes), b = a.next(); !b.done; b = a.next()) {

            b = b.value

            b.isAnimated && l._animatedMeshes.push(b)
        }

        this._onSceneChanged();
    }

    _onVisitNode(a) { // p
        this._nodeLookup[a.id] = a
    }

    serialize() {
        return {
            disableProgressiveLoader: this.disableProgressiveLoader,
            autoTour: this.autoTour,
            tours: this.tours.map(function (a) {
                return a.serialize()
            }),
            camera: this.camera.serialize(),
            materials: this.materials.map(function (a) {
                return a.serialize()
            }),
            nodeConfigs: this.nodeConfigs.map(function (a) {
                return a.serialize()
            }),
            nodes: this.nodes.map(function (a) {
                return a.serialize()
            }),
            lights: this.lights.map(function (a) {
                return a.serialize()
            }),
            lightProbes: this.lightProbes.map(function (a) {
                return a.serialize()
            }),
            cameraVolumes: this.cameraVolumes.map(function (a) {
                return a.serialize()
            }),
            autoAddLightProbes: !1,
            views: this.views.filter(function (a) {
                return !a.internal
            }).map(function (a) {
                return a.serialize()
            }),
            skies: this.skyMeshes.filter(function (a) {
                return a.name !== JMT.DEFAULT_SKY_NAME
            }).map(function (a) {
                return a.serialize()
            })
        }
    }

    addMaterial(a) {
        this.materials.push(a);
        a.addEventListener("materialUpdated", this._onMaterialUpdated.bind(this));
        a.isAnimated && this._mainAnimatedMaterials.add(a);
        if (this.camera.colorMapReady) {
            this.camera.colorMapReady() && void 0 !== a.colorMap && (a.colorMap = this.camera.colorMap);
            void 0 !== a.cameraExposure && (a.cameraExposure = this.camera.exposure);
            void 0 !== a.cameraGamma && (a.cameraGamma = this.camera.gamma);
        }
        void 0 !== a.headLight && (a.headLight = this.headLight)
    }

    replaceMaterial(material, typeOfMaterial) {

        var c = this.materials.indexOf(material);

        void 0 === this._disabledMaterials[c] && (this._disabledMaterials[c] = new Map);

        this._disabledMaterials[c].set(material.type, material);

        var newMaterial = this._disabledMaterials[c].get(typeOfMaterial);

        if (!newMaterial) {

            newMaterial = JMT.createMaterialOfType(typeOfMaterial)

            newMaterial.addEventListener("materialUpdated", this._onMaterialUpdated.bind(this))

            newMaterial.name = material.name

            0 === this.lightProbes.length && (newMaterial.disableLightProbeTmp = !0)
        }

        this.materials[c] = newMaterial;
        this.materialsListNeedsUpdate = !0

        this._onSceneChanged();

        for (var b = 0; b < this.gpuMeshes.length; b += 1) {

            if (this.gpuMeshes[b].material === material) {

                this.gpuMeshes[b].material = newMaterial

            }
        }

        material.isAnimated && this._mainAnimatedMaterials.delete(material);

        material.dispose()

        newMaterial.isAnimated && this._mainAnimatedMaterials.add(newMaterial);

        this._sortedMaterials = null;

        newMaterial.setUniforms();

        return newMaterial
    }

    addNodeConfig(a) {
        this.nodeConfigs.push(a);
        this._nodeConfigsLookup[a.name] = a;
        a.addEventListener("configUpdated", this._onConfigUpdated.bind(this))
    }

    findNodeConfig(a) {
        return this._nodeConfigsLookup.hasOwnProperty(a) ? this._nodeConfigsLookup[a] : null
    }

    addNode(a) {
        this.nodes.push(a);
        a.visitSubtree(this._onVisitNode.bind(this))
    }

    findNode(a) {
        return this._nodeLookup[a]
    }

    visitAllNodes(a) {
        for (var b = 0; b < this.nodes.length; b += 1)this.nodes[b].visitSubtree(a)
    }

    visitMeshesWithMaterial(material, callback) {
        if (material) {
            this.visitAllNodes(function (node) {
                let m = node.mesh
                if (m && m.material === material) {
                    callback(m, node)
                }
                //(c = c.mesh) && c.material === a && b(c)
            })
        }
    }

    sortedMaterials() {
        if (null === this._sortedMaterials || this.materialsListNeedsUpdate) {
            this._sortedMaterials = this.materials.slice(0).sort(stringCompare)
            this.materialsListNeedsUpdate = !1
        }
        return this._sortedMaterials
    }

    _updateSceneCenterWithGpuMesh(b) {

        if (b.logicalMeshes) {

            for (var c = 0; c < b.logicalMeshes.length; c += 1) {

                var d = b.logicalMeshes[c].geometry.boundingBox;

                if (!d.isEmpty()) {

                    //d.center(this._sceneCenterWithGpuMesh)
                    d.getCenter(this._sceneCenterWithGpuMesh)

                    this._sumLogicalMeshCenter.add(this._sceneCenterWithGpuMesh)

                    ++this._logicalNonemptyMeshCount
                }
            }
        }
        else {
            b = b.geometry.boundingBox

            if (!b.isEmpty()) {
                b.getCenter(this._sceneCenterWithGpuMesh)

                this._sumLogicalMeshCenter.add(this._sceneCenterWithGpuMesh)

                ++this._logicalNonemptyMeshCount
            }
        }

        if (this._logicalNonemptyMeshCount) {

            this._center.copy(this._sumLogicalMeshCenter).divideScalar(this._logicalNonemptyMeshCount)

        }
    }

    addGpuMesh(a) {
        a.isAnimated && this._animatedMeshes.push(a);

        if (a.material.planarReflector) {

            var b = new JMT.Mirror(
                this.threeScene,
                this.camera,
                {
                    clipBias: 0,
                    color: 8355711,
                    debugMode: !1
                }
            );

            b.material.name = a.material.name;

            var c = a.geometry;

            console.assert(c.boundingBox);

            var d = c.boundingBox

            var e = Math.sqrt(Math.pow(d.max.x - d.min.x, 2) + Math.pow(d.max.z - d.min.z, 2))
            var f = d.max.y - d.min.y;

            if (e && f) {
                e = new THREE.Mesh(new THREE.PlaneBufferGeometry(e, f), b.material)

                e.rotation.y = Math.atan2(c.normals[0], c.normals[2])

                d.center(e.position)

                e.geometry.boundingBox = d

                e.add(b)

                b = e
            }
            else {
                JMT.log("mirror with 0 dimension")

                b = null
            }

            this.mirrors.push(b.children[0]);

            this.addAuxiliaryObject(b)

        }
        else {

            this.addAuxiliaryObject(a);

        }
        this.gpuMeshes.push(a);

        this.boundingBox.union(a.geometry.boundingBox);

        this._updateSceneCenterWithGpuMesh(a)
    }

    addAuxiliaryObject(a, b) {
        b = void 0 === b ? !1 : b;
        this.threeScene.add(a);
        b && this._animatableAuxiliaryObjects.add(a)
    }

    removeAuxiliaryObject(a) {
        this.threeScene.remove(a);
        this._animatableAuxiliaryObjects.delete(a)
    }

    addSkyMesh(a) {
        var b = a.material;
        this.skyMeshes.push(a);
        if (this.camera.colorMapReady) {
            this.camera.colorMapReady() && (b.colorMap = this.camera.colorMap);
            void 0 !== b.cameraExposure && (b.cameraExposure = this.camera.exposure);
            void 0 !== b.cameraGamma && (b.cameraGamma = this.camera.gamma);
        }
        a.addEventListener("skyMeshUpdated", this._onSceneChanged.bind(this));
        this.dispatchEvent({type: "skyMeshAdded", skyMesh: a})
    }

    removeSkyMesh(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, this.skyMeshes);
        this.dispatchEvent({type: "skyMeshRemoved", skyMesh: a});
        a.geometry.dispose();
        a.material.map && a.material.map.dispose();
        a.material.dispose()
    }

    findSkyMesh(a) {
        return findBy(this.skyMeshes, a, "name")
    }

    addTour(tour) {
        tour.name = tour.name || 'tour' + this.tours.length
        console.assert(has(this.tours, tour.name, "name"));
        this.tours.push(tour)
        //tour.addEventListener('tourUpdated')
        //tour.addEventListener('viewAdded')
        //tour.addEventListener('viewRemoved')
        this._onSceneChanged();
        this.dispatchEvent({type: "tourAdded", tour: tour})
    }

    removeTour(tour) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(tour, this.tours);
        //tour.addEventListener('tourUpdated')
        //tour.addEventListener('viewAdded')
        //tour.addEventListener('viewRemoved')
        this._onSceneChanged();
        this.dispatchEvent({type: "tourRemoved", tour: tour})
    }

    findTour(id) {
        return findBy(this.tours, id)
    }

    addLight(light) {
        console.assert(has(this.lights, light.name, "name"));
        this.lights.push(light);
        light.addEventListener("lightUpdated", this._onSceneChanged.bind(this));
        light.addEventListener("lightInstanceAdded", this._onSceneChanged.bind(this));
        light.addEventListener("lightInstanceRemoved", this._onSceneChanged.bind(this));
        this._onSceneChanged();
        this.dispatchEvent({type: "lightAdded", light: light})
    }

    removeLight(light) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(light, this.lights);
        this._onSceneChanged();
        this.dispatchEvent({type: "lightRemoved", light: light})
    }

    addLightProbe(b) {
        console.assert(has(this.lightProbes, b.id));
        this.lightProbes.push(b);
        b.addEventListener("lightProbePositionUpdated", this._onSceneChanged.bind(this));
        b.addEventListener("lightProbeBoundsUpdated", this._onSceneChanged.bind(this));
        this._onSceneChanged();
        this.dispatchEvent({type: "lightProbeAdded", lightProbe: b})
    }

    removeLightProbe(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, this.lightProbes);
        for (var b = 0; b < this.gpuMeshes.length; b += 1) {
            if (this.gpuMeshes[b].lightProbe === a) {
                this.gpuMeshes[b].lightProbe = null
            }
        }
        this._onSceneChanged();
        this.dispatchEvent({type: "lightProbeRemoved", lightProbe: a});
        a.dispose()
    }

    findLightProbe(a) {
        return findBy(this.lightProbes, a)
    }

    addCameraVolume(b) {
        console.assert(has(this.cameraVolumes, b.id));
        this.cameraVolumes.push(b);
        b.addEventListener("cameraVolumeUpdated", this._onSceneChanged.bind(this));
        this._onSceneChanged();
        this.dispatchEvent({type: "cameraVolumeAdded", cameraVolume: b})
    }

    removeCameraVolume(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, this.cameraVolumes);
        this._onSceneChanged();
        this.dispatchEvent({type: "cameraVolumeRemoved", cameraVolume: a});
        a.dispose()
    }

    findCameraVolume(a) {
        return findBy(this.cameraVolumes, a)
    }

    shiftCameraVolume(a, b) {
        shift(this.cameraVolumes, this.cameraVolumes.indexOf(a), b);
        this.dispatchEvent({type: "cameraVolumeShifted", cameraVolume: a})
    }

    findView(a) {
        return findBy(this.views, a)
    }

    findViewByName(a) {
        return findBy(this.views, a, "name")
    }

    visibleViews() {
        return (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.filter)(this.views, function (a) {
            return !a.hideFromMenu
        })
    }

    visibleViewsOfTour(index) {

        if (this.tours.length <= 0 || this.tours.length <= index || index === -1) {
            return this.visibleViews()
        }

        let tour = this.tours[index]

        let views = []


        if (tour.views && tour.views.length) {
            tour.views.forEach(viewId=> {
                let view = this.views.find(v=> {
                    return (!v.hideFromMenu) && v.id === viewId.id
                })
                if(!!view){
                    view.moveTime = viewId.moveTime;
                    view.stopTime = viewId.stopTime;
                    view.evenMove = viewId.evenMove;
                    views.push(view)
                }
            })
        }

        return views
    }

    addView(b) {
        console.assert(has(this.views, b.id));
        this.views.push(b);
        b.addEventListener("viewUpdated", this._onViewUpdated.bind(this));
        this._onSceneChanged();
        this.dispatchEvent({type: "viewAdded", view: b})
    }

    removeView(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, this.views);
        this.nodeConfigs.forEach(function (b) {
            b.removeFromHideInViews(a.id)
        });
        this._onSceneChanged();
        this.dispatchEvent({type: "viewRemoved", view: a})
    }

    shiftView(a, b) {
        shift(this.views, this.views.indexOf(a), b);
        this.dispatchEvent({type: "viewShifted", view: a})
    }

    hasLightMap() {
        return void 0 !== (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.find)(this.materials, function (a) {
                return a.lightMapped
            })
    }

    adjustSkiesAndCameraFarToSpanWholeScene() {
        for (var a = 0, b = 0; b < this.skyMeshes.length; b += 1) {
            var c = this.skyMeshes[b];
            c.autoPosition && c.position.copy(this.center);
            if (this.boundingBox.isEmpty())var d = 0; else {
                var e = this.boundingBox, f = c.position;
                d = Math.max(Math.abs(e.min.x - f.x), Math.abs(e.max.x - f.x));
                var g = Math.max(Math.abs(e.min.y - f.y), Math.abs(e.max.y - f.y));
                e = Math.max(Math.abs(e.min.z - f.z), Math.abs(e.max.z - f.z));
                d = Math.sqrt(d * d + g * g +
                    e * e)
            }
            d += JMT.SKY_DISTANCE_TO_SCENE;
            c.radius = d;
            a = Math.max(a, d)
        }

        if (this.camera.setFar) {
            this.camera.setFar(Math.max(this.camera.far, 2 * a));
            JMT.log("Camera far set to " + this.camera.far)
        }
    }

    disableLightProbesForMaterials() {
        for (var a = 0; a < this.materials.length; a += 1) {
            this.materials[a].disableLightProbeTmp = !0
            this.materials[a].setUniforms && this.materials[a].setUniforms()
        }
    }

    enableLightProbesForMaterials() {
        for (var a = 0; a < this.materials.length; a += 1) {
            this.materials[a].disableLightProbeTmp = !1
            this.materials[a].setUniforms && this.materials[a].setUniforms()
        }
    }

    getAnimatedMaterials() {
        let n = this

        function c(object) {
            if (object instanceof THREE.Mesh && object.material.isAnimated) {
                n._animatedMaterials.set(object.material, d)
            }
        }

        var d = !n._notMeet

        var e = $jscomp.makeIterator(n._mainAnimatedMaterials)
        for (var f = e.next(); !f.done; f = e.next()) {
            n._animatedMaterials.set(f.value, d);
        }

        e = $jscomp.makeIterator(n._animatableAuxiliaryObjects);
        for (f = e.next(); !f.done; f = e.next()) {

            f.value.traverse(c);

        }

        e = $jscomp.makeIterator(n._animatedMaterials);
        for (f = e.next(); !f.done; f = e.next()) {
            f = $jscomp.makeIterator(f.value);

            var g = f.next().value;

            if (f.next().value === n._notMeet) {
                n._animatedMaterials.delete(g)
            }
        }

        n._notMeet = d;

        return n._animatedMaterials.keys()
    }

    getAnimatedMeshes() {
        return this._animatedMeshes
    }


    get center() {
        return this._center
    }

    get headLight() {
        return this._headLight
    }

    set headLight(a) {
        if (a !== this._headLight) {
            this._headLight = a
            this.materials.forEach(function (b) {
                b.headLight = a;
                b.setUniforms()
            })
        }
    }

    traverse(callback) {
        this.threeScene.traverse(callback)
    }
}


JMT.createMaterialOfType = function (a) {

    if ("water" === a) {

        return new JMT.j3dStandardMaterialWater()

    }
    else {

        return new JMT.j3dStandardMaterial()
        
    }
}


JMT.Scene = Scene

/***/ }),

/***/ "./objects/Tour.js":
/*!*************************!*\
  !*** ./objects/Tour.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tour": function() { return /* binding */ Tour; }
/* harmony export */ });
/**
 * Created by Kai on 2021/2/28.
 */


class Tour extends THREE.EventDispatcher{
    constructor(config={}){
        super()

        this._name = config.name
        this._id = config.id || JMT.genUUID()
        this._views = config.views || []
        this._description = config.description
        this._automaticTour = !!config.automaticTour
        this._startOnSceneLoad = !!config.startOnSceneLoad

        Object.defineProperty(this, 'name', {
            get: ()=>{
                return this._name
            },
            set: name=>{
                this._name = name
                this._update()
            }
        })

        Object.defineProperty(this, 'id', {
            get: ()=>{
                return this._id
            }
        })


        Object.defineProperty(this, 'views', {
            get: ()=>{
                return this._views
            },
            set: value=>{
                this._views = value
                this._update()
            }
        })


        Object.defineProperty(this, 'description', {
            get: ()=>{
                return this._description
            },
            set: value=>{
                this._description = value
                this._update()
            }
        })


        Object.defineProperty(this, 'automaticTour', {
            get: ()=>{
                return this._automaticTour
            },
            set: value=>{
                this._automaticTour = value
                this._update()
            }
        })


        Object.defineProperty(this, 'startOnSceneLoad', {
            get: ()=>{
                return this._startOnSceneLoad
            },
            set: value=>{
                this._startOnSceneLoad = value
                this._update()
            }
        })
    }

    addView(viewId){

        this.dispatchEvent({type:'viewAdded', tour: this})

        this._update()
    }

    removeView(viewId){

        this.dispatchEvent({type:'viewRemoved', tour: this})

        this._update()
    }

    _update(){
        this.dispatchEvent({type:'tourUpdated', tour: this})
    }

    serialize(){
        return {
            name : this._name,
            id : this._id,
            views: this._views,
            description: this._description,
            startOnSceneLoad : this._startOnSceneLoad,
            automaticTour: this._automaticTour
        }
    }
}

JMT.Tour = Tour

/***/ }),

/***/ "./objects/View.js":
/*!*************************!*\
  !*** ./objects/View.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "View": function() { return /* binding */ View; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


var DEFAULT_ID = 1E3

var DEFAULT_CONFIG = {
    internal: !1,
    position: [0, 0, 0],
    rotation: [0, 0],
    hideFromMenu: !0,
    sky: JMT.EDITOR_CONTROLLED_SKY_NAME
};

class View extends THREE.EventDispatcher {

    constructor(config) {
        super()

        this.deserialize(config)

        Object.defineProperty(this, 'upAngle', {
            get: ()=>{
                return [THREE.Math.radToDeg(this.minUpAngle), THREE.Math.radToDeg(this.maxUpAngle)]

            },
            set: (value)=>{
                this.minUpAngle = THREE.Math.degToRad(value[0])
                this.maxUpAngle = THREE.Math.degToRad(value[1])
                this._updated()
            }
        })

        Object.defineProperty(this, 'sideAngle', {
            get: ()=>{
                return [THREE.Math.radToDeg(this.minSideAngle), THREE.Math.radToDeg(this.maxSideAngle)]
            },
            set: (value)=>{
                this.minSideAngle = THREE.Math.degToRad(value[0])
                this.maxSideAngle = THREE.Math.degToRad(value[1])
                this._updated()
            }
        })


        Object.defineProperty(this, 'thumb', {
            get: ()=>{
                return this._thumb
            },
            set: (value)=>{
                this._thumb = value
                this._updated()
            }
        })
    }

    _updated() {
        return this.dispatchEvent({type: "viewUpdated", target: this})
    }

    isTop() {
        return "orbit" === this.mode && this.panPrimary && this.noPitchRotate
    }

    isOrbit() {
        return "orbit" === this.mode && !this.isTop()
    }

    usesDefaultSky() {
        return this.sky === JMT.DEFAULT_SKY_NAME
    }

    switchSky() {
        if (this.usesDefaultSky()) {
            this.sky = JMT.EDITOR_CONTROLLED_SKY_NAME
        }
        else {
            this.sky = JMT.DEFAULT_SKY_NAME;
        }
        this._updated()
    }

    setName(a) {
        this.name = a;
        this._updated()
    }

    setYaw(a) {
        this.rotation.yaw = a;
        this._updated()
    }

    setMinUpAngle(a) {
        if (a !== this.minUpAngle) {
            this.minUpAngle = a
            this._updated()
        }
    }

    setMaxUpAngle(a) {
        if (a !== this.maxUpAngle) {
            this.maxUpAngle = a
            this._updated()
        }
    }

    setHideFromMenu(a) {
        if (a !== this.hideFromMenu) {
            this.hideFromMenu = a
            this._updated()
        }
    }

    serialize() {
        var a = this
        var b = {
            id: this.id,
            name: this.name,
            mode: this.mode,
            rotation: this.rotation.toDegTriple().slice(0, 2),
            hideFromMenu: this.hideFromMenu || !1,
            sky: this.sky
        };
        this.position && (b.position = this.position.toArray());
        this.target && (b.target = this.target.toArray());
        -Infinity !== this.minSideAngle && (b.minSideAngle = this.minSideAngle);
        Infinity !== this.maxSideAngle && (b.maxSideAngle = this.maxSideAngle);
        "distance minDistance maxDistance panPrimary noPan noRotate noPitchRotate minUpAngle maxUpAngle fov".split(" ").forEach(function (c) {
            void 0 !== a[c] && (b[c] = a[c])
        });
        a.thumb && (b.thumb = a.thumb)
        return b
    }

    deserialize(config){

        void 0 === config && (config = DEFAULT_CONFIG);
        this.id = void 0 !== config.id ? config.id : DEFAULT_ID++;
        this.name = config.name || "view" + this.id;
        this.internal = config.internal || !1;

        if (config.position) {
            this.position = new THREE.Vector3(
                config.position[0],
                config.position[1],
                config.position[2]
            )
        }

        this.rotation = new JMT.Euler(
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(THREE.Math.degToRad(config.rotation[0])),
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(THREE.Math.degToRad(config.rotation[1])),
            0
        );


        this.hideFromMenu = config.hideFromMenu || !1;
        this.sky = config.sky || JMT.EDITOR_CONTROLLED_SKY_NAME;
        this.mode = config.mode || "fps";
        this.distance = config.distance;
        this.minDistance = config.minDistance;
        this.maxDistance = config.maxDistance;
        this.panPrimary = config.panPrimary;
        this.noPan = config.noPan;
        this.noRotate = config.noRotate;
        this.noPitchRotate = config.noPitchRotate;
        this.minUpAngle = void 0 === config.minUpAngle ? -Math.PI / 2 : config.minUpAngle;
        this.maxUpAngle = void 0 === config.maxUpAngle ? Math.PI / 2 : config.maxUpAngle;
        this.minSideAngle = void 0 === config.minSideAngle ? -Infinity : config.minSideAngle;
        this.maxSideAngle = void 0 === config.maxSideAngle ? Infinity : config.maxSideAngle;
        if(config.target){
            this.target = new THREE.Vector3(config.target[0], config.target[1], config.target[2])
        }
        this.fov = config.fov;

        config.thumb && (this._thumb = config.thumb)
    }
}

JMT.View = View


/***/ }),

/***/ "./src/App.editor.js":
/*!***************************!*\
  !*** ./src/App.editor.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Editor": function() { return /* binding */ Editor; }
/* harmony export */ });
/* harmony import */ var _App_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App.js */ "./src/App.js");
/* harmony import */ var _controllers_LightControls_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controllers/LightControls.js */ "./src/controllers/LightControls.js");
/* harmony import */ var _controllers_LightProbeControls_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./controllers/LightProbeControls.js */ "./src/controllers/LightProbeControls.js");
/* harmony import */ var _cameras_CameraVolume_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cameras/CameraVolume.js */ "./src/cameras/CameraVolume.js");
/* harmony import */ var _controllers_CameraVolumeControls_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./controllers/CameraVolumeControls.js */ "./src/controllers/CameraVolumeControls.js");
/* harmony import */ var _editor_EditorSelector_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./editor/EditorSelector.js */ "./src/editor/EditorSelector.js");
/* harmony import */ var _editor_EditorHooks_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./editor/EditorHooks.js */ "./src/editor/EditorHooks.js");
/* harmony import */ var _lights_arrangeLightProbes_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lights/arrangeLightProbes.js */ "./src/lights/arrangeLightProbes.js");
/**
 * Created by Kai on 2021/1/22.
 */


// 以下js编辑用
//import './lib/WebFontConfig.js'







//import './materials/DebugMaterial.js'
//import './utils/ObjectDistanceQuery.js'

//import {AlignControls} from '../controls/AlignControls.js'

//JMT.AlignControls = AlignControls

JMT.EDIT_MODE = true

class Editor extends _App_js__WEBPACK_IMPORTED_MODULE_0__.App{
    constructor(config){
        super(config)

        JMT.initEditMode = this.initEditMode.bind(this)

    }


    initEditMode(a) {
        var b = document.createElement("base");
        b.target = "_blank";
        document.head.appendChild(b);
        //this.loadFontFamilies(Object.keys(this.defaultFont), function () {
        this.initViewMode(a)

        this.mergeConfig.setAllMaterialsEditable();

        //})
    }


    getApiHook(appScene){

        this.editorHooks = new _editor_EditorHooks_js__WEBPACK_IMPORTED_MODULE_6__.EditorHooks(appScene, this.ui, this.controls, this.teleport, this.editorSelector, this.extensionsManager, this.screenshotTaker, this.aniController)

        return this.editorHooks
    }

    //notifyLoadComplete(appScene) {
    //    App.prototype.notifyLoadComplete.call(this, appScene)
    //}

    start(config) { //init
        config.mode = 1
        this.initEditMode(config)
    }

    _solveLightProbe(appScene, headless){

        var lightProbeMaker = this._enableLightProbes(appScene)


        if (lightProbeMaker) {

            this.initLightProbesEvent(appScene, lightProbeMaker)

        }
        else {

            console.warn("Cube maps support is required in the edit mode");

        }

        var lightControls = new _controllers_LightControls_js__WEBPACK_IMPORTED_MODULE_1__.LightControls(appScene, this.aniController);

        var lightProbeControls = new _controllers_LightProbeControls_js__WEBPACK_IMPORTED_MODULE_2__.LightProbeControls(appScene, this.aniController)

        var cameraVolumeControls = new _controllers_CameraVolumeControls_js__WEBPACK_IMPORTED_MODULE_4__.CameraVolumeControls(appScene, this.aniController);

        this.editorSelector = new _editor_EditorSelector_js__WEBPACK_IMPORTED_MODULE_5__.EditorSelector(this.pointerEventDispatcher, appScene, this.webGLRenderer, this.collider, lightControls, lightProbeControls, cameraVolumeControls, this.aniController, this.controls);

        //this.screenshotTaker.coverToServer(JMT.EDITOR_COVER_WIDTH, JMT.EDITOR_COVER_HEIGHT);

        this.getViewer().moveAndHeadTo(this.config.forcedInitialCameraPosition, this.config.forcedInitialCameraRotation)

    }


    K(a, b, c) {
        function d(f) {
            if (f === a.length) {
                c();
            }
            else {
                var g = a[f], h = g.name;
                if (e.has(h)) {
                    d(f + 1)
                }
                else {
                    e.add(h)
                    b.panoramaToServer(g, function () {
                        return d(f + 1)
                    })
                }
            }
        }

        var e = new Set;
        d(0)
    }

    _notifyLoadComplete(appScene, headless){
        if(headless){
            let t = this
            function onNotifyLoadComplete(){
                t.notifyLoadComplete(appScene)
            }
            this.K(this.sceneLoader.panoramas, this.screenshotTaker, onNotifyLoadComplete)
        }
        else {
            this.notifyLoadComplete(appScene)
        }
    }

    _arrangeLightProbes(appScene, lightProbeMaker, headless){

        if (0 === appScene.lightProbes.length && appScene.autoAddLightProbes) {

            (0,_lights_arrangeLightProbes_js__WEBPACK_IMPORTED_MODULE_7__.arrangeLightProbes)(appScene, lightProbeMaker, headless);  // a, d, c

        }
    }
}


JMT.Editor = Editor


/***/ }),

/***/ "./src/App.js":
/*!********************!*\
  !*** ./src/App.js ***!
  \********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "App": function() { return /* binding */ App; }
/* harmony export */ });
/* harmony import */ var _Config_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Config.js */ "./Config.js");
/* harmony import */ var _Config_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_Config_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils_Detector_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/Detector.js */ "./utils/Detector.js");
/* harmony import */ var _utils_ajax_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/ajax.js */ "./utils/ajax.js");
/* harmony import */ var _ui_GamepadManager_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../ui/GamepadManager.js */ "./ui/GamepadManager.js");
/* harmony import */ var _ui_GamepadManager_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_ui_GamepadManager_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _MergeConfig_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MergeConfig.js */ "./src/MergeConfig.js");
/* harmony import */ var _MergeConfig_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_MergeConfig_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _renderers_Renderer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderers/Renderer.js */ "./src/renderers/Renderer.js");
/* harmony import */ var _extensions_ExtensionsManager_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../extensions/ExtensionsManager.js */ "./extensions/ExtensionsManager.js");
/* harmony import */ var _webxr_VRManager_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webxr/VRManager.js */ "./webxr/VRManager.js");
/* harmony import */ var _webxr_VRHeightController_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webxr/VRHeightController.js */ "./webxr/VRHeightController.js");
/* harmony import */ var _controllers_AnimationController_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./controllers/AnimationController.js */ "./src/controllers/AnimationController.js");
/* harmony import */ var _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cameras/Camera.js */ "./src/cameras/Camera.js");
/* harmony import */ var _controllers_Controls_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./controllers/Controls.js */ "./src/controllers/Controls.js");
/* harmony import */ var _core_Viewer_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/Viewer.js */ "./src/core/Viewer.js");
/* harmony import */ var _extend_controllers_j3dCutoutTextureDetector_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./extend/controllers/j3dCutoutTextureDetector.js */ "./src/extend/controllers/j3dCutoutTextureDetector.js");
/* harmony import */ var _objects_Scene_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../objects/Scene.js */ "./objects/Scene.js");
/* harmony import */ var _loaders_SceneLoader_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./loaders/SceneLoader.js */ "./src/loaders/SceneLoader.js");
/* harmony import */ var _controllers_ExposureController_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./controllers/ExposureController.js */ "./src/controllers/ExposureController.js");
/* harmony import */ var _controllers_ExposureController_js__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_controllers_ExposureController_js__WEBPACK_IMPORTED_MODULE_16__);
/* harmony import */ var _utils_PointerEventDispatcher_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/PointerEventDispatcher.js */ "./src/utils/PointerEventDispatcher.js");
/* harmony import */ var _extend_controllers_j3dCollider_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./extend/controllers/j3dCollider.js */ "./src/extend/controllers/j3dCollider.js");
/* harmony import */ var _teleport_Teleport_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../teleport/Teleport.js */ "./teleport/Teleport.js");
/* harmony import */ var _teleport_HashChangeTeleport_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../teleport/HashChangeTeleport.js */ "./teleport/HashChangeTeleport.js");
/* harmony import */ var _teleport_HashChangeTeleport_js__WEBPACK_IMPORTED_MODULE_20___default = /*#__PURE__*/__webpack_require__.n(_teleport_HashChangeTeleport_js__WEBPACK_IMPORTED_MODULE_20__);
/* harmony import */ var _objects_AutoTour_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./../objects/AutoTour.js */ "./objects/AutoTour.js");
/* harmony import */ var _objects_AutoTour_js__WEBPACK_IMPORTED_MODULE_21___default = /*#__PURE__*/__webpack_require__.n(_objects_AutoTour_js__WEBPACK_IMPORTED_MODULE_21__);
/* harmony import */ var _controllers_ScreenshotTaker_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./controllers/ScreenshotTaker.js */ "./src/controllers/ScreenshotTaker.js");
/* harmony import */ var _controllers_ScreenshotTaker_js__WEBPACK_IMPORTED_MODULE_22___default = /*#__PURE__*/__webpack_require__.n(_controllers_ScreenshotTaker_js__WEBPACK_IMPORTED_MODULE_22__);
/* harmony import */ var _objects_GazePointer_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./objects/GazePointer.js */ "./src/objects/GazePointer.js");
/* harmony import */ var _utils_GazeModeObserver_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./utils/GazeModeObserver.js */ "./src/utils/GazeModeObserver.js");
/* harmony import */ var _ui_ClickNavigator_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./ui/ClickNavigator.js */ "./src/ui/ClickNavigator.js");
/* harmony import */ var _ui_ClickNavigator_js__WEBPACK_IMPORTED_MODULE_25___default = /*#__PURE__*/__webpack_require__.n(_ui_ClickNavigator_js__WEBPACK_IMPORTED_MODULE_25__);
/* harmony import */ var _utils_InteractionDispatcher_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./utils/InteractionDispatcher.js */ "./src/utils/InteractionDispatcher.js");
/* harmony import */ var _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./lights/LightProbe.js */ "./src/lights/LightProbe.js");
/* harmony import */ var _extend_lights_j3dLightProbeMaker_js__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./extend/lights/j3dLightProbeMaker.js */ "./src/extend/lights/j3dLightProbeMaker.js");
/* harmony import */ var _utils_StepsClimber_js__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./utils/StepsClimber.js */ "./src/utils/StepsClimber.js");
/* harmony import */ var _utils_StepsClimber_js__WEBPACK_IMPORTED_MODULE_29___default = /*#__PURE__*/__webpack_require__.n(_utils_StepsClimber_js__WEBPACK_IMPORTED_MODULE_29__);
/* harmony import */ var _ui_UsrMsg_js__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./../ui/UsrMsg.js */ "./ui/UsrMsg.js");
/* harmony import */ var _ui_UsrMsg_js__WEBPACK_IMPORTED_MODULE_30___default = /*#__PURE__*/__webpack_require__.n(_ui_UsrMsg_js__WEBPACK_IMPORTED_MODULE_30__);
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./math/Euler.js */ "./src/math/Euler.js");
/* harmony import */ var _math_Euler_js__WEBPACK_IMPORTED_MODULE_31___default = /*#__PURE__*/__webpack_require__.n(_math_Euler_js__WEBPACK_IMPORTED_MODULE_31__);
/* harmony import */ var _core_Line_js__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./core/Line.js */ "./src/core/Line.js");
/* harmony import */ var _ui_UiEventDelegate_js__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ../ui/UiEventDelegate.js */ "./ui/UiEventDelegate.js");
/* harmony import */ var _animations_AnimationsController_js__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ../animations/AnimationsController.js */ "./animations/AnimationsController.js");
/**
 * Created by Kai on 2020/12/18.
 */













//import {CutoutTextureDetector} from './controllers/CutoutTextureDetector.js'



//import './objects/LumaMeter.js'


//import './controllers/Collider.js'







//import {LightAssigner} from './lights/LightAssigner.js'



//import './lights/LightProbeMaker.js'












JMT.EDIT_MODE = false

const DEFAULT_FUNCTION = ()=> {
}

class App extends THREE.EventDispatcher {
    constructor() {
        super()
        this.gamepadMgr = new JMT.GamepadManager
        this.aniController = null
        this.vrMgr = null

        this._config = {}

        this.gazeModeObserver = new _utils_GazeModeObserver_js__WEBPACK_IMPORTED_MODULE_24__.GazeModeObserver()
        this.exposureController = null
        this.webGLRenderer = null   // L
        this.autoTour = null
        this.ui = null  //ca
        this.mergeConfig = new JMT.MergeConfig
        this.viewer = null
        this.controls = null
        this.pointerEventDispatcher = null
        this.renderer = null
        this.screenshotTaker = null
        this.sceneLoader = null
        this.isFirstPlay = false
        this.debugUI = null
        this.cutoutTextureDetector = null
        this.hashChangeTeleport = null
        this.extensionsManager = null   // M
        this.lumaMeter = null
        this.stepsClimber = null
        this.vrHeightController = null
        this.teleport = null
        this.collider = null
        this.editorSelector = null   //ua
        this.clickNavigator = null  // la
        this.elapsedLoadTimeSec = .0 //Aa
        this.gazePointer = null //ha
        this.interactionDispatcher = null //ia

        this.restoreCount = 0   // ka

        //this.defaultFont = {
        //    FontAwesomeSolid: "\uf2b9",
        //    FontAwesomeRegular: "\uf2b9",
        //    FontAwesomeBrands: "\uf293"
        //};

        this.Extensions = {}

        JMT.getViewer = this.getViewer.bind(this)

        let menuClass = JMT.UiEventDelegate || _ui_UiEventDelegate_js__WEBPACK_IMPORTED_MODULE_33__["default"]

        this.initMenu(menuClass)

        Object.defineProperty(this, 'config', {
            get: ()=> {
                return this._config
            },
            set: (value)=> {
                this._config = value
            }
        })

        window.UjP = this
    }

    get modelLoader(){

        if(!this.gltfLoader){

            this.gltfLoader = new THREE.GLTFLoader()
        }

        return this.gltfLoader
    }

    onVRClick() {
        if (this.vrMgr.vrEnabled()) {
            this.vrMgr.disableVr()
        }
        else {
            this.autoTour.isRunning() && this.autoTour.stop()
            this.vrMgr.enableVr(this.webGLRenderer.context)
        }
    }

    onPointLockClick() {
        if (this.canPointerLock()) {

            document.exitPointerLock = document.exitPointerLock ||
                document.mozExitPointerLock ||
                document.webkitExitPointerLock

            document.exitPointerLock && document.exitPointerLock()

        }
        else {
            let t = this

            function onpointerlockchange() {
                if (canPointerLock()) {
                    this.controls.mousePressLook = !1;
                    ca.onPointerLockChange(!0);
                    var a = JMT.urlHashContains("gazeinpointerlock");
                    if(a){
                        t.gazeModeObserver.enableMode()
                    }
                    else {
                        t.gazeModeObserver.disableMode();
                    }
                    t.viewer.anchorsVisible = a
                }
                else {
                    t.controls.mousePressLook = !0
                    t.ui.onPointerLockChange(!1)
                    t.gazeModeObserver.disableMode()
                    t.viewer.anchorsVisible = !0;
                }
                t.debugUI && dat.GUI.toggleHide()
            }

            this.Viewport.requestPointerLock = this.Viewport.requestPointerLock || this.Viewport.mozRequestPointerLock || this.Viewport.webkitRequestPointerLock
            this.Viewport.requestPointerLock()
            document.addEventListener("pointerlockchange", onpointerlockchange, !1)
            document.addEventListener("mozpointerlockchange", onpointerlockchange, !1)
            document.addEventListener("webkitpointerlockchange", onpointerlockchange, !1)
        }
    }

    initMenu(menuClass) {
        if (menuClass) {
            this.ui = new menuClass(
                JMT.EDIT_MODE,
                this.gamepadMgr,
                this.onVRClick.bind(this),
                DEFAULT_FUNCTION,
                this.onPointLockClick.bind(this)
            );
        }
    }

    //loadFontFamilies(a, b) {
    //    var c = {};
    //    let that = this
    //    a.forEach(function (a) {
    //        console.assert(that.defaultFont[a], "Font " + JSON.stringify(a) + " is not supported.");
    //        c[a] = that.defaultFont[a]
    //    });
    //    WebFont.load({
    //        custom: {families: a, testStrings: c}, active: b, fontinactive: function (a) {
    //            console.error("Cannot load font: " + a);
    //            JMT.USER_MSG.info("Cannot load required fonts.")
    //        }
    //    })
    //}

    start(config) { //init
        this.initViewMode(config)
    }

    getViewer() {
        return this.viewer
    }

    onteleportStarted(event) {

        if (event.view) {

            this.stepsClimber && this.stepsClimber.disable()

            if (this.interactionDispatcher) {

                this.interactionDispatcher.disable()

            }
        }
    }

    onteleportDone(event) {

        if (!(!this.stepsClimber || this.stepsClimber.isEnabled() || this.vrMgr.vrEnabled())) {

            this.stepsClimber.enable();

        }

        if (this.vrHeightController && this.vrMgr.vrEnabled()) {

            this.vrHeightController.onTeleportDone();

        }

        if (event.view && this.interactionDispatcher) {

            this.interactionDispatcher.enable();

        }

        if (this.vrMgr.vrEnabled()) {

            this.controls.hmdReset()

        }

    }

    resize() {

        if (JMT.DETECTOR.ios) {

            document.documentElement.style.height = window.innerHeight + "px"

            0 !== document.body.scrollTop && window.scrollTo(0, 0)

        }

        this.renderer.resize(this.vrMgr.vrEnabled());

        this.aniController.requestFrame();

        this.ui && this.ui.onResize()

    }

    canPointerLock() {

        let D = this.Viewport

        return document.pointerLockElement === D ||
            document.mozPointerLockElement === D ||
            document.webkitPointerLockElement === D

    }

    initInteractionDispatcher(a) {

        if(this.interactionDispatcher){

            return
        }

        a = [];

        var b = [], c = [];

        //a.push(this.viewer._clickListener);
        //var d = this.viewer._hoverListener();
        //d && c.push(d);
        this.viewer.bindListeners(a, c)

        this.clickNavigator = new JMT.ClickNavigator(this.collider, this.controls, this.teleport);

        b.push(this.clickNavigator.onMeshClicked);

        JMT.EDIT_MODE || a.push(this.clickNavigator.onMeshClicked);

        let t = this
        this.interactionDispatcher = new JMT.InteractionDispatcher(this.pointerEventDispatcher, this.collider, function () {
            t.aniController.requestFrame()
        }, a, b, c, this.gamepadMgr, this.gazePointer)

        this.assetsController.initPointerEventHelper(this.pointerEventDispatcher)
    }

    switchToVR() { //m
        this.stepsClimber && this.stepsClimber.disable();
        this.vrHeightController && this.vrHeightController.enable();
        this.controls.mouseControlsPitch = !1;
        this.controls.hmdReset();
        this.teleport.onVrChange(!0);
        this.gazeModeObserver.enableMode();
        this.ui.onVrChange(!0);
        this.viewer._vrChange(!0);
        this.resize()
    }

    onVRSet(a) {
        if (this.aniController.isEnabled()) {
            if (a) {
                this.switchToVR()
            }
            else {
                this.controls.resetRollAngle()
                this.controls.resetPitchAngle()
                this.controls.mouseControlsPitch = !0
                console.assert(!this.vrMgr.vrEnabled())
                this.vrHeightController && this.vrHeightController.disable()
                this.stepsClimber && this.stepsClimber.enable()
                this.teleport.onVrChange(!1)
                this.gazeModeObserver.disableMode()
                this.ui.onVrChange(!1)
                this.viewer._vrChange(!1)
                this.resize()
                setTimeout(this.resize.bind(this), 1E3)
            }
        }
    }

    onSetVrSupported(a) {
        if (this.ui) {
            JMT.EDIT_MODE || JMT.DETECTOR.mobile && !JMT.ALLOW_MOBILE_VR || (JMT.DETECTOR.ios || JMT.DETECTOR.mobile && JMT.DETECTOR.firefox) && JMT.DETECTOR.inCrossOriginIframe || this.ui.setVrSupported(a)
        }
    }

    onHmdPositionUpdate(a, b) {
        if (this.vrHeightController && null !== b) {
            this.vrHeightController.onHmdPositionUpdate(b);
        }
        this.controls.onHmdUpdate(a, b)
    }


    lightProbeAssigned(lightProbeMeshes) { //w
        for (var b = 0; b < lightProbeMeshes.length; b += 1) {
            if (!lightProbeMeshes[b].lightProbe) {
                return !1;
            }
        }
        return !0
    }

    addStaticObstacle(renderer, scene, controls) {
        this.collider = new JMT.j3dCollider(renderer, scene, controls);
        let that = this
        scene.visitAllNodes(function (n) {
            n.mesh && that.collider.addStaticObstacle(n.mesh)
        })
    }

    getView(scene) {
        var b = JMT.urlHashGetArgument("view"),
            c = null;
        if (b) {
            c = scene.findView(b);
        }
        return c || scene.views[0]
    }

    getViewFromReferer(scene) {
        var b = JMT.refererGetArgument("view"),
            c = null;
        if (b) {
            c = scene.findView(b);
        }
        return c || scene.views[0]
    }

    onReadyToDisplay(scene) {

        let that = this

        function onrequestFrame() {
            that.aniController.requestFrame()
        }

        this.scene = scene;
        this.scene.adjustSkiesAndCameraFarToSpanWholeScene();
        this.scene.headLight = JMT.HEAD_LIGHT;
        this.scene.addEventListener("sceneChanged", function () {
            return that.aniController.requestFrame()
        });
        this.scene.addEventListener("anyViewUpdated", function () {
            return that.ui.refresh()
        });
        this.scene.disableLightProbesForMaterials();
        this.controls.enable();
        this.scene.threeScene.updateMatrixWorld(!0);

        this.vrMgr.setCameraFar(this.scene.camera.far);
        this.renderer || (this.renderer = new JMT.Renderer(this.webGLRenderer, this.vrMgr, this.scene, this.exposureController));

        if(!this.pointerEventDispatcher){
            this.pointerEventDispatcher = new JMT.PointerEventDispatcher(this.webGLRenderer.domElement, this.config.mode)
        }
        else {
            this.pointerEventDispatcher.enable()
        }

        var enableCollisions = this.config.enableCollisions
        if ((enableCollisions || JMT.EDIT_MODE)) {
            this.addStaticObstacle(this.webGLRenderer, this.scene, this.controls);
        }

        if(!this.teleport){

            this.teleport = new JMT.Teleport(this.scene, this.controls, this.collider, this.aniController);

            this.teleport.addEventListener("teleportStarted", this.onteleportStarted.bind(this));

            this.teleport.addEventListener("teleportDone", this.onteleportDone.bind(this));
        }


        this.autoTour || (this.autoTour = new JMT.AutoTour(this.scene, this.teleport))

        if (enableCollisions && !this.stepsClimber && !this.vrHeightController) {
            if (this.scene.camera.autoClimb) {
                this.stepsClimber = new JMT.StepsClimber(this.collider, this.controls, this.aniController)
            }

            this.vrHeightController = new _webxr_VRHeightController_js__WEBPACK_IMPORTED_MODULE_8__.VRHeightController(this.controls, this.collider)


            if (!JMT.urlHashContains("nogazeteleport")) {
                this.gazePointer = new _objects_GazePointer_js__WEBPACK_IMPORTED_MODULE_23__.GazePointer(this.scene, this.controls, onrequestFrame, this.gazeModeObserver)
            }
        }

        this.teleport.switchToView(this.getViewFromReferer(this.scene), 0);

        this.exposureController.updateWithoutDelay();

        this.hashChangeTeleport || (this.hashChangeTeleport = new JMT.HashChangeTeleport(this.scene, this.teleport));

        this.screenshotTaker || (this.screenshotTaker = new JMT.ScreenshotTaker(this.webGLRenderer, this.scene, this.controls));

        this.viewer._sceneReadyToDisplay(this.webGLRenderer, this.scene, this.controls, this.teleport, this.autoTour, this.collider, this.screenshotTaker, this.lumaMeter, this.gazeModeObserver, this.pointerEventDispatcher, this.aniController);

        this.initInteractionDispatcher(enableCollisions);

        function onvisibilitychange() {
            if ("hidden" === document.visibilityState) {
                if (that.scene) {
                    var a = $jscomp.makeIterator(that.scene.getAnimatedMaterials())
                    for (var b = a.next(); !b.done; b = a.next()) {
                        b.value.sleepAnimation()
                    }
                }
            } else if ("visible" === document.visibilityState && that.scene) {
                var a = $jscomp.makeIterator(that.scene.getAnimatedMaterials());
                for (b = a.next(); !b.done; b = a.next()) {
                    b.value.wakeAnimation();
                }
                that.aniController.requestFrame()
            }
        }
        document.removeEventListener("visibilitychange", onvisibilitychange, !1);
        document.addEventListener("visibilitychange", onvisibilitychange);

        function onresize() {

            JMT.DETECTOR.ios ? setTimeout(that.resize.bind(that), 1E3) : that.resize()

        }
        window.removeEventListener("resize", onresize, !1);
        window.addEventListener("resize", onresize, !1);

        if (this.ui) {

            //this.canFullscreen() && this.ui.setFullScreenSupported();

            JMT.DETECTOR.mobile || JMT.DETECTOR.opera || void 0 === document.pointerLockElement && void 0 === document.mozPointerLockElement && void 0 === document.webkitPointerLockElement || this.ui.setPointerLockSupported();

            this.ui.sceneReadyToDisplay(this.scene, this.teleport, this.autoTour, this.screenshotTaker);

        }


        this.resize();

        if (JMT.DEBUG && JMT.DebugUI) {
            this.debugUI = new JMT.DebugUI(this.scene, this.controls, this.resize.bind(this), this.aniController)
        }

        JMT.DETECTOR.ios || this.Viewport.focus();

        JMT.DEBUG_SHARED_BUFFERS && (this.scene.threeScene.overrideMaterial = new JMT.DebugMaterial);

        this.scene.startAutoTourOnLoad() && this.autoTour.start();

        this.aniController.enable();

        this.vrMgr.vrEnabled() && switchToVR();

        this.elapsedLoadTimeSec = this.sceneLoader.elapsedLoadTimeSec()

        this.dispatchEvent({type: 'ReadyToDisplay'})
    }

    sendStats(a) {
        //if (this.ui) {
        //    JMT.EDIT_MODE || JMT.urlHashContains("nostats") || 0 !== this.restoreCount || this.ui.cover.sendStats && JMT.ajaxPost("./stats/" + a, null, null)
        //}
    }

    initLightProbesEvent(a, b) {   // O
        let n = this

        function onlightProbePositionUpdated(c) {
            function d() {
                f.delete(e);
                if (null !== a.findLightProbe(e.id)) {
                    b.assignLightProbesToObjects()
                    b.createLightProbeTexture(e, !1)
                    n.aniController.requestFrame()
                }
            }

            var e = c.lightProbe;
            c = f.get(e);
            if (void 0 === c) {
                c = new JMT.DeferringExecutor(d, 1E3)
                f.set(e, c)
            }
            c.deferRun()
        }

        function onlightProbeBoundsInit(a) {
            a = a.lightProbe;
            b.createLightProbeTexture(a, !0);
            if (!a.isBoundingBoxInitialized()) {
                var c = a.boxMax;
                a.boxMin.copy(a.position).addScalar(-1);
                c.copy(a.position).addScalar(1);
                a.enableBoundingBox()
            }
        }

        function onlightProbeBoundsUpdated(b) {
            for (b = 0; b < a.materials.length; b += 1) {
                a.materials[b].forceObjectUniformsRefresh()
            }
        }

        function onlightProbeAdded(event) {
            var a = event.lightProbe;
            b.assignLightProbesToObjects();
            b.createLightProbeTexture(a, !0);
            a.isBoundingBoxInitialized() || a.disableBoundingBox();
            a.addEventListener("lightProbeBoundsInit", onlightProbeBoundsInit);
            a.addEventListener("lightProbePositionUpdated", onlightProbePositionUpdated);
            a.addEventListener("lightProbeBoundsUpdated", onlightProbeBoundsUpdated)
        }

        function onlightProbeRemoved() {
            b.assignLightProbesToObjects()
        }

        var f = new Map;
        a.addEventListener("lightProbeAdded", onlightProbeAdded);
        a.addEventListener("lightProbeRemoved", onlightProbeRemoved);
        for (var g = 0; g < a.lightProbes.length; g += 1) {
            a.lightProbes[g].addEventListener("lightProbePositionUpdated", onlightProbePositionUpdated)
            a.lightProbes[g].addEventListener("lightProbeBoundsInit", onlightProbeBoundsInit)
            a.lightProbes[g].addEventListener("lightProbeBoundsUpdated", onlightProbeBoundsUpdated)
        }
    }

    getApiHook() {
        return this.viewer
    }

    notifyLoadComplete(appScene) {

        this.ui && this.ui.sceneLoadComplete();

        this.viewer._sceneLoadComplete();

        this.aniController.requestFrame();

        var b = this.sceneLoader.elapsedLoadTimeSec();

        //this.sendStats("loaded?readyToDisplayTime=" + this.elapsedLoadTimeSec.toFixed(1) + "&loadTime=" + b.toFixed(1));

        this.sceneLoader = null

        if (this.config.onSceneLoaded) {

            this.config.onSceneLoaded(this.getApiHook(appScene), {switched : !!this._switched});
        }
    }

    _enableLightProbes(appScene, headless) {

        var lightProbeMaker = undefined
        if (appScene.lightProbes.length > 0) {
            //if (JMT.j3dLightProbeMaker)
                lightProbeMaker = new JMT.j3dLightProbeMaker(appScene, this.webGLRenderer, JMT.DETECTOR.textureLod, JMT.DETECTOR.mirrorCubeMaps, this.config.mode);
            //else
            //   lightProbeMaker = new JMT.LightProbeMaker(appScene, this.webGLRenderer, JMT.DETECTOR.textureLod, JMT.DETECTOR.mirrorCubeMaps, this.config.mode);
        }
        

        if (this._arrangeLightProbes) {
            this._arrangeLightProbes(appScene, lightProbeMaker, headless)
        }

        if (0 < appScene.lightProbes.length) {

            if (!this.lightProbeAssigned(appScene.gpuMeshes)) {

                console.warn("Some objects do not have light probes assigned, this is not optimal.")

                lightProbeMaker.assignLightProbesToObjects()

            }
            var e;

            for (e = 0; e < appScene.views.length && "orbit" === appScene.views[e].mode; e += 1);

            e === appScene.views.length && (e = 0);

            this.teleport.executeWithViewVisibilitySettings(appScene.views[e], function () {

                lightProbeMaker.createAllLightProbeTextures()

            });

            appScene.enableLightProbesForMaterials()
        }

        return lightProbeMaker
    }

    _solveLightProbe(appScene, headless) {

        var lightProbeMaker = null

        if (0 < appScene.lightProbes.length || JMT.EDIT_MODE) {
            lightProbeMaker = this._enableLightProbes(appScene, headless)
        }

        appScene.hasLightMap() && this.renderer.enableAutoExposure();

        if (lightProbeMaker) {

            lightProbeMaker.dispose()

            lightProbeMaker = null
        }
    }

    onComplete(appScene) {

        var headless = JMT.urlHashContains("headless");

        this.cutoutTextureDetector && this.cutoutTextureDetector.dispose();

        this.cutoutTextureDetector = null;

        this._solveLightProbe(appScene, headless)

        if (0 < appScene.lights.length && JMT.DETECTOR.dynamicLights && JMT.DYNAMIC_LIGHTS) {

            e = new LightAssigner(this.webGLRenderer, appScene.camera.far, appScene.lights, appScene.materials, appScene.logicalMeshes)

            e.assignLightLookupMaps()

            e.dispose()
        }


        if (this._notifyLoadComplete) {
            this._notifyLoadComplete(appScene, headless)
        }
        else {
            this.notifyLoadComplete(appScene)
        }
    }

    onTextureLoaded(a) {
        let that = this
        this.webGLRenderer.uploadTexture && this.webGLRenderer.uploadTexture(a);

        if (this.cutoutTextureDetector) {
            
            if (a.isAtlas()) {
                a.forEachAtlasEntry(function (a) {
                    console.assert(null === a.isCutout);
                    that.cutoutTextureDetector.isCutoutTexture(a)
                })
            }
            else {
                null === a.isCutout && this.cutoutTextureDetector.isCutoutTexture(a);
            }
        }

        this.aniController && this.aniController.requestFrame()
    }

    onMeshBuffersLoaded(a) {
        this.webGLRenderer.uploadNewBuffers && this.webGLRenderer.uploadNewBuffers(a);
        this.aniController && this.aniController.requestFrame()
    }

    getNewLoader(scene, onProgress){

        let t = this

        function onTextureLoaded(texture){

            t.onTextureLoaded(texture)

        }

        function onMeshBuffersLoaded(mesh){

            t.onMeshBuffersLoaded(mesh)
        }

        function onReadyToDisplay(scene){

            t.aniController.enable()

            t.onReadyToDisplay(scene)

        }

        function onComplete(a){

            t.onComplete(a)

        }

        let sceneLoader = new _loaders_SceneLoader_js__WEBPACK_IMPORTED_MODULE_15__.SceneLoader(scene, this.config.assetsUrl, this.config.mode, this.mergeConfig);
        sceneLoader.onTextureLoaded = onTextureLoaded;
        sceneLoader.onMeshBuffersLoaded = onMeshBuffersLoaded;
        sceneLoader.onReadyToDisplay = onReadyToDisplay;
        sceneLoader.onComplete = onComplete;

        if(onProgress){

            sceneLoader.onProgress = onProgress

        }
        else if(this.ui){

            sceneLoader.onProgress = this.ui.loadProgress

        }


        return sceneLoader
    }

    onGetCover(cover) {
        let extensions = []
        if (cover) {
            this.ui && this.ui.updateCover(cover);
            extensions = this.config.extensions && (cover.extensions || []).concat(this.config.extensions)
        }
        else {
            cover = {}
        }
        this.extensionsManager.updateConfig(extensions || []);
        this.config.mode || this.extensionsManager.startExtensions();
        this.viewer._viewerConfigLoaded(cover);
        this.cutoutTextureDetector = new _extend_controllers_j3dCutoutTextureDetector_js__WEBPACK_IMPORTED_MODULE_13__.j3dCutoutTextureDetector(this.webGLRenderer);
        this.isFirstPlay = !0;

        var scene = new JMT.Scene(this.controls.camera());

        this.sceneLoader = this.getNewLoader(scene)

        //this.lumaMeter = new JMT.LumaMeter(this.webGLRenderer, scene);

        this.exposureController = new JMT.ExposureController(scene, this.controls, this.lumaMeter);

        //this.ui && (this.sceneLoader.onProgress = this.ui.loadProgress);

        let that = this

        function onPlay() {
            if (that.isFirstPlay) {
                that.isFirstPlay = !1
                that.sceneLoader.load()
                that.ui && that.ui.sceneLoadStarted(JMT.urlHashContains("help"))

                //this.sendStats("play")
            }
        }

        if (JMT.urlHashContains("autoplay") || 0 < this.restoreCount) {
            onPlay()
        }
        else if (!JMT.urlHashContains("hideplay")) {
            this.ui.enablePlayButton(onPlay)
        }
        else {
            onPlay()
        }
    }

    initScene() {
        let n = this
        // TODO: JMK集成版本Cover.json从外部请求，所以内部注释掉
        //JMT.ajaxGet(
        //    this.config.assetsUrl + JMT.COVER_JSON_URL, !1,
        //    this.onGetCover.bind(this),
        //    function () {
        //        JMT.USER_MSG.error("Failed to initialize the scene.")
        //        n.onGetCover({})
        //    }
        //)
        n.onGetCover()
    }

    switchScene(assetUrl, onProgress){

        JMT.ALWAYS_RENDER = false

        this.clear()

        if(this.config.assetsUrl !== assetUrl){

            this.aniController.disable()

            this.config.assetsUrl = assetUrl

            this.cutoutTextureDetector || (this.cutoutTextureDetector = new _extend_controllers_j3dCutoutTextureDetector_js__WEBPACK_IMPORTED_MODULE_13__.j3dCutoutTextureDetector(this.webGLRenderer));

            this.sceneLoader = this.getNewLoader(this.scene, onProgress)

            this._switched = true

            this.sceneLoader.load()

        }
    }

    clear(){

        this.ui.init(this).setVrSupported(true);

        this.viewer && this.viewer.clear()

        //this.extensionsManager && this.extensionsManager.clear()

        //this.vrMgr && this.vrMgr.clear()

        //this.aniController && this.aniController.clear()

        this.assetsController && this.assetsController.clear()

        this.animationsController && this.animationsController.clear()

        this.scene && this.scene.clearAll()

        if(this.pointerEventDispatcher){

            this.pointerEventDispatcher.disable()

        }
    }

    createAnimateController(vrMgr) {

        let t = this

        function onrenderIdle(a, b) {
            return t.renderer.renderIdle(a, b)
        }

        function onupdate(a, b) {

            UjP.dispatchEvent({type: 'onRequestFrame', delta: a})

            b && t.gamepadMgr.update();

            t.teleport.update(a);

            //t.config.enableCollisions && !b && t.collider.handleCollisions(a);
            t.config.enableCollisions && !JMT.EDIT_MODE && t.collider.handleCollisions(a);

            t.interactionDispatcher && t.interactionDispatcher.handleHover();

            t.controls.update(a);

            t.assetsController.update(a)

            t.stepsClimber && t.stepsClimber.updateCameraHeight(a);

            t.vrHeightController && t.vrHeightController.updateCameraHeight();

            if (b && !t.teleport.teleportingToPoint) {

                t.vrMgr.update()

                t.aniController.requestFrame()

            }

            if(t.gazePointer){
                if(b && !t.gamepadMgr.hasGamepads()){
                    t.gazePointer.update(a)
                }
                else {
                    t.gazePointer.reset()
                }
            }

            var c = $jscomp.makeIterator(t.scene.getAnimatedMeshes())

            for (var d = c.next(); !d.done; d = c.next()) {

                d.value.update(a, t.controls.cameraWorldPosition());

            }

            c = !1;

            d = $jscomp.makeIterator(t.scene.getAnimatedMaterials());

            for (var e = d.next(); !e.done; e = d.next()) {

                e = e.value

                if (e.isPlaying) {

                    e.update(a)

                    c = !0

                }
            }

            c && t.aniController.requestFrame();

            t.editorSelector && t.editorSelector.update(a);

            t.viewer._update(a);

            t.renderer.renderToScreen(a, b);

            t.debugUI && t.debugUI.animate()
        }

        let aniController = new _controllers_AnimationController_js__WEBPACK_IMPORTED_MODULE_9__.AnimationController(
            vrMgr,
            onupdate,
            onrenderIdle
        );
        aniController.disable()

        return aniController
    }

    initViewMode(config) { //N

        let that = this

        !function () { //setBeforeAddToScene();
            var a = THREE.Scene.prototype.add;
            THREE.Object3D.prototype.add = function (b) {
                //(b instanceof THREE.Points || b instanceof THREE.Mesh) && that.webGLRenderer.uploadNewBuffers(b);
                if (b instanceof THREE.Mesh && !b.isMesh && that.webGLRenderer.uploadNewBuffers)
                    that.webGLRenderer.uploadNewBuffers(b);
                a.call(this, b)
            }
        }()

        this.config = config
        let el = document.getElementById(config.el) || document.getElementById("s3d-canvas")
        this.Viewport = el

        //this.config.mode = JMT.EDIT_MODE

        this.webGLRenderer = JMT.createJMTRenderer(this.Viewport)
        if (this.webGLRenderer) {
            if (JMT.DETECTOR.missingCapabilities) {
                JMT.USER_MSG.error(JMT.DETECTOR.missingCapabilities);
            }
            else {
                //JMT.DETECTOR.logarithmicDepthBuffer = !!config.logarithmicDepthBuffer

                function onwebglcontextlost(event) {
                    event.preventDefault();
                    that.restoreCount += 1;
                    that.aniController.disable();
                    if (!JMT.EDIT_MODE &&
                        null === that.sceneLoader &&
                        that.restoreCount <= JMT.CONTEXT_LOST_RESTORE_LIMIT) {
                        that.extensionsManager.stopExtensions()
                        that.viewer._contextLost()
                        that.hashChangeTeleport.dispose()
                        that.hashChangeTeleport = null
                        that.interactionDispatcher.dispose()
                        that.interactionDispatcher = null
                        if (that.clickNavigator) {
                            that.clickNavigator.dispose()
                            that.clickNavigator = null
                        }
                        that.ui.contextLost()
                    }
                    else {
                        JMT.USER_MSG.error("Graphics context lost, reload to retry.")
                    }
                }

                function onwebglcontextrestored(event) {
                    event.preventDefault();
                    if (!JMT.EDIT_MODE && null === that.sceneLoader &&
                        that.restoreCount <= JMT.CONTEXT_LOST_RESTORE_LIMIT) {
                        JMT.USER_MSG.info("Graphics context switched, reloading the scene to use the new context.", 5E3)
                        JMT.createGlobalDetector(L.context)
                        L.webGLContextRestored()
                        onGetCover(that.ui.cover)
                    }
                }

                let canvas = this.Viewport
                canvas.addEventListener("webglcontextlost", onwebglcontextlost, !1);
                canvas.addEventListener("webglcontextrestored", onwebglcontextrestored, !1);


                this.ui.init(this).setVrSupported(true);

                this.viewer = new _core_Viewer_js__WEBPACK_IMPORTED_MODULE_12__.Viewer(JMT.EDIT_MODE, this.ui, this.mergeConfig);

                this.extensionsManager = new JMT.ExtensionsManager;

                var xrPolyfill = null;

                try {
                    if (JMT.urlHashContains("vrlo")) {
                        WebXRConfig.cardboardConfig.BUFFER_SCALE *= .5
                    }
                    else {
                        if (JMT.urlHashContains("vrhi")) {
                            WebXRConfig.cardboardConfig.BUFFER_SCALE *= 1.5
                        }
                        xrPolyfill = new WebXRPolyfill(WebXRConfig)
                    }
                }
                catch (Oa) {
                    JMT.log("Failed to initialize WebXR polyfill")
                }

                this.vrMgr = new _webxr_VRManager_js__WEBPACK_IMPORTED_MODULE_7__.VRManager( // W
                    this.webGLRenderer,
                    this.gamepadMgr,
                    xrPolyfill,
                    this.onSetVrSupported.bind(this),
                    this.onHmdPositionUpdate.bind(this),
                    function (a) {
                        a ? that.aniController.disable() : that.aniController.enable()
                    },
                    this.onVRSet.bind(this)
                );

                // 动画管理
                this.aniController = this.createAnimateController(this.vrMgr);

                var camera = new _cameras_Camera_js__WEBPACK_IMPORTED_MODULE_10__.Camera();

                this.controls = new _controllers_Controls_js__WEBPACK_IMPORTED_MODULE_11__.Controls(camera, this.Viewport, this.gamepadMgr, this.aniController);
                this.controls.mousePressLook = !0;
                if (JMT.urlHashContains("flipmouse")) {
                    this.controls.flipMouseLook = !0;
                }
                this.controls.disable();

                this.initScene()

                // 素材管理
                this.assetsController = new JMT.AssetsController(this)

                // 动画管理
                this.animationsController = new _animations_AnimationsController_js__WEBPACK_IMPORTED_MODULE_34__.AnimationsController(this)
            }
        }
        else {

            let errMsg = ''

            if (window.WebGLRenderingContext) {

                errMsg = 'Your graphics card does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">WebGL</a> or your browser has WebGL disabled.<br/><a href="http://get.webgl.org/" target="_blank">Find out how to get it.</a>'

            }
            else {

                errMsg = 'Your browser does not seem to support <a href="http://khronos.org/webgl/wiki/Getting_a_WebGL_Implementation" target="_blank">WebGL</a>.<br/><a href="http://get.webgl.org/" target="_blank">Find out how to get it.</a>'

            }


            JMT.USER_MSG.error(errMsg)
        }
    }

}

JMT.App = App


/***/ }),

/***/ "./src/MergeConfig.js":
/*!****************************!*\
  !*** ./src/MergeConfig.js ***!
  \****************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function SetUtil() {
    var a = new Set
    var c = [];
    this.add = function (b) {
        b instanceof RegExp ? c.push(b) : a.add(b)
    };
    this.matchesAny = function (b) {
        return a.has(b) ? !0 : c.some(function (a) {
            return a.test(b)
        })
    }
}

class MergeConfig {
    constructor(){
        this._editableNodeTypes = new SetUtil;
        this._editableMaterialNames = new SetUtil;
        this._allMaterialsEditable = !1;
    }

    setNodeTypeEditable(a) {
        this._editableNodeTypes.add(a)
    };
    setMaterialEditable(a) {
        this._editableMaterialNames.add(a)
    };
    setAllMaterialsEditable() {
        this._allMaterialsEditable = !0
    };
    isMaterialEditable(a) {
        return this._allMaterialsEditable || this._editableMaterialNames.matchesAny(a)
    };
    isNodeTypeEditable(a) {
        return this._editableNodeTypes.matchesAny(a)
    }
}

JMT.MergeConfig = MergeConfig

/***/ }),

/***/ "./src/animation/AnimationAction.js":
/*!******************************************!*\
  !*** ./src/animation/AnimationAction.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationAction": function() { return /* binding */ AnimationAction; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/animation/constants.js");




class AnimationAction {

    constructor(mixer, clip, localRoot, blendMode) {

        this._mixer = mixer;
        this._clip = clip;
        this._localRoot = localRoot || null;
        this.blendMode = blendMode || clip.blendMode;

        const tracks = clip.tracks,
            nTracks = tracks.length,
            interpolants = new Array(nTracks);

        const interpolantSettings = {
            endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding,
            endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding
        };

        for (let i = 0; i !== nTracks; ++i) {

            const interpolant = tracks[i].createInterpolant(null);
            interpolants[i] = interpolant;
            interpolant.settings = interpolantSettings;

        }

        this._interpolantSettings = interpolantSettings;

        this._interpolants = interpolants; // bound by the mixer

        // inside: PropertyMixer (managed by the mixer)
        this._propertyBindings = new Array(nTracks);

        this._cacheIndex = null; // for the memory manager
        this._byClipCacheIndex = null; // for the memory manager

        this._timeScaleInterpolant = null;
        this._weightInterpolant = null;

        this.loop = _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopRepeat;
        this._loopCount = -1;

        // 是否是门动画
        this._isDoor = false;

        // global mixer time when the action is to be started
        // it's set back to 'null' upon start of the action
        this._startTime = null;

        // scaled local time of the action
        // gets clamped or wrapped to 0..clip.duration according to loop
        this.time = 0;

        this.timeScale = 1;
        this._effectiveTimeScale = 1;

        this.weight = 1;
        this._effectiveWeight = 1;

        this.repetitions = Infinity; // no. of repetitions when looping

        this.paused = false; // true -> zero effective time scale
        this.enabled = true; // false -> zero effective weight

        this.clampWhenFinished = false;// keep feeding the last frame?

        this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
        this.zeroSlopeAtEnd = true;// clips for start, loop and end

    }

    // State & Scheduling

    play() {
        if(this._isDoor === true){
            this.time = 0;
            this._loopCount = 0;
            this.repetitions = 1;
            this.loop = _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopPingPong;
        }

        this._mixer._activateAction(this);
        return this;
    }

    // 反激活
    deactivate(){
        this._mixer._deactivateAction(this);
        return this.reset(); 
    }

    // 停止
    stop() {
        if(this._isDoor === false){
            this._mixer._deactivateAction(this);
            return this.reset();
        }
        else{
            this.paused = false;
            this.time = this._clip.duration - this.time;
            this.repetitions = 1;
            this._loopCount = 1;
        }
    }

    reset() {

        this.paused = false;
        this.enabled = true;

        this.time = 0; // restart clip
        this._loopCount = -1;// forget previous loops
        this._startTime = null;// forget scheduling

        return this.stopFading().stopWarping();

    }

    isRunning() {

        return this.enabled && !this.paused && this.timeScale !== 0 &&
            this._startTime === null && this._mixer._isActiveAction(this);

    }

    // return true when play has been called
    isScheduled() {

        return this._mixer._isActiveAction(this);

    }

    startAt(time) {

        this._startTime = time;

        return this;

    }

    setTime(_time){
        this.time = _time; 
    }

    setLoop(mode, repetitions) {

        this.loop = mode;
        this.repetitions = repetitions;

        return this;

    }

    setIsDoor(val){
        this._isDoor = val;
    }

    // Weight

    // set the weight stopping any scheduled fading
    // although .enabled = false yields an effective weight of zero, this
    // method does *not* change .enabled, because it would be confusing
    setEffectiveWeight(weight) {

        this.weight = weight;

        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;

        return this.stopFading();

    }

    // return the weight considering fading and .enabled
    getEffectiveWeight() {

        return this._effectiveWeight;

    }

    fadeIn(duration) {

        return this._scheduleFading(duration, 0, 1);

    }

    fadeOut(duration) {

        return this._scheduleFading(duration, 1, 0);

    }

    crossFadeFrom(fadeOutAction, duration, warp) {

        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);

        if (warp) {

            const fadeInDuration = this._clip.duration,
                fadeOutDuration = fadeOutAction._clip.duration,

                startEndRatio = fadeOutDuration / fadeInDuration,
                endStartRatio = fadeInDuration / fadeOutDuration;

            fadeOutAction.warp(1.0, startEndRatio, duration);
            this.warp(endStartRatio, 1.0, duration);

        }

        return this;

    }

    crossFadeTo(fadeInAction, duration, warp) {

        return fadeInAction.crossFadeFrom(this, duration, warp);

    }

    stopFading() {

        const weightInterpolant = this._weightInterpolant;

        if (weightInterpolant !== null) {

            this._weightInterpolant = null;
            this._mixer._takeBackControlInterpolant(weightInterpolant);

        }

        return this;

    }

    // Time Scale Control

    // set the time scale stopping any scheduled warping
    // although .paused = true yields an effective time scale of zero, this
    // method does *not* change .paused, because it would be confusing
    setEffectiveTimeScale(timeScale) {

        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;

        return this.stopWarping();

    }

    // return the time scale considering warping and .paused
    getEffectiveTimeScale() {

        return this._effectiveTimeScale;

    }

    setDuration(duration) {

        this.timeScale = this._clip.duration / duration;

        return this.stopWarping();

    }

    syncWith(action) {

        this.time = action.time;
        this.timeScale = action.timeScale;

        return this.stopWarping();

    }

    halt(duration) {

        return this.warp(this._effectiveTimeScale, 0, duration);

    }

    warp(startTimeScale, endTimeScale, duration) {

        const mixer = this._mixer,
            now = mixer.time,
            timeScale = this.timeScale;

        let interpolant = this._timeScaleInterpolant;

        if (interpolant === null) {

            interpolant = mixer._lendControlInterpolant();
            this._timeScaleInterpolant = interpolant;

        }

        const times = interpolant.parameterPositions,
            values = interpolant.sampleValues;

        times[0] = now;
        times[1] = now + duration;

        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;

        return this;

    }

    stopWarping() {

        const timeScaleInterpolant = this._timeScaleInterpolant;

        if (timeScaleInterpolant !== null) {

            this._timeScaleInterpolant = null;
            this._mixer._takeBackControlInterpolant(timeScaleInterpolant);

        }

        return this;

    }

    // Object Accessors

    getMixer() {

        return this._mixer;

    }

    getClip() {

        return this._clip;

    }

    getRoot() {

        return this._localRoot || this._mixer._root;

    }

    // Interna

    _update(time, deltaTime, timeDirection, accuIndex, isJumpTo) {

        // called by the mixer

        if (!this.enabled) {

            // call ._updateWeight() to update ._effectiveWeight

            this._updateWeight(time);
            return;

        }

        const startTime = this._startTime;

        if (startTime !== null) {

            // check for scheduled start of action

            const timeRunning = ( time - startTime ) * timeDirection;
            if (timeRunning < 0 || timeDirection === 0) {

                return; // yet to come / don't decide when delta = 0

            }

            // start

            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;

        }

        // apply time scale and advance time

        deltaTime *= this._updateTimeScale(time);
        const clipTime = this._updateTime(deltaTime, isJumpTo);

        // note: _updateTime may disable the action resulting in
        // an effective weight of 0

        const weight = this._updateWeight(time);

        if (weight > 0) {

            const interpolants = this._interpolants;
            const propertyMixers = this._propertyBindings;

            switch (this.blendMode) {

                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveAnimationBlendMode:

                    for (let j = 0, m = interpolants.length; j !== m; ++j) {

                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulateAdditive(weight);

                    }

                    break;

                case _constants_js__WEBPACK_IMPORTED_MODULE_0__.NormalAnimationBlendMode:
                default:

                    for (let j = 0, m = interpolants.length; j !== m; ++j) {

                        interpolants[j].evaluate(clipTime);
                        propertyMixers[j].accumulate(accuIndex, weight);

                    }

            }

        }

    }

    _updateWeight(time) {

        let weight = 0;

        if (this.enabled) {

            weight = this.weight;
            const interpolant = this._weightInterpolant;

            if (interpolant !== null) {

                const interpolantValue = interpolant.evaluate(time)[0];

                weight *= interpolantValue;

                if (time > interpolant.parameterPositions[1]) {

                    this.stopFading();

                    if (interpolantValue === 0) {

                        // faded out, disable
                        this.enabled = false;

                    }

                }

            }

        }

        this._effectiveWeight = weight;
        return weight;

    }

    _updateTimeScale(time) {

        let timeScale = 0;

        if (!this.paused) {

            timeScale = this.timeScale;

            const interpolant = this._timeScaleInterpolant;

            if (interpolant !== null) {

                const interpolantValue = interpolant.evaluate(time)[0];

                timeScale *= interpolantValue;

                if (time > interpolant.parameterPositions[1]) {

                    this.stopWarping();

                    if (timeScale === 0) {

                        // motion has halted, pause
                        this.paused = true;

                    } else {

                        // warp done - apply final time scale
                        this.timeScale = timeScale;

                    }

                }

            }

        }

        this._effectiveTimeScale = timeScale;
        return timeScale;

    }

    _updateTime(deltaTime, isJumpTo) {

        const duration = this._clip.duration;
        const loop = this.loop;

        let time = this.time + deltaTime;
        let loopCount = this._loopCount;

        const pingPong = ( loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopPingPong );

        if (deltaTime === 0) {

            if (loopCount === -1) return time;

            return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;
        }

        if (loop === _constants_js__WEBPACK_IMPORTED_MODULE_0__.LoopOnce) {

            if (loopCount === -1) {
                // just started

                this._loopCount = 0;
                this._setEndings(true, true, false);
            }

            handle_stop: {

                if (time >= duration) {

                    time = duration;

                } else if (time < 0) {

                    time = 0;

                } else {

                    this.time = time;

                    this._mixer.dispatchEvent({
                        type:'updated',
                        time: time,
                        deltaTime: deltaTime,
                        isJumpTo: isJumpTo
                    })

                    break handle_stop;

                }

                if (this.clampWhenFinished) {
                    this.paused = true;
                }
                else {
                    this.enabled = false;
                }

                this.time = time;

                this._mixer.dispatchEvent({
                    type:'updated',
                    time: time,
                    deltaTime: deltaTime,
                    isJumpTo: isJumpTo
                })

                this._mixer.dispatchEvent({
                    type: 'finished', action: this,
                    direction: deltaTime < 0 ? -1 : 1
                });

            }

        }
        else { // repetitive Repeat or PingPong

            if (loopCount === -1) {

                // just started

                if (deltaTime >= 0) {

                    loopCount = 0;

                    this._setEndings(true, this.repetitions === 0, pingPong);

                } else {

                    // when looping in reverse direction, the initial
                    // transition through zero counts as a repetition,
                    // so leave loopCount at -1

                    this._setEndings(this.repetitions === 0, true, pingPong);

                }

            }

            if (time >= duration || time < 0) {

                // wrap around

                const loopDelta = Math.floor(time / duration); // signed
                time -= duration * loopDelta;

                let bInvert = false;
                if (pingPong && ( loopCount & 1 ) === 1) {
                    // invert time for the "pong round"
                    //return duration - time;
                    bInvert = true;
                }

                loopCount += Math.abs(loopDelta);

                const pending = this.repetitions - loopCount;

                if (pending <= 0) {

                    // have to stop (switch state, clamp time, fire event)

                    if (this.clampWhenFinished) {
                        this.paused = true;
                    }
                    else{
                        this.enabled = false;
                    }

                    time = deltaTime > 0 ? duration : 0;
                    this.time = time;

                    if(loopCount === 1){
                        time = this.duration;
                    }else if(loopCount === 2){
                        time = 0;
                    }

                    // if(bInvert === true){
                    //     time = duration - time;
                    // }

                    this._mixer.dispatchEvent({
                        type: 'finished', action: this,
                        direction: deltaTime > 0 ? 1 : -1
                    });
                } else {

                    // keep running

                    if (pending === 1) {

                        // entering the last round

                        const atStart = deltaTime < 0;
                        this._setEndings(atStart, !atStart, pingPong);

                    } else {

                        this._setEndings(false, false, pingPong);

                    }

                    this._loopCount = loopCount;

                    this.time = time;

                    this._mixer.dispatchEvent({
                        type: 'loop',
                        action: this,
                        loopDelta: loopDelta,
                        loopCount: loopCount
                    });

                }

            } else {

                this.time = time;

                this._mixer.dispatchEvent({
                    type:'updated',
                    time: time,
                    deltaTime: deltaTime,
                    isJumpTo: isJumpTo
                })
            }

            if (pingPong && ( loopCount & 1 ) === 1) {

                // invert time for the "pong round"

                return duration - time;

            }

        }

        return time;
    }

    _setEndings(atStart, atEnd, pingPong) {

        const settings = this._interpolantSettings;

        if (pingPong) {

            settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding;
            settings.endingEnd = _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding;

        } else {

            // assuming for LoopOnce atStart == atEnd == true

            if (atStart) {

                settings.endingStart = this.zeroSlopeAtStart ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding : _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding;

            } else {

                settings.endingStart = _constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding;

            }

            if (atEnd) {

                settings.endingEnd = this.zeroSlopeAtEnd ? _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding : _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding;

            } else {

                settings.endingEnd = _constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding;

            }

        }

    }

    _scheduleFading(duration, weightNow, weightThen) {

        const mixer = this._mixer, now = mixer.time;
        let interpolant = this._weightInterpolant;

        if (interpolant === null) {

            interpolant = mixer._lendControlInterpolant();
            this._weightInterpolant = interpolant;

        }

        const times = interpolant.parameterPositions,
            values = interpolant.sampleValues;

        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;

        return this;

    }

}






/***/ }),

/***/ "./src/animation/AnimationClip.js":
/*!****************************************!*\
  !*** ./src/animation/AnimationClip.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationClip": function() { return /* binding */ AnimationClip; }
/* harmony export */ });
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationUtils.js */ "./src/animation/AnimationUtils.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");
/* harmony import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracks/BooleanKeyframeTrack.js */ "./src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracks/ColorKeyframeTrack.js */ "./src/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracks/NumberKeyframeTrack.js */ "./src/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracks/QuaternionKeyframeTrack.js */ "./src/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony import */ var _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tracks/StringKeyframeTrack.js */ "./src/animation/tracks/StringKeyframeTrack.js");
/* harmony import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tracks/VectorKeyframeTrack.js */ "./src/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./constants.js */ "./src/animation/constants.js");








//import { MathUtils } from '../math/MathUtils.js';


function AnimationClip( name, duration, tracks, blendMode ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : - 1;
	this.blendMode = ( blendMode !== undefined ) ? blendMode : _constants_js__WEBPACK_IMPORTED_MODULE_8__.NormalAnimationBlendMode;

	this.uuid = name || JMT.genUUID() //MathUtils.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.VectorKeyframeTrack;

		case 'color':

			return _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__.ColorKeyframeTrack;

		case 'quaternion':

			return _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__.BooleanKeyframeTrack;

		case 'string':

			return _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__.StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

Object.assign( AnimationClip, {

	parse: function ( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks, json.blendMode );

	},

	toJSON: function ( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},

	CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.getKeyframeOrder( times );
			times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.sortedArray( times, 1, order );
			values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new AnimationClip( name, - 1, tracks );

	},

	findByName: function ( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function ( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				_AnimationUtils_js__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					_tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					_tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new AnimationClip( clipName, duration, tracks, blendMode );

		return clip;

	}

} );

Object.assign( AnimationClip.prototype, {

	resetDuration: function () {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	},

	trim: function () {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	validate: function () {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	},

	optimize: function () {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	},

	clone: function () {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new AnimationClip( this.name, this.duration, tracks, this.blendMode );

	}

} );





/***/ }),

/***/ "./src/animation/AnimationClipCreator.js":
/*!***********************************************!*\
  !*** ./src/animation/AnimationClipCreator.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationClipCreator": function() { return /* binding */ AnimationClipCreator; }
/* harmony export */ });
/* harmony import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tracks/VectorKeyframeTrack.js */ "./src/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tracks/BooleanKeyframeTrack.js */ "./src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracks/ColorKeyframeTrack.js */ "./src/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracks/NumberKeyframeTrack.js */ "./src/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationClip.js */ "./src/animation/AnimationClip.js");
/**
 * Created by Kai on 2021/3/3.
 */









var AnimationClipCreator = function () {};

AnimationClipCreator.CreateRotationAnimation = function ( period, axis ) {

    var times = [ 0, period ], values = [ 0, 360 ];

    axis = axis || 'x';
    var trackName = '.rotation[' + axis + ']';

    var track = new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__.NumberKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, period, [ track ] );

};

AnimationClipCreator.CreateScaleAxisAnimation = function ( period, axis ) {

    var times = [ 0, period ], values = [ 0, 1 ];

    axis = axis || 'x';
    var trackName = '.scale[' + axis + ']';

    var track = new _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__.NumberKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, period, [ track ] );

};

AnimationClipCreator.CreateShakeAnimation = function ( duration, shakeScale ) {

    var times = [], values = [], tmp = new THREE.Vector3();

    for ( var i = 0; i < duration * 10; i ++ ) {

        times.push( i / 10 );

        tmp.set( Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0, Math.random() * 2.0 - 1.0 ).
            //multiply( shakeScale ).
            multiplyScalar(shakeScale).
            toArray( values, values.length );

    }

    var trackName = '.position';

    var track = new _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, duration, [ track ] );

};


AnimationClipCreator.CreatePulsationAnimation = function ( duration, pulseScale ) {

    var times = [], values = [], tmp = new THREE.Vector3();

    for ( var i = 0; i < duration * 10; i ++ ) {

        times.push( i / 10 );

        var scaleFactor = Math.random() * pulseScale;
        tmp.set( scaleFactor, scaleFactor, scaleFactor ).
            toArray( values, values.length );

    }

    var trackName = '.scale';

    var track = new _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, duration, [ track ] );

};


AnimationClipCreator.CreateVisibilityAnimation = function ( duration ) {

    var times = [ 0, duration / 2, duration ], values = [ true, false, true ];

    var trackName = '.visible';

    var track = new _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.BooleanKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, duration, [ track ] );

};


AnimationClipCreator.CreateMaterialColorAnimation = function ( duration, colors ) {

    var times = [], values = [],
        timeStep = duration / colors.length;

    for ( var i = 0; i <= colors.length; i ++ ) {

        times.push( i * timeStep );
        values.push( colors[ i % colors.length ] );

    }

    var trackName = '.material[0].color';

    var track = new _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__.ColorKeyframeTrack( trackName, times, values );

    return new _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip( null, duration, [ track ] );

};



/***/ }),

/***/ "./src/animation/AnimationMixer.js":
/*!*****************************************!*\
  !*** ./src/animation/AnimationMixer.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationMixer": function() { return /* binding */ AnimationMixer; }
/* harmony export */ });
/* harmony import */ var _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationAction.js */ "./src/animation/AnimationAction.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math/interpolants/LinearInterpolant.js */ "./src/animation/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _PropertyBinding_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PropertyBinding.js */ "./src/animation/PropertyBinding.js");
/* harmony import */ var _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PropertyMixer.js */ "./src/animation/PropertyMixer.js");
/* harmony import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationClip.js */ "./src/animation/AnimationClip.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ "./src/animation/constants.js");

//import { EventDispatcher } from '../core/EventDispatcher.js';








function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

AnimationMixer.prototype = Object.assign( Object.create( THREE.EventDispatcher.prototype ), {

	constructor: AnimationMixer,

	_bindAction: function ( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new _PropertyMixer_js__WEBPACK_IMPORTED_MODULE_3__.PropertyMixer(
					_PropertyBinding_js__WEBPACK_IMPORTED_MODULE_2__.PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function ( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function ( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function () {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function ( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function ( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function ( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function ( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function ( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function ( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function ( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function ( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function ( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function ( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function () {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_1__.LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function ( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 ),

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function ( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? _AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_5__.NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new _AnimationAction_js__WEBPACK_IMPORTED_MODULE_0__.AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function ( clip, optionalRoot ) {

		const root = optionalRoot || this._root;

		if(!root){
			return null
		}

		const rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				_AnimationClip_js__WEBPACK_IMPORTED_MODULE_4__.AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function () {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function ( deltaTime,  isJumpTo) {


		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex ,  isJumpTo);

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// Allows you to seek to a specific time in an animation.
	setTime: function ( timeInSeconds, isJumpTo ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds , isJumpTo); // Update used to set exact time. Returns "this" AnimationMixer object.

	},

	// return this mixer's root target object
	getRoot: function () {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function ( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function ( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function ( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );







/***/ }),

/***/ "./src/animation/AnimationUtils.js":
/*!*****************************************!*\
  !*** ./src/animation/AnimationUtils.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationUtils": function() { return /* binding */ AnimationUtils; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/animation/constants.js");
//import { Quaternion } from '../math/Quaternion.js';


const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {

		fps = fps || 30;

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame, referenceClip, fps ) {

		if ( referenceFrame === undefined ) referenceFrame = 0;
		if ( referenceClip === undefined ) referenceClip = targetClip;
		if ( fps === undefined || fps <= 0 ) fps = 30;

		const numTracks = targetClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
				&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			const valueSize = referenceTrack.getValueSize();
			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, 0, referenceTrack.valueSize );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * valueSize;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				interpolant.evaluate( referenceTime );
				referenceValue = interpolant.resultBuffer;

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new THREE.Quaternion( // new Quaternion(
					referenceValue[ 0 ],
					referenceValue[ 1 ],
					referenceValue[ 2 ],
					referenceValue[ 3 ]
				).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * valueSize;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueSize; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = _constants_js__WEBPACK_IMPORTED_MODULE_0__.AdditiveAnimationBlendMode;

		return targetClip;

	}

};




/***/ }),

/***/ "./src/animation/KeyframeTrack.js":
/*!****************************************!*\
  !*** ./src/animation/KeyframeTrack.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyframeTrack": function() { return /* binding */ KeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ "./src/animation/constants.js");
/* harmony import */ var _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math/interpolants/CubicInterpolant.js */ "./src/animation/math/interpolants/CubicInterpolant.js");
/* harmony import */ var _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./math/interpolants/LinearInterpolant.js */ "./src/animation/math/interpolants/LinearInterpolant.js");
/* harmony import */ var _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./math/interpolants/DiscreteInterpolant.js */ "./src/animation/math/interpolants/DiscreteInterpolant.js");
/* harmony import */ var _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AnimationUtils.js */ "./src/animation/AnimationUtils.js");






function KeyframeTrack( name, times, values, interpolation ) {

	if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
	if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

	this.name = name;

	this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.convertArray( values, this.ValueBufferType );

	this.interpolation = interpolation || this.DefaultInterpolation

	this.setInterpolation( this.interpolation );

}

// Static methods

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	toJSON: function ( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.convertArray( track.times, Array ),
				'values': _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

} );

Object.assign( KeyframeTrack.prototype, {

	constructor: KeyframeTrack,

	TimeBufferType: Float32Array,

	ValueBufferType: Float32Array,

	DefaultInterpolation: _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new _math_interpolants_DiscreteInterpolant_js__WEBPACK_IMPORTED_MODULE_3__.DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new _math_interpolants_LinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__.LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new _math_interpolants_CubicInterpolant_js__WEBPACK_IMPORTED_MODULE_1__.CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = "unsupported interpolation for " +
				this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( times, from, to );
			this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( this.times ),
			values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	},

	clone: function () {

		const times = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( this.times, 0 );
		const values = _AnimationUtils_js__WEBPACK_IMPORTED_MODULE_4__.AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

} );




/***/ }),

/***/ "./src/animation/PropertyBinding.js":
/*!******************************************!*\
  !*** ./src/animation/PropertyBinding.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyBinding": function() { return /* binding */ PropertyBinding; }
/* harmony export */ });
// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

				if(this.targetObject.setUniforms){

					this.targetObject.setUniforms()

				}
				else if(this.targetObject.updateMatrixWorld) {

					this.targetObject.updateMatrixWorld(!0)

				}
				else{

					this.targetObject.needsUpdate = true;

				}

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

				if(this.targetObject.updateMatrixWorld){

					this.targetObject.updateMatrixWorld(!0)

				}
				else {
					this.targetObject.matrixWorldNeedsUpdate = true;
				}

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				if(this.targetObject.setUniforms){

					this.targetObject.setUniforms()

				}
				else if(this.targetObject.updateMatrixWorld) {

					this.targetObject.updateMatrixWorld(!0)

				}
				else {
					this.targetObject.needsUpdate = true;
				}


			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				if(this.targetObject.updateMatrixWorld){

					this.targetObject.updateMatrixWorld(!0)

				}
				else {

					this.targetObject.matrixWorldNeedsUpdate = true;

				}
			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

				if(this.targetObject.setUniforms){

					this.targetObject.setUniforms()

				}
				else if(this.targetObject.updateMatrixWorld) {

					this.targetObject.updateMatrixWorld(!0)

				}
				else {

					this.targetObject.needsUpdate = true;

				}


			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

				if(this.targetObject.setUniforms){

					this.targetObject.setUniforms()

				}
				else if(this.targetObject.updateMatrixWorld) {

					this.targetObject.updateMatrixWorld(!0)

				}
				else {

					this.targetObject.needsUpdate = true;

				}
			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {


				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );




/***/ }),

/***/ "./src/animation/PropertyMixer.js":
/*!****************************************!*\
  !*** ./src/animation/PropertyMixer.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PropertyMixer": function() { return /* binding */ PropertyMixer; }
/* harmony export */ });
//import { Quaternion } from '../math/Quaternion.js';

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	let mixFunction,
		mixFunctionAdditive,
		setIdentity;

	// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property
	//
	// 'add' is used for additive cumulative results
	//
	// 'work' is optional and is only present for quaternion types. It is used
	// to store intermediate quaternion multiplication results

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			mixFunctionAdditive = this._slerpAdditive;
			setIdentity = this._setAdditiveIdentityQuaternion;

			this.buffer = new Float64Array( valueSize * 6 );
			this._workIndex = 5;
			break;

		case 'string':
		case 'bool':
			mixFunction = this._select;

			// Use the regular mix function and for additive on these types,
			// additive is not relevant for non-numeric types
			mixFunctionAdditive = this._select;

			setIdentity = this._setAdditiveIdentityOther;

			this.buffer = new Array( valueSize * 5 );
			break;

		default:
			mixFunction = this._lerp;
			mixFunctionAdditive = this._lerpAdditive;
			setIdentity = this._setAdditiveIdentityNumeric;

			this.buffer = new Float64Array( valueSize * 5 );

	}

	this._mixBufferRegion = mixFunction;
	this._mixBufferRegionAdditive = mixFunctionAdditive;
	this._setIdentity = setIdentity;
	this._origIndex = 3;
	this._addIndex = 4;

	this.cumulativeWeight = 0;
	this.cumulativeWeightAdditive = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

Object.assign( PropertyMixer.prototype, {

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function ( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive: function ( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function ( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function () {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function () {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},

	_setAdditiveIdentityNumeric: function () {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	},

	_setAdditiveIdentityQuaternion: function () {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * 4 + 3 ] = 1;

	},

	_setAdditiveIdentityOther: function () {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	},


	// mix functions

	_select: function ( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function ( buffer, dstOffset, srcOffset, t ) {

		THREE.Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	},

	_slerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		THREE.Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		THREE.Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	},

	_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	},

	_lerpAdditive: function ( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

} );





/***/ }),

/***/ "./src/animation/constants.js":
/*!************************************!*\
  !*** ./src/animation/constants.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AdditiveAnimationBlendMode": function() { return /* binding */ AdditiveAnimationBlendMode; },
/* harmony export */   "InterpolateDiscrete": function() { return /* binding */ InterpolateDiscrete; },
/* harmony export */   "InterpolateLinear": function() { return /* binding */ InterpolateLinear; },
/* harmony export */   "InterpolateSmooth": function() { return /* binding */ InterpolateSmooth; },
/* harmony export */   "LoopOnce": function() { return /* binding */ LoopOnce; },
/* harmony export */   "LoopPingPong": function() { return /* binding */ LoopPingPong; },
/* harmony export */   "LoopRepeat": function() { return /* binding */ LoopRepeat; },
/* harmony export */   "NormalAnimationBlendMode": function() { return /* binding */ NormalAnimationBlendMode; },
/* harmony export */   "WrapAroundEnding": function() { return /* binding */ WrapAroundEnding; },
/* harmony export */   "ZeroCurvatureEnding": function() { return /* binding */ ZeroCurvatureEnding; },
/* harmony export */   "ZeroSlopeEnding": function() { return /* binding */ ZeroSlopeEnding; }
/* harmony export */ });
/**
 * Created by Kai on 2021/3/3.
 */
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;


/***/ }),

/***/ "./src/animation/index.js":
/*!********************************!*\
  !*** ./src/animation/index.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _AnimationClipCreator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AnimationClipCreator.js */ "./src/animation/AnimationClipCreator.js");
/* harmony import */ var _AnimationMixer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationMixer.js */ "./src/animation/AnimationMixer.js");
/* harmony import */ var _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tracks/BooleanKeyframeTrack.js */ "./src/animation/tracks/BooleanKeyframeTrack.js");
/* harmony import */ var _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tracks/ColorKeyframeTrack.js */ "./src/animation/tracks/ColorKeyframeTrack.js");
/* harmony import */ var _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tracks/NumberKeyframeTrack.js */ "./src/animation/tracks/NumberKeyframeTrack.js");
/* harmony import */ var _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tracks/QuaternionKeyframeTrack.js */ "./src/animation/tracks/QuaternionKeyframeTrack.js");
/* harmony import */ var _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tracks/StringKeyframeTrack.js */ "./src/animation/tracks/StringKeyframeTrack.js");
/* harmony import */ var _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./tracks/VectorKeyframeTrack.js */ "./src/animation/tracks/VectorKeyframeTrack.js");
/* harmony import */ var _AnimationClip_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./AnimationClip.js */ "./src/animation/AnimationClip.js");
/**
 * Created by Kai on 2021/3/3.
 */










function inject(t){
    t.AnimationClipCreator = _AnimationClipCreator_js__WEBPACK_IMPORTED_MODULE_0__.AnimationClipCreator
    t.AnimationMixer = _AnimationMixer_js__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer
    t.BooleanKeyframeTrack = _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__.BooleanKeyframeTrack
    t.ColorKeyframeTrack = _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__.ColorKeyframeTrack
    t.NumberKeyframeTrack = _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack
    t.QuaternionKeyframeTrack = _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.QuaternionKeyframeTrack
    t.StringKeyframeTrack = _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__.StringKeyframeTrack
    t.VectorKeyframeTrack = _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.VectorKeyframeTrack
    t.AnimationClip = _AnimationClip_js__WEBPACK_IMPORTED_MODULE_8__.AnimationClip
}

/* harmony default export */ __webpack_exports__["default"] = ({
    inject,
    AnimationClipCreator: _AnimationClipCreator_js__WEBPACK_IMPORTED_MODULE_0__.AnimationClipCreator,
    AnimationMixer: _AnimationMixer_js__WEBPACK_IMPORTED_MODULE_1__.AnimationMixer,
    BooleanKeyframeTrack: _tracks_BooleanKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_2__.BooleanKeyframeTrack,
    ColorKeyframeTrack: _tracks_ColorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_3__.ColorKeyframeTrack,
    NumberKeyframeTrack: _tracks_NumberKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_4__.NumberKeyframeTrack,
    QuaternionKeyframeTrack: _tracks_QuaternionKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_5__.QuaternionKeyframeTrack,
    StringKeyframeTrack: _tracks_StringKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_6__.StringKeyframeTrack,
    VectorKeyframeTrack: _tracks_VectorKeyframeTrack_js__WEBPACK_IMPORTED_MODULE_7__.VectorKeyframeTrack,
    AnimationClip: _AnimationClip_js__WEBPACK_IMPORTED_MODULE_8__.AnimationClip
});

/***/ }),

/***/ "./src/animation/math/Interpolant.js":
/*!*******************************************!*\
  !*** ./src/animation/math/Interpolant.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interpolant": function() { return /* binding */ Interpolant; }
/* harmony export */ });
/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;

    this.resultBuffer = resultBuffer !== undefined ?
        resultBuffer : new sampleValues.constructor( sampleSize );
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

    evaluate: function ( t ) {

        const pp = this.parameterPositions;
        let i1 = this._cachedIndex,
            t1 = pp[ i1 ],
            t0 = pp[ i1 - 1 ];

        validate_interval: {

            seek: {

                let right;

                linear_scan: {

                    //- See http://jsperf.com/comparison-to-undefined/3
                    //- slower code:
                    //-
                    //- 				if ( t >= t1 || t1 === undefined ) {
                    forward_scan: if ( ! ( t < t1 ) ) {

                        for ( let giveUpAt = i1 + 2; ; ) {

                            if ( t1 === undefined ) {

                                if ( t < t0 ) break forward_scan;

                                // after end

                                i1 = pp.length;
                                this._cachedIndex = i1;
                                return this.afterEnd_( i1 - 1, t, t0 );

                            }

                            if ( i1 === giveUpAt ) break; // this loop

                            t0 = t1;
                            t1 = pp[ ++ i1 ];

                            if ( t < t1 ) {

                                // we have arrived at the sought interval
                                break seek;

                            }

                        }

                        // prepare binary search on the right side of the index
                        right = pp.length;
                        break linear_scan;

                    }

                    //- slower code:
                    //-					if ( t < t0 || t0 === undefined ) {
                    if ( ! ( t >= t0 ) ) {

                        // looping?

                        const t1global = pp[ 1 ];

                        if ( t < t1global ) {

                            i1 = 2; // + 1, using the scan for the details
                            t0 = t1global;

                        }

                        // linear reverse scan

                        for ( let giveUpAt = i1 - 2; ; ) {

                            if ( t0 === undefined ) {

                                // before start

                                this._cachedIndex = 0;
                                return this.beforeStart_( 0, t, t1 );

                            }

                            if ( i1 === giveUpAt ) break; // this loop

                            t1 = t0;
                            t0 = pp[ -- i1 - 1 ];

                            if ( t >= t0 ) {

                                // we have arrived at the sought interval
                                break seek;

                            }

                        }

                        // prepare binary search on the left side of the index
                        right = i1;
                        i1 = 0;
                        break linear_scan;

                    }

                    // the interval is valid

                    break validate_interval;

                } // linear scan

                // binary search

                while ( i1 < right ) {

                    const mid = ( i1 + right ) >>> 1;

                    if ( t < pp[ mid ] ) {

                        right = mid;

                    } else {

                        i1 = mid + 1;

                    }

                }

                t1 = pp[ i1 ];
                t0 = pp[ i1 - 1 ];

                // check boundary cases, again

                if ( t0 === undefined ) {

                    this._cachedIndex = 0;
                    return this.beforeStart_( 0, t, t1 );

                }

                if ( t1 === undefined ) {

                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.afterEnd_( i1 - 1, t0, t );

                }

            } // seek

            this._cachedIndex = i1;

            this.intervalChanged_( i1, t0, t1 );

        } // validate_interval

        return this.interpolate_( i1, t0, t, t1 );

    },

    settings: null, // optional, subclass-specific settings structure
    // Note: The indirection allows central control of many interpolants.

    // --- Protected interface

    DefaultSettings_: {},

    getSettings_: function () {

        return this.settings || this.DefaultSettings_;

    },

    copySampleValue_: function ( index ) {

        // copies a sample value to the result buffer

        const result = this.resultBuffer,
            values = this.sampleValues,
            stride = this.valueSize,
            offset = index * stride;

        for ( let i = 0; i !== stride; ++ i ) {

            result[ i ] = values[ offset + i ];

        }

        return result;

    },

    // Template methods for derived classes:

    interpolate_: function ( /* i1, t0, t, t1 */ ) {

        throw new Error( 'call to abstract method' );
        // implementations shall return this.resultBuffer

    },

    intervalChanged_: function ( /* i1, t0, t1 */ ) {

        // empty

    }

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

    //( 0, t, t0 ), returns this.resultBuffer
    beforeStart_: Interpolant.prototype.copySampleValue_,

    //( N-1, tN-1, t ), returns this.resultBuffer
    afterEnd_: Interpolant.prototype.copySampleValue_,

} );





/***/ }),

/***/ "./src/animation/math/interpolants/CubicInterpolant.js":
/*!*************************************************************!*\
  !*** ./src/animation/math/interpolants/CubicInterpolant.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CubicInterpolant": function() { return /* binding */ CubicInterpolant; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../constants.js */ "./src/animation/constants.js");
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Interpolant.js */ "./src/animation/math/Interpolant.js");




/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_1__.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_1__.Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding,
		endingEnd: _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__.ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case _constants_js__WEBPACK_IMPORTED_MODULE_0__.WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );





/***/ }),

/***/ "./src/animation/math/interpolants/DiscreteInterpolant.js":
/*!****************************************************************!*\
  !*** ./src/animation/math/interpolants/DiscreteInterpolant.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiscreteInterpolant": function() { return /* binding */ DiscreteInterpolant; }
/* harmony export */ });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./src/animation/math/Interpolant.js");


/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );





/***/ }),

/***/ "./src/animation/math/interpolants/LinearInterpolant.js":
/*!**************************************************************!*\
  !*** ./src/animation/math/interpolants/LinearInterpolant.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinearInterpolant": function() { return /* binding */ LinearInterpolant; }
/* harmony export */ });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./src/animation/math/Interpolant.js");


function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );





/***/ }),

/***/ "./src/animation/math/interpolants/QuaternionLinearInterpolant.js":
/*!************************************************************************!*\
  !*** ./src/animation/math/interpolants/QuaternionLinearInterpolant.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuaternionLinearInterpolant": function() { return /* binding */ QuaternionLinearInterpolant; }
/* harmony export */ });
/* harmony import */ var _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Interpolant.js */ "./src/animation/math/Interpolant.js");

//import { Quaternion } from '../Quaternion.js';

/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	_Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( _Interpolant_js__WEBPACK_IMPORTED_MODULE_0__.Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			THREE.Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );





/***/ }),

/***/ "./src/animation/tracks/BooleanKeyframeTrack.js":
/*!******************************************************!*\
  !*** ./src/animation/tracks/BooleanKeyframeTrack.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BooleanKeyframeTrack": function() { return /* binding */ BooleanKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./src/animation/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");



/**
 * A Track of Boolean keyframe values.
 */

function BooleanKeyframeTrack( name, times, values ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.prototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );




/***/ }),

/***/ "./src/animation/tracks/ColorKeyframeTrack.js":
/*!****************************************************!*\
  !*** ./src/animation/tracks/ColorKeyframeTrack.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorKeyframeTrack": function() { return /* binding */ ColorKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");


/**
 * A Track of keyframe values that represent color.
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.prototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );




/***/ }),

/***/ "./src/animation/tracks/NumberKeyframeTrack.js":
/*!*****************************************************!*\
  !*** ./src/animation/tracks/NumberKeyframeTrack.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumberKeyframeTrack": function() { return /* binding */ NumberKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");


/**
 * A Track of numeric keyframe values.
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.prototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );




/***/ }),

/***/ "./src/animation/tracks/QuaternionKeyframeTrack.js":
/*!*********************************************************!*\
  !*** ./src/animation/tracks/QuaternionKeyframeTrack.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "QuaternionKeyframeTrack": function() { return /* binding */ QuaternionKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./src/animation/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");
/* harmony import */ var _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math/interpolants/QuaternionLinearInterpolant.js */ "./src/animation/math/interpolants/QuaternionLinearInterpolant.js");




/**
 * A Track of quaternion keyframe values.
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.prototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,

	InterpolantFactoryMethodLinear: function ( result ) {

		return new _math_interpolants_QuaternionLinearInterpolant_js__WEBPACK_IMPORTED_MODULE_2__.QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );




/***/ }),

/***/ "./src/animation/tracks/StringKeyframeTrack.js":
/*!*****************************************************!*\
  !*** ./src/animation/tracks/StringKeyframeTrack.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringKeyframeTrack": function() { return /* binding */ StringKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants.js */ "./src/animation/constants.js");
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");



/**
 * A Track that interpolates Strings
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_1__.KeyframeTrack.prototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: _constants_js__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );




/***/ }),

/***/ "./src/animation/tracks/VectorKeyframeTrack.js":
/*!*****************************************************!*\
  !*** ./src/animation/tracks/VectorKeyframeTrack.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VectorKeyframeTrack": function() { return /* binding */ VectorKeyframeTrack; }
/* harmony export */ });
/* harmony import */ var _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../KeyframeTrack.js */ "./src/animation/KeyframeTrack.js");


/**
 * A Track of vectored keyframe values.
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	_KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype = Object.assign( Object.create( _KeyframeTrack_js__WEBPACK_IMPORTED_MODULE_0__.KeyframeTrack.prototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );




/***/ }),

/***/ "./src/cameras/Camera.js":
/*!*******************************!*\
  !*** ./src/cameras/Camera.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Camera": function() { return /* binding */ Camera; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */



class Camera extends THREE.PerspectiveCamera {

    constructor() {
        super(JMT.CAMERA_DEFAULT_FOV, 1, JMT.CAMERA_WALK_NEAR, JMT.CAMERA_MIN_FAR)

        this._defaultFov = this.fov;
        this._exposure = this._defaultExposure = 0;
        this._gamma = this._defaultGamma = 1;
        this._autoExposure = !1;
        this._autoExposureDarkness = .3;
        this._moveMaxSpeed = JMT.CAMERA_DEFAULT_MOVE_MAX_SPEED;
        this._autoClimb = !1;
        this._colorMap = null;

        this._changeFar = this.far;
        this._changeNear = this.near;

        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(this, 'defaultGamma')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(this, 'moveMaxSpeed')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(this, 'autoClimb')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(this, 'autoExposureDarkness')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.defineProperty)(this, 'defaultExposure')
    }

    _updated() {
        return this.dispatchEvent({
            type: "cameraUpdated",
            target: null
        })
    }

    colorMapReady() {
        return this._colorMap && this._colorMap.loaded
    }

    setExposureController(exposureController) {
        this.exposureController = exposureController
    }

    setExposure(exposure) {
        this.exposureController ? this.exposureController.setTargetExposure(exposure) : this.exposure = exposure
    }

    setGamma(gamma) {
        this.gamma = gamma
    }

    setFar(far) {
        this.far = far;
        this._changeFar = far;
        this.changeFar = far;
        this.updateProjectionMatrix();
        this._updated()
    }

    serialize() {
        return {
            fov: this.defaultFov,
            far: this.changeFar,
            near: this.changeNear,
            exposure: this.defaultExposure,
            gamma: this.defaultGamma,
            lutTexture: this.colorMap ? this.colorMap.serialize() : null,
            autoClimb: this.autoClimb,
            moveMaxSpeed: this.moveMaxSpeed
        }
    }
}


Object.defineProperty(Camera.prototype, "gamma", {
    get: function () {
        return this._gamma
    },
    set: function (a) {
        if (a !== this._gamma) {
            this._gamma = a
            this.dispatchEvent({
                type: "gammaUpdated",
                target: null
            })
        }
    }
});

Object.defineProperty(Camera.prototype, "autoExposure", {
    get: function () {
        return this._autoExposure
    },
    set: function (a) {
        if (a !== this._autoExposure) {
            this._autoExposure = a
            this._exposure = this._defaultExposure
            this._updated()
        }
    }
});


Object.defineProperty(Camera.prototype, "defaultFov", {
    get: function () {
        return this._defaultFov
    },
    set: function (a) {
        this.fov = this._defaultFov = a;
        this._updated()
    }
});

Object.defineProperty(Camera.prototype, "changeFar", {
    get: function () {
        return this._changeFar
    },
    set: function (a) {
        this.far = this._changeFar = a;
        this.updateProjectionMatrix()
        this._updated()
    }
});

Object.defineProperty(Camera.prototype, "changeNear", {
    get: function () {
        return this._changeNear
    },
    set: function (a) {
        this.near = this._changeNear = a;
        this.updateProjectionMatrix()
        this._updated()
    }
});

Object.defineProperty(Camera.prototype, "colorMap", {
    get: function () {
        return this._colorMap
    },
    set: function (a) {
        var b = this;
        this._colorMap && this._colorMap.dispose();
        (this._colorMap = a) ? a.addLoadedListener(function () {
            return b.dispatchEvent({
                type: "colorMapUpdated",
                target: null
            })
        }): this.dispatchEvent({
            type: "colorMapUpdated",
            target: null
        })
    }
});


Object.defineProperty(Camera.prototype, "exposure", {
    get: function () {
        return this._exposure
    },
    set: function (a) {
        if (a !== this._exposure) {
            this._exposure = a
            this.dispatchEvent({
                type: "exposureUpdated",
                target: null
            })
        }
    }
});

JMT.Camera = Camera

/***/ }),

/***/ "./src/cameras/CameraVolume.js":
/*!*************************************!*\
  !*** ./src/cameras/CameraVolume.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraVolume": function() { return /* binding */ CameraVolume; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


function onCameraVolumeUpdated(a) { // a
    a.dispatchEvent({type: "cameraVolumeUpdated", cameraVolume: a})
}

var b = null, c = null, d = new THREE.Vector3, e = new THREE.Quaternion;
function CameraVolume (a) {
    this.id = a.id;
    this.pId = a.pId;
    this.name = a.name;
    this._type = a.type;
    console.assert(0 <= CameraVolume.CameraVolumeTypes.indexOf(this._type));
    this.position = (new THREE.Vector3).fromArray(a.position);
    this.rotation = (new JMT.Euler).setFromDegTriple(a.rotation);
    this.scale = (new THREE.Vector3).fromArray(a.scale);
    this.exposure = a.exposure;
    this.gamma = a.gamma;
    this.assetType = a.assetType;
    this._inverse = new THREE.Matrix4;
    this._inverseDirty = !0


    Object.defineProperty(this, "camPosition", {
        get: ()=> {
            return this.position
        },
        set: (value)=> {
            this.setPosition(value.x, value.y, value.z)
        }
    })

    Object.defineProperty(this, "camScale", {
        get: ()=> {
            return this.scale
        },
        set: (value)=> {
            this.setScale(value.x, value.y, value.z)
        }
    })

    Object.defineProperty(this, "rotationDeg", {
        get : ()=>{
            return {
                x: this.rotation.yawDeg,
                y: this.rotation.pitchDeg,
                z: this.rotation.rollDeg
            }
        },
        set : (value)=>{
            if(undefined !== value._x){
                value = {
                    x : value._x,
                    y : value._y,
                    z : value._z
                }
            }
            this.setRotationDeg(value.x,value.y,value.z)
        }
    })
};
CameraVolume.CameraVolumeTypes = ["cube", "sphere"];
CameraVolume.prototype = Object.assign(Object.create(THREE.EventDispatcher.prototype), {
    constructor: CameraVolume,
    getVolumeGeometry: function () {
        b || (b = new THREE.BoxBufferGeometry(2, 2, 2), b.addTriangleOrderAttribute(), b.convertNormalsToSpherical(), c = new THREE.IcosahedronBufferGeometry(1, 2), c.addTriangleOrderAttribute(), c.convertNormalsToSpherical());
        return "sphere" === this._type ? c : b
    }, setName: function (b) {
        this.name = b;
        onCameraVolumeUpdated(this)
    }, setPosition: function (b, c, d) {
        this.position.set(b, c, d);
        this._inverseDirty = !0;
        onCameraVolumeUpdated(this)
    }, setRotation: function (b, c, d) {
        this.rotation.yaw = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(b);
        this.rotation.pitch = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(c);
        this.rotation.roll = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(d);
        this._inverseDirty = !0;
        onCameraVolumeUpdated(this)
    }, setRotationDeg: function (a, b, c) {
        a = THREE.Math.degToRad(a);
        b = THREE.Math.degToRad(b);
        c = THREE.Math.degToRad(c);
        this.setRotation(a, b, c)
    }, setScale: function (b, c, d) {
        this.scale.set(b, c, d);
        this._inverseDirty = !0;
        onCameraVolumeUpdated(this)
    }, setExposure: function (b) {
        this.exposure =
            b;
        onCameraVolumeUpdated(this)
    }, setGamma: function (b) {
        this.gamma = b;
        onCameraVolumeUpdated(this)
    }, worldCoordinatesInside: function (a) {
        this._inverseDirty && (this._inverseDirty = !1, this._inverse.compose(this.position, e.setFromEuler(this.rotation), this.scale), this._inverse.getInverse(this._inverse));
        d.copy(a).applyMatrix4(this._inverse);
        return "sphere" === this._type ? 1 >= d.lengthSq() : 1 >= Math.abs(d.x) && 1 >= Math.abs(d.y) && 1 >= Math.abs(d.z)
    }, serialize: function () {
        return {
            id: this.id,
            name: this.name,
            type: this._type,
            position: this.position.toArray(),
            rotation: this.rotation.toDegTriple(),
            scale: this.scale.toArray(),
            exposure: this.exposure,
            gamma: this.gamma,
            assetType : this.assetType,
            pId:this.pId
        }
    }, dispose: function () {
    }
});

//THREE.EventDispatcher.prototype.apply(CameraVolume.prototype)

JMT.CameraVolume = CameraVolume


/***/ }),

/***/ "./src/cameras/CubeCamera.js":
/*!***********************************!*\
  !*** ./src/cameras/CubeCamera.js ***!
  \***********************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

function createCamera(a, d, e, g) {
    for (var c = [], h = 0; 6 > h; h += 1) {
        var k = g ? new THREE.OrthographicCamera(-1, 1, 1, -1, a, d) : new THREE.PerspectiveCamera(90, 1, a, d);
        e.add(k);
        c.push(k)
    }
    c[0].up.set(0, -1, 0);
    b.set(1, 0, 0);
    c[0].lookAt(b);
    c[1].up.set(0, -1, 0);
    b.set(-1, 0, 0);
    c[1].lookAt(b);
    c[2].up.set(0, 0, 1);
    b.set(0, 1, 0);
    c[2].lookAt(b);
    c[3].up.set(0, 0, -1);
    b.set(0, -1, 0);
    c[3].lookAt(b);
    c[4].up.set(0, -1, 0);
    b.set(0, 0, 1);
    c[4].lookAt(b);
    c[5].up.set(0, -1, 0);
    b.set(0, 0, -1);
    c[5].lookAt(b);
    return c
}

var b = new THREE.Vector3;
class CubeCamera extends THREE.Object3D {
    constructor(b, d) {
        super();
        this.sideCameras = createCamera(b, d, this, !1);
    }  
};
JMT.CubeCamera = CubeCamera


class OrthoCubeCamera extends THREE.Object3D {
    constructor(b, d) {
        super();
        this.sideCameras = createCamera(b, d, this, !0);
    }
};
JMT.OrthoCubeCamera = OrthoCubeCamera

/***/ }),

/***/ "./src/controllers/AnimationController.js":
/*!************************************************!*\
  !*** ./src/controllers/AnimationController.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationController": function() { return /* binding */ AnimationController; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

class AnimationController {

    constructor(vrManagers, onupdate, onrenderIdle) {

        var t = this
        t._clock = new THREE.Clock
        t.h = !1
        t.k = !1
        t.rendering = !1
        t.p = 0
        t._enabled = !1

        t.initRenderFunc(vrManagers, onupdate, onrenderIdle)
    }

    initRenderFunc(vrManagers, onupdate, onrenderIdle){

        let t = this

        t.vrManagers = vrManagers

        function onVrRender() {

            render(vrManagers.vrEnabled())

        }

        function  onRender() {

            render(!1)

        }

        function render(isVrRendering) {

            if (t._enabled) {

                t.k = !1

                if (t.rendering) {

                    console.assert(!isVrRendering)

                    if (onrenderIdle(t._clock.getDelta(), t.p)) {

                        t.p += 1

                        t .render()

                    }
                    else {

                        t.rendering = !1

                    }
                }
                else {

                    t.h = !0

                    onupdate(t._clock.getDelta(), isVrRendering)

                    JMT.ALWAYS_RENDER && t.requestFrame()

                    t.h = !1

                    if (!t.k) {

                        t.rendering = !0

                        t.p = 0

                        t.render()
                    }
                }
            }
        }

        t.render = function(delta) {

            if (!this.k) {

                this.h || this._clock.getDelta()

                this.k = !0

                if(vrManagers.vrEnabled()){

                    vrManagers.requestAnimationFrame(onVrRender)

                }
                else {

                    requestAnimationFrame(onRender)

                }
            }
        }
    }


    requestFrame(delta) {

        if (this._enabled) {

            this.rendering = !1

            this.render(delta)

        }

    }

    disable() {

        this._enabled = !1

    }

    enable() {

        this._enabled = !0;

        this.k = !1;

        this.requestFrame()

    }

    isEnabled() {

        return this._enabled

    }
}

/***/ }),

/***/ "./src/controllers/CameraVolumeControls.js":
/*!*************************************************!*\
  !*** ./src/controllers/CameraVolumeControls.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraVolumeControls": function() { return /* binding */ CameraVolumeControls; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
function CameraVolumeControls(a, b) {
    function c(a) {
        function b() {
            d.position.copy(a.position);
            d.rotation.copy(a.rotation);
            d.scale.copy(a.scale);
            d.updateMatrixWorld()
        }

        var c = JMT.createBoundingBoxMaterial(),
            d = new THREE.Mesh(a.getVolumeGeometry(), c);
        d.visible = !1;
        d.visibilityId = null;
        g.add(d);
        e.set(a, d);
        b(a);
        a.addEventListener("cameraVolumeUpdated", b)
    }

    var d = function () {},
        e = new Map,
        g = new THREE.Object3D;
    g.visible = !1;
    a.addAuxiliaryObject(g);
    this.setHighlightedCameraVolume = function (a) {
        d();
        var b =
            e.get(a);
        b.visible = !0;
        d = function () {
            return b.visible = !1
        };
        return b.material
    };

    // lilingfeng 
    this.showCameraVolume = function (arr) {
        a.cameraVolumes.forEach(element => {
            var b = e.get(element);
            if(arr.includes(element)){            
                b.visible = !0;
            }else{
                b.visible = !1;
            }
           
        });
    };

    this.setControlsVisible = function (a) {
        g.visible = a;
        b.requestFrame()
    };
    a.addEventListener("cameraVolumeAdded", function (a) {
        c(a.cameraVolume);
        b.requestFrame()
    });
    a.addEventListener("cameraVolumeRemoved", function (a) {
        a = a.cameraVolume;
        var c = e.get(a);
        g.remove(c);
        c.material.dispose();
        e.delete(a);
        b.requestFrame()
    });
    for (var f = 0; f < a.cameraVolumes.length; f += 1) c(a.cameraVolumes[f])
}



/***/ }),

/***/ "./src/controllers/Controls.js":
/*!*************************************!*\
  !*** ./src/controllers/Controls.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Controls": function() { return /* binding */ Controls; }
/* harmony export */ });
/* harmony import */ var _OrbitControls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./OrbitControls.js */ "./src/controllers/OrbitControls.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/jscomp.js */ "./src/lib/jscomp.js");
/**
 * Created by Kai on 2020/12/18.
 */




const DuodecimalPI = Math.PI / 12;

_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const RecognitionSymbol = Symbol("GESTURE_RECOGNITION");    // Y
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const PinchSymbol = Symbol("GESTURE_PINCH");    // Q
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const TwoPointerDragSymbol = Symbol("GESTURE_TWO_POINTER_DRAG");   // C
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const IgnoreSymbol = Symbol("GESTURE_IGNORE")

_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const MoveSourceNoneSymbol = Symbol("MOVE_SOURCE_NONE");    //x
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const MoveSourceKeySymbol = Symbol("MOVE_SOURCE_KEY");    // t
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const MoveSourceGustureSymbol = Symbol("MOVE_SOURCE_GESTURE");    // v
_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_2__.$jscomp.initSymbol();
const MoveSourceGamepadSymbol = Symbol("MOVE_SOURCE_GAMEPAD") // w

class Controls {
    constructor(camera, viewport, gamepadMgr, aniController) {
        let t = this
        t._camera = camera
        t.viewport = viewport
        t.gamepadMgr = gamepadMgr
        t.aniController = aniController

        t.flipMouseLook = t.mousePressLook = !1;
        t.restrictVerticalAngle = t.mouseControlsPitch = !0;
        t.verticalAngleMin = -Math.PI / 2;
        t.verticalAngleMax = Math.PI / 3;
        t.arrowsTurn = !0;

        t.orbit = new _OrbitControls_js__WEBPACK_IMPORTED_MODULE_0__.OrbitControls(camera, t, viewport, aniController);
        t.orbit.keyYawRotateSpeed = JMT.CAMERA_ARROWS_TURN_SPEED;
        t.orbit.keyPitchRotateSpeed = JMT.CAMERA_ARROWS_TURN_SPEED / 2;
        t.cameraHeight = null;


        camera.rotation.set(0, 0, 0);
        camera.up.set(0, 0, 1);
        camera.lookAt(new THREE.Vector3(0, 1, 0));


        t.fpsEnabled = !0;
        t.MAX_PER_FRAME_LINEAR_DISTANCE = 1;
        t.leftRightMoveHelper = new MoveHelper(t.MAX_PER_FRAME_LINEAR_DISTANCE) // A
        t.forwardBackMoveHelper = new MoveHelper(t.MAX_PER_FRAME_LINEAR_DISTANCE)   // y
        t.upDownMoveHelper = new MoveHelper(t.MAX_PER_FRAME_LINEAR_DISTANCE)    // E
        t.uTurnMoveHelper = new MoveHelper(DuodecimalPI)   // I

        t.curScreenPos = [new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)]
        t.lastScreenPos = [new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)]
        t.startScreenPos = [new THREE.Vector2(0, 0), new THREE.Vector2(0, 0)]   // N
        t.cameraScrollDelta = 0;    // T


        t.pinchTime = 0 // D
        t.twoPointDragTime = 0

        t.mousePressed = !1
        t.hmdFirstSet = !1

        t.cameraLookRotation = new THREE.Vector3(0, 0, 0)   // P
        t.hmdRotation = new THREE.Euler(0, 0, 0);

        t.symbol = null // H

        t.cameraRoll = new THREE.Object3D   // W
        t.cameraPitch = new THREE.Object3D  // M
        t.cameraAgent = new THREE.Object3D  // R
        t.cameraRoll.add(camera);
        t.cameraPitch.add(t.cameraRoll);
        t.cameraAgent.add(t.cameraPitch);

        t.cameraPositionUpdated = function () {
            var c = null, d = null, e = null;
            return function () {
                t.cameraAgent.updateMatrixWorld(!0);
                var f = t.cameraAgent.position;
                if (c !== f.x || d !== f.y || e !== f.z) {
                    c = f.x
                    d = f.y
                    e = f.z
                    camera.dispatchEvent({type: "positionChanged", target: null})
                }
            }
        }();


        t.onHmdUpdate = function () {
            var a = new THREE.Vector3()
            var b = new THREE.Vector3()
            var c = new THREE.Vector3()
            var d = new THREE.Vector3()
            var e = new THREE.Vector3()
            return function (f, k) {
                if (t.fpsEnabled) {
                    t.hmdRotation.copy(f)

                    if (t.hmdFirstSet) {
                        t.cameraLookRotation.z -= t.hmdRotation.z
                    }
                    else if (k) {
                        d.subVectors(k, c)
                        a.set(Math.cos(t.cameraLookRotation.z), Math.sin(t.cameraLookRotation.z), 0)
                        b.set(-Math.sin(t.cameraLookRotation.z), Math.cos(t.cameraLookRotation.z), 0)
                        e.copy(a.multiplyScalar(d.x))
                        e.add(b.multiplyScalar(d.y))
                        e.z = d.z
                        t.cameraAgent.position.add(e)
                    }

                    k && c.copy(k)
                    t.hmdFirstSet = !1
                    t._updateCameraRotation()
                }
            }

        }();

        t._handleEvent()

    }


    _normalizeRotation() { // e
        this.cameraAgent.rotation.z = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.normalizeRotation)(this.hmdRotation.z + this.cameraLookRotation.z)
    }

    _handleEvent() {
        let r = this

        function solvePointerEventArgs(a) {   // h
            r.lastScreenPos[0].copy(r.curScreenPos[0]);
            r.lastScreenPos[1].copy(r.curScreenPos[1]);
            if (a.touches) {
                r.curScreenPos[0].set(a.touches[0].clientX, a.touches[0].clientY)
                if (2 === a.touches.length) {
                    r.curScreenPos[1].set(a.touches[1].clientX, a.touches[1].clientY)
                }
                else {
                    r.curScreenPos[1].set(0, 0)
                }
            }
            else {
                r.curScreenPos[0].set(a.clientX, a.clientY)
                r.curScreenPos[1].set(0, 0)
            }
        }

        function _validateY(a) {   // f
            return 40 >= Math.abs(a[0].y - a[1].y)
        }

        function onmousedown(event) {   // n
            if (UjP.viewer.disableMoveByClick) {
                return
            }
            if (r.fpsEnabled) {
                r.viewport.focus()
                event.preventDefault()
                solvePointerEventArgs(event)
                r.mousePressed = !0
                r.aniController.requestFrame()
            }
        }

        function onmouseup(event) { // p
            if (r.fpsEnabled) {
                event.preventDefault()
                r.mousePressed = !1
            }
        }

        function onmousemove(event) {   // k
            if (r.fpsEnabled) {
                event.preventDefault()
                solvePointerEventArgs(event)
                if (r.symbol) {
                    if (r.symbol !== IgnoreSymbol) {
                        if (r.symbol === RecognitionSymbol) {
                            var b = r.startScreenPos[0].distanceTo(r.startScreenPos[1]);
                            var a = r.curScreenPos[0].distanceTo(r.curScreenPos[1]);
                            if (10 <= Math.abs(a - b)) {
                                r.symbol = PinchSymbol
                                b = !0
                            }
                            else if (_validateY(r.O) && _validateY(N) && 10 <= Math.abs(r.curScreenPos[0].y - r.startScreenPos[0].y)) {
                                r.symbol = TwoPointerDragSymbol
                                b = !0
                            }
                            else {
                                b = !1;
                            }
                            if (!b) {
                                return
                            }
                        }
                        if (r.symbol === PinchSymbol) {
                            b = r.lastScreenPos[1].distanceTo(r.lastScreenPos[0])
                            b = r.curScreenPos[1].distanceTo(r.curScreenPos[0]) - b
                            if (0 < Math.abs(b)) {
                                r.pinchTime = Date.now()
                                r.forwardBackMoveHelper.activateDirectionFromSource(Math.sign(b), MoveSourceGustureSymbol)
                            }
                            r.aniController.requestFrame()
                        }
                        else if (r.symbol === TwoPointerDragSymbol && _validateY(O)) {
                            b = r.curScreenPos[0].y - r.lastScreenPos[0].y
                            if (0 < Math.abs(b)) {
                                r.twoPointDragTime = Date.now()
                                r.upDownMoveHelper.activateDirectionFromSource(Math.sign(b), MoveSourceGustureSymbol)
                            }
                            r.aniController.requestFrame()
                        }
                    }
                }
                else if (!r.mousePressLook || r.mousePressed || !r.symbol && event.touches) {
                    b = event.movementX || event.mozMovementX || event.webkitMovementX;
                    void 0 === b && (b = r.curScreenPos[0].x - r.lastScreenPos[0].x);
                    var c = event.movementY || event.mozMovementY || event.webkitMovementY;
                    void 0 === c && (c = r.curScreenPos[0].y - r.lastScreenPos[0].y);
                    var a = r.flipMouseLook || !r.symbol && event.touches ? 1 : -1;

                    r.cameraLookRotation.z += a * b * JMT.CAMERA_LOOK_SPEED;
                    if (r.mouseControlsPitch) {
                        r.cameraLookRotation.x += a * c * JMT.CAMERA_LOOK_SPEED
                    }
                    if (r.restrictVerticalAngle) {
                        // 限制视角
                        if (r.cameraLookRotation.x > r.verticalAngleMax) {
                            r.cameraLookRotation.x = r.verticalAngleMax
                        }
                        else if (r.cameraLookRotation.x < r.verticalAngleMin) {
                            r.cameraLookRotation.x = r.verticalAngleMin
                        }
                    }
                    r._updateCameraRotation();
                    r.aniController.requestFrame()
                }
            }
        }

        function onmousewheel(a) {  // l
            var c = 0, e;
            (e = !r.fpsEnabled) || (e = void 0 !== document.hasFocus ? document.hasFocus() : document.activeElement === b, e = !e);
            e || (a || (a = window.event), a.preventDefault(), a.wheelDelta ? c = a.wheelDelta / 120 : a.detail && (c = -a.detail / 3), r.cameraScrollDelta += c * JMT.CAMERA_SCROLL_SPEED, r.cameraScrollDelta = 0 <= r.cameraScrollDelta ? Math.min(r.cameraScrollDelta, .5) : Math.max(r.cameraScrollDelta, -.5), r.aniController.requestFrame())

        }


        function onkeydown(a) {
            var b = !0;
            if (r.fpsEnabled /*&& !isModifierPressed(a)*/) {
                switch (a.keyCode) {
                    case 38:
                    case 87:
                        r.forwardBackMoveHelper.activateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 37:
                        if (r.arrowsTurn) {
                            r.uTurnMoveHelper.activateDirectionFromSource(1, MoveSourceKeySymbol)
                        }
                        else {
                            r.leftRightMoveHelper.activateDirectionFromSource(-1, MoveSourceKeySymbol);
                        }
                        break;
                    case 65:
                        r.leftRightMoveHelper.activateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    case 40:
                    case 83:
                        r.forwardBackMoveHelper.activateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    case 39:
                        if (r.arrowsTurn) {
                            r.uTurnMoveHelper.activateDirectionFromSource(-1, MoveSourceKeySymbol)
                        }
                        else {
                            r.leftRightMoveHelper.activateDirectionFromSource(1, MoveSourceKeySymbol);
                        }
                        break;
                    case 68:
                        r.leftRightMoveHelper.activateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 33: // Page up
                    case 32: // 空格
                    case 69: // E
                        r.upDownMoveHelper.activateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 34: // Page down
                    case 17: // Ctrl
                    case 81: // Q
                        r.upDownMoveHelper.activateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    default:
                        b = !1
                }
                if (b) {
                    a.preventDefault()
                    r.aniController.requestFrame()
                }
            }
        }

        function onkeyup(a) {
            var b = !0;
            if (r.fpsEnabled) {
                switch (a.keyCode) {
                    case 38:
                    case 87:
                        r.forwardBackMoveHelper.deactivateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 37:
                    case 65:
                        r.uTurnMoveHelper.deactivateDirectionFromSource(1, MoveSourceKeySymbol);
                        r.leftRightMoveHelper.deactivateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    case 40:
                    case 83:
                        r.forwardBackMoveHelper.deactivateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    case 39:
                    case 68:
                        r.uTurnMoveHelper.deactivateDirectionFromSource(-1, MoveSourceKeySymbol);
                        r.leftRightMoveHelper.deactivateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 33: // Page up
                    case 32: // 空格
                    case 69: // E
                        r.upDownMoveHelper.deactivateDirectionFromSource(1, MoveSourceKeySymbol);
                        break;
                    case 34: // Page down
                    case 17: // Ctrl
                    case 81: // Q
                        r.upDownMoveHelper.deactivateDirectionFromSource(-1, MoveSourceKeySymbol);
                        break;
                    default:
                        b = !1
                }
                b && a.preventDefault()
            }
        }

        function onActionActivated(a) {
            if (r.fpsEnabled) {
                switch (a.action) {
                    case JMT.GAMEPAD_ACTION.BACKWARD:
                        r.forwardBackMoveHelper.activateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.FORWARD:
                        r.forwardBackMoveHelper.activateDirectionFromSource(1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.LEFT:
                        if(r.arrowsTurn){
                            r.uTurnMoveHelper.activateDirectionFromSource(1, MoveSourceGamepadSymbol)
                        }
                        else {
                            r.leftRightMoveHelper.activateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        }
                        break;
                    case JMT.GAMEPAD_ACTION.RIGHT:
                        if(r.arrowsTurn){
                            r.uTurnMoveHelper.activateDirectionFromSource(-1, MoveSourceGamepadSymbol)
                        }
                        else {
                            r.leftRightMoveHelper.activateDirectionFromSource(1, MoveSourceGamepadSymbol);
                        }
                        break;
                    case JMT.GAMEPAD_ACTION.DOWN:
                        r.upDownMoveHelper.activateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.UP:
                        r.upDownMoveHelper.activateDirectionFromSource(1, MoveSourceGamepadSymbol)
                }
            }
        }

        function onActionDeactivated(a) {
            if (r.fpsEnabled) {
                switch (a.action) {
                    case JMT.GAMEPAD_ACTION.BACKWARD:
                        r.forwardBackMoveHelper.deactivateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.FORWARD:
                        r.forwardBackMoveHelper.deactivateDirectionFromSource(1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.LEFT:
                        r.leftRightMoveHelper.deactivateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        r.uTurnMoveHelper.deactivateDirectionFromSource(1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.RIGHT:
                        r.leftRightMoveHelper.deactivateDirectionFromSource(1, MoveSourceGamepadSymbol);
                        r.uTurnMoveHelper.deactivateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.DOWN:
                        r.upDownMoveHelper.deactivateDirectionFromSource(-1, MoveSourceGamepadSymbol);
                        break;
                    case JMT.GAMEPAD_ACTION.UP:
                        r.upDownMoveHelper.deactivateDirectionFromSource(1, MoveSourceGamepadSymbol)
                }
            }
        }

        function ontouchstart(a) {
            if (r.fpsEnabled) {
                a.preventDefault()
                solvePointerEventArgs(a)
                if (2 === a.touches.length) {
                    r.symbol = RecognitionSymbol
                    r.startScreenPos[0].copy(r.curScreenPos[0])
                    r.startScreenPos[1].copy(r.curScreenPos[1])
                }
                else if (2 < a.touches.length) {
                    r.symbol = IgnoreSymbol
                }
            }
        }

        r.viewport.setAttribute("tabindex", -1);
        r.viewport.addEventListener("contextmenu", function (a) {
            a.preventDefault()
        }, !1);
        r.viewport.addEventListener("mousedown", onmousedown, !1);
        r.viewport.addEventListener("mousemove", onmousemove, !1);
        r.viewport.addEventListener("touchmove", onmousemove, !1);
        r.viewport.addEventListener("mouseup", onmouseup, !1);
        r.viewport.addEventListener("touchstart", ontouchstart, !1);
        r.viewport.addEventListener("touchend", function (a) {
            if (r.fpsEnabled) {
                a.preventDefault()
                r.symbol = 0 === a.touches.length ? null : IgnoreSymbol
            }
        }, !1);
        r.viewport.addEventListener("keydown", onkeydown, !1);

        r.viewport.addEventListener("keyup", onkeyup, !1);
        r.viewport.addEventListener("mouseout", onmouseup, !1);
        r.viewport.addEventListener("mouseenter", function (a) {
            0 < a.buttons && onmousedown(a)
        }, !1);
        r.viewport.addEventListener("DOMMouseScroll", onmousewheel, !1);
        r.viewport.addEventListener("mousewheel", onmousewheel, !1);
        r.viewport.addEventListener("blur", function (a) {
            r._stopAll()
        }, !1);

        r.gamepadMgr.addEventListener("actionActivated", onActionActivated);
        r.gamepadMgr.addEventListener("actionDeactivated", onActionDeactivated);
    }

    _stopAll() {    // q
        let r = this
        r.stopForward();
        r.stopBackward();
        r.stopLeft();
        r.stopRight();
        r.stopUp();
        r.stopDown();
        r.uTurnMoveHelper.stopInDirection(1);
        r.uTurnMoveHelper.stopInDirection(-1)
    }

    isFpsEnabled() {
        return this.fpsEnabled
    }

    isOrbitEnabled() {
        return this.orbit.isEnabled()
    }

    orbitModeEnable() {
        this.fpsEnabled = !1;
        this.orbit.enable()
    }

    camera() {
        return this._camera
    }

    applyCameraYaw(a) {
        a.applyEuler(this.cameraAgent.rotation)
    }

    cameraWorldPosition() {
        return this.cameraAgent.position
    }

    _updateCameraRotation() {   // g
        this._normalizeRotation();
        this.cameraPitch.rotation.x = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.normalizeRotation)(this.hmdRotation.x + this.cameraLookRotation.x);
        this.cameraRoll.rotation.y = this.hmdRotation.y;
        this.cameraAgent.updateMatrixWorld(!0)
        this._camera.dispatchEvent({type: "rotationChanged", target: null})
    }

    resetRollAngle() {
        if (0 !== this.cameraRoll.rotation.y) {
            this.hmdRotation.y = 0
            this._updateCameraRotation()
        }
    }

    getPitchAngle() {
        return this.cameraPitch.rotation.x
    }

    setPitchAngle(a) {
        if (a !== this.cameraPitch.rotation.x) {
            this.cameraLookRotation.x = a
            this.hmdRotation.x = 0
            this._updateCameraRotation()
        }
    }

    resetPitchAngle() {
        this.setPitchAngle(0)
    }

    getYawAngle() {
        return this.cameraAgent.rotation.z
    }

    setYawAngle(a) {
        if (a !== this.cameraAgent.rotation.z) {
            this.cameraLookRotation.z = a
            this.hmdRotation.z = 0
            this._updateCameraRotation()
        }
    }

    resetYawAngle() {
        this.setYawAngle(0)
    }

    isHandlingGesture() {
        return null !== this.symbol
    }

    hmdReset() {
        this.hmdFirstSet = !0;
        this.resetPitchAngle()
    }

    maxFrameMoveLinearDistance(b) {
        return Math.min(b * this._camera.moveMaxSpeed, this.MAX_PER_FRAME_LINEAR_DISTANCE)
    }

    movesForward() {
        return this.forwardBackMoveHelper.movesInDirection(1) || 0 < this.cameraScrollDelta
    }

    stopForward() {
        0 < this.cameraScrollDelta && (this.cameraScrollDelta = 0);
        this.forwardBackMoveHelper.stopInDirection(1)
    }

    movesBackward() {
        return this.forwardBackMoveHelper.movesInDirection(-1) || 0 > this.cameraScrollDelta
    }

    stopBackward() {
        0 > this.cameraScrollDelta && (this.cameraScrollDelta = 0);
        this.forwardBackMoveHelper.stopInDirection(-1)
    }

    movesLeft() {
        return this.leftRightMoveHelper.movesInDirection(-1)
    }

    stopLeft() {
        this.leftRightMoveHelper.stopInDirection(-1)
    }

    movesRight() {
        return this.leftRightMoveHelper.movesInDirection(1)
    }

    stopRight() {
        this.leftRightMoveHelper.stopInDirection(1)
    }

    movesUp() {
        return this.upDownMoveHelper.movesInDirection(1)
    }

    stopUp() {
        this.upDownMoveHelper.stopInDirection(1)
    }

    movesDown() {
        return this.upDownMoveHelper.movesInDirection(-1)
    }

    stopDown() {
        this.upDownMoveHelper.stopInDirection(-1)
    }

    enable() {
        this.orbit.disable();
        this.fpsEnabled = !0;
        this.mousePressed = 0
    }

    disable() {
        this.orbit.disable();
        this.fpsEnabled = !1;
        this._stopAll()
    }

    update(b) {
        if (this.fpsEnabled) {
            
            if (this.forwardBackMoveHelper.activeSource === MoveSourceGustureSymbol && 100 < Date.now() - this.pinchTime) {
                this.forwardBackMoveHelper.deactivateSource(MoveSourceGustureSymbol);
            }
            if (this.upDownMoveHelper.activeSource === MoveSourceGustureSymbol && 100 < Date.now() - this.twoPointDragTime) {
                this.upDownMoveHelper.deactivateSource(MoveSourceGustureSymbol);
            }

            var offsetX = this.leftRightMoveHelper.update(this._camera.moveMaxSpeed, b)
            var offsetY = this.forwardBackMoveHelper.update(this._camera.moveMaxSpeed, b)
            var offsetZ = this.upDownMoveHelper.update(this._camera.moveMaxSpeed, b);
            var k = 0;

            if (offsetY) {

                this.cameraScrollDelta = 0

            }
            else {

                if (this.cameraScrollDelta) {

                    offsetY = this.maxFrameMoveLinearDistance(b)

                    k = THREE.Math.clamp(this.cameraScrollDelta, -offsetY, offsetY)

                    this.cameraScrollDelta -= k
                }

                offsetY = k
            }

            this.cameraAgent.translateX(offsetX);
            this.cameraAgent.translateY(offsetY);
            this.cameraAgent.translateZ(offsetZ);

            b = this.uTurnMoveHelper.update(JMT.CAMERA_ARROWS_TURN_SPEED, b);
            this.cameraLookRotation.z += b;
            this._normalizeRotation();

            if(this.leftRightMoveHelper.moves() ||
                this.forwardBackMoveHelper.moves() ||
                this.upDownMoveHelper.moves() ||
                this.uTurnMoveHelper.moves() ||
                this.cameraScrollDelta){
                this.aniController.requestFrame();
            }
            this.cameraPositionUpdated()
        }
        else {
            this.orbit.update(b)
        }
    }

    isEnabled() {
        return this.fpsEnabled
    }
}

class MoveHelper {   // z
    constructor(threshold) {
        this.threshold = threshold
        this._activeDirection = 0;
        this._activeSource = MoveSourceNoneSymbol;
        this._speed = 0;

        //defineProperty(this, 'activeDirection')
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'activeSource')
        ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.defineProperty)(this, 'speed')

        Object.defineProperty(this, 'activeDirection', {
            get: ()=> {
                return this['_activeDirection']
            },
            set: t=> {
                this['_activeDirection'] = t
            }
        })
    }

    moves() {
        return this.activeDirection || this.speed
    }

    movesInDirection(a) {
        return this.activeDirection === a || Math.sign(this.speed) === a
    }

    activateDirectionFromSource(a, moveSource) {
        this.activeDirection = a;
        this.activeSource = moveSource

        UjP.dispatchEvent({type:'activateDirectionFromSource'})
    }

    deactivateDirectionFromSource(a, moveSource) {
        if (this.activeDirection === a && this.activeSource === moveSource) {
            this.activeDirection = 0
            this.activeSource = moveSource
        }

        UjP.dispatchEvent({type:'deactivateDirectionFromSource'})
    }

    deactivateSource(a) {
        if (this.activeSource === a) {
            this.activeDirection = 0
            this.activeSource = MoveSourceNoneSymbol
        }
    }

    stopInDirection(a) {
        if (this.activeDirection === a) {
            this.activeDirection = 0
            this.activeSource = MoveSourceNoneSymbol
        }
        Math.sign(this.speed) === a && (this.speed = 0)
    }

    update(b, c) {
        if (!this.moves()) {
            return 0;
        }
        var d = Math.sign(this.speed)
        var e = this.activeDirection || -d;
        e = c * e * (d === e ? b / JMT.CAMERA_FULL_ACCELERATION_TIME : b / JMT.CAMERA_FULL_DECELERATION_TIME);
        c *= this.speed + e / 2;
        this.speed = THREE.Math.clamp(this.speed + e, -b, b);
        this.activeDirection || Math.sign(this.speed) === d || (this.speed = 0);
        return THREE.Math.clamp(c, -this.threshold, this.threshold)
    }
}

/***/ }),

/***/ "./src/controllers/ExposureController.js":
/*!***********************************************!*\
  !*** ./src/controllers/ExposureController.js ***!
  \***********************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.ExposureController = function (a, b, c) {
    var d = a.camera,
        e = !1,
        g = 0,
        f, h, k, n = new JMT.Timer

    var p = function (a) {
        k = a;
        g = a - d.exposure;
        h = Math.sign(g);
        g = Math.abs(g);
        f = g / 1
    };
    this.adaptExposure = function () {
        if (e && d.autoExposure) {
            n.reset();
            var a = c.measureReflectedLuma();
            if (0 > a) {
                g = 0
            } else {
                p(Math.log2(d.autoExposureDarkness / a))
                .3 > g && (g = 0)
            }
        }
    };
    this.exposureNeedsUpdate = function () {
        return 0 < g
    };
    var l = new THREE.Vector3(Infinity, Infinity, Infinity)

    function onCameraVolumeUpdated() { // q
        if (!e || !d.autoExposure) {
            var throwVolumes = {
                "audioVolumes": [],
                "videoVolumes": []
            }
            var hasCameraVolume = false
            for (var b = a.cameraVolumes.length - 1; 0 <= b; --b) {
                var c = a.cameraVolumes[b];
                if (c.worldCoordinatesInside(l)) {
                    if (c.assetType === "audio") {
                        throwVolumes.audioVolumes.push(c.pId)
                    }
                    if (c.assetType === "video") {
                        throwVolumes.videoVolumes.push(c.pId)
                    }
                    if (!hasCameraVolume && c.assetType === "camera") {
                        p(c.exposure);
                        d.setGamma(c.gamma);
                        hasCameraVolume = true
                    }
                }
            }
            // 抛出监听  audioVolumes
            a.dispatchEvent({
                type: "audioVolumesUpdated",
                throwVolumes: throwVolumes
            })
            if (!!hasCameraVolume) {
                return
            }
            p(d.defaultExposure);
            if (d.setGamma) {
                d.setGamma(d.defaultGamma)
            }
        }
    }

    a.addEventListener("cameraVolumeAdded", function (a) {
        a.cameraVolume.addEventListener("cameraVolumeUpdated", onCameraVolumeUpdated);
        onCameraVolumeUpdated()
    });
    a.addEventListener("cameraVolumeShifted", onCameraVolumeUpdated);
    a.addEventListener("cameraVolumeRemoved", function (a) {
        a.cameraVolume.removeEventListener("cameraVolumeUpdated", onCameraVolumeUpdated);
        onCameraVolumeUpdated()
    });

    d.addEventListener("cameraUpdated", onCameraVolumeUpdated);

    this.update = function (a) {
        var c = b.cameraWorldPosition();
        if (!l.equals(c)) {
            l.copy(c)
            onCameraVolumeUpdated()
        }
        if (this.exposureNeedsUpdate()) {
            a = Math.min(f * a, g)
            g -= a
            if (1E-5 > g) {
                g = 0
                d.exposure = k
            } else {
                d.exposure += a * h
            }
        }
    };
    this.updateWithoutDelay = function () {
        this.update(1)
    };
    this.enableAutoExposure = function () {
        e = !0;
        g = 0
    };
    this.disableAutoExposure = function () {
        e = !1;
        onCameraVolumeUpdated()
    }
}

/***/ }),

/***/ "./src/controllers/LightControls.js":
/*!******************************************!*\
  !*** ./src/controllers/LightControls.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightControls": function() { return /* binding */ LightControls; }
/* harmony export */ });
/* harmony import */ var _extend_material_j3dLightMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extend/material/j3dLightMaterial.js */ "./src/extend/material/j3dLightMaterial.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */




function a() {
    var a = new THREE.BufferGeometry, b = new Float32Array(288);
    a.addAttribute("position", new THREE.BufferAttribute(b, 3));
    var e = 0;
    [[[-1, -1, -1], [-1, -.6, -1], [-.6, -1, -1]], [[-1, -1, -1], [-1, -1, -.6], [-1, -.6, -1]], [[-1, -1, -1], [-.6, -1, -1], [-1, -1, -.6]], [[-.6, -1, -1], [-1, -.6, -1], [-1, -1, -.6]], [[-1, -1, 1], [-.6, -1, 1], [-1, -.6, 1]], [[-1, -1, 1], [-1, -.6, 1], [-1, -1, .6]], [[-1, -1, 1], [-1, -1, .6], [-.6, -1, 1]], [[-.6, -1, 1], [-1, -1, .6], [-1, -.6, 1]], [[1, -1, -1], [.6, -1, -1], [1, -.6, -1]], [[1, -1, -1], [1, -.6, -1], [1, -1, -.6]],
        [[1, -1, -1], [1, -1, -.6], [.6, -1, -1]], [[.6, -1, -1], [1, -1, -.6], [1, -.6, -1]], [[-1, 1, -1], [-.6, 1, -1], [-1, .6, -1]], [[-1, 1, -1], [-1, .6, -1], [-1, 1, -.6]], [[-1, 1, -1], [-1, 1, -.6], [-.6, 1, -1]], [[-.6, 1, -1], [-1, 1, -.6], [-1, .6, -1]], [[1, 1, 1], [.6, 1, 1], [1, .6, 1]], [[1, 1, 1], [1, .6, 1], [1, 1, .6]], [[1, 1, 1], [1, 1, .6], [.6, 1, 1]], [[.6, 1, 1], [1, 1, .6], [1, .6, 1]], [[1, -1, 1], [1, -.6, 1], [.6, -1, 1]], [[1, -1, 1], [1, -1, .6], [1, -.6, 1]], [[1, -1, 1], [.6, -1, 1], [1, -1, .6]], [[.6, -1, 1], [1, -.6, 1], [1, -1, .6]], [[1, 1, -1], [1, .6, -1], [.6, 1, -1]], [[1, 1, -1], [1, 1, -.6], [1, .6,
        -1]], [[1, 1, -1], [.6, 1, -1], [1, 1, -.6]], [[.6, 1, -1], [1, .6, -1], [1, 1, -.6]], [[-1, 1, 1], [-1, .6, 1], [-.6, 1, 1]], [[-1, 1, 1], [-1, 1, .6], [-1, .6, 1]], [[-1, 1, 1], [-.6, 1, 1], [-1, 1, .6]], [[-.6, 1, 1], [-1, .6, 1], [-1, 1, .6]]].forEach(function (a) {
            for (var c = 0; 3 > c; c += 1)for (var d = 0; 3 > d; d += 1)b[e] = a[c][d], e += 1
        });
    a.computeVertexNormals();
    a.convertNormalsToSpherical();
    return a
}

function b() {
    // var a = new JMT.j3dStandardMaterial;
    // a.disableLightProbe = !0;
    // a.headLight = !0;
    // a.baseColor = JMT.EDITOR_SELECTION_COLOR;
    // a.setUniforms();
    // return a
    var a = new THREE.MeshBasicMaterial()
    a.color.set(JMT.EDITOR_SELECTION_COLOR)
    return a;
}

function LightControls(c, d) {
    function createLightInstanceGeometry(light) {   // e
        if ("spot" === light.type) {
            var b = THREE.Math.degToRad(light.angle);
            let a = 1 * Math.cos(b / 2);
            b = new THREE.CylinderBufferGeometry(0, 1 * Math.sin(b / 2), a, 32, 1);
            x.makeTranslation(0, -a / 2, 0);
            u.makeRotationZ(Math.PI);
            t.multiplyMatrices(u, x);
            b.applyMatrix(t);
            b.convertNormalsToSpherical()
        }
        else {
            b = "area" === a.type ? w : v;
        }
        return b
    }

       //test instances buffer
    //    var t0 = new THREE.InstancedBufferAttribute(new Float32Array([1, 0, 0, 0]), 4);
    //    var t1 = new THREE.InstancedBufferAttribute(new Float32Array([0, 1, 0, 0]), 4);
    //    var t2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1, 0]), 4);
   
       //uv2Mod
    //    var uv = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
    //    var uv2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
    //    var uv2Mod = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1 / 65535, 1 / 65535]), 4);

    function createLightInstanceMesh(a, b, d) { // g
        var e = new JMT.j3dLightMaterial(a);
        d = new THREE.Mesh(d, e);
        d.visibilityId = null;
        //test 
        // {
        //     //d.forcePick = true;
        //     if (false&&!d.geometry.attributes.t0) {
                
        //         d.geometry.setAttribute("t0", t0)
        //         d.geometry.setAttribute("t1", t1)
        //         d.geometry.setAttribute("t2", t2)
    
        //         // d.geometry.setAttribute("uv", uv)
        //         // d.geometry.setAttribute("uv2", uv2)
        //         // d.geometry.setAttribute("uv2Mod", uv2Mod)

        //         d.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{
        //             //强制刷新uniforms
        //             material.refreshPerObjectUniforms && material.refreshPerObjectUniforms(d, material.uniforms)
        //             material.uniformsNeedUpdate = true        
        
        //         }
        //     }
        // }
        var f = new THREE.Mesh(z, A);
        d.add(f);
        if ("sun" !== a.type) {
            var g = b.rotation.toQuaternion().multiply(d.quaternion);
            d.setRotationFromQuaternion(g);
            d.position.copy(b.position);
            if ("area" === a.type) {
                e.side = THREE.DoubleSide
                d.scale.set(a.width, 1, a.height)
                e = Math.max(a.width, a.height) / 2
                f.scale.set(e / a.width, e, e / a.height)
            }
            else {
                d.scale.set(a.size, a.size, a.size)
            }
        }
        else {
            a = c.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME).radius
            a = 1 * Math.PI * a * 1.5 / 360
            ;(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_1__.sunRotationToPosition)(c, b.rotation, d.position)
            d.scale.set(a, a, a);
        }
        d.userData.lightInstance = b;
        d.updateMatrixWorld();
        r.lightInstanceMeshes.push(d);
        m && c.addAuxiliaryObject(d)
    }

    function createLightInstanceMeshes(light) { // f
        var b = createLightInstanceGeometry(light);
        light.forEachLightInstance(function (c) {
            createLightInstanceMesh(light, c, b)
        })
    }

    function getLightInstsnceMesh(a) {
        for (var b = 0; b < r.lightInstanceMeshes.length; b += 1) {
            var c = r.lightInstanceMeshes[b];
            if (c.userData.lightInstance === a) {
                return c
            }
        }
        return null
    }

    function disposeLightInstanceMeshes(a) {    // k
        var b = []
        for (var d = 0; d < r.lightInstanceMeshes.length; d += 1) {
            var e = r.lightInstanceMeshes[d];
            if (e.userData.lightInstance.light === a) {
                if (m) {
                    c.removeAuxiliaryObject(e)
                }
                if (e.geometry !== v && e.geometry !== w) {
                    e.geometry.dispose()
                }
                e.material.dispose()
            }
            else {
                b.push(e)
            }
        }
        r.lightInstanceMeshes = b
    }

    function onLightUpdated(a) {    // n
        a = a.light;
        disposeLightInstanceMeshes(a)
        createLightInstanceMeshes(a)
    }

    function onLightInstanceAdded(a) {  // p
        a = a.instance;
        var b = a.light;
        var c = b.instances[0] !== a ? getLightInstsnceMesh(b.instances[0]).geometry : createLightInstanceGeometry(b);
        createLightInstanceMesh(b, a, c);
        d.requestFrame()
    }

    function onLightInstanceRemoved(a) {    // l
        a = a.instance.light;
        disposeLightInstanceMeshes(a);
        createLightInstanceMeshes(a);
        d.requestFrame()
    }

    function createLightInstance(a) {   // q
        createLightInstanceMeshes(a);
        a.addEventListener("lightUpdated", onLightUpdated);
        a.addEventListener("lightInstanceAdded", onLightInstanceAdded);
        a.addEventListener("lightInstanceRemoved", onLightInstanceRemoved)
    }

    var r = this, m = !1, u = new THREE.Matrix4, x = new THREE.Matrix4, t = new THREE.Matrix4, v = new THREE.SphereBufferGeometry(1, 32, 16);
    v.convertNormalsToSpherical();
    var w = new THREE.PlaneBufferGeometry(1, 1);
    u.makeRotationX(-Math.PI / 2);
    w.applyMatrix(u);
    w.convertNormalsToSpherical();
    var z = a(), A = b();
    this.lightInstanceMeshes = [];
    this.getLightInstanceMaterial = function (a) {
        return getLightInstsnceMesh(a).material
    };
    this.showLights = function () {
        if (!m) {
            m = !0;
            for (var a = 0; a < this.lightInstanceMeshes.length; a += 1){
                c.addAuxiliaryObject(this.lightInstanceMeshes[a]);
            }
            d.requestFrame()
        }
    };
    this.showSelectionMesh = function (a) {
        this.lightInstanceMeshes.forEach(function (b) {
            b.children[0].visible = b.userData.lightInstance.light === a ? !0 : !1
        })
    };
    this.hideLights = function () {
        if (m) {
            m = !1;
            for (var a = 0; a < this.lightInstanceMeshes.length; a += 1) {
                c.removeAuxiliaryObject(this.lightInstanceMeshes[a]);
            }
            d.requestFrame()
        }
    };
    c.lights.forEach(createLightInstance);
    c.addEventListener("lightAdded", function (a) {
        createLightInstance(a.light);
        d.requestFrame()
    });
    c.addEventListener("lightRemoved", function (a) {
        disposeLightInstanceMeshes(a.light);
        d.requestFrame()
    })
}



/***/ }),

/***/ "./src/controllers/LightProbeControls.js":
/*!***********************************************!*\
  !*** ./src/controllers/LightProbeControls.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightProbeControls": function() { return /* binding */ LightProbeControls; }
/* harmony export */ });
/* harmony import */ var _materials_createBoundingBoxMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/createBoundingBoxMaterial.js */ "./src/materials/createBoundingBoxMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */



function LightProbeControls(a, b) {
    var t0 = new THREE.InstancedBufferAttribute(new Float32Array([1, 0, 0, 0]), 4);
    var t1 = new THREE.InstancedBufferAttribute(new Float32Array([0, 1, 0, 0]), 4);
    var t2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1, 0]), 4);

    //uv2Mod
    // var uv = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
    // var uv2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
    // var uv2Mod = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1 / 65535, 1 / 65535]), 4);

    function c(a, b) {
        b.position.addVectors(a.boxMin, a.boxMax).multiplyScalar(.5).sub(a.position);
        b.scale.subVectors(a.boxMax, a.boxMin);
        b.scale.subScalar(.005)
    }

    function d(b) {
        var d = new JMT.j3dStandardMaterial;
        d.hideFromLightProbes = !0;
        d.disableLightProbe = !1;
        d.highlight = JMT.EDITOR_SELECTION_COLOR;
        d.metallic = 1;
        d.roughness = 0;
        d.setUniforms();
        d = new THREE.Mesh(q, d);
        d.visibilityId = null;
        d.lightProbe = b;
        d.position.copy(b.position);
        d.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{
            material.refreshPerObjectUniforms(d, material.uniforms)
            //强制刷新uniforms
            material.uniformsNeedUpdate = true
        }

        var boxMesh = new THREE.Mesh(m, r);
        boxMesh.visible = !1;
        boxMesh.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{
            material.refreshPerObjectUniforms(boxMesh, material.uniforms)
            //强制刷新uniforms
            material.uniformsNeedUpdate = true
        }

        d.add(boxMesh);
        b.isBoundingBoxEnabled() && c(b, boxMesh);
        d.updateMatrixWorld(!0);
        d.visible = p;
        n.lightProbeMeshes.push(d);
        a.addAuxiliaryObject(d)
    }

    function e(a) {
        for (var b = 0; b < n.lightProbeMeshes.length; b += 1)
            if (n.lightProbeMeshes[b].lightProbe === a)
                return b;
        console.assert(!1);
        return null
    }

    function g(a) {
        a = a.lightProbe;
        var b = n.lightProbeMeshes[e(a)];
        b.position.copy(a.position);
        var d = b.children[0];
        if(a.isBoundingBoxEnabled()) {
            c(a, d)
            d.visible = !0
        }
        else {
            d.visible = !1;
        }
        b.updateMatrixWorld()
    }

    function f(a) {
        a = a.lightProbe;
        d(a);
        b.requestFrame();
        a.addEventListener("lightProbePositionUpdated", g);
        a.addEventListener("lightProbeBoundsUpdated", g)
    }

    function h(c) {
        c = e(c.lightProbe);
        var d = n.lightProbeMeshes[c];
        a.removeAuxiliaryObject(d);
        d.material.dispose();
        n.lightProbeMeshes.splice(c, 1);
        b.requestFrame()
    }

    function k(a) {
        for (var b = 0; b < n.lightProbeMeshes.length; b += 1) {
            var c = n.lightProbeMeshes[b];
            if (c.lightProbe === a)return c
        }
        return null
    }

    var n = this, p = !1, l = null;
    this.lightProbeMeshes = [];
    var q = new THREE.SphereBufferGeometry(.2, 32, 16);
    q.convertNormalsToSpherical();
    q.setAttribute("t0", t0)
    q.setAttribute("t1", t1)
    q.setAttribute("t2", t2)
    // geometry.setAttribute("uv", uv)
    // geometry.setAttribute("uv2", uv2)
    // geometry.setAttribute("uv2Mod", uv2Mod)

    var r = JMT.createBoundingBoxMaterial(), 
    m = new THREE.BoxBufferGeometry(1, 1, 1);
    m.addTriangleOrderAttribute();
    m.convertNormalsToSpherical();
    m.setAttribute("t0", t0)
    m.setAttribute("t1", t1)
    m.setAttribute("t2", t2)
    this.getLightProbeMaterial = function (a) {
        return (a = k(a)) ? a.material : null
    };
    this.showLightProbeBoundingBox = function (a) {
        l && (l.visible = !1, l = null);
        a.isBoundingBoxEnabled() && (l = k(a).children[0], l.visible = !0)
    };
    this.showLightProbes = function () {
        if (!p) {
            p = !0;
            for (var a = 0; a < this.lightProbeMeshes.length; a += 1)this.lightProbeMeshes[a].visible = !0
        }
        b.requestFrame()
    };
    this.hideLightProbes = function () {
        if (p) {
            p = !1;
            for (var a = 0; a < this.lightProbeMeshes.length; a += 1)this.lightProbeMeshes[a].visible = !1
        }
        b.requestFrame()
    };
    (function () {
        for (var b = 0; b < a.lightProbes.length; b += 1) {
            var c = a.lightProbes[b];
            d(c);
            c.addEventListener("lightProbePositionUpdated", g);
            c.addEventListener("lightProbeBoundsUpdated", g)
        }
        a.addEventListener("lightProbeAdded", f);
        a.addEventListener("lightProbeRemoved", h)
    })()
}



/***/ }),

/***/ "./src/controllers/MinimapCreater.js":
/*!*******************************************!*\
  !*** ./src/controllers/MinimapCreater.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MinimapCreater": function() { return /* binding */ MinimapCreater; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/3/10.
 */



function createShaderPass() {
    var shader = {
        uniforms: {
            plane: {type: "v4", value: null}
        },
        vertexShader: JMT.SHADERS["standard_material_clip_vertex.glsl"],
        fragmentShader: JMT.SHADERS["standard_material_clip_fragment.glsl"]
    }
    let pass = new THREE.ShaderPass(shader, "inputBuffer")
    pass.material.depthTest = !1;
    pass.material.depthWrite = !1;
    pass.material.blending = THREE.CustomBlending;
    pass.material.blendEquation = GLC.FUNC_ADD;
    pass.material.blendDst = GLC.ONE_MINUS_SRC_ALPHA;
    pass.material.blendSrc = GLC.SRC_ALPHA;
    return pass
}


class MinimapCreater {
    constructor(viewer) {
        this.renderer = viewer.webGLRenderer,
            this.scene = viewer.scene

        this.controls = viewer.controls

    }

    generate(width = 512, height = 512) {

        let center = this.scene.boundingBox.center()

        var plan = new THREE.Plane()
        plan.setFromNormalAndCoplanarPoint(
            new THREE.Vector3(0, 0, -1),
            new THREE.Vector3(0, 0, center.z)
        )

        let sw = (this.scene.boundingBox.max.x - this.scene.boundingBox.min.x) / 2
        let sh = (this.scene.boundingBox.max.y - this.scene.boundingBox.min.y) / 2
        let camera = new THREE.OrthographicCamera(-sw, sw, sh, -sh)
        camera.up.set(0, 1, 0);

        camera.position.set(
            center.x,
            center.y,
            this.scene.boundingBox.max.z + 10
        )

        camera.lookAt(new THREE.Vector3(
            center.x,
            center.y,
            this.scene.boundingBox.max.z
        ))


        camera.updateMatrixWorld(!0)

        this.setClippingPlane(plan)

        var renderTarget = this.renderer.createRenderTarget(width, height, {
            format: GLC.RGBA,
            magFilter: GLC.NEAREST,
            minFilter: GLC.NEAREST,
            stencilBuffer: !1,
            generateMipmaps: !1
        });

        let renderPass = new THREE.RenderPass(this.scene.threeScene, camera)
        renderPass.renderToScreen = !1
        var p = new JMT.AutoClearAlter(this.renderer);
        p.set(!0, !0, !1);
        renderPass.render(this.renderer, renderTarget) //
        p.restore();
        let buffer = this.copyAccumulatedSamplesToBuffer(width, height);
        buffer = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64)(buffer, width, height, 1)
        renderTarget.dispose();

        this.setClippingPlane(null)

        return buffer
    }

    copyAccumulatedSamplesToBuffer(width = 512, height = 512) {
        var d = new Uint8Array(width * height * 4);
        this.renderer.readPixels(width, height, d);
        return d
    }

    setClippingPlane(plane) {

        var frag = JMT.getShader("standard_material_clip_fragment.glsl"),
            vert = JMT.getShader("standard_material_clip_vertex.glsl")

        if (!plane) {
            frag = JMT.getShader("standard_material_fragment.glsl")
            vert = JMT.getShader("standard_material_vertex.glsl")
        }

        let p = plane
        if (!p) {
            p = new THREE.Plane()
            p.setFromNormalAndCoplanarPoint(new THREE.Vector3(0, 0, 1), new THREE.Vector3(2.383300759407927, 3.386221243277655, 0.509999990463257))

        }

        let p4 = new THREE.Vector4(p.normal.x, p.normal.y, p.normal.z, p.constant)

        let jmtScene = this.scene

        jmtScene.materials.forEach(mtl => {

            if (mtl instanceof JMT.StandardMaterial) {

                mtl._vertexShaderBody = vert;
                mtl._fragmentShaderBody = frag;

                if (plane) {
                    mtl.setUniform("plane", "v4", p4)
                }
                else {
                    delete mtl.setUniform['plane']
                }
                mtl.programNeedsUpdate = !0

            }

        })
    }
}


JMT.SHADERS["standard_material_clip_vertex.glsl"] =
    '//AUTO GENERATED\n' +
    'const float PI = 3.14159265358979;\n' +
    'const float RECIPROCAL_PI2 = 0.15915494;\n' +
    'float saturate(in float a) {\n' +
    'return clamp(a, 0.0, 1.0);\n' +
    '}\n' +
    'vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\n' +
    'return normalize((vec4(normal, 0.0) * matrix).xyz);\n' +
    '}\n' +
    'vec3 sphericalDecode(in vec2 spNormal) {\n' +
    'float theta = (spNormal.x / 254.0 + 0.5) * PI;\n' +
    'float phi = spNormal.y * (PI / 127.0);\n' +
    'float sinTheta = sin(theta);\n' +
    'return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));\n' +
    '}\n' +
    'vec4 transformPosition() {\n' +
    'return vec4(\n' +
    't0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\n' +
    't1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\n' +
    't2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n' +
    '1.0);\n' +
    '}\n' +
    '#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\n' +
    'varying vec2 vUv;\n' +
    'uniform vec4 uvMod;\n' +
    '#endif\n' +
    '#ifdef USE_LIGHTMAP\n' +
    'varying vec2 vUv2;\n' +
    '#endif\n' +
    '#ifdef USE_BUMP_TEXTURE\n' +
    'varying vec3 vPositionV;\n' +
    'varying vec3 vNormalV;\n' +
    '#endif\n' +
    '#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\n' +
    'varying vec3 vNormalW;\n' +
    'varying vec3 vPositionW;\n' +
    '#endif\n' +
    'varying vec3 vWorldPosition;\n' +
    '\n' +
    'void main() {\n' +
    '#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\n' +
    'vUv = uv * uvMod.zw + uvMod.xy;\n' +
    '#endif\n' +
    'vec4 transformedPosition = transformPosition();\n' +
    'vec4 mvPosition = modelViewMatrix * transformedPosition;\n' +
    '#ifdef USE_LIGHTMAP\n' +
    'float zeroOrOne = clamp(ceil(uv2.x + uv2.y), 0.0, 1.0);\n' +
    'vUv2 = uv2 * uv2Mod.zw + uv2Mod.xy * zeroOrOne;\n' +
    '#endif\n' +
    '#if defined(USE_BUMP_TEXTURE) || defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\n' +
    'vec3 n = sphericalDecode(sphericalNormal);\n' +
    'vec3 normal = vec3(\n' +
    't0.x * n.x + t0.y * n.y + t0.z * n.z,\n' +
    't1.x * n.x + t1.y * n.y + t1.z * n.z,\n' +
    't2.x * n.x + t2.y * n.y + t2.z * n.z);\n' +
    '#endif\n' +
    '#if defined(USE_BUMP_TEXTURE)\n' +
    'vPositionV = -mvPosition.xyz;\n' +
    'vNormalV = normalize(normalMatrix * normal);\n' +
    '#endif\n' +
    '#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\n' +
    'vNormalW = mat3(modelMatrix[0].xyz,\n' +
    'modelMatrix[1].xyz,\n' +
    'modelMatrix[2].xyz) * normal;\n' +
    'vNormalW = normalize(vNormalW);\n' +
    'vPositionW = (modelMatrix * transformedPosition).xyz;\n' +
    '#endif\n' +
    'vWorldPosition = (modelMatrix * transformedPosition).xyz;\n' +
    'gl_Position = projectionMatrix * mvPosition;\n' +
    '\n' +
    '}\n'


JMT.SHADERS["standard_material_clip_fragment.glsl"] =
    '//AUTO GENERATED\n' +
    'const float PI = 3.14159265358979;\n' +
    'const float RECIPROCAL_PI2 = 0.15915494;\n' +
    'float saturate(in float a) {\n' +
    'return clamp(a, 0.0, 1.0);\n' +
    '}\n' +
    'vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\n' +
    'return normalize((vec4(normal, 0.0) * matrix).xyz);\n' +
    '}\n' +
    'float _g2l(in float x) {\n' +
    'return (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n' +
    '}\n' +
    'vec3 gammaToLinear(in vec3 rgb) {\n' +
    'return vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));\n' +
    '}\n' +
    'float _l2g(in float x) {\n' +
    'return (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n' +
    '}\n' +
    'vec3 linearToGamma(in vec3 rgb) {\n' +
    'return vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n' +
    '}\n' +
    'vec3 linearToGammaUnreal(in vec3 rgb) {\n' +
    'return rgb / (rgb + 0.187) * 1.035;\n' +
    '}\n' +
    'vec3 hdrDecode(in vec4 rgbm) {\n' +
    'const float rgbmScale = 2.82842712;  // sqrt(8)\n' +
    'vec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\n' +
    'return r * r;\n' +
    '}\n' +
    '#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\n' +
    'varying vec3 vNormalW;\n' +
    'varying vec3 vPositionW;\n' +
    '#endif\n' +
    '#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\n' +
    'varying vec2 vUv;\n' +
    '#endif\n' +
    '#if defined(USE_BUMP_TEXTURE)\n' +
    'varying vec3 vPositionV;\n' +
    'varying vec3 vNormalV;\n' +
    'uniform float bumpScale;\n' +
    'uniform sampler2D bumpTexture;\n' +
    'vec2 dBumpdxy() {\n' +
    'vec2 texdx = dFdx(vUv);\n' +
    'vec2 texdy = dFdy(vUv);\n' +
    'float Hll = bumpScale * texture2D(bumpTexture, vUv).x;\n' +
    'float dBx = bumpScale * texture2D(bumpTexture, vUv + texdx).x - Hll;\n' +
    'float dBy = bumpScale * texture2D(bumpTexture, vUv + texdy).x - Hll;\n' +
    'return vec2(dBx, dBy);\n' +
    '}\n' +
    'vec3 perturbNormal(in vec3 surfPos, in vec3 surfNorm) {\n' +
    'vec2 dBdxy = dBumpdxy();\n' +
    'vec3 vSigmaX = dFdx(surfPos);\n' +
    'vec3 vSigmaY = dFdy(surfPos);\n' +
    'vec3 R1 = cross(vSigmaY, surfNorm);\n' +
    'vec3 R2 = cross(surfNorm, vSigmaX);\n' +
    'float fDet = dot(vSigmaX, R1);\n' +
    'vec3 vGrad = sign(fDet) * (dBdxy.x * R1 + dBdxy.y * R2);\n' +
    'return normalize(abs(fDet) * surfNorm - vGrad);\n' +
    '}\n' +
    '#endif\n' +
    '#ifdef USE_BASE_COLOR_TEXTURE\n' +
    'uniform sampler2D baseColorTexture;\n' +
    'uniform vec4 baseColorAtlasUvMod;\n' +
    'uniform float alphaDiscardThreshold;\n' +
    '#ifdef USE_PARALLAX_CORRECTION\n' +
    '#endif\n' +
    '#else\n' +
    'uniform vec3 baseColor;\n' +
    '#endif\n' +
    'uniform float opacity;\n' +
    'uniform vec4 baseColorCorrection;\n' +
    'vec3 getBaseColor(out float alpha) {\n' +
    '#ifdef USE_BASE_COLOR_TEXTURE\n' +
    '#ifdef USE_PARALLAX_CORRECTION\n' +
    '#else\n' +
    'vec2 baseColorUv = vUv;\n' +
    '#endif\n' +
    'baseColorUv = baseColorUv * baseColorAtlasUvMod.zw + baseColorAtlasUvMod.xy;\n' +
    '#ifdef USE_ALPHA_IN_LOWER_HALF\n' +
    'vec4 baseColorGamma = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 + .5 * baseColorUv.y));\n' +
    'float textureAlpha = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 * baseColorUv.y)).r;\n' +
    '#else\n' +
    'vec4 baseColorGamma = texture2D(baseColorTexture, baseColorUv);\n' +
    'float textureAlpha = baseColorGamma.a;\n' +
    '#endif\n' +
    'vec3 baseColor = gammaToLinear(baseColorGamma.rgb);\n' +
    'alpha = opacity * textureAlpha;\n' +
    '#else // NOT USE_BASE_COLOR_TEXTURE\n' +
    'alpha = opacity;\n' +
    '#endif\n' +
    'vec3 baseColorCorrected = baseColorCorrection.a * baseColor +\n' +
    'baseColorCorrection.rgb;\n' +
    'return clamp(baseColorCorrected, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n' +
    '}\n' +
    '#ifdef USE_LIGHTMAP\n' +
    'varying vec2 vUv2;\n' +
    'uniform sampler2D lightMap;\n' +
    'vec3 getLightIntensity() {\n' +
    'return hdrDecode(texture2D(lightMap, vUv2));\n' +
    '}\n' +
    '#else // NOT USE_LIGHTMAP\n' +
    'vec3 getLightIntensity() {\n' +
    'return vec3(1.0);\n' +
    '}\n' +
    '#endif\n' +
    '#ifdef USE_ROUGHNESS_TEXTURE\n' +
    'uniform sampler2D roughnessTexture;\n' +
    '#else\n' +
    'uniform float roughness;\n' +
    '#endif\n' +
    '#ifdef USE_METALLIC_TEXTURE\n' +
    'uniform sampler2D metallicTexture;\n' +
    '#else\n' +
    'uniform float metallic;\n' +
    '#endif\n' +
    'vec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity,\n' +
    'inout float opacity);\n' +
    '#if defined(USE_DYNAMIC_LIGHT) || defined(USE_ENVMAP)\n' +
    'const float DLT = 0.001;\n' +
    '#ifdef USE_ENVMAP\n' +
    'uniform samplerCube envMap;\n' +
    'uniform float envMipsCount;\n' +
    '#ifdef HAVE_TEXTURE_LOD\n' +
    '#else\n' +
    'uniform samplerCube envMap2;\n' +
    '#endif\n' +
    '#endif\n' +
    'struct Roughness {\n' +
    '#ifdef USE_DYNAMIC_LIGHT\n' +
    '#endif\n' +
    '#ifdef USE_ENVMAP\n' +
    'float envFresnel; // (1.0 - roughness)^2, used for Fresnel with env map\n' +
    'float envMipLevel0;\n' +
    'float envMipLevel1;\n' +
    'float envMipMixFactor;\n' +
    '#endif\n' +
    '};\n' +
    'Roughness getRoughnessFactors() {\n' +
    'Roughness r;\n' +
    '#ifdef USE_ROUGHNESS_TEXTURE\n' +
    'float roughness = texture2D(roughnessTexture, vUv).x;\n' +
    '#endif // else roughness is a uniform\n' +
    'float roughness2 = roughness * roughness;\n' +
    '#ifdef USE_DYNAMIC_LIGHT\n' +
    '#endif\n' +
    '#ifdef USE_ENVMAP\n' +
    'float maxMipLevel = envMipsCount - 1.0;\n' +
    'float mipSelector = roughness * maxMipLevel;\n' +
    'r.envMipLevel0 = floor(mipSelector);\n' +
    'r.envMipLevel1 = min(r.envMipLevel0 + 1.0, maxMipLevel);\n' +
    'r.envMipMixFactor = fract(mipSelector);\n' +
    'r.envFresnel = (roughness2 - 2.0 * roughness + 1.0);\n' +
    '#endif\n' +
    'return r;\n' +
    '}\n' +
    '#ifdef USE_ENVMAP\n' +
    '#ifdef USE_ENVMAP_PROJECT\n' +
    'uniform vec3 envBoxMin;\n' +
    'uniform vec3 envBoxMax;\n' +
    'uniform vec3 envMapPosW;\n' +
    'const vec3 infBox = vec3(1000.0);\n' +
    'vec3 cubeMapProject(vec3 reflectionW) {\n' +
    'vec3 firstPlaneIntersect = (envBoxMax - vPositionW) / reflectionW;\n' +
    'vec3 secondPlaneIntersect = (envBoxMin - vPositionW) / reflectionW;\n' +
    'vec3 furthestPlane = max(firstPlaneIntersect, secondPlaneIntersect);\n' +
    'vec3 furthestPlaneNonNeg =\n' +
    'step(0.0, -furthestPlane) * infBox + abs(furthestPlane);\n' +
    'float distance = min(min(furthestPlaneNonNeg.x, furthestPlaneNonNeg.y),\n' +
    'furthestPlaneNonNeg.z);\n' +
    '/*if (furthestPlane.x > 0.0){\n' +
    'distance = furthestPlane.x;\n' +
    '}\n' +
    'if (furthestPlane.y > 0.0) {\n' +
    'distance = min(distance, furthestPlane.y);\n' +
    '}\n' +
    'if (furthestPlane.z > 0.0) {\n' +
    'distance = min(distance, furthestPlane.z);\n' +
    '}*/\n' +
    'vec3 intersectionPosW = vPositionW + reflectionW * distance;\n' +
    'return intersectionPosW - envMapPosW;\n' +
    '}\n' +
    '#endif // USE_ENVMAP_PROJECT\n' +
    'vec3 fixSeams(vec3 vec, float mipLevel) {\n' +
    'float scale = 1.0 - exp2(mipLevel) / 128.0;\n' +
    'float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\n' +
    'if (abs(vec.x) != M) vec.x *= scale;\n' +
    'if (abs(vec.y) != M) vec.y *= scale;\n' +
    'if (abs(vec.z) != M) vec.z *= scale;\n' +
    'return vec;\n' +
    '}\n' +
    'vec3 getEnvColor(in samplerCube envMap, in Roughness roughness,\n' +
    'in vec3 reflectionW) {\n' +
    'vec3 reflectionNormW = normalize(reflectionW);\n' +
    '#ifdef USE_ENVMAP_PROJECT\n' +
    'if (envBoxMin.x != envBoxMax.x) {\n' +
    'reflectionNormW = cubeMapProject(reflectionNormW);\n' +
    '}\n' +
    '#endif\n' +
    'vec3 reflectionNormFixedW = fixSeams(reflectionNormW,\n' +
    'roughness.envMipLevel0);\n' +
    '#ifdef HAVE_TEXTURE_LOD\n' +
    'vec4 cubeColorRaw0 = textureCubeLodEXT(envMap, reflectionNormFixedW,\n' +
    'roughness.envMipLevel0);\n' +
    '#else\n' +
    'vec4 cubeColorRaw0 = textureCube(envMap, reflectionNormFixedW);\n' +
    '#endif\n' +
    'vec3 cubeColor0 = hdrDecode(cubeColorRaw0);\n' +
    '#ifdef HAVE_TEXTURE_LOD\n' +
    'vec4 cubeColorRaw1 = textureCubeLodEXT(envMap, reflectionNormFixedW,\n' +
    'roughness.envMipLevel1);\n' +
    '#else\n' +
    'vec4 cubeColorRaw1 = textureCube(envMap2, reflectionNormFixedW);\n' +
    '#endif\n' +
    'vec3 cubeColor1 = hdrDecode(cubeColorRaw1);\n' +
    'return mix(cubeColor0, cubeColor1, roughness.envMipMixFactor);\n' +
    '}\n' +
    'vec3 fresnelSchlickEnv(in vec3 specularColor, in Roughness roughness,\n' +
    'in float clampCosnv, inout float opacity) {\n' +
    'float fresnel = 1.0 - clampCosnv;\n' +
    'float fresnel2 = fresnel * fresnel;\n' +
    'fresnel *= fresnel2 * fresnel2;\n' +
    'fresnel *= roughness.envFresnel;\n' +
    'opacity = opacity + (1.0 - opacity) * fresnel;\n' +
    'return specularColor + (1.0 - specularColor) * fresnel;\n' +
    '}\n' +
    '#endif // USE_ENVMAP\n' +
    '#ifdef USE_DYNAMIC_LIGHT\n' +
    '#endif // USE_DYNAMIC_LIGHT\n' +
    'vec3 getSpecularColor(in vec3 baseColor, float metalic) {\n' +
    'const float dielectricF0 = 0.04;\n' +
    'return mix(vec3(dielectricF0), baseColor, metalic);\n' +
    '}\n' +
    'float getLuminance(in vec3 color) {\n' +
    'return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n' +
    '}\n' +
    'vec4 lerpLightVisibility(in sampler2D map, in vec2 uv, in vec2 size) {\n' +
    'vec2 fragAddress = uv * size + 0.5;\n' +
    'vec2 weight = fract(fragAddress);\n' +
    'vec2 sizeInv = 1.0 / size;\n' +
    'vec2 uvlb = floor(fragAddress) * sizeInv;\n' +
    'vec4 lb = texture2D(map, uvlb);\n' +
    'vec4 lt = texture2D(map, uvlb + vec2(0.0, sizeInv.y));\n' +
    'vec4 rb = texture2D(map, uvlb + vec2(sizeInv.x, 0.0));\n' +
    'vec4 rt = texture2D(map, uvlb + vec2(sizeInv.x, sizeInv.y));\n' +
    'vec4 lb_idx = floor(lb);\n' +
    'vec4 lt_idx = floor(lt);\n' +
    'vec4 rb_idx = floor(rb);\n' +
    'vec4 rt_idx = floor(rt);\n' +
    'vec4 lt_idx_smaller_eq = step(lt_idx, lb_idx);\n' +
    'vec4 rb_idx_smaller_eq = step(rb_idx, lb_idx);\n' +
    'vec4 rt_idx_smaller_eq = step(rt_idx, lb_idx);\n' +
    'lt = clamp(lt, lb_idx, lb_idx + 0.999 * lt_idx_smaller_eq);\n' +
    'rb = clamp(rb, lb_idx, lb_idx + 0.999 * rb_idx_smaller_eq);\n' +
    'rt = clamp(rt, lb_idx, lb_idx + 0.999 * rt_idx_smaller_eq);\n' +
    'vec4 a = mix(lb, lt, weight.y);\n' +
    'vec4 b = mix(rb, rt, weight.y);\n' +
    'return mix(a, b, weight.x);\n' +
    '}\n' +
    'vec3 getNormalW() {\n' +
    '#ifdef USE_BUMP_TEXTURE\n' +
    'vec3 normalPerturbedV = perturbNormal(-vPositionV, normalize(vNormalV));\n' +
    'return normalize(\n' +
    'inverseTransformDirection(normalPerturbedV, viewMatrix));\n' +
    '#else\n' +
    'return normalize(vNormalW);\n' +
    '#endif\n' +
    '}\n' +
    'vec3 addSpecular(in vec3 baseColor, in vec3 totalIntensity,\n' +
    'inout float opacity) {\n' +
    'vec3 totalSpec = vec3(0.0, 0.0, 0.0);\n' +
    '#ifdef USE_METALLIC_TEXTURE\n' +
    'float metallic = texture2D(metallicTexture, vUv).x;\n' +
    '#endif // else metallic is a uniform\n' +
    'vec3 diffuseIntensity = totalIntensity * (1.0 - mix(0.04, 1.0, metallic));\n' +
    'vec3 viewW = normalize(cameraPosition - vPositionW);\n' +
    'vec3 normalW = getNormalW();\n' +
    'float clampCosnv = saturate(dot(normalW, viewW));\n' +
    'vec3 reflectionW = reflect(-viewW, normalW);\n' +
    'vec3 specularColor = getSpecularColor(baseColor, metallic);\n' +
    'Roughness roughness = getRoughnessFactors();\n' +
    '#ifdef USE_ENVMAP\n' +
    'vec3 envColor = getEnvColor(envMap, roughness, reflectionW);\n' +
    'vec3 fresnel = fresnelSchlickEnv(specularColor, roughness,\n' +
    'clampCosnv, opacity);\n' +
    'totalSpec = envColor * fresnel;\n' +
    '#endif\n' +
    '#ifdef USE_DYNAMIC_LIGHT\n' +
    '#endif\n' +
    'float luminance = getLuminance(totalIntensity);\n' +
    'return (baseColor * diffuseIntensity +\n' +
    'totalSpec * mix(0.4, 1.0, luminance));\n' +
    '}\n' +
    '#else // NOT (USE_DYNAMIC_LIGHT or USE_ENVMAP)\n' +
    'vec3 addSpecular(vec3 baseColor, in vec3 lightIntensity, in float opacity) {\n' +
    'return baseColor * lightIntensity;\n' +
    '}\n' +
    '#endif\n' +
    '#ifdef USE_HIGHLIGTH\n' +
    'uniform vec3 highlight;\n' +
    'uniform float highlightMix;\n' +
    '#endif\n' +
    '#if defined(HDR_OUTPUT)\n' +
    'vec4 hdrEncode(in vec3 rgb) {\n' +
    'const float rgbmScale = 2.82842712;  // sqrt(8)\n' +
    'vec3 r = sqrt(rgb) / rgbmScale;\n' +
    'float m = max(max(r.r, r.g), r.b);\n' +
    'm = clamp(m, 1.0 / 255.0, 1.0);\n' +
    'm = ceil(m * 255.0) / 255.0;\n' +
    'r /= m;\n' +
    'return vec4(r.r, r.g, r.b, (1.0 - m));\n' +
    '}\n' +
    '#endif\n' +
    '#ifdef USE_COLORMAP\n' +
    'vec3 colormap(in sampler2D texture, in vec3 color) {\n' +
    'const float resolution = 16.0;\n' +
    'const float maxValueIndex = resolution - 1.0;\n' +
    'const float sliceWidth = 1.0 / resolution;\n' +
    'const float slicePixelWidth = sliceWidth / resolution;\n' +
    'const float sliceMarginWidth = 0.5 * slicePixelWidth;\n' +
    'const float sliceInnerWidth = sliceWidth - slicePixelWidth;\n' +
    'const float slicePixelHeight = 1.0 / resolution;\n' +
    'const float sliceMarginHeight = 0.5 * slicePixelHeight;\n' +
    'const float sliceInnerHeight = 1.0 - slicePixelHeight;\n' +
    'float bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);\n' +
    'float bSlice1 = bSlice0 + 1.0;\n' +
    'float bOffset = color.b * maxValueIndex - bSlice0;\n' +
    'float rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;\n' +
    'float gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;\n' +
    'float rPos0 = rSlicePos + (bSlice0 * sliceWidth);\n' +
    'float rPos1 = rSlicePos + (bSlice1 * sliceWidth);\n' +
    'vec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;\n' +
    'vec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;\n' +
    'return mix(color0, color1, bOffset);\n' +
    '}\n' +
    'uniform sampler2D colorMap;\n' +
    '#endif\n' +
    '#ifdef USE_CHROMA_KEY\n' +
    'uniform vec3 chromaKeyColor;\n' +
    'uniform vec3 chromaKeyDeltaCoeff;\n' +
    'const float k32 = sqrt(3.0) / 2.0;\n' +
    'vec3 rgb2abi(vec3 color) {\n' +
    'float r = color.r;\n' +
    'float g = color.g;\n' +
    'float b = color.b;\n' +
    'return vec3(\n' +
    'r - 0.5 * g - 0.5 * b,\n' +
    'k32 * (g - b),\n' +
    '0.3333 * (r + g + b));\n' +
    '}\n' +
    'const float IPI2 = 0.5 / 3.1415926538;\n' +
    'vec3 rgb2hci(vec3 color) {\n' +
    'vec3 abi = rgb2abi(color);\n' +
    'return vec3(\n' +
    'atan(abi.y, abi.x) * IPI2,\n' +
    'length(abi.xy),\n' +
    'abi.z);\n' +
    '}\n' +
    'float chromaKeyShapeFn(vec3 delta, vec3 color, vec3 key) {\n' +
    'vec3 diff = color - key;\n' +
    'vec3 v = delta * vec3(\n' +
    '0.5 - abs(abs(diff.x) - 0.5),\n' +
    'abs(diff.y),\n' +
    'abs(diff.z));\n' +
    'float x = max(v.r, max(v.g, v.b));\n' +
    'return x * x;\n' +
    '}\n' +
    'float chromaKeyEdgeFn(float a) {\n' +
    'return clamp(.2/.5 * (a - 1.0), 0.0, 1.0);\n' +
    '}\n' +
    '#endif\n' +
    'uniform float emissionStrength;\n' +
    'uniform float exposure;\n' +
    'uniform float cameraGamma;\n' +
    '\n' +
    'uniform vec4 plane;\n' +
    'varying vec3 vWorldPosition;\n' +
    '\n' +
    'void main() {\n' +
    'float alpha;\n' +
    'vec3 baseColor = getBaseColor(alpha);\n' +
    '#ifdef USE_CHROMA_KEY\n' +
    'float dist = chromaKeyShapeFn(chromaKeyDeltaCoeff, rgb2hci(baseColor), rgb2hci(chromaKeyColor));\n' +
    'alpha *= chromaKeyEdgeFn(dist);\n' +
    '#endif\n' +
    '#ifdef USE_BASE_COLOR_TEXTURE\n' +
    'if (alpha < alphaDiscardThreshold) {\n' +
    'discard;\n' +
    '}\n' +
    '#endif\n' +
    'vec3 lightIntensity = getLightIntensity();\n' +
    '#ifdef USE_HIGHLIGTH\n' +
    'baseColor = mix(baseColor, highlight, highlightMix);\n' +
    'alpha = mix(alpha, 1.0, highlightMix);\n' +
    '#endif\n' +
    'vec3 diffuseSpecular = addSpecularHook(baseColor, lightIntensity, alpha);\n' +
    '#ifdef USE_HEADLIGHT\n' +
    'vec3 lightW = normalize(cameraPosition - vPositionW.xyz);\n' +
    'float pointDiffuse = max(dot(normalize(vNormalW), lightW), 0.0);\n' +
    'diffuseSpecular *= pointDiffuse;\n' +
    '#endif\n' +
    'vec3 diffuseSpecularEmissive = diffuseSpecular + baseColor * emissionStrength;\n' +
    '#ifdef HDR_OUTPUT\n' +
    'if (alpha < 0.5) {\n' +
    'discard;\n' +
    '}\n' +
    'gl_FragColor = hdrEncode(diffuseSpecularEmissive);\n' +
    '#else // no HDR_OUTPUT\n' +
    'vec3 exposedColor = pow(exposure * diffuseSpecularEmissive.xyz,\n' +
    'vec3(cameraGamma));\n' +
    'vec3 gammaColor =  linearToGammaUnreal(exposedColor);\n' +
    '#ifdef USE_COLORMAP\n' +
    'gl_FragColor.rgb = colormap(colorMap, min(gammaColor, 1.0));\n' +
    '#else\n' +
    'gl_FragColor.rgb = gammaColor;\n' +
    '#endif\n' +
    'gl_FragColor.a = alpha;\n' +
    '#endif // no HDR_OUTPUT\n' +

        // 'if ( dot( vWorldPosition, plane.xyz ) < plane.w ) {\n' +
        //     'discard;\n'+
        // '}\n' +

        //'vec4 plane0 = vec4(0.0, 0.0, 1.0, -0.5)'

        //'gl_FragColor.rgb = vec3(vWorldPosition.zzz);\n'+
        //'if (dot( vWorldPosition, plane.xyz ) <= -plane.w) gl_FragColor.rgb = vec3(1,0,0);\n'+
    'if (dot( vWorldPosition, plane.xyz ) < -plane.w) discard;\n' +

    '}\n'


/***/ }),

/***/ "./src/controllers/OrbitControls.js":
/*!******************************************!*\
  !*** ./src/controllers/OrbitControls.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitControls": function() { return /* binding */ OrbitControls; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


function OrbitControls(a, b, c, d) {
    function e() {
        var a = b.getYawAngle(), c = b.getPitchAngle(), e = b.cameraWorldPosition();
        z.copy(e).sub(l.target);
        l.autoRotate && J === D.NONE && l.rotateLeft(2 * Math.PI / 60 / 60 * l.autoRotateSpeed);
        a += I;
        c += O;
        a = THREE.Math.clamp(a, l.minYawAngle, l.maxYawAngle);
        c = THREE.Math.clamp(c, l.getMinPitchAngle(), l.getMaxPitchAngle());
        var f = z.length() * K;
        f = THREE.Math.clamp(f, l.minDistance, l.maxDistance);
        l.target.add(T);
        JMT.OrbitControls.computeCameraPosition(e, l.target, a, c, f);
        b.cameraPositionUpdated();
        b.setYawAngle(a);
        b.setPitchAngle(c);
        O = I = 0;
        K = 1;
        T.set(0, 0, 0);
        d.requestFrame()
    }

    function g() {
        H = N = C = B = Q = 0;
        L && (L(), L = !1)
    }

    function onMouseMove(a) {   // f
        if (!1 !== q) {
            a.preventDefault();
            var b = c === document ? c.body : c;
            if (J === D.ROTATE) {
                if (!0 === l.noRotate)return;
                m.set(a.clientX, a.clientY);
                u.subVectors(m, r);
                l.rotateLeft(u.x / b.clientWidth * l.mouseRotateSpeed);
                !1 === l.noPitchRotate && l.rotateUp(u.y / b.clientHeight * l.mouseRotateSpeed);
                r.copy(m)
            } else if (J === D.DOLLY) {
                if (!0 === l.noZoom)return;
                y.set(a.clientX, a.clientY);
                E.subVectors(y, A);
                0 < E.y ?
                    l.dollyIn() : 0 > E.y && l.dollyOut();
                A.copy(y)
            } else if (J === D.PAN) {
                if (!0 === l.noPan)return;
                t.set(a.clientX, a.clientY);
                v.subVectors(t, x);
                l.pan(v.x / b.clientHeight, v.y / b.clientWidth);
                x.copy(t)
            }
            J !== D.NONE && e()
        }
    }

    function onMouseUp() {  // h
        if (!1 !== q && L) {
            L()
            L = !1
        }
    }

    function onMouseWheel(a) { // k
        if (!1 !== q && !0 !== l.noZoom && J === D.NONE) {
            a.preventDefault();
            var b = 0;
            void 0 !== a.wheelDelta ? b = a.wheelDelta : void 0 !== a.detail && (b = -a.detail);
            0 < b ? l.dollyOut() : 0 > b && l.dollyIn();
            e()
        }
    }

    function n(a, b, c) {
        return !0 === c ? b : a === b ? 0 : a
    }

    function p(a, b) {
        var c = !1, e = a.keyCode;
        if (!1 !== q) {
            if (!0 === Y && !1 === l.noPan){
                if (38 === e || 87 === e){
                    N = n(N, 1, b)
                    c = !0;
                }
                else if (40 === e || 83 === e){
                    N = n(N, -1, b)
                    c = !0;
                }
                else if (37 === e || 65 === e){
                    H = n(H, 1, b)
                    c = !0;
                }
                else if (39 === e || 68 === e){
                    H = n(H, -1, b)
                    c = !0
                }
            }
            else if (!1 === Y && !1 === l.noRotate){

                if ((38 === e || 87 === e) && !1 === l.noPitchRotate){
                    B = n(B, 1, b)
                    c = !0;
                }
                else if ((40 === e || 83 === e) && !1 === l.noPitchRotate){
                    B = n(B, -1, b)
                    c = !0;
                }
                else if (37 === e || 65 === e){
                    C = n(C, 1, b)
                    c = !0;
                }
                else if (39 === e || 68 === e){
                    C = n(C, -1, b)
                    c = !0;
                }
            }
            switch (e) {
                case l.dollyKeys.IN1:
                case l.dollyKeys.IN2:
                case l.dollyKeys.IN3:
                    if(!1 === l.noZoom){
                        Q = n(Q, 1, b)
                        c = !0
                    }
                    break;
                case l.dollyKeys.OUT1:
                case l.dollyKeys.OUT2:
                case l.dollyKeys.OUT3:
                    if(!1 === l.noZoom){
                        Q = n(Q, -1, b)
                        c = !0
                    }
            }
            if (c) {
                a.preventDefault()
                d.requestFrame()
            }
        }
    }

    this.target = new THREE.Vector3;
    this.noZoom = !1;
    this.mouseZoomSpeed = .98;
    this.keyZoomSpeed = .7;
    this.minDistance = 0;
    this.maxDistance = Infinity;
    this.minZoom = 0;
    this.maxZoom = Infinity;
    this.noPitchRotate = this.noRotate = !1;
    this.mouseRotateSpeed = 2 * Math.PI;
    this.keyYawRotateSpeed = Math.PI / 4;
    this.keyPitchRotateSpeed = this.keyYawRotateSpeed / 2;
    this.autoRotate = !1;
    this.autoRotateSpeed = 2;
    this.getMinPitchAngle = function () {
        return -Math.PI / 2
    };
    this.getMaxPitchAngle = function () {
        return Math.PI / 2
    };
    this.minYawAngle = -Infinity;
    this.maxYawAngle = Infinity;
    this.noPan = !1;
    this.keyPanSpeed = .25;
    this.dollyKeys = {IN1: 61, IN2: 187, IN3: 69, OUT1: 173, OUT2: 189, OUT3: 81};
    this.primaryMouseButton = THREE.MOUSE.LEFT;
    this.secondaryMouseButton = THREE.MOUSE.RIGHT;
    this.mouseButtons = {ROTATE: this.primaryMouseButton, ZOOM: THREE.MOUSE.MIDDLE, PAN: this.secondaryMouseButton};
    var l = this, q = !1, r = new THREE.Vector2,
        m = new THREE.Vector2, u = new THREE.Vector2, x = new THREE.Vector2, t = new THREE.Vector2, v = new THREE.Vector2, w = new THREE.Vector3, z = new THREE.Vector3, A = new THREE.Vector2, y = new THREE.Vector2, E = new THREE.Vector2, I = 0, O = 0, K = 1, T = new THREE.Vector3, Y = !1, Q = 0, C = 0, B = 0, H = 0, N = 0, D = {
            NONE: -1,
            ROTATE: 0,
            DOLLY: 1,
            PAN: 2,
            TOUCH_ROTATE: 3,
            TOUCH_DOLLY: 4,
            TOUCH_PAN: 5
        }, J = D.NONE, L = !1;
    this.enable = function () {
        q = !0;
        e()
    };
    this.disable = function () {
        q = !1;
        g()
    };
    this.isEnabled = function () {
        return q
    };
    this.setPanPrimary = function (a) {
        Y = a;
        if (!0 === Y) {
            this.mouseButtons.PAN = this.primaryMouseButton
            this.mouseButtons.ROTATE = this.secondaryMouseButton
        }
        else {
            this.mouseButtons.ROTATE = this.primaryMouseButton
            this.mouseButtons.PAN = this.secondaryMouseButton
        }
    };
    this.getCameraDistance = function () {
        var a = new THREE.Vector3;
        return function () {
            a.copy(b.cameraWorldPosition()).sub(this.target);
            return a.length()
        }
    }();
    this.rotateLeft = function (a) {
        void 0 === a && (a = 2 * Math.PI / 60 / 60 * l.autoRotateSpeed);
        I -= a
    };
    this.rotateUp = function (a) {
        void 0 === a && (a = 2 * Math.PI / 60 / 60 * l.autoRotateSpeed);
        O -= a
    };
    this.panLeft = function (b) {
        var c = a.matrixWorld.elements;
        w.set(c[0], c[1], c[2]);
        w.multiplyScalar(-b);
        T.add(w)
    };
    this.panUp = function (b) {
        var c = a.matrixWorld.elements;
        w.set(c[4], c[5], c[6]);
        w.multiplyScalar(b);
        T.add(w)
    };
    this.pan = function (c, d) {
        if (a instanceof THREE.PerspectiveCamera) {
            var e = b.cameraWorldPosition().clone().sub(l.target).length();
            e *= Math.tan(a.fov / 2 * Math.PI / 180);
            l.panLeft(2 * c * e);
            l.panUp(2 * d * e)
        }
        else if (a instanceof THREE.OrthographicCamera) {
            l.panLeft(c * (a.right - a.left))
            l.panUp(d * (a.top - a.bottom))
        }
    };
    this.dollyIn =
        function (b) {
            void 0 === b && (b = this.mouseZoomSpeed);
            if (a instanceof THREE.PerspectiveCamera) {
                K /= b
            }
            else if (a instanceof THREE.OrthographicCamera) {
                a.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, a.zoom * b))
                a.updateProjectionMatrix()
            }
        };
    this.dollyOut = function (b) {
        void 0 === b && (b = this.mouseZoomSpeed);
        if (a instanceof THREE.PerspectiveCamera) {
            K *= b
        }
        else if (a instanceof THREE.OrthographicCamera) {
            a.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, a.zoom / b))
            a.updateProjectionMatrix()
        }
    };
    this.update = function (a) {
        if (q && a) {
            var b = !1;
            if (0 !== C) {
                l.rotateLeft(C * l.keyYawRotateSpeed * a)
                b = !0
            }
            if (0 !== B) {
                l.rotateUp(B * l.keyPitchRotateSpeed * a)
                b = !0
            }
            if (0 !== H || 0 !== N){
                l.pan(H * l.keyPanSpeed * a, N * l.keyPanSpeed * a)
                b = !0;
            }

            if (0 !== Q) {
                a = Math.pow(l.keyZoomSpeed, a)
                if(- 1 === Q){
                    l.dollyIn(a)
                }
                else {
                    l.dollyOut(a)
                }
                b = !0
            }
            b && e()
        }
    };
    c.addEventListener("mousedown", function (a) {
        if (!1 !== q) {
            c.focus();
            a.preventDefault();
            if (a.button === l.mouseButtons.ROTATE) {
                if (!0 === l.noRotate)return;
                J = D.ROTATE;
                r.set(a.clientX, a.clientY)
            } else if (a.button === l.mouseButtons.ZOOM) {
                if (!0 === l.noZoom)return;
                J = D.DOLLY;
                A.set(a.clientX, a.clientY)
            } else if (a.button === l.mouseButtons.PAN) {
                if (!0 === l.noPan)return;
                J = D.PAN;
                x.set(a.clientX, a.clientY)
            }

            if (J !== D.NONE) {

                document.addEventListener("mousemove", onMouseMove, !1)

                document.addEventListener("mouseup", onMouseUp, !1)

                L = function () {
                    document.removeEventListener("mousemove", onMouseMove, !1);
                    document.removeEventListener("mouseup", onMouseUp, !1);
                    J = D.NONE
                }

            }
        }
    }, !1);
    c.addEventListener("mousewheel", onMouseWheel, !1);
    c.addEventListener("DOMMouseScroll", onMouseWheel, !1);
    c.addEventListener("touchstart", function (a) {
        if (!1 !== q) {
            var b = a.touches.length;
            a.preventDefault();
            !l.noPan && (Y && 1 === b || !Y && 3 === b) ? (J = D.TOUCH_PAN, x.set(a.touches[0].clientX, a.touches[0].clientY)) : l.noRotate || Y || 1 !== b ? l.noZoom || 2 !== b ? J = D.NONE : (J = D.TOUCH_DOLLY, b = a.touches[0].clientX - a.touches[1].clientX, a = a.touches[0].clientY - a.touches[1].clientY, A.set(0, Math.sqrt(b * b + a * a))) : (J = D.TOUCH_ROTATE, r.set(a.touches[0].clientX, a.touches[0].clientY))
        }
    }, !1);
    c.addEventListener("touchend", function () {
        !1 !== q && (J = D.NONE)
    }, !1);
    c.addEventListener("touchmove", function (a) {
        if (!1 !== q) {
            var b = a.touches.length;
            a.preventDefault();
            var d = c === document ? c.body : c;
            !l.noPan && (Y && 1 === b || !Y && 3 === b) && J === D.TOUCH_PAN ? (t.set(a.touches[0].clientX, a.touches[0].clientY), v.subVectors(t, x), l.pan(v.x / d.clientHeight, v.y / d.clientWidth), x.copy(t), e()) : l.noRotate || Y || 1 !== b || J !== D.TOUCH_ROTATE ? l.noZoom || 2 !== b || J !== D.TOUCH_DOLLY ? J = D.NONE : (b = a.touches[0].clientX - a.touches[1].clientX, a = a.touches[0].clientY - a.touches[1].clientY, y.set(0, Math.sqrt(b * b + a * a)), E.subVectors(y, A), 0 < E.y ? l.dollyOut() : 0 > E.y && l.dollyIn(), A.copy(y), e()) : (m.set(a.touches[0].clientX, a.touches[0].clientY), u.subVectors(m, r), l.rotateLeft(u.x / d.clientWidth * l.mouseRotateSpeed), l.rotateUp(u.y / d.clientHeight * l.mouseRotateSpeed), r.copy(m), e())
        }
    }, !1);
    c.addEventListener("blur", function (a) {
        g()
    }, !1);
    window.addEventListener("keydown", function (a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.isModifierPressed)(a) || p(a, !0)
    }, !1);
    window.addEventListener("keyup", function (a) {
        p(a, !1)
    }, !1);
    a instanceof THREE.PerspectiveCamera || a instanceof THREE.OrthographicCamera || console.warn("WARNING: OrbitControls.js requires perspective or orthographic camers")
};

JMT.OrbitControls = OrbitControls
JMT.OrbitControls.prototype.constructor = JMT.OrbitControls;
JMT.OrbitControls.computeCameraPosition = function () {
    var a = new THREE.Vector3;
    return function (b, c, d, e, g) {
        d -= Math.PI / 2;
        e += Math.PI / 2;
        a.x = g * Math.sin(e) * Math.cos(d);
        a.y = g * Math.sin(e) * Math.sin(d);
        a.z = g * Math.cos(e);
        b.copy(c).add(a)
    }
}()

/***/ }),

/***/ "./src/controllers/ScreenshotTaker.js":
/*!********************************************!*\
  !*** ./src/controllers/ScreenshotTaker.js ***!
  \********************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

JMT.ScreenshotTaker = function (a, b, c) {
    function d() {
        var a = (document.body.offsetWidth - document.body.offsetHeight * h) / 2
        var b = a + "px";
        a = Math.max(a, 0) + "px";
        k.style.width = a;
        n.style.width = a;
        p.style.left = b;
        p.style.right = b
    }

    this.screenToPano = function (c, d, e, f) { // e
        var g = new JMT.CubeCamera(b.camera.near, b.camera.far);
        g.rotateZ(d);
        g.position.copy(c);
        g.updateMatrixWorld();
        c = a.createRenderTargetCube(4096, 4096, {
            format: GLC.RGBA,
            magFilter: GLC.LINEAR,
            minFilter: GLC.LINEAR,
            stencilBuffer: !1,
            generateMipmaps: !1
        });
        for (d = 0; 6 > d; d += 1) {
            c.activeCubeFace = d
            a.render(b.threeScene, g.sideCameras[d], c);
        }
        g = a.createRenderTarget(e, f, {
            format: GLC.RGBA,
            magFilter: GLC.NEAREST,
            minFilter: GLC.NEAREST,
            stencilBuffer: !1,
            generateMipmaps: !1
        });
        d = {
            uniforms: {panoramaCube: {type: "t", value: null}},
            vertexShader: JMT.getShader("cube_to_equirect_vertex.glsl"),
            fragmentShader: JMT.getShader("cube_to_equirect_fragment.glsl")
        };
        d = new THREE.ShaderPass(d, "panoramaCube");
        d.render(a, g, c);
        d.dispose();
        c.dispose();
        c = new Uint8Array(e * f * 4);
        a.readPixels(e, f, c);
        g.dispose();
        return c
    }

    this.screenToImage = function(c, d) {  // g
        var e = new THREE.WebGLRenderTarget(c, d, {
            format: THREE.RGBAFormat,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            stencilBuffer: false,
            generateMipmaps: false
        })
        
        c = new THREE.WebGLRenderTarget(c, d, {
            format: THREE.RGBAFormat,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            stencilBuffer: false,
            depthBuffer: false,
            generateMipmaps: false
        })
        d = new JMT.SsaaRenderer(a, b);
        for (d.setTargets(e, c); !d.allSamplesRendered();) {
            d.renderSample();
        }
        var f = d.copyAccumulatedSamplesToBuffer();
        e.dispose();
        c.dispose();
        d.dispose();
        return f
    }

    function f(a, b) {
        var c = Math.min(JMT.MAX_PANORAMA_SIZE, JMT.DETECTOR.maxRenderBufferSize);
        if (a <= c && b <= c) {
            return [a, b];
        }
        var d = a / b;
        return a > b ? [c, Math.floor(c / d)] : [Math.floor(c * d), c]
    }

    var h = null, k = null, n = null, p = null, l = new THREE.Vector3;
    this.markArea = function (scale) {
        function b(a, b) {
            a.style.zIndex = 1;
            a.style.pointerEvents = "none";
            a.style.position = "absolute";
            a.style.top = 0;
            a.style.bottom = 0;
            a.style[b] = 0;
            a.style.backgroundColor = "rgba(0, 0, 0, 0.5)"
        }

        function c(a) {
            a.style.zIndex = 1;
            a.style.pointerEvents = "none";
            a.style.position = "absolute";
            a.style.boxSizing = "border-box";
            a.style.top = 0;
            a.style.bottom = 0;
            a.style.border = "4px solid rgba(35, 181, 233, 0.5)"
        }

        if (!p) {
            k = document.createElement("div")
            b(k, "left")
            n = document.createElement("div")
            b(n, "right")
            p = document.createElement("div")
            c(p)
            document.body.appendChild(k)
            document.body.appendChild(n)
            document.body.appendChild(p)
            window.addEventListener("resize", d)
        }
        h = scale || 1.;
        d()
    };

    this.unmarkArea = function () {
        if (p) {
            k.remove()
            n.remove()
            p.remove()
            window.removeEventListener("resize", d)
            p = n = k = h = null
        }
    };

    this.screenToBuffer = function (isPano, width, height) {
        if (isPano) {
            return this.screenToPano(c.cameraWorldPosition(), c.getYawAngle(), width, height)
        }
        else {
            return this.screenToImage(width, height)
        }
    };

    this.screenToDataUrl = function (isPano, width, height, quality) {

        var buffer = this.screenToBuffer(isPano, width, height);

        for (var d = 0; d < height; ++d) {

            for (var e = 0; e < width; ++e) {

                var f = 4 * (d * width + e);

                if (d < height / 2) {

                    var g = 4 * ((height - d - 1) * width + e)

                    for (var h = 0; 3 > h; ++h) {

                        var k = buffer[f + h];

                        buffer[f + h] = buffer[g + h];

                        buffer[g + h] = k

                    }

                }

                buffer[f + 3] = 255

            }

        }

        var array = new Uint8ClampedArray(buffer);

        var imageData = new ImageData(array, width, height);

        var canvas = document.createElement("canvas");

        canvas.width = width;

        canvas.height = height;

        canvas.getContext("2d").putImageData(imageData, 0, 0);

        return canvas.toDataURL("image/jpeg", quality)

    };

    this.screenToLocalImage = function (a, b, c) {

        a = this.screenToDataUrl(a, b, c);

        if (navigator.msSaveOrOpenBlob) {

            fetch(a).then(function (a) {

                return a.blob()

            }).then(function (a) {

                return navigator.msSaveOrOpenBlob(a, "screen.jpg")

            })
        }
        else {
            b = document.createElement("a")
            document.body.appendChild(b)
            b.style.cssText = "display: none"
            b.href = a
            b.download = "screenshot"
            b.click()
            window.URL.revokeObjectURL(a)
            b.parentNode.removeChild(b)
        }
    };
    this.coverToServer = function (a, b) {
        var c = this.screenToImage(a, b);
        JMT.ajaxPost("screenshot?width=" + a + "&height=" + b, "application/binary", c)
    };
    this.panoramaToServer = function (a, b) {
        a.position ? l.fromArray(a.position) : l.copy(c.cameraWorldPosition());
        var d = void 0 !== a.width ? a.width : 8E3, g = void 0 !== a.height ? a.height : 4E3;
        g = $jscomp.makeIterator(f(d, g));
        d = g.next().value;
        g = g.next().value;
        var h = void 0 !== a.rotation ? THREE.Math.degToRad(a.rotation) : 0;
        h = this.screenToPano(l, h, d, g);
        JMT.ajaxPost("panorama?width=" + d + "&height=" + g + "&name=" + a.name, "application/binary", h, b, b)
    }
}

/***/ }),

/***/ "./src/controllers/StaticRenderViewer.js":
/*!***********************************************!*\
  !*** ./src/controllers/StaticRenderViewer.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StaticRenderViewer": function() { return /* binding */ StaticRenderViewer; }
/* harmony export */ });
/* harmony import */ var _materials_BaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/BaseMaterial.js */ "./src/materials/BaseMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */


function a() {
    JMT.BaseMaterial.call(this, JMT.getShader("static_render_vertex.glsl"), JMT.getShader("static_render_fragment.glsl"));
    this.uniforms = {staticRender: {type: "t", value: null}, sizeInv: {type: "v2", value: new THREE.Vector2}}
}

function b(a) {
    a = JMT.createRenderer(a, {antialias: !1});
    a.autoClear = !1;
    a.autoUpdateObjects = !1;
    a.sortObjects = !1;
    return a
}

a.prototype = Object.create(JMT.BaseMaterial.prototype);

a.prototype.constructor = a;

function StaticRenderViewer(c) {
    var d = b(c), e = new a, g = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1), f = new THREE.Scene;
    c = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), e);
    d.uploadNewBuffers(c);
    f.add(c);
    this.update = function (a) {
        var b = new Float32Array(a, 0, a.byteLength / 4);
        a = b[0];
        var c = b[1];
        b = b.subarray(2);
        console.assert(a * c === b.length / 3);
        b = new JMT.DataTexture(b, a, c, GLC.RGB, GLC.FLOAT);
        b.minFilter = GLC.NEAREST;
        b.magFilter = GLC.NEAREST;
        b.generateMipmaps = !1;
        b.flipY = !1;
        b.needsUpdate = !0;
        e.uniforms.staticRender.value = b;
        e.uniforms.sizeInv.value.set(1 / a, 1 / c);
        d.setCanvasSize(a, c);
        d.render(f, g);
        b.dispose()
    }
}

JMT.StaticRenderViewer = StaticRenderViewer

/***/ }),

/***/ "./src/core/BufferAttribute.js":
/*!*************************************!*\
  !*** ./src/core/BufferAttribute.js ***!
  \*************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

class BufferAttribute extends THREE.BufferAttribute {
    constructor(a, b, c) {
        super(a, b)
        this._length = a.length;
        this.releaseOnLoadedToGpu = !UjP.config.mode //!0;
        this.divisor = c || 0;
        this.glType = this.buffer = null
    }

    get length() {
        return this._length
    }
};

JMT.BufferAttribute = BufferAttribute;


/***/ }),

/***/ "./src/core/Geometry.js":
/*!******************************!*\
  !*** ./src/core/Geometry.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BufferAttribute.js */ "./src/core/BufferAttribute.js");
/* harmony import */ var _BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_BufferAttribute_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */

//import {$jscomp} from '../../src_new/lib/jscomp.js'

function addBufferAttribute(geom, name, array, itemSize, divisor) {
    if (divisor && undefined != THREE.InstancedBufferAttribute) {
        let attribute = new THREE.InstancedBufferAttribute(array, itemSize);
        geom.setAttribute(name, attribute)
    }
    else {
        let attribute = new JMT.BufferAttribute(array, itemSize, divisor || 0);
        if (geom.setAttribute != undefined)
            geom.setAttribute(name, attribute)
        else
            geom.addAttribute(name, attribute)
    }
    
}

THREE.BufferGeometry.prototype.addTriangleOrderAttribute = function () {
    if (void 0 === this.getAttribute("order")) {
        var a = this.getAttribute("position").length / 3
        var c = new Float32Array(a)
        for (var d = 0; d < a; d += 1) {
            c[d] = d % 3;
        }
        this.addAttribute("order", new JMT.BufferAttribute(c, 1))
    }
};
THREE.BufferGeometry.prototype.convertNormalsToSpherical = function () {
    console.assert(void 0 === this.getAttribute("sphericalNormal"));
    var a = this.getAttribute("normal");
    console.assert(!a.buffer);
    a = a.array;
    for (var c = a.length / 3, d = (JMT.DETECTOR && JMT.DETECTOR.ios) ? new Int16Array(2 * c) : new Int8Array(2 * c), e = 0; e < c; e += 1) {
        var g = 3 * e, f = 2 * e, h = Math.atan2(a[g + 1], a[g]) / Math.PI;
        d[f] = JMT.Math.toSnorm8(2 * (Math.acos(a[g + 2]) / Math.PI - .5));
        d[f + 1] = JMT.Math.toSnorm8(h)
    }
    delete this.attributes.normal;
    //this.addAttribute("sphericalNormal", new JMT.BufferAttribute(d, 2))
    this.setAttribute("sphericalNormal", new JMT.BufferAttribute(d, 2))
};
THREE.BufferGeometry.prototype.changePosition = function (a) {
    var b = this.getAttribute("position"), d = b.length / 3;
    b = b.array;
    for (var e = 0; e < 3 * d; e += 3) {
        b[e] += a.x
        b[e + 1] += a.y
        b[e + 2] += a.z
    }
};
THREE.BufferGeometry.prototype.clone = function () {
    console.error("JMT.BufferGeometry cloning not supported")
};

class Geometry extends THREE.BufferGeometry{
    constructor() {
        super()

        this.isInstanced = !1;
        this.instanceCount = 0;
        this.indices = null;
        this.indexUint = !0;
        this.uvs1 = this.uvs0 = this.normals = this.vertices = null;
        this.vertexOffset = this.vertexCnt = this.indexOffset = this.indexCnt = 0;
        this.boundingBox = new THREE.Box3;
        this.boundingSphere = new THREE.Sphere;
        this.gpuSize = 0
    }
};
JMT.Geometry = Geometry

JMT.Geometry.prototype.allocateCoreBuffers = function (useIndex) {
    console.assert(!this.vertices);
    if (useIndex) {

        if (65536 >= this.vertexCnt) {
            this.indexUint = false;
            this.indices = new Uint16Array(this.indexCnt);
            this.gpuSize += 2 * this.indexCnt;
        }
        else {
             this.indexUint = true;
             this.indices = new Uint32Array(this.indexCnt);
             this.gpuSize += 4 * this.indexCnt;
        }
    }

    this.vertices = new Float32Array(3 * this.vertexCnt);
    this.gpuSize += 12 * this.vertexCnt;
    this.normals = JMT.DETECTOR.ios ?
        new Int16Array(2 * this.vertexCnt) : new Int8Array(2 * this.vertexCnt);
    this.gpuSize += 2 * this.vertexCnt
};
JMT.Geometry.prototype.addCoreAttributes = function () {
    if (this.indices) {
        if (!JMT.threeExtension) {
            addBufferAttribute(this, "index", this.indices, 1);
            this.indices = null;
        }
        else {
            let attribute = new JMT.BufferAttribute(this.indices, 1);
            this.setIndex(attribute)
            this.indices = null;
            this.index.name = "_index_"+this.id
        }
    }
    
    addBufferAttribute(this, "position", this.vertices, 3);
    this.vertices = null;
    addBufferAttribute(this, "sphericalNormal", this.normals, 2);
    this.normals = null
};
JMT.Geometry.prototype.allocateUv0 = function () {
    console.assert(!this.uvs0);
    this.uvs0 = new Float32Array(2 * this.vertexCnt);
    this.gpuSize += 8 * this.vertexCnt
};
JMT.Geometry.prototype.addUv0Attribute = function () {
    addBufferAttribute(this, "uv", this.uvs0, 2);
    this.uvs0 = null
};
JMT.Geometry.prototype.allocateUv1 = function () {
    console.assert(!this.uvs1);
    this.uvs1 = new Uint16Array(2 * this.vertexCnt);
    this.gpuSize += 4 * this.vertexCnt
};
JMT.Geometry.prototype.addUv1Attribute = function () {
    addBufferAttribute(this, "uv2", this.uvs1, 2);
    this.uvs1 = null
};
JMT.Geometry.prototype.computeBoundingBox = void 0;
JMT.Geometry.prototype.computeBoundingSphere = void 0;

class InstancedGeometry extends THREE.BufferGeometry{
    constructor (parentGeometry, ownsGpuBuffers) {
        super();
        this.parent = parentGeometry;
        this.ownsGpuBuffers = ownsGpuBuffers;
        this.isInstanced = !0;
        this.instanceCount = 0;
        this.transforms2 = this.transforms1 = this.transforms0 = this.uvs1Mod = null;
        this.vertexOffset = this.indexOffset = 0;
        this.boundingBox = new THREE.Box3;
        this.boundingSphere = new THREE.Sphere;
        this._gpuSize = 0

        Object.defineProperty(this,
            "indices", {
                get: function () {
                    return this.parent.indices
                }
            });
    }
    
};
JMT.InstancedGeometry = InstancedGeometry

JMT.InstancedGeometry.prototype.allocateCoreBuffers = function (useIndex) {
    console.assert(!this.transforms0);
    this.parent.vertices ||
    this.parent.allocateCoreBuffers(useIndex);
    let a = 4 * this.instanceCount;
    this.transforms0 = new Float32Array(a);
    this.transforms1 = new Float32Array(a);
    this.transforms2 = new Float32Array(a);
    this._gpuSize += 12 * a
};
JMT.InstancedGeometry.prototype.addCoreAttributes = function () {
    this.parent.attributes.position || this.parent.addCoreAttributes();
    for (var b = $jscomp.makeIterator(Object.keys(this.parent.attributes)), c = b.next(); !c.done; c = b.next()) {
        c = c.value
        //this.addAttribute(c, this.parent.attributes[c]);
        this.setAttribute(c, this.parent.attributes[c]);
    }

    if (JMT.threeExtension) {
        this.setIndex(this.parent.getIndex());
    }
    
    addBufferAttribute(this, "t0", this.transforms0, 4, 1);
    addBufferAttribute(this, "t1", this.transforms1, 4, 1);
    addBufferAttribute(this, "t2", this.transforms2, 4, 1);
    this.transforms2 = this.transforms1 = this.transforms0 = null
};
JMT.InstancedGeometry.prototype.allocateUv0 = function () {
    this.parent.uvs0 || this.parent.allocateUv0()
};
JMT.InstancedGeometry.prototype.addUv0Attribute = function () {
    this.parent.attributes.uv || this.parent.addUv0Attribute();
    this.setAttribute("uv", this.parent.attributes.uv)
};
JMT.InstancedGeometry.prototype.allocateUv1 = function () {
    console.assert(!this.uvs1Mod);
    this.parent.uvs1 ||
    this.parent.allocateUv1();
    this.uvs1Mod = new Float32Array(4 * this.instanceCount);
    this._gpuSize += 16 * this.instanceCount
};
JMT.InstancedGeometry.prototype.addUv1Attribute = function () {
    this.parent.attributes.uv2 || this.parent.addUv1Attribute();
    //this.addAttribute("uv2", this.parent.attributes.uv2);
    this.setAttribute("uv2", this.parent.attributes.uv2);
    addBufferAttribute(this, "uv2Mod", this.uvs1Mod, 4, 1);
    this.uvs1Mod = null
};
JMT.InstancedGeometry.prototype.computeBoundingBox = void 0;
JMT.InstancedGeometry.prototype.computeBoundingSphere = void 0;

Object.defineProperty(JMT.InstancedGeometry.prototype, "vertices", {
    get: function () {
        return this.parent.vertices
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "normals", {
    get: function () {
        return this.parent.normals
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "uvs0", {
    get: function () {
        return this.parent.uvs0
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "uvs1", {
    get: function () {
        return this.parent.uvs1
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "indexUint", {
        get: function () {
            return this.parent.indexUint
        }
    });
Object.defineProperty(JMT.InstancedGeometry.prototype, "vertexCnt", {
    get: function () {
        return this.parent.vertexCnt
    }, set: function (a) {
        this.parent.vertexCnt = a
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "indexCnt", {
    get: function () {
        return this.parent.indexCnt
    }, set: function (a) {
        this.parent.indexCnt = a
    }
});
Object.defineProperty(JMT.InstancedGeometry.prototype, "gpuSize", {
    get: function () {
        return this.ownsGpuBuffers ? this._gpuSize + this.parent.gpuSize :
            this._gpuSize
    }
});


class SubGeometry extends THREE.BufferGeometry {
    constructor(indexCnt, vertexCnt, parent, indexOffset, vertexOffset, boundingBox, boundingSphere) {
        super();

        this.indexCnt = indexCnt;
        this.vertexCnt = vertexCnt;
        this.parent = parent;
        this.vertexOffset = vertexOffset;
        this.indexOffset = indexOffset;
        this.boundingBox = boundingBox;
        this.boundingSphere = boundingSphere;
        this.isInstanced = parent.isInstanced;
        this.instanceId = 0;
        this.instanceCount = 1

        Object.defineProperty(this, "attributes", {
            get: function () {
                return this.parent.attributes
            }
        });

        Object.defineProperty(this, "attributesKeys", {
            get: function () {
                return this.parent.attributesKeys
            }
        });
        Object.defineProperty(this, "indexUint", {
            get: function () {
                return this.parent.indexUint
            }
        });

        Object.defineProperty(this, "index", {
            get: function () {
                return this.parent.index
            }
        })
    }
};
JMT.SubGeometry = SubGeometry;

JMT.SubGeometry.prototype.computeBoundingBox = void 0;
JMT.SubGeometry.prototype.computeBoundingSphere = void 0;
JMT.SubGeometry.prototype.addTriangleOrderAttribute = function () {
    this.parent.addTriangleOrderAttribute()
}

/***/ }),

/***/ "./src/core/Line.js":
/*!**************************!*\
  !*** ./src/core/Line.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Line": function() { return /* binding */ Line; }
/* harmony export */ });

function Line(geometry, material) {

    if(!geometry){
        geometry = new THREE.BufferGeometry
        var poss = new Float32Array(2 * 3);
        var normals = new Float32Array(2 * 3);
        var uvs = new Float32Array(2 * 2);


        this.type = "JMT.Line";
        for (let i=0; i<2; i++) {
            poss[i*3+0] = poss[i*3+1] = poss[i*3+2] = 0
            normals[i*3+0] = normals[i*3+1] = normals[i*3+2] = 0
            uvs[i*2+0] = uvs[i*2+1] = 0
        }

        geometry.addAttribute("position", new THREE.BufferAttribute(poss, 3));
        geometry.addAttribute("normal", new THREE.BufferAttribute(normals, 3));
        //geometry.addAttribute("uv", new THREE.BufferAttribute(uvs, 2))

        geometry.convertNormalsToSpherical()
    }

    this.geometry = geometry

    if(!material){
        material = new JMT.StandardMaterial;
        //material.hideFromLightProbes = !0;
        //material.baseColor.copy(color);
        material.baseColor = new THREE.Color(1,0,0);
        //material.opacity = opacity;
        material.specularOff = 1;
        material.depthTest = !1;
        material.depthWrite = !0;
    }

    this.material = material

    THREE.Mesh.call(this, geometry, material)

    function _updateBuffer(l) {
        l.geometry.attributes.position.needsUpdate = true
        l.geometry.attributes.position.buffer = null
        UjP.webGLRenderer.uploadNewBuffers(l)
    }

    this.setStartPoint = function (x, y, z) {
        this.geometry.attributes.position.array[0] = x
        this.geometry.attributes.position.array[1] = y
        this.geometry.attributes.position.array[2] = z

        _updateBuffer(this)
    }

    this.setEndPoint = function (x, y, z) {
        this.geometry.attributes.position.array[3] = x
        this.geometry.attributes.position.array[4] = y
        this.geometry.attributes.position.array[5] = z

        _updateBuffer(this)
    }

    this.update = function () {

    }
}

THREE.Line = Line

THREE.Line.prototype = Object.create(THREE.Mesh.prototype);
THREE.Line.prototype.constructor = THREE.Line;

//[x,y,z,x,y,z]
THREE.PolyLine = function (points) {

    this.type = "JMT.PolyLine";

    var geometry = new THREE.BufferGeometry
    var poss = new Float32Array(points.length);
    var normals = new Float32Array(points.length);

    for (let i=0; i<points.length; i++){
        poss[i] = points[i]
        normals[i] = 0
    }

    geometry.addAttribute("position", new THREE.BufferAttribute(poss, 3));
    geometry.addAttribute("normal", new THREE.BufferAttribute(normals, 3));

    geometry.convertNormalsToSpherical()
    this.geometry = geometry

    var mtl = new JMT.StandardMaterial;
    mtl.hideFromLightProbes = !0;
    //mtl.baseColor.copy(color);
    mtl.baseColor = new THREE.Color(1,0,0);
    //mtl.opacity = opacity;
    mtl.specularOff = 1;
    //mtl.depthTest = !1;
    //mtl.depthWrite = !0;

    this.material = mtl

    THREE.Mesh.call(this, geometry, mtl)
}

THREE.PolyLine.prototype = Object.create(THREE.Mesh.prototype);
THREE.PolyLine.prototype.constructor = THREE.PolyLine;

/***/ }),

/***/ "./src/core/Viewer.js":
/*!****************************!*\
  !*** ./src/core/Viewer.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Viewer": function() { return /* binding */ Viewer; }
/* harmony export */ });
/* harmony import */ var _ViewerApi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ViewerApi.js */ "./ViewerApi.js");
/* harmony import */ var _utils_GpuRaycaster_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils/GpuRaycaster.js */ "./src/utils/GpuRaycaster.js");
/* harmony import */ var _objects_View_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../objects/View.js */ "./objects/View.js");
/* harmony import */ var _objects_Tour_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../objects/Tour.js */ "./objects/Tour.js");
/* harmony import */ var _textures_VideoTexture_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../textures/VideoTexture.js */ "./src/textures/VideoTexture.js");
/* harmony import */ var _textures_VideoTexture_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_textures_VideoTexture_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _objects_Avatar_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../objects/Avatar.js */ "./src/objects/Avatar.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _tools_Ruler_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../tools/Ruler.js */ "./src/tools/Ruler.js");
/**
 * Created by Kai on 2020/12/18.
 */












function DEFUALT_FUNCTION() {   // d
    return null
}


function notify(a, b) {
    for (var c = [], d = 1; d < arguments.length; ++d) {
        c[d - 1] = arguments[d];
    }
    try {
        return a.apply(null, $jscomp.arrayFromIterable(c))
    } catch (pa) {
        console.error(pa)
    }
    return !1
}

function fire(a, b) {

    for (var c = [], d = 1; d < arguments.length; ++d) {

        c[d - 1] = arguments[d];

    }

    if (a) {

        d = $jscomp.makeIterator(a);

        for (var e = d.next(); !e.done; e = d.next()) {

            notify.apply(null, [e.value].concat($jscomp.arrayFromIterable(c)))

        }
    }
}

class Viewer extends _ViewerApi_js__WEBPACK_IMPORTED_MODULE_0__.ViewerApi {
    constructor(mode, ui, mergeConfig) {    // a, b, c
        super()

        this.mode = mode
        this.ui = ui
        this.mergeConfig = mergeConfig
        this.scene = null
        this.controls = null
        this.teleport = null
        this.autoTour = null
        this.collider = null
        this.screenshotTaker = null
        this.lumaMeter = null
        this.aniController = null
        this._viewerConfig = null
        this.gazeModeObserver = null
        this.pointerEventDispatcher = null
        this.clickEventListened = !1
        this.sceneLoaded = !1
        this.materialPicker = null
        this.meeting = null
        this.events = {
            pageFirstInteraction: [],
            viewerConfigLoaded: [],
            sceneReadyToDisplay: [],
            sceneLoadComplete: [],
            anchorClicked: {},
            materialPickerClicked: {},
            nodeTypeClicked: {},
            anyNodeTypeClicked: [],
            materialClicked: {},
            materialHoverChanged: {},
            viewSwitchStarted: [],
            viewSwitchDone: [],
            vrChange: [],
            beforeRender: [],
            anchorsVisibilityChanged: [],
            apiUserStateChanged: {},
            anyApiUserStateChanged: [],
            meetingJoined: [],
            avatarListChanged: [],
            sceneClicked: []
        }
        this._anchors = []  // da
        this._avartars = []    // ba


        let that = this
        this.pageFirstInteraction = !1   // P
        function onPointerDown() {   //z
            that.pageFirstInteraction = !0;
            fire(that.events.pageFirstInteraction);
            that.events.pageFirstInteraction = [];
            document.removeEventListener("mousedown", onPointerDown);
            document.removeEventListener("touchend", onPointerDown);
            document.removeEventListener("keydown", onPointerDown)
        }

        document.addEventListener("mousedown", onPointerDown);
        document.addEventListener("touchend", onPointerDown);
        document.addEventListener("keydown", onPointerDown);

        this._anchorsVisible = !0;  // la

        Object.defineProperty(this, "anchorsVisible", {
            get: function () {
                return this._anchorsVisible
            },
            set: function (value) {
                if (value !== this._anchorsVisible) {
                    this._anchorsVisible = value
                    if (this._anchorsVisible) {
                        this._anchors.forEach(function (a) {
                            return this._addAnchorToScene(a)
                        })
                    }
                    else {
                        this._anchors.forEach(function (a) {
                            this.scene.removeAuxiliaryObject(a);
                            this.collider.removeDynamicObstacle(a.colliderMesh)
                        })

                        this.requestFrame()

                        fire(this.events.anchorsVisibilityChanged, this._anchorsVisible)
                    }
                }
            }
        });

        Object.defineProperty(this, "menuVisible", {
            get: function () {
                return this.ui.visible
            }, set: function (a) {
                this.ui.visible = a
            }
        });


        this.userStates = {}

        this.roams = []
    }


    clear(){

        this.roams.forEach(r=>{

            r.dispose()

        })
        this.roams = []

        this._anchors.forEach(r=>{

            r.dispose()

        })
        this._anchors = []  // da


        this._avartars.forEach(r=>{

            r.dispose()

        })
        this._avartars = []    // ba
    }

    makeOffset(fromPos, distance, toPos) {
        var camPos = this.controls.cameraWorldPosition();
        var offset = new THREE.Vector3().set(fromPos.x, fromPos.y, camPos.z).sub(camPos);
        var length = offset.length();
        if (length > distance) {
            offset.normalize().multiplyScalar(length - distance)
            toPos.add(offset)
        }
    }

    seeItem(c) {

        if (!c) {
            return
        }

        var b = new THREE.Vector3()
        var d = new THREE.Vector3()
        var e = new _objects_View_js__WEBPACK_IMPORTED_MODULE_2__.View()
        var f = new THREE.Sphere()
        var g = this.controls.cameraWorldPosition();

        var k = e.position;

        k.copy(g);

        if (c instanceof JMT.LightInstance && "sun" === c.light.type) {

            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.sunRotationToPosition)(this.scene, c.rotation, b)

            c = b

        }
        else if (c instanceof JMT.Node) {

            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.computeNodeBoundingSphere)(c, f)

            c = f.center

            this.makeOffset(c, 1 + f.radius, k)

        }
        else if (c instanceof JMT.StandardMaterial) {

            this.scene.visitMeshesWithMaterial(c, function (mesh, node) {

                (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.computeNodeBoundingSphere)(node, f)

                c = f.center

                this.makeOffset(c, 1 + f.radius, k)

            })

        }
        else {

            c = c.position

            this.makeOffset(c, 1, k)

        }

        d.copy(c).sub(k).normalize();

        e.rotation.setFromDirection(d);

        this.teleport.switchToView(e)

    }

    bindListeners(clickEvents, hoverEvents) {

        let that = this

        function _createHoverListener() {

            var a = that.events.materialHoverChanged

            var b = [];

            if (0 === Object.keys(a).length) {

                return null

            }
            else {

                return function (mesh, d) {

                    var e = $jscomp.makeIterator(a[mesh.material.name] || b)

                    for (var f = e.next(); !f.done; f = e.next()) {

                        if (notify(f.value, mesh.material, d)) {

                            return !0;

                        }
                    }
                    return !1
                }
            }
        }

        hoverEvents.push(_createHoverListener)

        function _clickListener(a, b, c) {

            fire(that.events.sceneClicked)

            if (!that.clickEventListened) {

                return !1;

            }

            if (that.materialPicker) {

                var d = that.events.materialPickerClicked[a.id];

                if (d) {

                    notify(d, a.material, U.meshes.indexOf(a))

                    return !0;

                }

                this.materialPicker.meshes.forEach(function (a) {
                    that.scene.removeAuxiliaryObject(a);
                    that.collider.removeDynamicObstacle(a);
                    delete that.events.materialPickerClicked[a.id]
                });

                that.aniController.requestFrame();

                that.materialPicker.dispose();

                that.materialPicker = null;

                return !0
            }

            d = that.events.anchorClicked[a.id]

            if (d) {

                notify(d, a.anchor, b, c)

                return !0;
            }

            d = function (a, d) {
                if (a) {
                    a = $jscomp.makeIterator(a);
                    for (var e = a.next(); !e.done; e = a.next()) {
                        if (notify(e.value, d, b, c)) {
                            return !0
                        }
                    }
                }
                return !1
            }

            for (var e = a.node; e;) {

                if (d(that.events.nodeTypeClicked[e.config.name], a.node)) {

                    return !0;

                }

                e = e.parent
            }

            if (a.node && d(that.events.anyNodeTypeClicked, a.node)) {

                return !0

            }
            else if (a.material) {

                return d(that.events.materialClicked[a.material.name], a.material)

            }
            else {

                return !1

            }
        }

        clickEvents.push(_clickListener)
    }

    getEditableMaterials() {

        var a = []

        var b = $jscomp.makeIterator(this.scene.materials)

        for (var d = b.next(); !d.done; d = b.next()) {

            d = d.value, c.isMaterialEditable(d.name) && a.push(d);

        }

        return a
    }

    getEditableNodeTypes() {

        var a = []

        var b = $jscomp.makeIterator(this.scene.nodeConfigs)

        for (var d = b.next(); !d.done; d = b.next()) {

            d = d.value, c.isNodeTypeEditable(d.name) &&

            a.push(d.name);

        }

        return a
    }

    findMaterial(a) {

        this._validateMaterial(a);

        var b = $jscomp.makeIterator(this.scene.materials)

        for (var c = b.next(); !c.done; c = b.next()) {
            c = c.value
            if (c.name === a) {
                return c;
            }
        }

        return null
    }

    getRoamCharacters() {

        return this.roams

    }

    enableRoamCharacter(index, enable) {

        let curChar = null;
        let that = this

        function onRoamWalk() {

            if (curChar) {

                let yaw = that.controls.getYawAngle()

                console.log(yaw * 180 / Math.PI);

                let normal = new THREE.Vector3(
                    Math.sin(-yaw),
                    Math.cos(-yaw),
                    1
                ).normalize()

                let pos = that.controls.cameraWorldPosition()

                let newPos = new THREE.Vector3().copy(pos).add(normal.multiplyScalar(2.0))

                curChar.setPosition(newPos.x, newPos.y, curChar.position.z)

                curChar.updateMatrixWorld(!0)

                that.aniController.requestFrame()
            }
        }

        if (this.roams.length > 0 && index < this.roams.length && index >= 0) {


            curChar = this.roams[index]

            curChar.visible = enable

            let camera = this.scene.camera

            if (enable) {
                camera.addEventListener('rotationChanged', onRoamWalk)
                camera.addEventListener('positionChanged', onRoamWalk)

                onRoamWalk()
            }
            else {
                camera.removeEventListener('rotationChanged', onRoamWalk, !1)
                camera.removeEventListener('positionChanged', onRoamWalk, !1)

                that.aniController.requestFrame()
            }
        }
    }

    findMeshesWithMaterial(a) {

        var b = [];

        this._validateMaterial(a);

        var c = $jscomp.makeIterator(this.scene.gpuMeshes)

        for (var d = c.next(); !d.done; d = c.next()) {

            d = d.value

            d.material.name === a && b.push(d);

        }

        return b
    }

    findNodesOfType(a) {

        a = this.scene.findNodeConfig(a)

        return a ? a.nodes : []
    }

    getCameraPosition() {
        let pos = new THREE.Vector3() //ea
        pos.copy(this.controls.cameraWorldPosition());
        return pos
    }

    getCameraRotation() {
        let rotation = new JMT.Euler(); //ia
        rotation.yaw = this.controls.getYawAngle();
        rotation.pitch = this.controls.getPitchAngle();
        rotation.roll = 0;
        return rotation
    }

    getCamera() {
        return this.controls.camera()
    }

    setCamaraPositionRotationChangedCallback(callback) {
        this.scene.camera.removeEventListener('rotationChanged', callback, !1)
        this.scene.camera.addEventListener('rotationChanged', callback)

        this.scene.camera.removeEventListener('positionChanged', callback, !1)
        this.scene.camera.addEventListener('positionChanged', callback)
    }

    getSceneBoundingBox() {
        return this.scene.boundingBox
    }

    setMaterialForNode(node, material) {
        console.warn("setMaterialForNode() is deprecated, use setMaterialForMesh() instead");
        this.setMaterialForMesh(node, material)
    }

    setMaterialForMesh(mesh, material) {
        mesh.material = material;
        this.aniController.requestFrame()
    }

    switchToView(name, time, isTop) {

        var view;

        if ("string" === typeof name) {

            view = this.scene.findViewByName(name)

        }
        else {

            view = name

        }

        if (view) {
            if (!0 === time) {
                time = 0
            }
            else if (!1 === time) {
                time = void 0
            }

            if (this.autoTour.isRunning()) {
                time = 0
                this.autoTour.stop()
            }

            if (isTop) {
                this.teleport.activateSky(view)
                this.teleport.updateHiddenMeshes(view)
            }
            else {
                this.teleport.switchToView(view, time)
            }
        }
        else {
            console.error("Unknown view: " + name)
        }
    }

    captureImage(config) {

        config = void 0 === config ? {} : config;

        var b = config.isPanorama || !1

        var c = config.width || (b ? 4E3 : window.innerWidth)

        var d = config.height || (b ? 2E3 : window.innerHeight);

        if (config.toDataUrl) {

            return this.screenshotTaker.screenToDataUrl(b, c, d);

        }

        this.screenshotTaker.screenToLocalImage(b, c, d)
    }

    loadAssets(extobj) {
        UjP.assetsController.deserialize(extobj, asset=> {
            if (asset.isRoamCharacter) {
                this.roams.push(asset)
            }
        })
    }

    addAnchor(config, onAnchorClick) {
        var a = new JMT.Anchor(this.scene, config);
        this._anchors.push(a);
        this._anchorsVisible && this._addAnchorToScene(a);
        this.events.anchorClicked[a.colliderMesh.id] = onAnchorClick;
        this.clickEventListened = !0;
        this.aniController.requestFrame();
        return a
    }

    removeAnchor(anchor) {

        delete this.events.anchorClicked[anchor.colliderMesh.id];

        if (this._anchorsVisible) {

            this.scene.removeAuxiliaryObject(anchor)

            this.collider.removeDynamicObstacle(anchor.colliderMesh)
        }

        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(anchor, this._anchors);

        anchor.dispose();

        this.aniController.requestFrame()
    }

    addAvatar(uuid, config) {
        var avatar = new JMT.Avatar(this.scene, uuid, config);
        this._avartars.push(avatar);
        this.scene && this.scene.addAuxiliaryObject(avatar, !0);
        fire(this.events.avatarListChanged);
        this.aniController.requestFrame();
        return avatar
    }

    removeAvatar(avatar) {
        this.scene.removeAuxiliaryObject(avatar);
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(avatar, this._avartars);
        avatar.dispose();
        fire(this.events.avatarListChanged);
        this.aniController.requestFrame()
    }

    findAvatar(avatar) {

        return (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.find)(this._avartars, function (avatar) {

            return b.uuid === a

        })
    }

    sleepAnimatedMaterials() {

        var a = $jscomp.makeIterator(this.scene.getAnimatedMaterials())

        for (var b = a.next(); !b.done; b = a.next()) {

            b.value.sleepAnimation()

        }
    }

    wakeAnimatedMaterials() {

        var a = $jscomp.makeIterator(this.scene.getAnimatedMaterials())

        for (var b = a.next(); !b.done; b = a.next()) {

            b.value.wakeAnimation();

        }
        this.aniController.requestFrame()
    }

    _validateMaterial(a) {  // e

        if (!this.mergeConfig.isMaterialEditable(a)) {

            console.assert(!1, "Can't access material, call ViewerApi.setMaterialEditable('" + a + "') before the scene is loaded.")

        }

    }

    _addAnchorToScene(a) {  // t
        this.scene.addAuxiliaryObject(a);

        if (a !== a.colliderMesh) {

            this.webGLRenderer.uploadNewBuffers && this.webGLRenderer.uploadNewBuffers(a.colliderMesh)

        }

        this.collider.addDynamicObstacle(a.colliderMesh)
    }

    openMaterialPicker(a, b, c, d) {

        this.materialPicker = new JMT.MaterialPicker(a, c, d, this.scene, this.controls, this.lumaMeter, this.gazeModeObserver);

        this.materialPicker.meshes.forEach(function (a) {

            this.scene.addAuxiliaryObject(a);

            this.collider.addDynamicObstacle(a);

            this.events.materialPickerClicked[a.id] = b

        });

        this.aniController.requestFrame()
    }

    _vrChange(a) {
        fire(this.events.vrChange, a)
    }

    _update(a) {
        fire(this.events.beforeRender, a)
    }

    _viewerConfigLoaded(viewerConfig) {
        this._viewerConfig = viewerConfig;
        fire(this.events.viewerConfigLoaded, this._viewerConfig);
        this.events.viewerConfigLoaded = []
    }

    _sceneReadyToDisplay( //a, b, c, d, e, t, v, z, P, aa, ia) {
        webGLRenderer,
        scene,
        controls,
        teleport,
        autoTour,
        collider,
        screenshotTaker,
        lumaMeter,
        gazeModeObserver,
        pointerEventDispatcher,
        aniController) {

        this.webGLRenderer = webGLRenderer
        this.scene = scene
        this.controls = controls    // B
        this.teleport = teleport
        this.autoTour = autoTour
        this.collider = collider
        this.screenshotTaker = screenshotTaker
        this.lumaMeter = lumaMeter
        this.gazeModeObserver = gazeModeObserver
        this.pointerEventDispatcher = pointerEventDispatcher
        this.aniController = aniController

        fire(this.events.sceneReadyToDisplay, this.scene);
        this.events.sceneReadyToDisplay = [];


        let t = this

        function _teleportStarted(a) {

            let view = a.view;

            //console.log(a);
            null !== view && fire(t.events.viewSwitchStarted, view)

        }

        function _teleportDone(a) {

            let view = a.view;

            null !== view && fire(t.events.viewSwitchDone, view)

        }

        this.teleport.addEventListener("teleportStarted", _teleportStarted);
        this.teleport.addEventListener("teleportDone", _teleportDone)

        if(JMT.DEBUG){
            this._toolMeasure = new _tools_Ruler_js__WEBPACK_IMPORTED_MODULE_7__.Ruler(this)
        }
    }


    _contextLost() {
        this.sceneLoaded = !1;
        this._viewerConfig
            = this.scene
            = this.teleport
            = this.autoTour
            = this.collider
            = this.screenshotTaker
            = this.pointerEventDispatcher
            = this.aniController
            = null;
        this.wakeAnimatedMaterials
            = this.sleepAnimatedMaterials
            = this.findAvatar
            = this.removeAnchor
            = this.addAvatar
            = this.addAnchor
            = this.captureImage
            = this.switchToView
            = this.setMaterialForMesh
            = this.setMaterialForNode
            = this.findNodesOfType
            = this.findMeshesWithMaterial
            = this.findMaterial
            = this.getEditableNodeTypes
            = this.getEditableMaterials
            = DEFUALT_FUNCTION
    }

    _sceneLoadComplete() {
        fire(this.events.sceneLoadComplete);
        this.events.sceneLoadComplete = [];
        this.sceneLoaded = !0;
        for (var a = $jscomp.makeIterator(this._anchors), b = a.next(); !b.done; b = a.next()) {
            b.value.enableLightProbe()
        }
    }

    openUrl(url, newWindow) {

        if (newWindow || this.mode) {

            window.open(url)

        }
        else {

            window.location.href = url

        }
    }

    onPageFirstInteraction(callback) {
        this.pageFirstInteraction ? callback() : this.events.pageFirstInteraction.push(callback)
    }

    onViewerConfigLoaded(callback) {
        this._viewerConfig ? callback(this._viewerConfig) : this.events.viewerConfigLoaded.push(callback)
    }

    isSceneReadyToDisplay() {
        return null !== this.scene
    }

    onSceneReadyToDisplay(callback) {
        this.scene ? callback(this.scene) : this.events.sceneReadyToDisplay.push(callback)
    }

    onSceneLoadComplete(callback) {
        this.sceneLoaded ? callback(this.scene) : this.events.sceneLoadComplete.push(callback)
    }

    requestFrame() {
        this.aniController && this.aniController.requestFrame()
    }

    setNodeTypeEditable(callback) {
        console.assert(null === this.scene, "setNodeTypeEditable must be called before the scene is loaded");
        this.mergeConfig.setNodeTypeEditable(callback)
    }

    setMaterialEditable(callback) {
        console.assert(null === this.scene, "setMaterialEditable must be called before the scene is loaded");
        this.mergeConfig.setMaterialEditable(callback)
    }

    setAllMaterialsEditable() {
        console.assert(null === this.scene, "setAllMaterialsEditable must be called before the scene is loaded");
        this.mergeConfig.setAllMaterialsEditable()
    }

    onNodeTypeClicked(callback, b) {
        if ("function" === typeof callback) {
            this.events.anyNodeTypeClicked.push(callback)
        }
        else {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.getSafeValue)(this.events.nodeTypeClicked, callback).push(b);
        }
        this.clickEventListened = !0
    }

    removeOnNodeTypeClicked(a, b) {
        if ("function" === typeof a) {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(a, this.events.anyNodeTypeClicked)
        }
        else {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(b, this.events.nodeTypeClicked[a])
        }
    }



    onSceneClicked(callback){
        if ("function" === typeof callback) {
            this.events.sceneClicked.push(callback)
        }
    }

    removeSceneClicked(callback){
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(callback, this.events.sceneClicked)
    }

    onMaterialClicked(material, callback) {
        this.setMaterialEditable(material);
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.getSafeValue)(this.events.materialClicked, material).push(callback);
        this.clickEventListened = !0
    }

    onMaterialHoverChanged(material, callback) {
        this.setMaterialEditable(material);
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.getSafeValue)(this.events.materialHoverChanged, material).push(callback)
    }

    onViewSwitchStarted(callback) {
        this.events.viewSwitchStarted.push(callback)
    }

    onViewSwitchDone(callback) {
        this.events.viewSwitchDone.push(callback)
    }

    onVrChange(callback) {
        this.events.vrChange.push(callback)
    }

    onBeforeRender(callback) {
        this.events.beforeRender.push(callback)
    }

    createTextureFromHtmlImage(image) {

        function b() {
            d.needsUpdate = !0;
            d.width = image.naturalWidth;
            d.height = image.naturalHeight;
            THREE.Math.isPowerOfTwo(d.width) && THREE.Math.isPowerOfTwo(d.height) || (d.minFilter = GLC.LINEAR);
            d.notifyLoaded()
        }

        function c() {
            b();
            e && e();
            image.onload = e
        }

        var d = new JMT.Texture;
        d.image = image;
        d.wrapS = d.wrapT = GLC.REPEAT;
        d.minFilter = GLC.LINEAR_MIPMAP_LINEAR;
        d.anisotropy = JMT.DEFAULT_ANISOTROPY;
        d.format = GLC.RGB;
        var e = null;
        image.complete && 0 !== image.naturalHeight ? b() : (e = image.onload, image.onload = c);
        return d
    }

    createTextureFromHtmlVideo(video) {
        var b = new JMT.VideoTexture;
        b.video = video;
        b.minFilter = GLC.LINEAR;
        b.anisotropy = JMT.DEFAULT_ANISOTROPY;
        b.format = GLC.RGB;
        b.generateMipmaps = !1;
        video.setAttribute("playsinline", "");
        video.setAttribute("webkit-playsinline", "");
        video.crossOrigin = "anonymous";
        JMT.onVideoDataReady(video, function (a) {
            b.width = a.videoWidth;
            b.height = a.videoHeight;
            if (THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height)) {
                b.wrapS = GLC.REPEAT
                b.wrapT = GLC.REPEAT
            }
            else {
                b.wrapS = GLC.CLAMP_TO_EDGE
                b.wrapT = GLC.CLAMP_TO_EDGE
            }
            b.notifyLoaded()
        });
        return b
    }

    onAnchorsVisibilityChanged(callback) {
        this.events.anchorsVisibilityChanged.push(callback)
    }

    removeAnchorsVisibilityChangedListener(callback) {
        this.events.anchorsVisibilityChanged = this.events.anchorsVisibilityChanged.filter(function (b) {
            return b !== callback
        })
    }

    getViewerAssetUrl(a) {
        return (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.getViewerAssetUrl)(a)
    }

    getViews() {
        return this.scene.views
    }

    getTours() {
        return this.scene.tours
    }

    loadViewsAndTours(config) {

        let scene = this.scene
        if (scene != null) {
            let views = config.views || []
            let tours = config.tours || []
    
            views.forEach(function (view) {
                scene.addView(new _objects_View_js__WEBPACK_IMPORTED_MODULE_2__.View(view))
            })
    
            tours.forEach(function(tour){
                scene.addTour(new _objects_Tour_js__WEBPACK_IMPORTED_MODULE_3__.Tour(tour))
            })
        }
    }


    getAutoTour() {
        return this.autoTour
    }

    addMenuButton(a) {
        return this.ui.addExtraButton(a)
    }

    removeMenuButton(a) {
        this.ui.removeExtraButton(a)
    }

    getMenuButtonIcon(a) {
        return this.ui.getExtraButonIcon(a)
    }

    onMenuVisibilityChanged(callback) {
        this.ui.addEventListener("visibilityChanged", function () {
            callback()
        })
    }

    play() {
        JMT.play()
    }

    // 暂停场景
    pause() {

    }

    apiUserChangeState(name, b) {

        if (!(0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.deepEqual)(this.userStates[name], b)) {

            this.userStates[name] = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.readOnlyCopy)(b)

            let obj = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(b)

            fire(this.events.apiUserStateChanged[name], name, obj)

            fire(this.events.anyApiUserStateChanged, name, obj)

        }

    }

    onApiUserStateChanged(a, b) {
        if ("function" === typeof a) {
            this.events.anyApiUserStateChanged.push(a)
        }
        else {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.getSafeValue)(this.events.apiUserStateChanged, a).push(b)
        }
    }

    removeOnApiUserStateChanged(a, b) {
        if ("function" === typeof a) {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(a, this.events.anyApiUserStateChanged)
        }
        else {
            (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(b, this.events.apiUserStateChanged[a])
        }
    }

    getApiUserState(a) {

        if (void 0 === a) {

            return (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.cloneObject)(this.userStates);

        }

        a = this.userStates[a];

        if (void 0 === a) {
            return void 0
        }
        else {
            return JMT.cloneObject(a)
        }
    }

    _meetingJoined(meeting) {
        console.assert(null === this.meeting);
        this.meeting = meeting;
        fire(this.events.meetingJoined, this.meeting)
    }

    _onMeetingJoined(callback) {
        this.events.meetingJoined.push(callback);
        null !== this.meeting && callback(this.meeting)
    }

    _removeOnMeetingJoined(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(a, this.events.meetingJoined)
    }

    _createPointerEventHelper(a) {
        return new JMT.PointerEventHelper(this.pointerEventDispatcher, a)
    }

    onAvatarListChanged(callback) {
        this.events.avatarListChanged.push(callback)
    }

    removeOnAvatarListChanged(callback) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_6__.removeFromArray)(callback, this.events.avatarListChanged)
    }


    disableControls() {
        this.controls.disable()
    }

    enableControls() {
        this.controls.enable()
    }

    enableRuler(value) {
        if(this._toolMeasure){
            value ? this._toolMeasure.disable() : this._toolMeasure.enable()
        }
    }

    findIntersectionAtPosition(x, y) {
        var ya = new JMT.RayIntersection;
        this.collider.findIntersectionAtPosition(x, y, !0, ya);
        return ya
    }

    getAssets(){

        return UjP.assetsController.assets

    }

    // 获取动画
    getAnimationById(assetId) {

        return UjP.animationsController.findAnimation(assetId)

    }

    // 加载全部动画
    loadAnimations(json) {

        let ctl = UjP.animationsController

        let anis = ctl.deserialize(json)

        ctl.solveTriggers()

        return anis
    }


    // 动画播放
    animationPlayById(assetId, loop = 2200, repetitions = Infinity) {

        let asset = UjP.assetsController.findAsset('uuid', assetId)

        if(asset){
            UjP.animationsController.play(asset, loop, repetitions)
        }
    }

    // 动画播放
    animationPlay(asset, loop = 2200, repetitions = Infinity) {

        UjP.animationsController.play(asset, loop, repetitions)

    }

    // 动画停止
    animationStop(asset) {
        UjP.animationsController.stop(asset)
    }

    // 设置动画播放时回调
    setAnimationPlayCallback(callback) {

        if (callback) {

            UjP.animationsController.mixer.removeEventListener('updated', callback, !1)
            UjP.animationsController.mixer.addEventListener('updated', callback)

        }
    }

    // 设置动画播放结束回调
    setAnimationFinishedCallback(callback) {
        if (callback) {

            UjP.animationsController.onFinished = callback

        }
    }

    // 设置动画播放单次循环结束回调
    setAnimationLoopEndCallback(callback) {
        if (callback) {

            UjP.animationsController.onLoop = callback

        }
    }


    moveAndHeadTo(position, rotation) {

        position && this.controls.cameraWorldPosition().set(position[0], position[1], position[2]);

        if (rotation) {

            var euler = new JMT.Euler

            euler.setFromDegTriple(rotation)

            this.controls.setYawAngle(euler.yaw)

            this.controls.setPitchAngle(euler.pitch)
        }


        this.aniController.requestFrame()
    }
}

/***/ }),

/***/ "./src/editor/EditorHooks.js":
/*!***********************************!*\
  !*** ./src/editor/EditorHooks.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorHooks": function() { return /* binding */ EditorHooks; }
/* harmony export */ });
/* harmony import */ var _EditorHooksApi_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../EditorHooksApi.js */ "./EditorHooksApi.js");
/* harmony import */ var _EditorHooksApi_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_EditorHooksApi_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _objects_Tour_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../objects/Tour.js */ "./objects/Tour.js");
/* harmony import */ var _objects_View_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../objects/View.js */ "./objects/View.js");
/* harmony import */ var _controllers_StaticRenderViewer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/StaticRenderViewer.js */ "./src/controllers/StaticRenderViewer.js");
/* harmony import */ var _controllers_MinimapCreater_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../controllers/MinimapCreater.js */ "./src/controllers/MinimapCreater.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */







function makeNameFromType(type) {
    return type[0].toUpperCase() + type.slice(1)
}

function getID(a) {
    for (var b = 0, c = 0; c < a.length; c += 1) {
        a[c].id >= b && (b = a[c].id + 1);
    }
    return b
}

function exists(a, b) { // c
    for (var c = 0; c < a.length; c += 1) {
        if (a[c].name === b) {
            return !1;
        }
    }
    return !0
}

function createName(a, b) { //d
    for (var d = a, e = 2; !exists(b, d); e += 1) {
        d = a + e.toString();
    }
    return d
}

class EditorHooks extends JMT.EditorHooksApi {

    constructor(scene, ui, controls, teleport, editorSelector, extensionsManager, screenshotTaker, aniController) {
        // c, g, f, h, k, n, p, l
        super()
        this.scene = scene
        this.extensionsManager = extensionsManager
        this.screenshotTaker = screenshotTaker
        this.ui = ui
        this.controls = controls
        this.teleport = teleport
        this.editorSelector = editorSelector
        this.aniController = aniController

        this._sceneStats = {
            geometryFacesCnt: this.scene.nodes.reduce(function (a, b) {
                return a + b.facesInSubtree()
            }, 0)
        }

        function onerr() {
            WALK.USER_MSG.info("Failed to load texture")
        }

        this.m = new JMT.TextureLoader(
            "./",
            JMT.DETECTOR,
            function (a) {
                aniController.requestFrame()
            },
            onerr,
            onerr,
            !0
        )
        this.skyLoader = new JMT.SkyLoader(this.m) // u
        this.transformControls = this.editorSelector.transformControls;
    }

    getExtensionManager() {
        return this.extensionsManager
    }

    getCameraPosition() {
        var cameraPosition = this.controls.cameraWorldPosition();
        return [cameraPosition.x, cameraPosition.y, cameraPosition.z]
    }

    getCameraPositionV3() {
        return this.controls.cameraWorldPosition();
    }

    getCameraRotation() {
        return [
            THREE.Math.radToDeg(this.controls.getYawAngle()),
            THREE.Math.radToDeg(this.controls.getPitchAngle()),
            0
        ]
    }

    getCamera() {
        return this.scene.camera
    }

    setCamaraPositionRotationChangedCallback(callback) {
        this.scene.camera.addEventListener('rotationChanged', callback)
        this.scene.camera.addEventListener('positionChanged', callback)
    }

    getSceneStats() {
        return this._sceneStats
    }

    getSceneConfig() {
        return UjP.ui.cover
    }

    getMaterials() {
        return this.scene.sortedMaterials()
    }

    getLights() {
        return this.scene.lights
    }

    getLightProbes() {
        return this.scene.lightProbes
    }

    getCameraVolumes() {
        return this.scene.cameraVolumes
    }

    getNodes() {
        return this.scene.nodes
    }

    // 获取素材
    getAssets() {
        return UjP.assetsController.assets
    }

    ////////////////////////////////////////////////////////
    addLight(name, type, position) {
        let a = new JMT.Light({
            name: createName(name, this.scene.lights),
            type: type,
            doNotImport: !0
        });
        a.addInstance(position);
        this.scene.addLight(a)
        return a
    }

    removeLight(light) {
        this.scene.removeLight(light)
    }

    addLightInstance(light, position) {
        return light.addInstance(position)
    }

    removeLightInstance(light, instance) {
        light.removeInstance(instance)
    }

    addLightProbe(position) {
        var id = getID(this.scene.lightProbes);
        let a = new JMT.LightProbe({
            id: id,
            position: position
        });
        a.enableBoundingBox();
        this.scene.addLightProbe(a);
        if (1 === this.scene.lightProbes.length) {
            this.scene.enableLightProbesForMaterials()
        }
        return a
    }

    removeLightProbe(lightProbe) {
        this.scene.removeLightProbe(lightProbe);
        if (0 === this.scene.lightProbes.length) {
            this.scene.disableLightProbesForMaterials()
        }
    }

    getCameraVolumeTypes() {
        return JMT.CameraVolume.CameraVolumeTypes
    }

    addAuxiliaryObject(a, b) {
        this.scene.addAuxiliaryObject(a, b)
    }

    removeAuxiliaryObject(a) {
        this.scene.removeAuxiliaryObject(a)
    }

    addCameraVolume(type, name,assetType,pId) {
        var f = (new THREE.Vector3).fromArray(this.getCameraPosition())
        var g = this.getCameraRotation();
        g = (new THREE.Vector3(0, 3, 0)).applyEuler(new JMT.Euler(g[0] / 180 * Math.PI, g[1] / 180 * Math.PI, 0));
        var k = getID(this.scene.cameraVolumes);
        let cv = new JMT.CameraVolume({
            id: k,
            name: name || makeNameFromType(type) + k,
            type: type,
            position: f.add(g).toArray(),
            rotation: [0, 0, 0],
            scale: [1, 1, 1],
            exposure: this.scene.camera.defaultExposure,
            gamma: this.scene.camera.defaultGamma,
            assetType:assetType || 'camera',
            pId:pId||""
        })
        this.scene.addCameraVolume(cv)
        return cv
    }

    removeCameraVolume(cameraVolume) {
        this.scene.removeCameraVolume(cameraVolume)
    }

    shiftCameraVolume(cameraVolume, toIndex) {
        this.scene.shiftCameraVolume(cameraVolume, toIndex)
    }

    getViews() {
        return this.scene.views
        //.filter(function (a) {
        //    return !a.internal
        //})
    }

    markScreenshotArea(scale) {
        this.screenshotTaker.markArea(scale)
    }

    unmarkScreenshotArea() {
        this.screenshotTaker.unmarkArea()
    }

    screenToBuffer(isPano, width, height) {
        return this.screenshotTaker.screenToBuffer(isPano, width, height)
    }

    screenToDataUrl(isPano, width, height) {
        return this.screenshotTaker.screenToDataUrl(isPano, width, height)
    }

    coverToServer() {
        this.screenshotTaker.coverToServer(JMT.EDITOR_COVER_WIDTH, JMT.EDITOR_COVER_HEIGHT);
    }

    getSceneBBox() {
        return this.scene.boundingBox
    }

    switchToFirstTopView() {

        let topView = null
        this.getViews().some(view => {
            if (view.isTop()) {
                topView = view
                return true
            }
        })

        if (topView) {
            this.switchToView(topView)
            return true
        }

        return false
    }

    addViewFromCamera(name, mode) {

        var g = [];

        let f = this.controls,
            c = this.scene

        let e = mode,
            a = name

        console.assert("fps" === e || "top" === e || "orbit" === e);

        var k = f.cameraWorldPosition()
        var h = f.orbit;

        g[0] = THREE.Math.radToDeg(f.getYawAngle());
        g[1] = THREE.Math.radToDeg(f.getPitchAngle());

        a = {
            id: getID(c.views),
            name: createName(a.trim() || "view", c.views),
            rotation: g
        };

        "fps" === e ? (a.mode = "fps", a.sky = JMT.EDITOR_CONTROLLED_SKY_NAME, a.position = k.toArray()) : "top" === e ?
            (a.mode = "orbit", a.sky = JMT.DEFAULT_SKY_NAME, a.panPrimary = !0, a.noPitchRotate = !0, a.rotation[1] = -90, a.minUpAngle = 0, a.maxUpAngle = Math.PI / 2, h.isEnabled() ? (a.target = h.target.toArray(), a.distance = h.getCameraDistance()) : (a.target = [k.x, k.y, c.boundingBox.min.z], a.distance = Math.max(k.z - c.boundingBox.min.z, 1))) : (a.mode = "orbit", a.sky = JMT.DEFAULT_SKY_NAME, a.panPrimary = !1, a.noPitchRotate = !1, h.isEnabled() ? (a.target = h.target.toArray(), a.distance = h.getCameraDistance(), a.minUpAngle = -h.getMaxPitchAngle(), a.maxUpAngle = -h.getMinPitchAngle()) : (e = c.boundingBox.center(), a.target = e.toArray(), e.sub(k), a.distance = e.length(), e.normalize(), a.rotation = [THREE.Math.radToDeg(Math.atan2(-e.x, e.y)), THREE.Math.radToDeg(Math.asin(e.z))], a.minUpAngle = 0, a.maxUpAngle = Math.PI / 2));

        k = new _objects_View_js__WEBPACK_IMPORTED_MODULE_2__.View(a);

        c.addView(k);

        return k
    }

    resetViewFromCamera(view) {

        var b = this.controls.cameraWorldPosition();

        if ("fps" === view.mode) {

            view.position.copy(b)

        } else {

            view.target.copy(this.controls.orbit.target)

            view.distance = b.distanceTo(view.target)

        }

        if (!("fps" !== view.mode && view.isTop())) {

            view.rotation.pitch = this.controls.getPitchAngle()

        }

        view.setYaw(this.controls.getYawAngle())
    }

    removeView(view) {
        this.scene.removeView(view)
    }

    shiftView(view, index) {
        this.scene.shiftView(view, index)
    }

    activateSkyForView(sky) {
        this.teleport.activateSky(sky)
    }

    switchToView(view) {
        this.teleport.switchToView(view);
        $(UjP.config.el).focus()
    }

    renameView(view, name) {
        name = name.trim() || "view";
        view.name = "";
        view.setName(createName(name, this.scene.views))
    }

    updateHiddenMeshes(a) {
        this.teleport.updateHiddenMeshes(a)
    }

    getSky() {
        return this.scene.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME)
    }

    getSkys() {
        return this.scene.skyMeshes
    }

    loadTexture(url) {
        let texture = this.m.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, url, !0, !0, JMT.DEFAULT_ANISOTROPY);
        texture.fromEditor = !0;
        return texture
    }

    getStaticRenderViewer(dom) {

        return new _controllers_StaticRenderViewer_js__WEBPACK_IMPORTED_MODULE_3__.StaticRenderViewer(dom)

    }

    materialTextureUpdated(material, typeName) {

        var d = new Set

        var e = "";

        if (material.textureNeedsUv0(typeName)) {

            this.scene.visitMeshesWithMaterial(material, function (a) {

                if (!(0 === a.geometry.vertexCnt || a.uv0InBuffers() || d.has(a.node.type))) {

                    d.add(a.node.type)

                    if (!(5 < d.size)) {

                        if ("" !== e) {

                            e += ", "

                        }

                        e += "'" + a.node.type + "'"
                    }
                }

            });
        }
        return 0 < d.size && "Texture " + typeName + " won't be correctly mapped. The following objects lack base color UV mapping coming from the 3D modeling tool: " +
            e + (5 < d.size ? " (plus " + (d.size - 5) + " more)." : ".")
    }

    changeSkyTexture(url) {
        var b = this.scene.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME);

        if (b.isEquirect) {
            this.skyLoader.loadSkyTexture(b, url)
        } else {
            this.scene.removeSkyMesh(b)

            this.skyLoader.loadSingleSky({
                name: JMT.EDITOR_CONTROLLED_SKY_NAME,
                type: "equirect",
                texture: url
            }, this.scene)
        }
        this.scene.adjustSkiesAndCameraFarToSpanWholeScene()
    }

    removeSkyTexture() {
        var a = this.scene.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME);
        if (a.isEquirect) {

            this.scene.removeSkyMesh(a)

            this.skyLoader.loadSingleSky({
                    name: JMT.EDITOR_CONTROLLED_SKY_NAME,
                    type: "procedural"
                },
                this.scene)

        }
        this.scene.adjustSkiesAndCameraFarToSpanWholeScene()
    }

    getColorMapName() {
        return this.scene.camera.colorMap ? this.scene.camera.colorMap.name : null
    }

    loadColorMap(url) {
        let texture = this.m.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, url, !1, !1, JMT.NO_ANISOTROPY);
        texture.flipY = !1;
        return texture
    }

    getSceneJson() {
        return this.scene.serialize()
    }

    getCoverJson() {
        var a = this.ui.cover || {};
        a.extensions = this.extensionsManager.getConfig();
        return a
    }

    disableSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.OFF)
    }

    enableMaterialSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.MATERIAL)
    }

    enableLightSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.LIGHT)
    }

    enableLightProbeSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.LIGHT_PROBE)
    }

    enableExtensionSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.EXTENSION)
    }

    enablePositionSelection(distance) {
        this.editorSelector.setDistanceToObject(distance);
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.POSITION)
    }

    enableNodeSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.NODE)
    }

    enableCameraVolumeSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.CAMERA_VOLUME)
    }

    enableAssetSelection() {
        this.editorSelector.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.ASSET)
    }

    selectMaterial(material) {
        this.editorSelector.selectMaterial(material, !1)
    }

    replaceMaterial(material, typeOfMaterial) {
        var newMaterial = this.scene.replaceMaterial(material, typeOfMaterial);
        newMaterial.isAnimated && newMaterial.play();
        this.editorSelector.selectMaterial(newMaterial, !0);
        return newMaterial
    }

    selectLight(light) {
        this.editorSelector.selectLight(light)
    }

    selectLightInstance(lightInstance) {
        this.editorSelector.selectLightInstance(lightInstance, !1)
    }

    selectLightProbe(lightProbe) {
        this.editorSelector.selectLightProbe(lightProbe, !1)
    }

    selectCameraVolume(cameraVolume) {
        this.editorSelector.selectEditorCameraVolume(cameraVolume)
    }
    showCameraVolume(cameraVolume) {
        this.editorSelector.showEditorCameraVolume(cameraVolume)
    }
    selectExtension(extension) {
        this.editorSelector.selectExtension(extension, !1)
    }

    selectNodes(nodesPrimary, nodesSecondary) {
        this.editorSelector.selectNodes(nodesPrimary, nodesSecondary)
    }

    ////////////////////////////////////////////////////
    // 素材
    addAsset(config) {
        return new Promise(resolve => {

            UjP.addEventListener('assetAdded', resolve)

            UjP.assetsController.addAssetWithConfig(config, resolve)

        })
    }

    getAssets() {
        return UjP.assetsController.assets
    }

    removeAsset(asset) {
        UjP.assetsController.removeAsset(asset)
    }

    selectAsset(asset) {
        UjP.assetsController.selectedAsset = asset
    }

    loadAssets(config) {
        UjP.assetsController.deserialize(config)
    }

    getAssetsJson() {
        return UjP.assetsController.serialize()
    }

    ////////////////////////////////////////////////////////////////////
    // 动画

    // 添加动画
    addAnimation(asset) {

        let animation = UjP.animationsController.findAnimation(asset.uuid)

        if (!animation) {

            animation = UjP.animationsController.createAnimation(asset)

        }

        return animation

    }

    // 获取全部动画
    getAnimations() {

        UjP.animationsController.getAnimations()

    }

    // 移除动画
    removeAnimation(animation) {

        UjP.animationsController.removeAnimation(animation)

    }


    // 获取动画
    getAnimation(asset) {

        return UjP.animationsController.findAnimation(asset.uuid)

    }

    // 加载全部动画
    loadAnimations(json) {

        return UjP.animationsController.deserialize(json)

    }

    // 获取全部动画JSON
    getAnimationsJson() {

        return UjP.animationsController.serialize()

    }

    // 设置动画属性改变回调
    setAnimationUpdateCallback(callback) {

        if (callback) {

            UjP.animationsController.removeEventListener('channelUpdate', callback, !1)
            UjP.animationsController.addEventListener('channelUpdate', callback)

        }
    }

    // 动画跳转
    animationJumpTo(asset, time) {

        UjP.animationsController.jumpTo(asset, time)
    }

    // 动画播放
    animationPlay(asset, loop = 2200, repetitions = Infinity) {

        UjP.animationsController.play(asset, loop, repetitions)

    }

    // 动画停止
    animationStop(asset) {
        UjP.animationsController.stop(asset)
    }

    // 设置动画播放时回调
    setAnimationPlayCallback(callback) {

        if (callback) {

            //UjP.animationsController.mixer.removeEventListener('updated', callback, !1)
            //UjP.animationsController.mixer.addEventListener('updated', callback)

            UjP.animationsController.onUpdated = callback
        }
    }

    // 设置动画播放结束回调
    setAnimationFinishedCallback(callback) {
        if (callback) {

            UjP.animationsController.onFinished = callback

        }
    }

    // 设置动画播放单次循环结束回调
    setAnimationLoopEndCallback(callback) {
        if (callback) {

            UjP.animationsController.onLoop = callback

        }
    }

    ////////////////////////////////////////////////////////////////////
    //

    setUpdateCallback(updateCallback) {
        updateCallback && UjP.addEventListener('update', updateCallback)
    }

    setMaterialSelectedCallback(callback) {
        this.editorSelector.setMaterialSelectedCallback(callback)
    }

    setLightInstanceSelectedCallback(a) {
        this.editorSelector.setLightInstanceSelectedCallback(a)
    }

    setLightProbeSelectedCallback(a) {
        this.editorSelector.setLightProbeSelectedCallback(a)
    }

    setNodeSelectedCallback(a) {
        this.editorSelector.setNodeSelectedCallback(a)
    }

    setExtensionSelectedCallback(a) {
        this.editorSelector.setExtensionSelectedCallback(a)
    }

    setPositionSelectedCallback(a) {
        this.editorSelector.setPositionSelectedCallback(a)
    }

    setItemModifiedCallback(a) {
        this.transformControls.setItemModifiedCallback(a);
    }

    setViewSelectedCallback(a) {
        this.teleport.addEventListener("teleportStarted", function (b) {
            null !== b.view && a(b.view)
        })
    }

    setSceneChangedCallback(callback) {
        this.scene.addEventListener("sceneChanged", callback)
    }

    setAssetSelectCallback(callback) {
        function onassetClick(event) {
            callback && callback(event.asset)
        }

        UjP.viewer.addEventListener('assetClick', onassetClick)
    }

    setAssetsLoadedCallback(callback) {
        UjP.assetsController.addEventListener('assetsLoaded', callback)
    }

    setAssetUpdatedCallback(callback) {
        UjP.assetsController.addEventListener('assetUpdated', callback)
    }

    coverModified(cover) {
        this.ui.updateCover(cover)
    }

    autoTourModified() {
        this.ui.refresh()
    }

    hasLightMap() {
        return this.scene.hasLightMap()
    }

    getSceneMiniMap(width, height) {
        return new _controllers_MinimapCreater_js__WEBPACK_IMPORTED_MODULE_4__.MinimapCreater(UjP.viewer).generate(width, height)
    }

    /////////////////////////////////////////////////////////
    //
    getAutoTour() {
        return UjP.autoTour //this.scene.autoTour
    }

    getTours() {
        return this.scene.tours
    }

    removeTour(tour) {
        this.scene.removeTour(tour)
    }

    addTour(config) {

        let tour = new _objects_Tour_js__WEBPACK_IMPORTED_MODULE_1__.Tour(config)
        this.scene.addTour(tour)
        return tour
    }

    selectTour(tourId) {
        this.scene.findTour(tourId)
    }

    addTourView(tour, viewId) {

    }

    removeTourView(tour, viewId) {

    }

    loadViewsAndTours(config) {

        let scene = this.scene
        if (scene != null) {
            let views = config.views || []
            let tours = config.tours || []
    
            views.forEach(function (view) {
                scene.addView(new _objects_View_js__WEBPACK_IMPORTED_MODULE_2__.View(view))
            })
    
            tours.forEach(function(tour){
                scene.addTour(new _objects_Tour_js__WEBPACK_IMPORTED_MODULE_1__.Tour(tour))
            })
        }
    }

    ////////////////////////////////////////////////////////
    //
    getDisableProgressiveLoader() {
        return this.scene.disableProgressiveLoader
    }

    setDisableProgressiveLoader(loader) {
        this.scene.disableProgressiveLoader = loader
    }

    getSceneScaleHtmlWarning() {
        var a = this.scene.boundingBox;
        if (!a.empty()) {
            a = a.size()
            if (200 < a.x || 200 < a.y || 200 < a.z) {
                return "The scene has unusually large dimensions: <strong>" + Math.round(a.x) + "m x " + Math.round(a.y) + "m x " + Math.round(a.z) + 'm</strong>.</br></br>We assumes real-world scale, 1 meter in the scene should correspond to 1 meter in the real world. If the scale of the scene is invalid, either re-scale the model or change the scale in the import dialog, otherwise you can disable this message.</br></br>For more information consult <a href="/assets/help.html#importing-the-scene">Importing the scene</a> section of the help.'
            }
        }
        return null
    }

    getTransformMode() {
        return this.transformControls.mode
    }

    setTransformMode(mode) {
        this.transformControls.setTransformMode(mode)
    }

    getSupportedTransformModes() {
        return this.transformControls.supportedModes
    }

    seeItem(object) {
        JMT.getViewer().seeItem(object)
    }
}


JMT.EditorHooks = EditorHooks

/***/ }),

/***/ "./src/editor/EditorSelector.js":
/*!**************************************!*\
  !*** ./src/editor/EditorSelector.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EditorSelector": function() { return /* binding */ EditorSelector; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

//import '../controllers/TransformControls.js'

var Selection = function (a, c) {
    this._nodesPrimary = a;
    this._nodesSecondary = c
};

Selection.prototype.constructor = Selection;

Object.defineProperty(Selection.prototype, "highlightMix", {
    set: function (a) {
        this._nodesPrimary.forEach(function (b) {
            b.highlightMix = a
        });
        this._nodesSecondary.forEach(function (b) {
            b.highlightMix = a
        })
    }
});

Object.defineProperty(Selection.prototype, "selected", {
    set: function (a) {
        this._nodesPrimary.forEach(function (b) {
            b.selected = a
        });
        this._nodesSecondary.forEach(function (b) {
            b.selectedSecondary = a
        })
    }
});


function DEFAULT_CALLBACK() {
}

class EditorSelector {
    constructor(pointerEventDispatcher, scene, renderer, collider, lightControls, lightProbeControls, cameraVolumeControls, aniController, controls) {
        // b, c, d, e, g, f, h, k, n
        this.aniController = aniController
        this.lightControls = lightControls
        this.lightProbeControls = lightProbeControls
        this.scene = scene
        this.cameraVolumeControls = cameraVolumeControls
        this.collider = collider
        this.renderer = renderer

        this._selected = null
        this._curTimeSec = 0    // w
        this._selection = null
        this._distance = 0
        this.y = new JMT.RayIntersection

        this._transformControls = new JMT.j3dTransformControls(pointerEventDispatcher, aniController, scene, collider, controls) 

        this.evetHandlers = {
            materialSelected: DEFAULT_CALLBACK,
            lightInstanceSelected: DEFAULT_CALLBACK,
            lightProbeSelected: DEFAULT_CALLBACK,
            nodeSelected: DEFAULT_CALLBACK,
            extensionSelected: DEFAULT_CALLBACK,
            positionSelected: DEFAULT_CALLBACK
        }

        this.autoClearAlter = new JMT.AutoClearAlter(renderer)      //O

        this.clearColorAlter = new JMT.ClearColorAlter(renderer)    //K

        this._clearColor = new THREE.Color(16777215)

        this.wireframeMaterial = new JMT.j3dWireframeMaterial(new THREE.Color(0)); // Y

        this.wireframeMaterial.highlight = this.wireframeMaterial.meshSelectedLineColor;

        this.selectionTimeSec = 1;

        this.initPointerEventHelper(pointerEventDispatcher)

        Object.defineProperty(this, "transformControls", {
            get: function () {
                return this._transformControls
            }
        });

        this._invisibleMeshes = [];

        this.setSelectionMode(JMT.EditorSelector.SELECTION_MODE.OFF)
    }

    initPointerEventHelper(pointerEventDispatcher) {

        var a = new JMT.PointerEventHelper(pointerEventDispatcher, JMT.POINTER_PRIORITY.EDITOR_SELECTOR);

        let t = this

        t.selectionMode = null;

        a.callbacks.onClick = function (a, b) {

            if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.OFF) {

                return !1;

            }

            var c = !1;

            if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.MATERIAL) {

                a = t.collider.findObstacleMeshAtPosition(a, b)

                a = null !== a ? a.material : null

                t.selectMaterial(a, !0)
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.LIGHT) {

                //a = t.collider.findMeshFromListAtPosition(t.lightControls.lightInstanceMeshes, a, b)
                a = (t.collider.findMeshFromListRayCast != undefined) ?
                t.collider.findMeshFromListRayCast(t.lightControls.lightInstanceMeshes, a, b)
                 : t.collider.findMeshFromListAtPosition(t.lightControls.lightInstanceMeshes, a, b)

                a = null !== a ? a.userData.lightInstance : null

                null !== a && t.selectLightInstance(a, !0)
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.LIGHT_PROBE) {

                a = t.collider.findMeshFromListAtPosition(t.lightProbeControls.lightProbeMeshes, a, b)

                a = null !== a ? a.lightProbe : null

                null !== a && t.selectLightProbe(a, !0)
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.NODE) {

                a = t.collider.findObstacleMeshAtPosition(a, b)

                a = null !== a ? a.node : null

                t._selectNode(a)
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.EXTENSION) {

                a = t.collider.findIntersectionAtPosition(a, b, !1, t.y) ? t.y.object.anchor || null : null

                t.selectExtension(a ? a.extension : null, !0)
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.POSITION) {

                if(t.collider.findIntersectionAtPosition(a, b, !1, t.y) && !t.y.object.anchor){

                    a = t.collider.movePointTowardsTheCamera(t.y.point, this._distance)

                }
                else {

                    a = null

                }

                if (a) {

                    t.evetHandlers.positionSelected(a)

                    c = !0
                }
            }
            else if (t.selectionMode === JMT.EditorSelector.SELECTION_MODE.ASSET) {

            }

            return c
        };

        a.callbacks.onDoubleClick = function (a, b) {
            return !1
        }
    }


    _highlightSelected() {
        this._selected.highlightMix = .8 * Math.pow(this._curTimeSec / this.selectionTimeSec, 2)
    }

    highlight(a) {  // q

        if(null !== this._selected){

            this._selected.highlightMix = 0
        }

        if (null !== a) {

            this._selected = a

            this._curTimeSec = this.selectionTimeSec

            this._highlightSelected()

        }

        this.aniController.requestFrame()

    }

    _setInvisible(a) {  // r
        var b = a.geometry;

        if (b && void 0 === b.getAttribute("order") && a.visible) {

            a.visible = !1

            this._invisibleMeshes.push(a)

        }
    }

    _setVisible() { // m
        var a = $jscomp.makeIterator(this._invisibleMeshes)

        for (var b = a.next(); !b.done; b = a.next()) {

            b.value.visible = !0

        }
    }

    _setToWireframe() { // u

        this.autoClearAlter.set(!0, !1, !1);

        this.clearColorAlter.set(this._clearColor);

        let t = this

        this.scene.gpuMeshes.forEach(function (a) {

            a.geometry.addTriangleOrderAttribute();

            a.highlightMix = 0;

            a.selected = !1;

            t.renderer.uploadNewBuffers && t.renderer.uploadNewBuffers(a)

        });

        this._invisibleMeshes.length = 0;

        this.scene.threeScene.traverse(this._setInvisible.bind(this));

        this.scene.threeScene.overrideMaterial = this.wireframeMaterial;

        this.scene.skyMeshes.forEach(function (a) {

            a.visible = !1

        })
    }

    _setToOrigin() {

        this.autoClearAlter.restore();

        this.clearColorAlter.restore();

        this._setVisible();

        this.scene.threeScene.overrideMaterial = null;

        this.scene.gpuMeshes.forEach(function (a) {

            a.highlightMix = null;

            a.selected = null;

            a.selectedSecondary = !1

        });

        this._selection = null;

        this.scene.skyMeshes.forEach(function (a) {

            a.visible = !0

        })
    }

    selectMaterial(a, b) {

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.MATERIAL);

        this.highlight(a);

        null !== a && b && this.evetHandlers.materialSelected(a)
    }

    selectLight(a) {

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.LIGHT);

        this.lightControls.showSelectionMesh(a);

        this.aniController.requestFrame()
    }

    selectLightInstance(a, b) {

        var c = null;

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.LIGHT);

        if (a) {

            c = this.lightControls.getLightInstanceMaterial(a);

            var d = a.light.type;

            var value

            if ("point" === d) {
                value = [JMT.TRANSFORM_MODE.TRANSLATE]
            }
            else if ("sun" === d) {
                value = [JMT.TRANSFORM_MODE.ROTATE]
            }
            else {
                value = [JMT.TRANSFORM_MODE.TRANSLATE, JMT.TRANSFORM_MODE.ROTATE]
            }

            this._transformControls && this._transformControls.enable(a, value)

        }
        else {

            this._transformControls && this._transformControls.disable();

        }

        this.highlight(c);

        if (a && b) {

            this.evetHandlers.lightInstanceSelected(a)

        }
    }

    selectLightProbe(a, b) {
        var c = null;

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.LIGHT_PROBE);

        if (a) {

            this.lightProbeControls.showLightProbeBoundingBox(a)

            c = this.lightProbeControls.getLightProbeMaterial(a)

            this._transformControls.enable(a, [JMT.TRANSFORM_MODE.TRANSLATE])

        }
        else {

            this._transformControls && this._transformControls.disable();

        }

        this.highlight(c);

        if (a && b) {

            this.evetHandlers.lightProbeSelected(a)

        }
    }

    selectEditorCameraVolume(a) {

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.CAMERA_VOLUME);

        if (a) {
            if(a.assetType === "camera"){
                this.highlight(this.cameraVolumeControls.setHighlightedCameraVolume(a))
            }    
            this._transformControls.enable(a, [
                JMT.TRANSFORM_MODE.TRANSLATE,
                JMT.TRANSFORM_MODE.ROTATE,
                JMT.TRANSFORM_MODE.SCALE
            ])
        }
        else {
            this.highlight(null)
            this._transformControls.disable()
        }
    }

    showEditorCameraVolume(arr) {
        this.cameraVolumeControls.showCameraVolume(arr)
    }

    selectExtension(a, b) {
        var c = null;

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.EXTENSION);

        if (a && 0 < a.triggers.length) {

            var d = a.triggers[0].mesh;

            d && (c = this.renderer.material)
        }

        this.highlight(c);

        if (a && b) {
            this.evetHandlers.extensionSelected(a)
        }
    }

    selectNodes(nodesPrimary, nodesSecondary) {

        console.assert(this.selectionMode === JMT.EditorSelector.SELECTION_MODE.NODE);

        if (this._selection) {

            this._selection.selected = !1

        }

        if (nodesPrimary.length || this.scene.length) {

            this._selection = new Selection(nodesPrimary, nodesSecondary)

            this._selection.selected = !0

        }
        else {
            this._selection = null;
        }

        this.highlight(this._selection)
    }

    _selectNode(node) {

        if (null !== node) {

            this.selectNodes([node], [])

        }
        else {

            this.selectNodes([], []);

        }

        node && this.evetHandlers.nodeSelected(node)
    }

    update(a) {
        this._transformControls && this._transformControls.update();

        if (null !== this._selected) {

            this._curTimeSec -= a

            if (0 < this._curTimeSec) {
                this._highlightSelected()
            }
            else {
                this._selected.highlightMix = 0

                this._selected = null
            }

            this.aniController.requestFrame()
        }
    }

    setDistanceToObject(distance = 0) {
        this._distance = distance
    }

    setSelectionMode(mode) {
        if (mode !== this.selectionMode) {

            if (this.selectionMode === JMT.EditorSelector.SELECTION_MODE.NODE) {

                this._setToOrigin();

            }

            switch (mode) {
                case JMT.EditorSelector.SELECTION_MODE.OFF:
                case JMT.EditorSelector.SELECTION_MODE.MATERIAL:
                case JMT.EditorSelector.SELECTION_MODE.EXTENSION:
                case JMT.EditorSelector.SELECTION_MODE.POSITION:
                case JMT.EditorSelector.SELECTION_MODE.CAMERA_VOLUME:
                case JMT.EditorSelector.SELECTION_MODE.ASSET:
                    this.lightControls.hideLights();
                    this.lightProbeControls.hideLightProbes();
                    break;
                case JMT.EditorSelector.SELECTION_MODE.LIGHT:
                    this.lightControls.showLights();
                    this.lightProbeControls.hideLightProbes();
                    break;
                case JMT.EditorSelector.SELECTION_MODE.LIGHT_PROBE:
                    this.lightControls.hideLights();
                    this.lightProbeControls.showLightProbes();
                    break;
                case JMT.EditorSelector.SELECTION_MODE.NODE:
                    this.lightControls.hideLights()
                    this.lightProbeControls.hideLightProbes()
                    this._setToWireframe()
                    break;
            }

            if(UjP.assetsController){
                if(mode === JMT.EditorSelector.SELECTION_MODE.ASSET){
                    UjP.assetsController.enableSelection()
                }
                else {
                    UjP.assetsController.disableSelection()
                }
            }

            this.cameraVolumeControls.setControlsVisible(!1);
            if (mode === JMT.EditorSelector.SELECTION_MODE.CAMERA_VOLUME) {

                this.cameraVolumeControls.setControlsVisible(!0);

            }

            this._transformControls && this._transformControls.disable();

            if (mode === JMT.EditorSelector.SELECTION_MODE.MATERIAL) {
                var b = $jscomp.makeIterator(this.scene.getAnimatedMaterials())
                for (var d = b.next(); !d.done; d = b.next()) {
                    d.value.play();
                }
            }
            else {
                var b = $jscomp.makeIterator(this.scene.getAnimatedMaterials())

                for (var d = b.next(); !d.done; d = b.next()) {
                    d.value.pause();
                }
            }
            this.selectionMode = mode
        }
    }

    setMaterialSelectedCallback(callback) {
        console.assert(this.evetHandlers.materialSelected === DEFAULT_CALLBACK);
        this.evetHandlers.materialSelected = callback
    }

    setLightInstanceSelectedCallback(callback) {
        console.assert(this.evetHandlers.lightInstanceSelected === DEFAULT_CALLBACK);
        this.evetHandlers.lightInstanceSelected = callback
    }

    setLightProbeSelectedCallback(callback) {
        console.assert(this.evetHandlers.lightProbeSelected === DEFAULT_CALLBACK);
        this.evetHandlers.lightProbeSelected = callback
    }

    setNodeSelectedCallback(callback) {
        console.assert(this.evetHandlers.nodeSelected === DEFAULT_CALLBACK);
        this.evetHandlers.nodeSelected = callback
    }

    setExtensionSelectedCallback(callback) {
        console.assert(this.evetHandlers.extensionSelected === DEFAULT_CALLBACK);
        this.evetHandlers.extensionSelected = callback
    }

    setPositionSelectedCallback(callback) {
        console.assert(this.evetHandlers.positionSelected === DEFAULT_CALLBACK);
        this.evetHandlers.positionSelected = callback
    }
}


EditorSelector.SELECTION_MODE = {
    OFF: 0,
    MATERIAL: 1,
    LIGHT: 2,
    LIGHT_PROBE: 3,
    NODE: 4,
    EXTENSION: 6,
    POSITION: 7,
    CAMERA_VOLUME: 8,
    ASSET: 9
}

JMT.EditorSelector = EditorSelector

/***/ }),

/***/ "./src/extend/controllers/THREE.j3dTransformControls.js":
/*!**************************************************************!*\
  !*** ./src/extend/controllers/THREE.j3dTransformControls.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_j3dRotateGizmoMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../material/j3dRotateGizmoMaterial.js */ "./src/extend/material/j3dRotateGizmoMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */



(function () {  // THREE.TransformControls
    function a(a) {
        var b = new THREE.Box3;
        a instanceof THREE.Object3D && a.traverse(function (a) {
            a instanceof THREE.Mesh && (a.geometry.boundingBox || a.geometry.computeBoundingBox(), b.union(a.geometry.boundingBox))
        });
        return b
    }

    function b(b, c) {
        var d = a(b);
        let size = new THREE.Vector3()
        d.getSize(size);
        b = new THREE.BoxBufferGeometry(size.x, size.y, size.z);
        d.getCenter(size);
        d = size
        var e = new THREE.Matrix4;
        e.makeTranslation(d.x, d.y, d.z);
        b.applyMatrix4(e);
        b.computeBoundingBox();
        c = new THREE.Mesh(b, c);
        c.visible = !1;
        c.visibilityId = null;

        c.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{

            //强制刷新uniforms
            material.refreshPerObjectUniforms && material.refreshPerObjectUniforms(c, material.uniforms)
            material.uniformsNeedUpdate = true        

        }

        return c
    }

    function c(color, opacity) {  // axis material
        
        var material = new THREE.MeshBasicMaterial()
        // material.hideFromLightProbes = !0;
        material.color.copy(color)
        material.opacity = opacity;
        //material.specularOff = 1;
        material.depthTest = false;
        material.depthWrite = false;
        material.configureTransparency()

       return material
    }

    
    //封装交互的工具、如平移工具的坐标轴等；包含了它的碰撞体
    //d
    function createTransformToolObject(a) {
        for (var d = [], e = 0; e < arguments.length; ++e)d[e - 0] = arguments[e];
        console.assert(0 < d.length, "Part must have at least one element!");
        var f = new THREE.Object3D;
        d.forEach(function (a) {
            return f.add(a)
        });
        d = b(f, c(g, .6));
        return new q(f, d, f.children[0].material)
    }
    var d = createTransformToolObject

    function e(a, b, c) {
        var d = a.material;
        d.opacity = b === a.collider ? a.hoveredOpacity : c && null !== b ? a.notUsedOpacity : a.defaultOpacity;
        d.setUniforms&&d.setUniforms()
    }

    JMT.TRANSFORM_MODE = {TRANSLATE: 0, ROTATE: 1, SCALE: 2};
    var g = new THREE.Color(16777215)
    var f = new THREE.Color(16711680)
    var h = new THREE.Color(65280)
    var k = new THREE.Color(255)
    var n = new THREE.Vector3(0, 0, 1)
    var p = new THREE.Vector3(1, 0, 0)
    var l = new THREE.Vector3(0, 1, 0)

     //test instances buffer
     var t0 = new THREE.InstancedBufferAttribute(new Float32Array([1, 0, 0, 0]), 4);
     var t1 = new THREE.InstancedBufferAttribute(new Float32Array([0, 1, 0, 0]), 4);
     var t2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1, 0]), 4);
 
     //uv2Mod
     var uv = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
     var uv2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
     var uv2Mod = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1 / 65535, 1 / 65535]), 4);
  
    class q extends THREE.Object3D {

        constructor (a, b, c) {
            super();
            
            this.add(a);
            this.add(b);
            this.material = c;
            this.collider = b;
            this.defaultOpacity = c.opacity;
            this.hoveredOpacity = .99;
            this.notUsedOpacity = .3;
            this.usedAxes = 0

            this.collider.forcePick = true;
            if (!this.collider.geometry.boundingSphere)
                this.collider.geometry.computeBoundingSphere()

            if (!this.collider.geometry.attributes.t0){
                
                this.collider.geometry.setAttribute("t0", t0)
                this.collider.geometry.setAttribute("t1", t1)
                this.collider.geometry.setAttribute("t2", t2)
    
                this.collider.geometry.setAttribute("uv", uv)
                this.collider.geometry.setAttribute("uv2", uv2)
                this.collider.geometry.setAttribute("uv2Mod", uv2Mod)
            }
        }
    };
  
    //var r = function () {
    class r extends THREE.Object3D {
        constructor () {
            super()

            function a(a) {
                a = c(a, .6);
                a.depthTest = !0;
                return new THREE.Mesh(b, a)
            }

            var b = new THREE.CylinderBufferGeometry(.005, .005, 1E3, 4, 1, !1), d = a(f);
            d.rotation.set(0, 0, Math.PI / 2);
            var e = a(h), g = a(k);
            g.rotation.set(Math.PI / 2, 0, 0);
            this.add(d);
            this.add(e);
            this.add(g);

            var m = [!1, !1, !1];

            this.show = function (a) {
                m[0] = 1 === (1 & a);
                m[1] = 2 === (2 & a);
                m[2] = 4 === (4 & a);
                d.visible = m[0];
                e.visible = m[1];
                g.visible = m[2]
            };

            var q = new THREE.Vector3;
            this.update = function (a) {
                q.copy(a);
                q.sub(this.position);
                q.normalize();
                d.visible = m[0] && .998 > Math.abs(p.dot(q));
                e.visible = m[1] && .998 > Math.abs(l.dot(q));
                g.visible = m[2] && .998 > Math.abs(n.dot(q))
            }
        }
        
        //THREE.Object3D.call(this);
        
        
       
    };
    
    //var m = function () {
    class m extends THREE.Object3D {
        constructor() {
            super()

            function a() {
                var a = c(g, .99);
                return new THREE.Mesh(b, a)
            }

            var b = new THREE.SphereBufferGeometry(.012, 10, 10), d = a(), e = a(), f = a();
            this.add(d);
            this.add(e);
            this.add(f);
            this.show = function (a) {
                d.visible = 1 === (1 & a);
                e.visible = 2 === (2 & a);
                f.visible = 4 === (4 & a)
            };
            this.update = function (a) {
                d.position.set(a.x, 0, 0);
                d.updateMatrixWorld();
                e.position.set(0, a.y, 0);
                e.updateMatrixWorld();
                f.position.set(0, 0, a.z);
                f.updateMatrixWorld()
            }
        }
      
    };
    
    //var u = function () {
    class u extends THREE.Object3D {
        constructor () {
            super()

            function a(a) {
                a = c(a, .2);
                a.depthTest = !0;
                a.side = THREE.DoubleSide;
                //return d(new THREE.Mesh(b, a))
                return createTransformToolObject(new THREE.Mesh(b, a))
                
            }
    
            //THREE.Object3D.call(this);
            var b = new THREE.PlaneBufferGeometry(1E3, 1E3, 1, 1), e = a(g);
            this.add(e);
            var m = new THREE.Object3D;
            this.add(m);
            var l = a(k);
            l.rotation.set(0, 0,
                0);
            var q = a(h);
            q.rotation.set(Math.PI / 2, 0, 0);
            var r = a(f);
            r.rotation.set(0, Math.PI / 2, 0);
            m.add(l);
            m.add(q);
            m.add(r);
            this.setLocalRotation = function (a) {
                a ? m.rotation.copy(a) : m.rotation.set(0, 0, 0)
            };
            this.update = function (a) {
                e.rotation.setFromRotationMatrix(a.matrixWorld);
                e.updateMatrixWorld()
            };
            this.cameraPlane = e;
            this.findPlaneIntersectionPoint = function () {
                function a(a) {
                    switch (a) {
                        case 1:
                            return r;
                        case 2:
                            return q;
                        case 4:
                            return l;
                        case 3:
                            return l;
                        case 5:
                            return q;
                        case 6:
                            return r;
                        case 7:
                            return e;
                        default:
                            throw"Impossible";
                    }
                }
    
                var b = new THREE.Vector3, c = new THREE.Vector3;
                return function (d, e, f, g) {
                    var k = a(d);
                    k.getWorldPosition(b).sub(e);
                    k.getWorldDirection(c);
                    if (1 === d || 2 === d || 4 === d) {
                        d = c.dot(c);
                        k = c.dot(f);
                        var m = f.dot(f), h = c.dot(b), l = f.dot(b);
                        m = d * m - k * k;
                        d = 1E-5 > Math.abs(m) ? Infinity : (d * l - k * h) / m
                    } else d = c.dot(f), d = 1E-5 > Math.abs(d) ? Infinity : c.dot(b) / d;
                    if (Infinity === d)return !1;
                    g.copy(f).multiplyScalar(d).add(e);
                    return !0
                }
            }();
            this.show = function (a) {
                e.visible = 7 === a ? !0 : !1;
                l.visible = 3 === a;
                q.visible = 5 === a;
                r.visible = 6 === a
            }
        }
       
       
    };
    
    //translate
    //var x = function () {
    class TranslateToolObjects extends THREE.Object3D {
        constructor () {
            super()

            function a(a) {
                for (var b = new Uint8Array(4096), c = Math.floor(255 * a.r), e = Math.floor(255 * a.g), f = Math.floor(255 * a.b), g = 0, k = 0; 32 > k; k++)for (var m = 0; 32 > m; m++)b[g] = c, b[g + 1] = e, b[g + 2] = f, b[g + 3] = 0 === k || 0 === m || 31 === k || 31 === m ? 220 : 150, g += 4;
                b = new THREE.DataTexture(b, 32, 32, THREE.RGBAFormat);
                b.hasAlpha = true;
                b.needsUpdate = !0;
                b.loaded = !0;

                c = new THREE.MeshBasicMaterial();
                c.hideFromLightProbes = !0;
                c.specularOff = 1;
                c.disableLightProbe = !0;
                c.depthTest = !1;
                c.depthWrite = !1;
                c.transparent = !0;
                c.color = a;
                c.side = THREE.DoubleSide;
                c.map = b;
                c.opacity = .6;
                c.configureTransparency && c.configureTransparency();
                c.setUniforms&&c.setUniforms();
                return createTransformToolObject(new THREE.Mesh(l.squareGeometry, c))
            }
    
            function b(a) {
                a = c(a, .6);
                //return d(new THREE.Mesh(l.lineGeometry, a), new THREE.Mesh(l.arrowHeadGeometry, a))
                return createTransformToolObject(new THREE.Mesh(l.lineGeometry, a), new THREE.Mesh(l.arrowHeadGeometry, a))
            }
    
            var m = this;
            //THREE.Object3D.call(this);

            var l = function () {
                var a = new THREE.Matrix4, b = new THREE.SphereBufferGeometry(.1, 16, 16), c = new THREE.PlaneBufferGeometry(.23, .23, 1, 1);
                a.makeTranslation(.45, .45, 0);
                c.applyMatrix4(a);
                c.addTriangleOrderAttribute();
                var d = new THREE.CylinderBufferGeometry(.015, .015, 1, 4, 1, !1);
                a.makeTranslation(0, .65, 0);
                d.applyMatrix4(a);
                var e = new THREE.CylinderBufferGeometry(0, .05, .2, 10, 1, !1);
                a.makeTranslation(0, 1.25, 0);
                e.applyMatrix4(a);
                return {pickerGeometry: b, squareGeometry: c, lineGeometry: d, arrowHeadGeometry: e}
            }(), 
            q = function () {
                var a = c(g, .6);
                //return d(new THREE.Mesh(l.pickerGeometry, a))
                return createTransformToolObject(new THREE.Mesh(l.pickerGeometry, a))
            }(), 
            r = b(f);
            r.rotation.set(0, 0, -Math.PI / 2);
            var n = b(h), p = b(k);
            p.rotation.set(Math.PI / 2, 0, 0);
            var u = a(k), t = a(h);
            t.rotation.set(Math.PI /
                2, 0, 0);
            var x = a(f);
            x.rotation.set(0, -Math.PI / 2, 0);
            q.usedAxes = 7;
            r.usedAxes = 1;
            n.usedAxes = 2;
            p.usedAxes = 4;
            u.usedAxes = 3;
            t.usedAxes = 5;
            x.usedAxes = 6;
            var v = [q, r, n, p, u, t, x];
            v.forEach(function (a) {
                return m.add(a)
            });
            var B = new Map(v.map(function (a) {
                return [a.collider, a]
            }));
            this.colliders = [].concat($jscomp.arrayFromIterable(B.keys()));
            this.highlight = function (a, b) {
                v.forEach(function (c) {
                    return e(c, a, b)
                })
            };
            this.usedAxes = function (a) {
                return B.get(a).usedAxes
            }
        }
        
        
    };
    

    //rotate
    //var t = function () {
    class t extends THREE.Object3D {
        constructor() {
            super();
            function a(a) {
                var b = new THREE.TorusBufferGeometry(a, .012, 6, 64);
                a = new THREE.TorusBufferGeometry(a, .038, 6, 64);
                return {torusGeometry: b, colliderGeometry: a}
            }
    
            function b(a, b) {
                a = new JMT.j3dRotateGizmoMaterial(a, .6);
                var c = new THREE.Object3D;
                c.add(new THREE.Mesh(b.torusGeometry, a));
                b = new THREE.Mesh(b.colliderGeometry, a);
                b.visible = !1;
                b.visibilityId = null;

                b.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{

                    //强制刷新uniforms
                    material.refreshPerObjectUniforms && material.refreshPerObjectUniforms(b, material.uniforms)
                    material.uniformsNeedUpdate = true        
        
                }
                return new q(c, b, a)
            }
    
            var d = this;
            //THREE.Object3D.call(this);

            var m = a(.9), l = b(f, m);
            l.rotation.set(0, Math.PI / 2, 0);
            var r = b(h, m);
            r.rotation.set(Math.PI / 2, 0, 0);
            m = b(k, m);
            var n = a(1.12), 
            p = b(g, n), 
            u = function (a, b) {
                a = c(a, 0);
                var d = new THREE.SphereBufferGeometry(b, 32, 32);
                b = new THREE.Object3D;
                b.add(new THREE.Mesh(d, a));
                d = new THREE.Mesh(d, a);
                d.visible = !1;
                d.visibilityId = null;
                a = new q(b, d, a);
                a.defaultOpacity = 0;
                a.hoveredOpacity = .2;
                a.notUsedOpacity = 0;
                return a
            }(g, .848), 
            t = [l, r, m, p, u];
            t.forEach(function (a) {
                return d.add(a)
            });
            var x = new Map(t.map(function (a) {
                return [a.collider, a]
            }));
            this.colliders = [].concat($jscomp.arrayFromIterable(x.keys()));
            this.update = function (a) {
                var b =
                    this;
                t.filter(function (a) {
                    return a !== u
                }).forEach(function (a) {
                    a = a.material;
                    a.gizmoPosition.copy(b.position);
                    a.sphereRadius = .86 * b.scale.x
                });
                p.rotation.setFromRotationMatrix(a.matrixWorld);
                p.updateMatrixWorld()
            };
            l.usedAxes = 1;
            r.usedAxes = 2;
            m.usedAxes = 4;
            p.usedAxes = 7;
            u.usedAxes = 0;
            this.highlight = function (a, b) {
                t.forEach(function (c) {
                    return e(c, a, b)
                })
            };
            this.usedAxes = function (a) {
                return x.get(a).usedAxes
            }
        }
        
    };

    //scale
    //var v = function () {
    class v extends THREE.Object3D{
        constructor() {

            super();

            function a(a) {
                var b = new Uint8Array(4096)
                var c = Math.floor(255 * a.r)
                var e = Math.floor(255 * a.g)
                var f = Math.floor(255 * a.b)
                for (var g = 0, k = 0; 32 > k; k++) {
                    for (var m = 0; 32 > m; m++) {
                        b[g] = c
                        b[g + 1] = e
                        b[g + 2] = f
                        b[g + 3] = 0 === k || 0 === m || 31 === k || 31 === m ? 220 : 150
                        g += 4;
                    }
                }

                b = new THREE.DataTexture(b, 32, 32, THREE.RGBAFormat)
                b.hasAlpha = !0;
                b.needsUpdate = !0;
                b.loaded = !0;

                c = new THREE.MeshBasicMaterial()
                c.hideFromLightProbes = !0;
                c.specularOff = 1;
                c.disableLightProbe = !0;
                c.depthTest = !1;
                c.depthWrite = !1;
                c.transparent = !0;
                c.color = a;
                c.side = THREE.DoubleSide;
                c.map = b;
                c.opacity = .6;
                c.configureTransparency && c.configureTransparency();
                c.setUniforms && c.setUniforms();
                //return d(new THREE.Mesh(l.squareGeometry, c))
                return createTransformToolObject(new THREE.Mesh(l.squareGeometry, c))
            }
    
            function b(a) {
                a = c(a, .6);
                return createTransformToolObject(new THREE.Mesh(l.lineGeometry, a), new THREE.Mesh(l.cubeGeometry, a))
            }
    
            var m = this;
            //THREE.Object3D.call(this);

            var l = function () {
                var a = new THREE.Matrix4, b = new THREE.BoxBufferGeometry(.3, .3, .3), c = new THREE.PlaneBufferGeometry(.23, .23, 1, 1);
                a.makeTranslation(.45, .45, 0);
                c.applyMatrix4(a);
                c.addTriangleOrderAttribute();
                var d = new THREE.CylinderBufferGeometry(.015, .015, 1, 4, 1, !1);
                a.makeTranslation(0, .65, 0);
                d.applyMatrix4(a);
                var e = new THREE.BoxBufferGeometry(.1, .1, .1);
                a.makeTranslation(0, 1.1, 0);
                e.applyMatrix4(a);
                return {pickerGeometry: b, squareGeometry: c, lineGeometry: d, cubeGeometry: e}
            }(), q = function () {
                var a = c(g, .6);
                //return d(new THREE.Mesh(l.pickerGeometry, a))
                return createTransformToolObject(new THREE.Mesh(l.pickerGeometry, a))
            }(), r = b(f);
            r.rotation.set(0, 0, -Math.PI / 2);
            var n = b(h), p = b(k);
            p.rotation.set(Math.PI / 2, 0, 0);
            var u = a(k), t = a(h);
            t.rotation.set(Math.PI / 2, 0, 0);
            var x = a(f);
            x.rotation.set(0, -Math.PI / 2, 0);
            q.usedAxes = 7;
            r.usedAxes = 1;
            n.usedAxes = 2;
            p.usedAxes = 4;
            u.usedAxes = 3;
            t.usedAxes = 5;
            x.usedAxes = 6;
            var v = [q, r, n, p, u, t, x];
            v.forEach(function (a) {
                return m.add(a)
            });
            var B = new Map(v.map(function (a) {
                return [a.collider, a]
            }));
            this.colliders = [].concat($jscomp.arrayFromIterable(B.keys()));
            this.highlight = function (a, b) {
                v.forEach(function (c) {
                    return e(c, a, b)
                })
            };
            this.usedAxes = function (a) {
                return B.get(a).usedAxes
            }
        }
       
        
    };
   
    JMT.j3dTransformGizmo = function (a, b, c, d) {
        function e(a) {
            k.oldPosition.copy(a);
            k.newPosition.copy(a);
            h.position.copy(a);
            q.position.copy(a);
            w.position.copy(a);
            A.position.copy(a);
            B.position.copy(a);
            z.position.copy(a)
        }

        function f(a) {
            k.oldRotation.copy(a);
            k.newRotation.copy(a);
            if (W === JMT.TRANSFORM_MODE.SCALE) {
                h.rotation.copy(a)
                q.setLocalRotation(a)
                z.rotation.copy(k.oldRotation)
            }
            else {
                h.rotation.set(0, 0, 0)
                q.setLocalRotation(null)
            }
        }

        function g() {
            if (M) {
                if (W === JMT.TRANSFORM_MODE.TRANSLATE) {
                    a.addAuxiliaryObject(h)
                    a.addAuxiliaryObject(q)
                    a.addAuxiliaryObject(w)
                    a.addAuxiliaryObject(A)
                    a.removeAuxiliaryObject(B)
                    a.removeAuxiliaryObject(z)
                }
                else if (W === JMT.TRANSFORM_MODE.ROTATE) {
                    a.addAuxiliaryObject(h)
                    a.removeAuxiliaryObject(A)
                    a.addAuxiliaryObject(B)
                    a.removeAuxiliaryObject(z)
                }
                else {
                    a.addAuxiliaryObject(h)
                    a.addAuxiliaryObject(q)
                    a.removeAuxiliaryObject(A)
                    a.removeAuxiliaryObject(B)
                    a.addAuxiliaryObject(z)
                }
            }
            else {
                a.removeAuxiliaryObject(h)
                a.removeAuxiliaryObject(q)
                a.removeAuxiliaryObject(w)
                a.removeAuxiliaryObject(A)
                a.removeAuxiliaryObject(B)
                a.removeAuxiliaryObject(z)
            }
        }

        var k = this;
        this.target = null;
        var h = new r;
        h.show(7);
        var q = new u;
        q.show(0);
        var w =
            new m;
        w.show(0);
        var A = new TranslateToolObjects, B = new t, z = new v, y = !1;
        Object.defineProperty(this, "transforming", {
            get: function () {
                return y
            }
        });
        var D = new THREE.Vector3(0, 0, 0), J = 0, L = new THREE.Vector3;
        this.oldPosition = new THREE.Vector3(0, 0, 0);
        this.newPosition = new THREE.Vector3(0, 0, 0);
        this.oldRotation = new THREE.Euler(0, 0, 0);
        this.newRotation = new THREE.Euler(0, 0, 0);
        this.oldScale = new THREE.Vector3(1, 1, 1);
        this.newScale = new THREE.Vector3(1, 1, 1);
        Object.defineProperty(this, "position", {
            get: function () {
                return h.position
            }
        });
        Object.defineProperty(this,
            "rotation", {
                get: function () {
                    return k.oldRotation
                }
            });
        var W = !1;
        Object.defineProperty(this, "scale", {
            get: function () {
                return k.oldScale
            }
        });
        var M = !1;
        Object.defineProperty(this, "mode", {
            get: function () {
                return W
            }, set: function (a) {
                W !== a && (W = a, g(), d.requestFrame())
            }
        });
        Object.defineProperty(this, "visible", {
            get: function () {
                return M
            }, set: function (a) {
                M !== a && (M = a, g())
            }
        });
        this.mode = JMT.TRANSFORM_MODE.TRANSLATE;
        var R = Infinity, F = Infinity, P = new THREE.Vector3(0, 0, 0), V = null, aa = !1, U = 7
        var X = function () {
            var b = new THREE.Vector3
            var d = new THREE.Vector3
            var e = new THREE.Quaternion;
            return function (f, g, k) {
                b.set(g, k, 1).unproject(a.camera);
                b.sub(c).normalize();
                if (!q.findPlaneIntersectionPoint(f, c, b, d)) {
                    return null;
                }
                d.sub(h.position);
                d.applyQuaternion(e.setFromEuler(h.rotation).inverse());
                f & 1 || (d.x = 0);
                f & 2 || (d.y = 0);
                f & 4 || (d.z = 0);
                return d
            }
        }(), S = function () {
            var a = new THREE.Vector3, b = new THREE.Vector3, c = new THREE.Vector3;
            return function (d, e) {
                var f = q.cameraPlane;
                a.set(0, 0, -1);
                a.transformDirection(f.matrixWorld);
                b.set(-1, 0, 0);
                b.transformDirection(f.matrixWorld);
                d = X(7, d, e).normalize();
                c.copy(b).cross(d);
                return Math.sign(a.dot(c)) * Math.acos(b.dot(d))
            }
        }(), da = new THREE.Vector3;
        this.rotationSpeed = 5;
        var ba = function () {
            var a = new THREE.Vector2(0, 0), b = new THREE.Quaternion, c = new THREE.Euler, d = new THREE.Quaternion, e = new THREE.Quaternion, f = new THREE.Vector3, g = new THREE.Vector3, m = new THREE.Vector3;
            return function (h, r) {
                b.setFromEuler(k.oldRotation);
                b.normalize();
                a.set(R - h, F - r);
                a.multiplyScalar(k.rotationSpeed);
                if (0 === U) {
                    h = q.cameraPlane
                    f.copy(p)
                    f.transformDirection(h.matrixWorld)
                    g.set(0, 1, 0)
                    g.transformDirection(h.matrixWorld)
                    e.setFromAxisAngle(f, a.y)
                    d.setFromAxisAngle(g, -a.x)
                    d.multiply(e)
                    d.multiply(b)
                    d.normalize()
                    c.setFromQuaternion(d, "ZXY")
                    return c;
                }
                if (7 === U) {
                    var u = q.cameraPlane;
                    m.set(0, 0, -1);
                    m.transformDirection(u.matrixWorld);
                    u = m;
                    h = S(h, r);
                    h -= J
                }
                else {
                    4 !== U && a.multiplyScalar((1 === U ? -1 : 1) * Math.sign((1 === U ? l : p).dot(da)));
                    a:{
                        switch (U) {
                            case 1:
                                u = p;
                                break a;
                            case 2:
                                u = l;
                                break a;
                            case 4:
                                u = n;
                                break a
                        }
                        console.error("Unable to get direction for this value!");
                        u = void 0
                    }
                    h = 4 === U ? -a.x : a.y
                }
                d.setFromAxisAngle(u, h);
                d.multiply(b);
                d.normalize();
                c.setFromQuaternion(d, "ZXY");
                return c
            }
        }(), ea = function () {
            var a = {hoveredCollider: null, hasAnythingChanged: !1};
            return function (c, d, e) {
                var f = W === JMT.TRANSFORM_MODE.TRANSLATE ? A : W === JMT.TRANSFORM_MODE.ROTATE ? B : z;
                
                f.colliders.forEach(obj=>{
                    obj.updateMatrixWorld(true)
                    obj.visible = true;
                })

                c = b.findMeshFromListAtPosition(f.colliders, c, d, !0);
                d = !1;
                if (c !== V || aa !== e)V = c, f.highlight(c, e), d = !0;
                a.hoveredCollider = c;
                a.hasAnythingChanged = d;

                f.colliders.forEach(obj=>{
                    //obj.updateMatrixWorld(true)
                    obj.visible = false;
                })

                return a
            }
        }();
        this.onCanvasPointerMove = function (a, b) {
            if (this.transforming) {
                if (this.mode === JMT.TRANSFORM_MODE.TRANSLATE) {
                    var c = X(U, a, b);
                    c && this.newPosition.copy(c.sub(D).add(h.position));
                    P.copy(this.newPosition);
                    P.sub(h.position);
                    P.divide(h.scale);
                    w.update(P);
                    if (a !== R || b !== F) {
                        A.visible = !1
                        w.show(U)
                        h.show(U)
                    }
                }
                else if (this.mode === JMT.TRANSFORM_MODE.ROTATE) {
                    h.show(U)
                    this.newRotation.copy(ba(a, b))
                    if (a !== R || b !== F) {
                        B.visible = !1
                    }
                }
                else {
                    h.show(U);
                    if (c = X(U, a, b)) {
                        c.addScalar(1).divide(L)
                        this.newScale.copy(c);
                    }
                    if (a !== R || b !== F) {
                        z.visible = !1
                    }
                }
                d.requestFrame();
                return !0
            }
            ea(a, b, aa).hasAnythingChanged && d.requestFrame();
            return !1
        };
        this.onCanvasPointerDown = function (a, b) {
            var c = ea(a, b, !0);
            aa = !0;
            if (null !== c.hoveredCollider)return y = !0, U = (W === JMT.TRANSFORM_MODE.TRANSLATE ? A : W === JMT.TRANSFORM_MODE.ROTATE ? B : z).usedAxes(c.hoveredCollider), R = a, F = b, this.mode === JMT.TRANSFORM_MODE.TRANSLATE ? (q.show(U), this.newPosition.copy(this.oldPosition), D.copy(X(U, a, b))) : this.mode === JMT.TRANSFORM_MODE.ROTATE ? 7 === U && (this.newRotation.copy(this.oldRotation), J = S(a, b)) : (q.show(7 === U ? 0 : U), this.newScale.copy(this.oldScale), a = X(U, a, b), L.copy(a).addScalar(1).divide(this.oldScale)),
                !0;
            U = 7;
            y = !1;
            c.hasAnythingChanged && d.requestFrame();
            return !1
        };
        this.onCanvasPointerUp = function (a, b) {
            if (this.transforming) {
                e(this.newPosition);
                f(this.newRotation);
                var c = this.newScale;
                k.oldScale.copy(c);
                k.newScale.copy(c);
                q.show(0);
                w.show(0);
                U = 7;
                h.show(U);
                this.mode === JMT.TRANSFORM_MODE.TRANSLATE ? A.visible = !0 : this.mode === JMT.TRANSFORM_MODE.ROTATE ? B.visible = !0 : z.visible = !0
            }
            c = this.transforming;
            y = !1;
            this.update();
            ea(a, b, !1).hasAnythingChanged && d.requestFrame();
            aa = !1;
            return c
        };
        this.update = function () {
            if (!this.transforming &&
                (void 0 !== this.target.position && e(this.target.position), void 0 !== this.target.rotation && f(this.target.rotation), void 0 !== this.target.scale)) {
                var b = this.target.scale;
                k.oldScale.copy(b);
                k.newScale.copy(b)
            }
            da.copy(c);
            da.sub(h.position);
            da.normalize();
            b = .18 * h.position.distanceTo(c) * a.camera.fov / 90;
            h.scale.set(b, b, b);
            q.scale.set(b, b, b);
            w.scale.set(b, b, b);
            A.scale.set(b, b, b);
            B.scale.set(b, b, b);
            z.scale.set(b, b, b);
            B.update(a.camera);
            q.update(a.camera);
            h.update(c);
            h.updateMatrixWorld();
            q.updateMatrixWorld();
            w.updateMatrixWorld();
            A.updateMatrixWorld();
            B.updateMatrixWorld();
            z.updateMatrixWorld()
        }
    }
})();

/***/ }),

/***/ "./src/extend/controllers/j3dAlignControls.js":
/*!****************************************************!*\
  !*** ./src/extend/controllers/j3dAlignControls.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dAlignControls": function() { return /* binding */ j3dAlignControls; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2021/3/13.
 */




function getKey(from, to) {
    return from.uuid + ',' + to.uuid
}

function equalKey(left, right) {
    let l = left.split(','),
        r = right.split(',')

    return (l[0] === r[0] && l[1] === r[1]) ||
        (l[0] === r[1] && l[1] === r[0])
}

function createGuidelineMaterial(color, opacity = 0.6) {
    var material = new THREE.MeshBasicMaterial;//new JMT.StandardMaterial;
    //material.hideFromLightProbes = !0;
    material.color.copy(color);
    material.opacity = opacity;
    //material.specularOff = 1;
    material.depthTest = false;
    material.depthWrite = false;
    return material
}

const ZERO = 0.0001

var isZero = function () {
    return function (a) {
        return a < ZERO || Math.abs(a - 1) < ZERO
    }
}()

class j3dAlignControls extends THREE.EventDispatcher {

    constructor(assetsController, option = {}) {

        super()

        this.nearBy = []

        option.threshold = option.threshold || {}

        this.threshold = option.threshold.tip || 5

        this.adsbThreshold = option.threshold.adsorb || 0.001

        this._assets = assetsController.assets

        this.bindPointerEvent()

        this.bindAssetEvent()

        this._alignments = new Set()
    }

    bindPointerEvent() {

        let a = UjP.pointerEventDispatcher

        var peh = new JMT.PointerEventHelper(a, JMT.POINTER_PRIORITY.ASSET_ALIGNMENT);

        let t = this

        peh.callbacks.onPointerDown = function (x, y) {

        };

        peh.callbacks.onPointerUp = function (x, y) {
            t.clearAlignments()
        };

        peh.callbacks.onPointerMove = function (x, y) {

        }
    }

    bindAssetEvent() {

        let viewer = UjP.viewer

        let t = this

        viewer.addEventListener('assetUpdating', function (event) {

            //if(event.property === 'asPosition' || event.property === 'asScale'){
            if (event.property === 'Pos&Nor') {

                let asset = event.asset

                t.detectAlignment(asset, event.value.position, event.value.normal)
            }
        })

        //viewer.addEventListener('assetUpdated', function(event){
        //
        //    if(event.property === 'asPosition' || event.property === 'asScale'){
        //
        //        let  asset = event.asset
        //
        //        t.detectAlignment(asset)
        //    }
        //})
    }

    detectAlignment(asset, nextPosition, nextNormal) {

        if (!asset) {
            return
        }

        let anchor = asset.position

        this._assets.forEach(asItem=> {
            if (asItem !== asset) {
                let pos = asItem.position

                if (pos.distanceTo(anchor) < this.threshold) {

                    //this.nearBy.push(asItem)
                    //asItem.hover()

                    let alignment = this.getAlignment(asset, asItem)

                    alignment.update(Alignment.Mode.Auto, nextPosition, nextNormal)

                }
                else {

                    asItem.leave()

                    let key = getKey(asset, asItem)

                    let alignment = this._getExistedAlignment(key)

                    if (alignment) {

                        this.removeAlignment(alignment)

                    }

                }
            }
        })
    }

    onDrop(asset) {
        this.clearAlignments()
    }

    alignLeft(from, to) {

        this._alignSilence(Alignment.Mode.Left)

    }

    alignRight(from, to) {

        this._alignSilence(from, to, Alignment.Mode.Right)
    }

    alignTop(from, to) {

        this._alignSilence(from, to, Alignment.Mode.Top)
    }

    alignBottom(from, to) {

        this._alignSilence(from, to, Alignment.Mode.Bottom)
    }

    _alignSilence(from, to, mode) {

        let alignment = getAlignment(from, to)

        alignment.guidelineHidden = !0

        alignment.update(mode)

    }

    //updateAlignmentLine(from, to, mode){
    //
    //    let key = getKey(from, to)
    //
    //    alignment.update(mode)
    //
    //}

    addAlignment(alignment) {

        this._alignments.add(alignment)

        UjP.scene.addAuxiliaryObject(alignment)
    }

    removeAlignment(alignment) {


        console.assert(alignment)

        this._alignments.delete(alignment)

        UjP.scene.removeAuxiliaryObject(alignment)

        alignment.dispose()

    }

    clearAlignments() {

        this._alignments.forEach(a=> {

            UjP.scene.removeAuxiliaryObject(a)

            a.dispose()

        })

        this._alignments.clear()
    }

    getAlignment(from, to) {

        let key = getKey(from, to)

        let alignment = this._getExistedAlignment(key)

        if (!alignment) {

            alignment = new Alignment(from, to)

            this.addAlignment(alignment)

        }

        return alignment
    }

    _getExistedAlignment(key) {

        for (var alignment of this._alignments) {

            if (equalKey(alignment.key, key)) {

                return alignment

            }
        }

        return null

    }

    enable() {

    }

    disable() {

    }
}

JMT.j3dAlignControls = j3dAlignControls

class Alignment extends THREE.Object3D {

    constructor(from, to, adsorbe = {}) {

        super()

        this.autoAdsorbe = !!adsorbe.autoAdsorbe

        this.threshold = adsorbe.threshold || 0.05

        this.guidelineHidden = !!adsorbe.guidelineHidden

        this.fromAsset = from

        this.toAsset = to

        this.key = getKey(from, to)

        this.material = createGuidelineMaterial(new THREE.Color(0xff0000), .6)
        this.material.depthTest = !0;

        this.guideLine = this.createGuideline()

        this.guideLine.visible = !1

        this.add(this.guideLine)


        let t = this
        this.alignAuto = function () {
            //平面默认法线状态
            var v0 = new THREE.Vector3(0, 1, 0);
            //四元数对象
            var quaternion = new THREE.Quaternion();

            let pos = new THREE.Vector3()

            let dir = new THREE.Vector3()

            t.guideLine.visible = !0

            return function (nextPosition, nextNormal) {


                if (
                    this.fromAsset.isModel || this.toAsset.isModel ||
                    this.fromAsset.isAnchor || this.toAsset.isAnchor ||
                    this.fromAsset.isEffect || this.toAsset.isEffect) {
                    return
                }


                let calc = [0, 0, 0]

                let toNormal = this.toAsset._normal instanceof THREE.Vector3 ? this.toAsset._normal : new THREE.Vector3().copy(this.toAsset._normal)

                let angle = nextNormal.angleTo(toNormal)

                if (angle < ZERO) {

                    pos.set(
                        (nextPosition.x + this.toAsset.position.x) / 2,
                        (nextPosition.y + this.toAsset.position.y) / 2,
                        (nextPosition.z + this.toAsset.position.z) / 2
                    )

                    dir.set(
                        Math.abs(this.toAsset.position.x - nextPosition.x),
                        Math.abs(this.toAsset.position.y - nextPosition.y),
                        Math.abs(this.toAsset.position.z - nextPosition.z)
                    ).normalize()


                    if (JMT.ASSET_ADSORB) {
                        let adThreshold = JMT.ASSET_ADSORB_THRESHOLD || 0.1

                        let visible = !1

                        function distZero(a) {
                            return a < adThreshold
                        }


                        if (isZero(dir.z)) {

                            if (distZero(dir.x)) {
                                visible = !0

                                pos.x = nextPosition.x = this.toAsset.position.x

                                dir.x = 0

                                calc[1] = 1
                            }
                            else if (distZero(dir.y)) {
                                visible = !0

                                pos.y = nextPosition.y = this.toAsset.position.y

                                dir.y = 0

                                calc[0] = 1
                            }

                        }
                        else if (isZero(dir.y)) {

                            if (distZero(dir.x)) {
                                visible = !0

                                pos.x = nextPosition.x = this.toAsset.position.x

                                dir.x = 0

                                calc[2] = 1
                            }
                            else if (distZero(dir.z)) {
                                visible = !0

                                pos.z = nextPosition.z = this.toAsset.position.z

                                dir.z = 0

                                calc[0] = 1
                            }

                        }
                        else if (isZero(dir.x)) {

                            if (distZero(dir.y)) {
                                visible = !0

                                pos.y = nextPosition.y = this.toAsset.position.y

                                dir.y = 0

                                calc[2] = 1
                            }
                            else if (distZero(dir.z)) {
                                visible = !0

                                pos.z = nextPosition.z = this.toAsset.position.z

                                dir.z = 0

                                calc[1] = 1
                            }
                        }

                        if (visible) {

                            this.fromAsset._pinTo(nextPosition, nextNormal)
                        }

                        this.visible = visible
                    }
                    else {
                        this.visible = (isZero(dir.z) && (isZero(dir.y) || isZero(dir.x))) ||
                            (isZero(dir.y) && (isZero(dir.x) || isZero(dir.z))) ||
                            (isZero(dir.x) && (isZero(dir.y) || isZero(dir.z)))
                    }


                }


                if (this.visible) {

                    this.position.copy(pos)


                    let dis = undefined

                    let absordNow = !1

                    if (calc[0]) {
                        // 计算x轴距离
                        dis = Math.abs(this.toAsset.position.x - nextPosition.x)

                        dis -= this.toAsset.scale.x / 2
                        dis -= this.fromAsset.scale.x / 2

                        absordNow = Math.abs(dis) <= this.adsbThreshold
                    }
                    else if(calc[1]){
                        // 计算y轴距离
                        dis = Math.abs(this.toAsset.position.y - nextPosition.y)

                        dis -= this.toAsset.scale.y / 2
                        dis -= this.fromAsset.scale.y / 2

                        absordNow = Math.abs(dis) <= this.adsbThreshold
                    }
                    else if(calc[2]){
                        // 计算z轴距离
                        dis = Math.abs(this.toAsset.position.z - nextPosition.z)

                        dis -= this.toAsset.scale.z / 2
                        dis -= this.fromAsset.scale.z / 2

                        absordNow = Math.abs(dis) <= this.adsbThreshold
                    }

                    if(dis!== undefined){
                        if(absordNow){
                            // 边缘吸附

                        }
                        else {
                            this.updateText(dis.toFixed(3), nextPosition, nextNormal)
                        }
                    }

                    // 创建一个向量表示模型的姿态
                    // setFromUnitVectors方法计算两个向量之间需要如何旋转，渲染信息保存在四元数对象中
                    quaternion.setFromUnitVectors(v0, dir);

                    this.setRotationFromQuaternion(quaternion)

                    this.updateMatrixWorld(!0)
                }


                let vsFrom = this.fromAsset.getVertices()
                let vsTo = this.toAsset.getVertices()

                //let dist = this.fromAsset.position.distanceTo(this.toAsset.position)

                //if(dist <= this.threshold){
                //    console.log('adsorbe!');
                //}
                //
                //console.log('>>', dist);
            }
        }()
    }

    createTip(position, normal) {
        var e = new THREE.PlaneBufferGeometry(1, 1)
        e.convertNormalsToSpherical()

        if (!this.material) {
            var m = new THREE.MeshBasicMaterial();

            m.baseColorTexture = this.resolveCanvas();

            this.material = m
        }


        var mesh = new THREE.Mesh(e, this.material)

        position = new THREE.Vector3().copy(normal).multiplyScalar(0.001)

        mesh.position.copy(position)

        this.tipMesh = mesh

        this.add(mesh)

        return mesh
    }

    updateText(text, position, normal, config = {}) {

        if (!this.tipMesh) {
            this.tipMesh = this.createTip(position, normal)
        }

        let newTexture = this.resolveCanvas(text, config)

        let m = this.material
        if (m) {
            m.map && m.map.dispose()
            m.map = newTexture
            //m.doubleSided = true
            m.side = THREE.DoubleSide;
            m.configureTransparency();
            m.setUniforms && m.setUniforms();



            let size = config.size || 0.2

            this.tipMesh.scale.set(size, size * newTexture.height/newTexture.width, 1)
            //this.tipMesh.updateMatrixWorld(!0);
            //console.log(this.tipMesh.matrixWorld);
        }
    }

    resolveCanvas(text, config) {

        var canvas = document.getElementById("anchor-canvas");

        if (!canvas) {
            canvas = document.createElement("canvas")
            canvas.id = "anchor-canvas"
        }

        let fontFamily = config.fontFamily || "Noto Sans";
        let textMargin = config.textMargin || 5

        let texture = new THREE.Texture(canvas);
        texture.hasAlpha = true
        texture.opacity = config.opacity || 1

        let ret = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.resolveText)(canvas, text, fontFamily, textMargin)

        let context = ret[0]
        text = ret[1]
        context.fillStyle = config.color || "#ffffff";
        context.textAlign = config.textAlign || "center";
        context.textBaseline = config.textBaseline || "middle";
        context.shadowColor = config.shadowColor || "black";
        context.shadowBlur = config.shadowBlur || 16;

        context.fillText(text, canvas.width / 2, canvas.height / 2)


        texture.minFilter = THREE.LinearFilter;//GLC.LINEAR;
        texture.loaded = !0;
        texture.needsUpdate = !0;

        texture.width = canvas.width
        texture.height = canvas.height

        return texture
    }

    createGuideline() {

        var b = new THREE.CylinderBufferGeometry(.005, .005, 1E3, 4, 1, !1)
        return new THREE.Mesh(b, this.material)
    }


    update(mode, nextPosition, nextNormal) {

        switch (mode) {
            case Alignment.Mode.Top:
                this.alignTop()
                break
            case Alignment.Mode.Right:
                this.alignRight()
                break
            case Alignment.Mode.Bottom:
                this.alignBottom()
                break
            case Alignment.Mode.Left:
                this.alignLeft()
                break
            case Alignment.Mode.HCenter:
                this.alignHCenter()
                break
            case Alignment.Mode.VCenter:
                this.alignVCenter()
                break
            case Alignment.Mode.Auto:
            default :
                this.alignAuto(nextPosition, nextNormal)
                break

        }

    }


    alignLeft() {

    }

    alignRight() {

    }

    alignTop() {

    }

    alignBottom() {

    }

    alignHCenter() {

    }

    alignVCenter() {

    }

    dispose() {

    }
}


//平面默认法线状态
var v0 = new THREE.Vector3(0, 0, 1);
//四元数对象
var quaternion = new THREE.Quaternion();

Object.defineProperty(Alignment, 'Mode', {
    get: function () {
        return {
            Auto: 0,
            Top: 1,
            Right: 2,
            Bottom: 3,
            Left: 4,
            HCenter: 5,
            VCenter: 6
        }
    }
})

/***/ }),

/***/ "./src/extend/controllers/j3dCollider.js":
/*!***********************************************!*\
  !*** ./src/extend/controllers/j3dCollider.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


JMT.movePointTowards = function () {
    var a = new THREE.Vector3;
    return function (b, c, d) {
        a.copy(b);
        a.sub(c).normalize();
        a.multiplyScalar(d);
        return b.sub(a)
    }
}();

//renderer, scene, controls
JMT.j3dCollider = function (renderer, b, c) {

    var d = this
    var e = new THREE.Octree({
        scene: null,
        depthMax: Infinity,
        objectsThreshold: 8,
        overlapPct: .15
    })
    var cameraPos = c.cameraWorldPosition()//g
    var f = b.camera
    var h = [];

    this.addStaticObstacle = function (mesh, position, radius) {
        e.add(mesh, position, radius)
    };

    this.addDynamicObstacle = function (a) {
        h.push(a)
    };

    this.removeDynamicObstacle = function (a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, h)
    };

    var k = function () {
        var b = new JMT.j3dGpuRaycaster(renderer, f);
        return function (a, c) {

            var d = e.search(a.ray.origin, a.far, a.ray.direction)

            for (var f = 0; f < h.length; f += 1) {

                d.push(h[f]);

            }

            return b.closestIntersection(d, a, c) ? !0 : !1
        }
    }();

    var n = function () {
        var a = new JMT.RayIntersection;
        return function (b) {
            return k(b, a) ? a.distance : Infinity
        }
    }();

    var p = function () {
        var a = new JMT.RaycasterConfig;
        a.ray.direction.set(0, 0, -1);
        a.respectColliderSettings = !0;
        a.onlyGroundCollisions = f.autoClimb;
        return function (b, c) {
            a.ray.origin.copy(b);
            a.far = c;
            b = n(a);
            return f.autoClimb ||
            1 <= b ? b : Infinity
        }
    }();

    this.distanceToGround = function (a) {
        return p(g, a)
    };

    this.objectBelowCamera = function () {
        var a = new JMT.RayIntersection, b = new JMT.RaycasterConfig(cameraPos);
        b.ray.direction.set(0, 0, -1);
        b.respectColliderSettings = !0;
        return function (c) {
            b.far = c;
            return k(b, a) ? a.object : null
        }
    }();

    this.distanceToCeiling = function () {
        var a = new JMT.RaycasterConfig(cameraPos);
        a.ray.direction.set(0, 0, 1);
        a.respectColliderSettings = !0;
        return function (b) {
            a.far = b;
            return n(a)
        }
    }();

    this.distanceToCeilingFrom = function () {
        var a = new JMT.RaycasterConfig;
        a.ray.direction.set(0, 0, 1);
        a.respectColliderSettings = !0;
        return function (b, c) {
            a.ray.origin.copy(b);
            a.far = c;
            return n(a)
        }
    }();

    this.cameraHeightFromPoint = function (a) {
        a = p(a, JMT.MAX_GROUND_SEARCH_DEPTH);
        return Infinity === a ? null : a
    };

    this.adjustPointToMatchCameraHeight = function (a) {
        var b = c.cameraHeight;
        if (null === b)return !1;
        var d = p(a, JMT.MAX_GROUND_SEARCH_DEPTH);
        if (Infinity === d)return !1;
        b -= d;
        if (.01 > Math.abs(b) || 0 < b && Infinity !== this.distanceToCeilingFrom(a, b + JMT.MIN_DISTANCE_TO_CEILING))
            return !1;
        a.z += b;
        return !0
    };

    this.findIntersectionAtPosition = function () {
        var a = new JMT.RaycasterConfig(cameraPos)
        var b = a.ray.direction;
        return function (d, e, f, h) {
            b.set(d, e, 1).unproject(c.camera());
            b.sub(cameraPos).normalize();
            a.respectColliderSettings = f;
            return k(a, h)
        }
    }();

    this.findObstacleMeshAtPosition = function () {
        var a = new JMT.RayIntersection;
        return function (b, c) {
            
            let obj = this.findIntersectionAtPosition(b, c, !1, a) ? a.object : null
            UjP.lastMouseDistance = obj!=null ? a.distance : 100000; //如果没有选中场景，这里暂时给定一个极值
            return obj;
        }
    }();

    this.findMeshFromListAtPosition = function () {
        var b = new JMT.RaycasterConfig(cameraPos), 
        intersect_ = new JMT.RayIntersection, 
        d = new JMT.j3dGpuRaycaster(renderer,f), 
        e = b.ray.direction;
        return function (meshes, x, y, ignoreVisibility, destIntersection) {
            b.ignoreVisibility = void 0 === ignoreVisibility ? !1 : ignoreVisibility;
            let intersection = void 0 === destIntersection ? intersect_ : destIntersection;
            e.set(x, y, 1).unproject(f);
            e.sub(cameraPos).normalize();
            return d.closestIntersection(meshes, b, intersection) ? intersection.object : null
        }
    }();

    this.findMeshFromListRayCast = function () {
        var rayConfig = new JMT.RaycasterConfig(cameraPos);
        var intersect_ = new JMT.RayIntersection;
        var d = new JMT.j3dGpuRaycaster(renderer,f);
        var e = rayConfig.ray.direction;

        let raycaster = new THREE.Raycaster();
        let pointer = new THREE.Vector3()
        return function (meshes, x, y, ignoreVisibility, destIntersection) {
            // rayConfig.ignoreVisibility = (undefined === ignoreVisibility) ? !1 : ignoreVisibility;
            let intersection = (undefined === destIntersection) ? intersect_ : destIntersection;
            pointer.set(x, y, 0.5)
            raycaster.setFromCamera( pointer, f );
			const intersects = raycaster.intersectObjects( meshes );
            if (intersects.length > 0) {
                intersection.object = intersects[ 0 ].object
                intersection.distance = intersects[ 0 ].distance
                intersection.point = intersects[ 0 ].point

                return intersection.object
            }
            return null;
        }
    }();

    this.clickedPointToMoveTarget = function () {
        function a(g) {
            var m = c.x - h.x;
            var q = c.y - h.y;
            m = Math.sqrt(m * m + q * q);
            b.far = m + JMT.CLICK_MOVE_MIN_DISTANCE_TO_OBSTACLE;
            e.x = h.x - c.x;
            e.y = h.y - c.y;
            if (!(.01 > Math.abs(e.x) && .01 > Math.abs(e.y))) {
                if (e.z = 0, e.normalize(), k(b, f)) {
                    if (q = f.distance - JMT.CLICK_MOVE_MIN_DISTANCE_TO_OBSTACLE,
                        0 < q && (g.x = c.x + e.x * q, g.y = c.y + e.y * q, g.z = c.z), q = Math.min(f.distance - .01, m), c.x += e.x * q, c.y += e.y * q, d.adjustPointToMatchCameraHeight(c))
                            return a(g)
                }
                else {
                    g.x = h.x, g.y = h.y, g.z = c.z
                }
            }
            else {
                console.log("aaa")
            }
        }

        var b = new JMT.RaycasterConfig;
        b.respectColliderSettings = !0;
        var c = b.ray.origin, e = b.ray.direction, f = new JMT.RayIntersection, h = new THREE.Vector3;
        return function (b) {
            c.copy(cameraPos);
            h.copy(b);
            b.copy(cameraPos);
            a(b);
            d.adjustPointToMatchCameraHeight(b)
        }
    }();

    this.movePointTowardsTheCamera = function (a, b) {
        return JMT.movePointTowards(a, g, b)
    };

    this.handleCollisions = function () {
        function a(a) {
            c.applyCameraYaw(d);
            d.normalize();
            var h = e.start.distanceTo(cameraPos), m = e.end.distanceTo(cameraPos);
            if (k - .02 < h + m && h + m < k + .02 && m >= a && f.equals(d))return !1;
            h = n(b);
            Infinity === h && (h = b.far);
            f.copy(d);
            e.start.copy(cameraPos);
            e.end.copy(d).multiplyScalar(h).add(cameraPos);
            k = e.distance();
            return h < a
        }

        var b = new JMT.RaycasterConfig(cameraPos), d = b.ray.direction, e = new THREE.Line3, f = new THREE.Vector3, k = 0;
        b.respectColliderSettings = !0;
        b.far = 5;
        console.assert(b.far > c.MAX_PER_FRAME_LINEAR_DISTANCE);
        return function (b) {
            b = c.maxFrameMoveLinearDistance(b) + JMT.KEY_MOVE_MIN_DISTANCE_TO_OBSTACLE;
            c.movesForward() && (d.set(0, 1, 0), a(b) && c.stopForward());
            c.movesBackward() && (d.set(0, -1, 0), a(b) && c.stopBackward());
            c.movesLeft() && (d.set(-1, 0, 0), a(b) && c.stopLeft());
            c.movesRight() && (d.set(1, 0, 0), a(b) && c.stopRight());
            c.movesDown() && (d.set(0, 0, -1), a(b) && c.stopDown());
            c.movesUp() && (d.set(0, 0, 1), a(b) && c.stopUp())
        }
    }()
}

/***/ }),

/***/ "./src/extend/controllers/j3dCutoutTextureDetector.js":
/*!************************************************************!*\
  !*** ./src/extend/controllers/j3dCutoutTextureDetector.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dCutoutTextureDetector": function() { return /* binding */ j3dCutoutTextureDetector; }
/* harmony export */ });
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderers/shaders/SHADERS.js */ "./src/renderers/shaders/SHADERS.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _j3dThree_ext_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../j3dThree.ext.js */ "./src/extend/j3dThree.ext.js");
/* harmony import */ var _j3dThree_ext_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_j3dThree_ext_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../j3dWebGLRendererUtil.js */ "./src/extend/j3dWebGLRendererUtil.js");
/**
 * Created by Kai on 2020/12/18.
 */




function j3dCutoutTextureDetector(b) {

    var d = [
        new THREE.WebGLRenderTarget(1024, 1024, {
            format: THREE.RGBAFormat,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            stencilBuffer: false,
            depthBuffer: false,
            generateMipmaps : false
        }),
        new THREE.WebGLRenderTarget(512, 512, {
            format: THREE.RGBAFormat,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            stencilBuffer: false,
            depthBuffer: false,
            generateMipmaps : false
        })
    ];

    var rendererUtil = new _j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_2__.j3dWebGLRendererUtil(b)

    var e = new THREE.ShaderPass({
        uniforms: {
            map: {type: "t", value: null},
            mapUvStep: {type: "v2", value: null},
            mapUvOffsetScale: {type: "v4", value: null}
        },
        vertexShader: JMT.getShader("alpha_stats_vertex.glsl").code,
        fragmentShader: JMT.getShader("alpha_stats_fragment.glsl").code
    }, "map");
    e.material.depthTest = !1;
    e.material.depthWrite = !1;
    var g = new THREE.Vector2
    var f = new THREE.Vector4;
    e.uniforms.mapUvStep.value = g;
    e.uniforms.mapUvOffsetScale.value = f;

    var h = new THREE.ShaderPass({
        uniforms: {
            map: {type: "t", value: null},
            mapUvStep: {type: "v2", value: null},
            mapUvScale: {type: "v2", value: null}
        },
        vertexShader: JMT.getShader("alpha_stats_vertex.glsl").code,
        fragmentShader: JMT.getShader("alpha_stats_combine_fragment.glsl").code
    }, "map");
    h.material.depthTest = !1;
    h.material.depthWrite = !1;
    var k = new THREE.Vector2;
    h.uniforms.mapUvScale.value = k;
    h.uniforms.mapUvStep.value = g;

    var n = new Uint8Array(4096)
    var p = null;

    JMT.DEBUG && (p = new JMT.Timer);

    this.isCutoutTexture = function (c) {
        var l = void 0 !== c.parentTexture;
        if (l) {
            var r = c.parentTexture;
            var m = c.uvOffsetScale.x;
            var u = c.uvOffsetScale.y;
            var x = c.uvOffsetScale.z;
            var t = c.uvOffsetScale.w
        }
        else {
            r = c
            m = u = 0
            x = t = 1;
        }

        if (!r.hasAlpha || r.video) {
            c.isCutout = !1;
        }
        else {
            JMT.DEBUG && p.reset();
            b.enableScissorTest(!0);
            var v = r.width * x, w = r.height * t;
            g.set(1 / v, 1 / w);
            f.set(m, u, x, t);
            v = Math.max(Math.floor(v / 2), 1);
            w = Math.max(Math.floor(w / 2), 1);
            b.setRenderTarget(d[0]);
            b.setViewport(0, 0, v, w);
            b.setScissor(0, 0, v, w);
            e.render(b, d[0], r);
            for (var z = 1, A = d[0]; 1 !== v && 1 !== w;) {
                g.set(1 / A.width, 1 / A.height);
                k.set(v / A.width, w / A.height);
                v = Math.floor(v / 2);
                w = Math.floor(w / 2);
                var y = d[z];
                b.setRenderTarget(y);
                b.setViewport(0, 0, v, w);
                b.setScissor(0, 0, v, w);
                h.render(b, y, A);
                A = y;
                z = (z + 1) % 2
            }
            //b.readPixels(v, w, n);
            rendererUtil.readPixels(v, w, n);
            A = z = 0;
            v = Math.max(v, w);
            for (w = 0; w < v; ++w){
                z += n[4 * w]
                A += n[4 * w + 1];
            }
            z = 100 * z / (255 * v);
            A = 100 * A / (255 * v);
            c.isCutout = 20 > z || 50 < A;

            if (JMT.DEBUG) {
                v = ""
                if (l) {
                    v += "From atlas: " + r.name + " [" + m + ", " + u + ", " + x + ", " + t + "]\n"
                }
                console.log(c.name + " " + r.width + "x" + r.height + "\n " + v + "Is cutout: " + c.isCutout + "\n Partialy transparent regions: " + z + "%\n Fully transparent pixels: " + A + "%\n Time: " + p.elapsedSec())
            }

            b.enableScissorTest(!1)
        }
    };

    this.dispose = function () {
        d[0].dispose();
        d[1].dispose();
        e.dispose && e.dispose();
        h.dispose && h.dispose()
    }
}

/***/ }),

/***/ "./src/extend/controllers/j3dTransformControls.js":
/*!********************************************************!*\
  !*** ./src/extend/controllers/j3dTransformControls.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _THREE_j3dTransformControls_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./THREE.j3dTransformControls.js */ "./src/extend/controllers/THREE.j3dTransformControls.js");
/**
 * Created by Kai on 2020/12/18.
 */



//pointerEventDispatcher, aniController, scene, collider, controls
JMT.j3dTransformControls = function (a, b, c, d, e) {
    function g() {
    }

    function f(a) {
        e.isEnabled() !== a && (a ? e.enable() : e.disable())
    }

    var h = this, k = !1
    var n = new JMT.j3dTransformGizmo(c, d, e.cameraWorldPosition(), b);
    //var n = new THREE.TransformControls()

    n.mode = JMT.TRANSFORM_MODE.TRANSLATE;

    var p = {itemModified: g}, l = [];

    Object.defineProperty(this, "supportedModes", {
        get: function () {
            return l
        }
    });

    Object.defineProperty(this, "mode", {
        get: function () {
            return n.mode
        }
    });

    this.setItemModifiedCallback = function (a) {
        console.assert(p.itemModified === g);
        p.itemModified = a
    };

    var q = new JMT.PointerEventHelper(a, JMT.POINTER_PRIORITY.TRANSFORM_CONTROLS);

    q.callbacks.onPointerDown = function (a, b) {
        a = n.onCanvasPointerDown(a, b);
        f(!n.transforming);
        return a
    };

    q.callbacks.onPointerUp = function (a, b) {
        a = n.onCanvasPointerUp(a, b);
        f(!n.transforming);
        return a
    };

    q.callbacks.onPointerMove = function (a, b) {
        a = n.onCanvasPointerMove(a, b);

        if (n.transforming) {

            if (n.mode === JMT.TRANSFORM_MODE.TRANSLATE) {

                b = n.newPosition

                h.target.setPosition(b.x, b.y, b.z)

            }
            else if (n.mode === JMT.TRANSFORM_MODE.ROTATE) {

                b = n.newRotation

                if (b.order !== h.target.rotation.order)
                    h.target.rotation.order = b.order
                h.target.setRotation(b.x, b.y, b.z)

            }
            else {

                b = n.newScale
                h.target.setScale(b.x, b.y, b.z)

            }

            p.itemModified(h.target)
        }
        return a
    };

    q.disable();

    Object.defineProperty(this, "target", {
        get: function () {
            return n.target
        }
    });

    this.setTransformMode = function (a) {
        n.mode = a
    };

    this.update = function () {
        k && n.update()
    };

    this.enable = function (object, modes) {
        k = !0;
        n.target = object;
        if (null !== object) {
            n.update()
            n.visible = !0;
        }
         
        l = modes;
        -1 === modes.indexOf(n.mode) && (n.mode = modes[0]);

        this._enableUI(!0)

        q.enable()
    };

    const DEFAULT_UI_ID = '__jmk_transform_control_default'

    this._createDefaultTransformUI = function(){

        let parent = document.getElementById(UjP.config.el).parentElement
        let container = document.createElement('div')
        container.id = DEFAULT_UI_ID
        let style = container.style
        style.position = 'absolute'
        style.backgroundColor = 'rgba(12,120,240,0.5)'
        parent.append(container)

        container.style.top = '0'
        /*圆角角度左上，右上，右下，左下都是10px*/
        container.style['border-radius'] = '0 0 10px 10px ';
        container.style.transform = 'translate(calc(-50% + 0.5 px), calc(-50% + 0.5 px))';

        return container
    }

    this._enableUI = function () {
        let translate, rotate, scale, container, showStyle

        if( window.top === window){

            container = h._createDefaultTransformUI()

            function createButton(text, attr) {
                let el = document.createElement('button')
                el.style['font-size'] = '12px'
                el.style.width = '60px'
                el.style.height = '40px'
                el.style.margin = '5px'
                el.style.backgroundColor = 'rgba(120,120,3,0.5)'
                el.style.color = 'white'
                el.style['border-radius'] = '5px';
                el.innerHTML = text
                el.setAttribute('data-action', attr)
                container.append(el)
                return el
            }

            translate = createButton('平移', 'move')
            rotate = createButton('旋转', 'rotation')
            scale = createButton('缩放', 'scale')

            showStyle = ''
        }
        else {

            let doc = window.parent.document

            translate = doc.querySelector('[data-action=move]')

            rotate = doc.querySelector('[data-action=rotation]')

            scale = doc.querySelector('[data-action=scale]')

            showStyle = 'block'
        }

        translate.onclick = function () {
            rotate.classList.remove("checked");
            scale.classList.remove("checked");
            translate.classList.add("checked");
            h.setTransformMode(0)
        }

        rotate.onclick = function () {
            translate.classList.remove("checked");
            scale.classList.remove("checked");
            rotate.classList.add("checked");
            h.setTransformMode(1)
        }

        scale.onclick = function () {
            translate.classList.remove("checked");
            rotate.classList.remove("checked");
            scale.classList.add("checked");
            h.setTransformMode(2)
        }

        return function (value) {

            if(container){
                container.style.left = (parent.innerWidth - 200) / 2 + 'px'
            }

            translate.disabled = h.supportedModes.indexOf(0) < 0
            rotate.disabled = h.supportedModes.indexOf(1) < 0
            scale.disabled = h.supportedModes.indexOf(2) < 0

            let display = value ? showStyle : 'none'

            translate.style.display = display
            rotate.style.display = display
            scale.style.display = display

            translate.classList.remove("checked");
            rotate.classList.remove("checked");
            scale.classList.remove("checked");

            if(h.mode == 0){
                translate.classList.add("checked");
            }
            else if(h.mode == 1){
                rotate.classList.add("checked");
            }
            else {
                scale.classList.add("checked");
            }
        }
    }();

    this.disable = function () {
        k = !1;
        l = [];
        n.visible = !1;

        this._enableUI(!1)

        q.disable()
    }
}

/***/ }),

/***/ "./src/extend/j3dExtends.js":
/*!**********************************!*\
  !*** ./src/extend/j3dExtends.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material/j3dStandardMaterial.js */ "./src/extend/material/j3dStandardMaterial.js");
/* harmony import */ var _material_j3dProceduralSkyMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./material/j3dProceduralSkyMaterial.js */ "./src/extend/material/j3dProceduralSkyMaterial.js");
/* harmony import */ var _material_j3dEquirectSkyMaterial_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./material/j3dEquirectSkyMaterial.js */ "./src/extend/material/j3dEquirectSkyMaterial.js");
/* harmony import */ var _material_j3dFlashMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./material/j3dFlashMaterial.js */ "./src/extend/material/j3dFlashMaterial.js");
/* harmony import */ var _material_j3dFlashMaterial_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_material_j3dFlashMaterial_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _material_j3dMaterialsExtensions_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./material/j3dMaterialsExtensions.js */ "./src/extend/material/j3dMaterialsExtensions.js");
/* harmony import */ var _material_j3dMaterialsExtensions_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_material_j3dMaterialsExtensions_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _texture_j3dTexture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture/j3dTexture.js */ "./src/extend/texture/j3dTexture.js");
/* harmony import */ var _texture_j3dCompressedTexture_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./texture/j3dCompressedTexture.js */ "./src/extend/texture/j3dCompressedTexture.js");
/* harmony import */ var _texture_j3dVideoTexture_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./texture/j3dVideoTexture.js */ "./src/extend/texture/j3dVideoTexture.js");
/* harmony import */ var _j3dTextureLoader_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./j3dTextureLoader.js */ "./src/extend/j3dTextureLoader.js");
/* harmony import */ var _controllers_j3dCollider_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./controllers/j3dCollider.js */ "./src/extend/controllers/j3dCollider.js");
/* harmony import */ var _controllers_j3dTransformControls_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./controllers/j3dTransformControls.js */ "./src/extend/controllers/j3dTransformControls.js");
/* harmony import */ var _controllers_j3dAlignControls_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./controllers/j3dAlignControls.js */ "./src/extend/controllers/j3dAlignControls.js");
/* harmony import */ var _utils_j3dGpuRaycaster_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/j3dGpuRaycaster.js */ "./src/extend/utils/j3dGpuRaycaster.js");

//materials






//textures


//import { j3dDataTexture } from "./texture/j3dDataTexture.js"








//import './lights/j3dLightProbeMaker.js'



JMT.threeExtension = true

/***/ }),

/***/ "./src/extend/j3dTextureLoader.js":
/*!****************************************!*\
  !*** ./src/extend/j3dTextureLoader.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dTextureLoader": function() { return /* binding */ j3dTextureLoader; }
/* harmony export */ });
/* harmony import */ var _loaders_j3dKTXLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loaders/j3dKTXLoader.js */ "./src/extend/loaders/j3dKTXLoader.js");
/* harmony import */ var _loaders_createBasisLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../loaders/createBasisLoader.js */ "./src/loaders/createBasisLoader.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * #Created by: Jimuyida Martian
 * Date 2022/3/22
 */

 
 
 
 
 function Cache() {  // a
     var a = {};
     this.cacheKey = function (a, b, c, d, e) {
         return a + "@" + b + "@" + c + "@" + d + "@" + e
     };
     this.get = function (b) {
         return a[b]
     };
     this.insert = function (b, c) {
         a[b] = c
     }
 }
 
 var d = !1;
 
 function loadNormalTexture(priority, url, format, onload, onerror) {
     function onprocess(a) {
         texture.image = a;
         texture.width = a.width;
         texture.height = a.height;
         onload(texture)
     }
 
     var texture = new JMT.j3dTexture;
     texture.format = format;
     JMT.queueImageGet(priority, url, d ? function (data) {
         createImageBitmap(data, {
             premultiplyAlpha: "none",
             imageOrientation: texture.flipY ? "flipY" : "none"
         }).then(onprocess).catch(onerror)
     } : onprocess, onerror);
     return texture
 }
 
 function loadVideoTexture(priority, url, format, onload, onerror) {
     var texture = new JMT.j3dVideoTexture;
     texture.format = format;
     JMT.queueVideoGet(priority, url, function (a) {
         texture.video = a;
         texture.width = a.videoWidth;
         texture.height = a.videoHeight;
         if (!(THREE.Math.isPowerOfTwo(texture.width) && THREE.Math.isPowerOfTwo(texture.height))) {
             texture.wrapS = THREE.ClampToEdgeWrapping
             texture.wrapT = THREE.ClampToEdgeWrapping
         }
         onload(texture)
     }, onerror);
     return texture
 }
 
 
 function j3dTextureLoader(path, detector, onLoad, onError, onVideoError, noCache) {
 
     function resolveURL(a) {
 
         if (a.url) {
             return a.url
         }
 
         var b = a.id
 
         var c = a.webFormats;
 
         if (a.video) {
             return path + "video/" + c[0] + "/" + b + "." + a.stdExt;
         }
         var e = path + "img/"
 
         var f = detector.ios && a.rgbm;
 
         if (_basisLoader && !f) {
             if (!detector.mobile && -1 < c.indexOf("large/basis")) {
                 return e + "large/basis/" + b + ".basis";
             }
             if (-1 < c.indexOf("small/basis")) {
                 return e + "small/basis/" + b + ".basis"
             }
         }
 
         if (detector.pvrtcTextures && !f && -1 < c.indexOf("small/pvr")) {
             return e + "small/pvr/" + b + ".ktx";
         }
 
         if (detector.etc1Textures && -1 < c.indexOf("small/etc1")) {
             return e + "small/etc1/" + b + ".ktx";
         }
 
         if (detector.dxtTextures && -1 < c.indexOf("large/dxt")) {
             return e + "large/dxt/" + b + ".ktx";
         }
 
         f = -1 < c.indexOf("small/std");
 
         if (!(-1 < c.indexOf("large/std")) || detector.mobile && f) {
             return e + "small/std/" + b + "." + a.stdExt
         }
         else {
             return e + "large/std/" + b + "." + a.stdExt
         }
 
     }
 
     function _onload(texture) {
         --u.texturesToLoad;
         texture.needsUpdate = !0;
 
         texture.notifyLoading()
 
         var c = THREE.Math.isPowerOfTwo(texture.image.width) && THREE.Math.isPowerOfTwo(texture.image.height)
 
        //  if (!c) {
        //      //TODO: resize image
        //      if(texture.url.indexOf("/fire/7.png") >= 0){
        //          texture.image = resizeImage(texture.image, true, 0, 8192)
        //          texture.width = texture.image.width
        //          texture.height = texture.image.height
        //      }
 
        //      //a.hasAlpha = true
        //      //a.minFilter = t.minFilter;
        //      //a.loaded = !0;
        //      //a.needsUpdate = !0;
        //  }
 
         onLoad(texture);
         texture.notifyLoaded()
     }
 
     function _onerror() {
         --u.texturesToLoad;
         onError()
     }
 
     function _onvideoerror() {
         --u.texturesToLoad;
         onVideoError()
     }
 
     function loadBufferTexture(priority, url, format, onload, onerror) {
         var texture = new JMT.DataTexture;
         JMT.queueAjaxGet(priority, url, !0, function (data) {
             data = new Uint8Array(data, 0, data.byteLength);
             texture.image.width = Math.pow(2, data[0]);
             texture.image.height = Math.pow(2, data[1]);
             texture.format = format;
             texture.type = GLC.UNSIGNED_BYTE;
             texture.image.data = data.subarray(2);
             onload && onload(texture);
             f = null
         }, onerror);
         return texture
     }
 
     var u = this
 
     var _cache = new Cache()
 
     var _ktxLoader = new JMT.j3dKTXLoader
 
     var _basisLoader = !JMT.urlHashContains("nobasis") && JMT.createBasisLoader(detector);
 
     noCache && (_cache.insert = function () {
     });
 
     this.texturesToLoad = 0;
 
     this.clearCache = function () {
         _cache = null
     };
 
     this.load = function (priority, loadArgs, isRepeat, mipmap, anisotropy) {
 
        var format = loadArgs.alpha ? THREE.RGBAFormat : THREE.RGBFormat
 
         var url = resolveURL(loadArgs)
 
         var isBasis = /\.basis$/.test(url)
         var isKTX = /\.ktx$/.test(url)
         var isBinary = /\.buf$/.test(url)
         var video = loadArgs.video
         var isNormal = !(isKTX || isBinary || video)
 
         var texture = null
         if (!loadArgs.noCache) {
             var cacheKey = _cache.cacheKey(url, isRepeat, mipmap, anisotropy, format)
             texture = _cache.get(cacheKey);
         }
 
         if (texture) {
 
             return texture;
 
         }
 
         u.texturesToLoad += 1;
 
         if (isBinary) {
             texture = loadBufferTexture(priority, url, format, _onload, _onerror)
         }
         else if (isBasis) {
             texture = _basisLoader.load(priority, url, _onload, _onerror)
         }
         else if (isKTX) {
             texture = _ktxLoader.load(priority, url, _onload, _onerror)
         }
         else if (isNormal) {
             texture = loadNormalTexture(priority, url, format, _onload, _onerror)
         }
         else {
             console.assert(video)
             anisotropy = 1
             isRepeat = false
             texture = loadVideoTexture(JMT.LOAD_PRIORITY.VIDEO, url, format, _onload, _onvideoerror)
         }
 
         texture.hasAlpha = !!loadArgs.alpha;
 
         texture.isRgbm = !!loadArgs.rgbm;
 
         if (isRepeat) {
             texture.wrapS = THREE.RepeatWrapping
             texture.wrapT = THREE.RepeatWrapping
         }
 
         if (mipmap && !video) {
             texture.minFilter = THREE.LinearMipmapLinearFilter//GLC.LINEAR_MIPMAP_LINEAR
             texture.generateMipmaps = !isKTX
         }
         else {
             texture.minFilter = THREE.LinearFilter
             texture.generateMipmaps = false
         }
 
         if (anisotropy) {
             texture.anisotropy = anisotropy
         }
 
         if (!loadArgs.noCache) {
             _cache.insert(cacheKey, texture);
         }
 
         //texture.id = loadArgs.id;
 
         texture.name = loadArgs.name;
 
         texture.webFormats = loadArgs.webFormats;
 
         loadArgs.rawExt && (texture.rawExt = loadArgs.rawExt);
 
         texture.stdExt = loadArgs.stdExt;
 
         texture.url = url
 
         return texture
     }
 }
 
 JMT.j3dTextureLoader = j3dTextureLoader

/***/ }),

/***/ "./src/extend/j3dThree.ext.js":
/*!************************************!*\
  !*** ./src/extend/j3dThree.ext.js ***!
  \************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/19.
 */

THREE.FXAAShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'resolution': { value: new THREE.Vector2( 1 / 1024, 1 / 512 ) }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader:

	// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)

	//----------------------------------------------------------------------------------
	// File:				es3-kepler\FXAA\assets\shaders/FXAA_DefaultES.frag
	// SDK Version: v3.00
	// Email:			 gameworks@nvidia.com
	// Site:				http://developer.nvidia.com/
	//
	// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.
	//
	// Redistribution and use in source and binary forms, with or without
	// modification, are permitted provided that the following conditions
	// are met:
	//	* Redistributions of source code must retain the above copyright
	//		notice, this list of conditions and the following disclaimer.
	//	* Redistributions in binary form must reproduce the above copyright
	//		notice, this list of conditions and the following disclaimer in the
	//		documentation and/or other materials provided with the distribution.
	//	* Neither the name of NVIDIA CORPORATION nor the names of its
	//		contributors may be used to endorse or promote products derived
	//		from this software without specific prior written permission.
	//
	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS\'\' AND ANY
	// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
	// PURPOSE ARE DISCLAIMED.	IN NO EVENT SHALL THE COPYRIGHT OWNER OR
	// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
	// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
	// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
	// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
	// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	//
	//----------------------------------------------------------------------------------

	/* glsl */`

		precision highp float;

		uniform sampler2D tDiffuse;

		uniform vec2 resolution;

		varying vec2 vUv;

		#define FXAA_PC 1
		#define FXAA_GLSL_100 1
		#define FXAA_QUALITY_PRESET 12

		#define FXAA_GREEN_AS_LUMA 1

		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_PC_CONSOLE
				//
				// The console algorithm for PC is included
				// for developers targeting really low spec machines.
				// Likely better to just run FXAA_PC, and use a really low preset.
				//
				#define FXAA_PC_CONSOLE 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_120
				#define FXAA_GLSL_120 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GLSL_130
				#define FXAA_GLSL_130 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_3
				#define FXAA_HLSL_3 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_4
				#define FXAA_HLSL_4 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_HLSL_5
				#define FXAA_HLSL_5 0
		#endif
		/*==========================================================================*/
		#ifndef FXAA_GREEN_AS_LUMA
				//
				// For those using non-linear color,
				// and either not able to get luma in alpha, or not wanting to,
				// this enables FXAA to run using green as a proxy for luma.
				// So with this enabled, no need to pack luma in alpha.
				//
				// This will turn off AA on anything which lacks some amount of green.
				// Pure red and blue or combination of only R and B, will get no AA.
				//
				// Might want to lower the settings for both,
				//		fxaaConsoleEdgeThresholdMin
				//		fxaaQualityEdgeThresholdMin
				// In order to insure AA does not get turned off on colors
				// which contain a minor amount of green.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_GREEN_AS_LUMA 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_EARLY_EXIT
				//
				// Controls algorithm\'s early exit path.
				// On PS3 turning this ON adds 2 cycles to the shader.
				// On 360 turning this OFF adds 10ths of a millisecond to the shader.
				// Turning this off on console will result in a more blurry image.
				// So this defaults to on.
				//
				// 1 = On.
				// 0 = Off.
				//
				#define FXAA_EARLY_EXIT 1
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_DISCARD
				//
				// Only valid for PC OpenGL currently.
				// Probably will not work when FXAA_GREEN_AS_LUMA = 1.
				//
				// 1 = Use discard on pixels which don\'t need AA.
				//		 For APIs which enable concurrent TEX+ROP from same surface.
				// 0 = Return unchanged color on pixels which don\'t need AA.
				//
				#define FXAA_DISCARD 0
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_FAST_PIXEL_OFFSET
				//
				// Used for GLSL 120 only.
				//
				// 1 = GL API supports fast pixel offsets
				// 0 = do not use fast pixel offsets
				//
				#ifdef GL_EXT_gpu_shader4
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_FAST_PIXEL_OFFSET 1
				#endif
				#ifndef FXAA_FAST_PIXEL_OFFSET
						#define FXAA_FAST_PIXEL_OFFSET 0
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#ifndef FXAA_GATHER4_ALPHA
				//
				// 1 = API supports gather4 on alpha channel.
				// 0 = API does not support gather4 on alpha channel.
				//
				#if (FXAA_HLSL_5 == 1)
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_ARB_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifdef GL_NV_gpu_shader5
						#define FXAA_GATHER4_ALPHA 1
				#endif
				#ifndef FXAA_GATHER4_ALPHA
						#define FXAA_GATHER4_ALPHA 0
				#endif
		#endif


		/*============================================================================
														FXAA QUALITY - TUNING KNOBS
		------------------------------------------------------------------------------
		NOTE the other tuning knobs are now in the shader function inputs!
		============================================================================*/
		#ifndef FXAA_QUALITY_PRESET
				//
				// Choose the quality preset.
				// This needs to be compiled into the shader as it effects code.
				// Best option to include multiple presets is to
				// in each shader define the preset, then include this file.
				//
				// OPTIONS
				// -----------------------------------------------------------------------
				// 10 to 15 - default medium dither (10=fastest, 15=highest quality)
				// 20 to 29 - less dither, more expensive (20=fastest, 29=highest quality)
				// 39			 - no dither, very expensive
				//
				// NOTES
				// -----------------------------------------------------------------------
				// 12 = slightly faster then FXAA 3.9 and higher edge quality (default)
				// 13 = about same speed as FXAA 3.9 and better than 12
				// 23 = closest to FXAA 3.9 visually and performance wise
				//	_ = the lowest digit is directly related to performance
				// _	= the highest digit is directly related to style
				//
				#define FXAA_QUALITY_PRESET 12
		#endif


		/*============================================================================

															 FXAA QUALITY - PRESETS

		============================================================================*/

		/*============================================================================
												 FXAA QUALITY - MEDIUM DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 10)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 3.0
				#define FXAA_QUALITY_P2 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 11)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 3.0
				#define FXAA_QUALITY_P3 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 12)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 4.0
				#define FXAA_QUALITY_P4 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 13)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 4.0
				#define FXAA_QUALITY_P5 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 14)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 4.0
				#define FXAA_QUALITY_P6 12.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 15)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 12.0
		#endif

		/*============================================================================
												 FXAA QUALITY - LOW DITHER PRESETS
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 20)
				#define FXAA_QUALITY_PS 3
				#define FXAA_QUALITY_P0 1.5
				#define FXAA_QUALITY_P1 2.0
				#define FXAA_QUALITY_P2 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 21)
				#define FXAA_QUALITY_PS 4
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 22)
				#define FXAA_QUALITY_PS 5
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 23)
				#define FXAA_QUALITY_PS 6
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 24)
				#define FXAA_QUALITY_PS 7
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 3.0
				#define FXAA_QUALITY_P6 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 25)
				#define FXAA_QUALITY_PS 8
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 4.0
				#define FXAA_QUALITY_P7 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 26)
				#define FXAA_QUALITY_PS 9
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 4.0
				#define FXAA_QUALITY_P8 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 27)
				#define FXAA_QUALITY_PS 10
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 4.0
				#define FXAA_QUALITY_P9 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 28)
				#define FXAA_QUALITY_PS 11
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 4.0
				#define FXAA_QUALITY_P10 8.0
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_QUALITY_PRESET == 29)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.5
				#define FXAA_QUALITY_P2 2.0
				#define FXAA_QUALITY_P3 2.0
				#define FXAA_QUALITY_P4 2.0
				#define FXAA_QUALITY_P5 2.0
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif

		/*============================================================================
												 FXAA QUALITY - EXTREME QUALITY
		============================================================================*/
		#if (FXAA_QUALITY_PRESET == 39)
				#define FXAA_QUALITY_PS 12
				#define FXAA_QUALITY_P0 1.0
				#define FXAA_QUALITY_P1 1.0
				#define FXAA_QUALITY_P2 1.0
				#define FXAA_QUALITY_P3 1.0
				#define FXAA_QUALITY_P4 1.0
				#define FXAA_QUALITY_P5 1.5
				#define FXAA_QUALITY_P6 2.0
				#define FXAA_QUALITY_P7 2.0
				#define FXAA_QUALITY_P8 2.0
				#define FXAA_QUALITY_P9 2.0
				#define FXAA_QUALITY_P10 4.0
				#define FXAA_QUALITY_P11 8.0
		#endif



		/*============================================================================

																		API PORTING

		============================================================================*/
		#if (FXAA_GLSL_100 == 1) || (FXAA_GLSL_120 == 1) || (FXAA_GLSL_130 == 1)
				#define FxaaBool bool
				#define FxaaDiscard discard
				#define FxaaFloat float
				#define FxaaFloat2 vec2
				#define FxaaFloat3 vec3
				#define FxaaFloat4 vec4
				#define FxaaHalf float
				#define FxaaHalf2 vec2
				#define FxaaHalf3 vec3
				#define FxaaHalf4 vec4
				#define FxaaInt2 ivec2
				#define FxaaSat(x) clamp(x, 0.0, 1.0)
				#define FxaaTex sampler2D
		#else
				#define FxaaBool bool
				#define FxaaDiscard clip(-1)
				#define FxaaFloat float
				#define FxaaFloat2 float2
				#define FxaaFloat3 float3
				#define FxaaFloat4 float4
				#define FxaaHalf half
				#define FxaaHalf2 half2
				#define FxaaHalf3 half3
				#define FxaaHalf4 half4
				#define FxaaSat(x) saturate(x)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_100 == 1)
			#define FxaaTexTop(t, p) texture2D(t, p, 0.0)
			#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), 0.0)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_120 == 1)
				// Requires,
				//	#version 120
				// And at least,
				//	#extension GL_EXT_gpu_shader4 : enable
				//	(or set FXAA_FAST_PIXEL_OFFSET 1 to work like DX9)
				#define FxaaTexTop(t, p) texture2DLod(t, p, 0.0)
				#if (FXAA_FAST_PIXEL_OFFSET == 1)
						#define FxaaTexOff(t, p, o, r) texture2DLodOffset(t, p, 0.0, o)
				#else
						#define FxaaTexOff(t, p, o, r) texture2DLod(t, p + (o * r), 0.0)
				#endif
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_GLSL_130 == 1)
				// Requires "#version 130" or better
				#define FxaaTexTop(t, p) textureLod(t, p, 0.0)
				#define FxaaTexOff(t, p, o, r) textureLodOffset(t, p, 0.0, o)
				#if (FXAA_GATHER4_ALPHA == 1)
						// use #extension GL_ARB_gpu_shader5 : enable
						#define FxaaTexAlpha4(t, p) textureGather(t, p, 3)
						#define FxaaTexOffAlpha4(t, p, o) textureGatherOffset(t, p, o, 3)
						#define FxaaTexGreen4(t, p) textureGather(t, p, 1)
						#define FxaaTexOffGreen4(t, p, o) textureGatherOffset(t, p, o, 1)
				#endif
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_3 == 1)
				#define FxaaInt2 float2
				#define FxaaTex sampler2D
				#define FxaaTexTop(t, p) tex2Dlod(t, float4(p, 0.0, 0.0))
				#define FxaaTexOff(t, p, o, r) tex2Dlod(t, float4(p + (o * r), 0, 0))
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_4 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
		#endif
		/*--------------------------------------------------------------------------*/
		#if (FXAA_HLSL_5 == 1)
				#define FxaaInt2 int2
				struct FxaaTex { SamplerState smpl; Texture2D tex; };
				#define FxaaTexTop(t, p) t.tex.SampleLevel(t.smpl, p, 0.0)
				#define FxaaTexOff(t, p, o, r) t.tex.SampleLevel(t.smpl, p, 0.0, o)
				#define FxaaTexAlpha4(t, p) t.tex.GatherAlpha(t.smpl, p)
				#define FxaaTexOffAlpha4(t, p, o) t.tex.GatherAlpha(t.smpl, p, o)
				#define FxaaTexGreen4(t, p) t.tex.GatherGreen(t.smpl, p)
				#define FxaaTexOffGreen4(t, p, o) t.tex.GatherGreen(t.smpl, p, o)
		#endif


		/*============================================================================
											 GREEN AS LUMA OPTION SUPPORT FUNCTION
		============================================================================*/
		#if (FXAA_GREEN_AS_LUMA == 0)
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.w; }
		#else
				FxaaFloat FxaaLuma(FxaaFloat4 rgba) { return rgba.y; }
		#endif




		/*============================================================================

																 FXAA3 QUALITY - PC

		============================================================================*/
		#if (FXAA_PC == 1)
		/*--------------------------------------------------------------------------*/
		FxaaFloat4 FxaaPixelShader(
				//
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy} = center of pixel
				FxaaFloat2 pos,
				//
				// Used only for FXAA Console, and not used on the 360 version.
				// Use noperspective interpolation here (turn off perspective interpolation).
				// {xy_} = upper left of pixel
				// {_zw} = lower right of pixel
				FxaaFloat4 fxaaConsolePosPos,
				//
				// Input color texture.
				// {rgb_} = color in linear or perceptual color space
				// if (FXAA_GREEN_AS_LUMA == 0)
				//		 {__a} = luma in perceptual color space (not linear)
				FxaaTex tex,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 2nd sampler.
				// This sampler needs to have an exponent bias of -1.
				FxaaTex fxaaConsole360TexExpBiasNegOne,
				//
				// Only used on the optimized 360 version of FXAA Console.
				// For everything but 360, just use the same input here as for "tex".
				// For 360, same texture, just alias with a 3nd sampler.
				// This sampler needs to have an exponent bias of -2.
				FxaaTex fxaaConsole360TexExpBiasNegTwo,
				//
				// Only used on FXAA Quality.
				// This must be from a constant/uniform.
				// {x_} = 1.0/screenWidthInPixels
				// {_y} = 1.0/screenHeightInPixels
				FxaaFloat2 fxaaQualityRcpFrame,
				//
				// Only used on FXAA Console.
				// This must be from a constant/uniform.
				// This effects sub-pixel AA quality and inversely sharpness.
				//	 Where N ranges between,
				//		 N = 0.50 (default)
				//		 N = 0.33 (sharper)
				// {x__} = -N/screenWidthInPixels
				// {_y_} = -N/screenHeightInPixels
				// {_z_} =	N/screenWidthInPixels
				// {__w} =	N/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt,
				//
				// Only used on FXAA Console.
				// Not used on 360, but used on PS3 and PC.
				// This must be from a constant/uniform.
				// {x__} = -2.0/screenWidthInPixels
				// {_y_} = -2.0/screenHeightInPixels
				// {_z_} =	2.0/screenWidthInPixels
				// {__w} =	2.0/screenHeightInPixels
				FxaaFloat4 fxaaConsoleRcpFrameOpt2,
				//
				// Only used on FXAA Console.
				// Only used on 360 in place of fxaaConsoleRcpFrameOpt2.
				// This must be from a constant/uniform.
				// {x__} =	8.0/screenWidthInPixels
				// {_y_} =	8.0/screenHeightInPixels
				// {_z_} = -4.0/screenWidthInPixels
				// {__w} = -4.0/screenHeightInPixels
				FxaaFloat4 fxaaConsole360RcpFrameOpt2,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_SUBPIX define.
				// It is here now to allow easier tuning.
				// Choose the amount of sub-pixel aliasing removal.
				// This can effect sharpness.
				//	 1.00 - upper limit (softer)
				//	 0.75 - default amount of filtering
				//	 0.50 - lower limit (sharper, less sub-pixel aliasing removal)
				//	 0.25 - almost off
				//	 0.00 - completely off
				FxaaFloat fxaaQualitySubpix,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// The minimum amount of local contrast required to apply algorithm.
				//	 0.333 - too little (faster)
				//	 0.250 - low quality
				//	 0.166 - default
				//	 0.125 - high quality
				//	 0.063 - overkill (slower)
				FxaaFloat fxaaQualityEdgeThreshold,
				//
				// Only used on FXAA Quality.
				// This used to be the FXAA_QUALITY_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				//	 0.0833 - upper limit (default, the start of visible unfiltered edges)
				//	 0.0625 - high quality (faster)
				//	 0.0312 - visible limit (slower)
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaQualityEdgeThresholdMin,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_SHARPNESS define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_SHARPNESS for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only three safe values here: 2 and 4 and 8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// For all other platforms can be a non-power of two.
				//	 8.0 is sharper (default!!!)
				//	 4.0 is softer
				//	 2.0 is really soft (good only for vector graphics inputs)
				FxaaFloat fxaaConsoleEdgeSharpness,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD define.
				// It is here now to allow easier tuning.
				// This does not effect PS3, as this needs to be compiled in.
				//	 Use FXAA_CONSOLE_PS3_EDGE_THRESHOLD for PS3.
				//	 Due to the PS3 being ALU bound,
				//	 there are only two safe values here: 1/4 and 1/8.
				//	 These options use the shaders ability to a free *|/ by 2|4|8.
				// The console setting has a different mapping than the quality setting.
				// Other platforms can use other values.
				//	 0.125 leaves less aliasing, but is softer (default!!!)
				//	 0.25 leaves more aliasing, and is sharper
				FxaaFloat fxaaConsoleEdgeThreshold,
				//
				// Only used on FXAA Console.
				// This used to be the FXAA_CONSOLE_EDGE_THRESHOLD_MIN define.
				// It is here now to allow easier tuning.
				// Trims the algorithm from processing darks.
				// The console setting has a different mapping than the quality setting.
				// This only applies when FXAA_EARLY_EXIT is 1.
				// This does not apply to PS3,
				// PS3 was simplified to avoid more shader instructions.
				//	 0.06 - faster but more aliasing in darks
				//	 0.05 - default
				//	 0.04 - slower and less aliasing in darks
				// Special notes when using FXAA_GREEN_AS_LUMA,
				//	 Likely want to set this to zero.
				//	 As colors that are mostly not-green
				//	 will appear very dark in the green channel!
				//	 Tune by looking at mostly non-green content,
				//	 then start at zero and increase until aliasing is a problem.
				FxaaFloat fxaaConsoleEdgeThresholdMin,
				//
				// Extra constants for 360 FXAA Console only.
				// Use zeros or anything else for other platforms.
				// These must be in physical constant registers and NOT immediates.
				// Immediates will result in compiler un-optimizing.
				// {xyzw} = float4(1.0, -1.0, 0.25, -0.25)
				FxaaFloat4 fxaaConsole360ConstDir
		) {
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posM;
				posM.x = pos.x;
				posM.y = pos.y;
				#if (FXAA_GATHER4_ALPHA == 1)
						#if (FXAA_DISCARD == 0)
								FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
								#if (FXAA_GREEN_AS_LUMA == 0)
										#define lumaM rgbyM.w
								#else
										#define lumaM rgbyM.y
								#endif
						#endif
						#if (FXAA_GREEN_AS_LUMA == 0)
								FxaaFloat4 luma4A = FxaaTexAlpha4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffAlpha4(tex, posM, FxaaInt2(-1, -1));
						#else
								FxaaFloat4 luma4A = FxaaTexGreen4(tex, posM);
								FxaaFloat4 luma4B = FxaaTexOffGreen4(tex, posM, FxaaInt2(-1, -1));
						#endif
						#if (FXAA_DISCARD == 1)
								#define lumaM luma4A.w
						#endif
						#define lumaE luma4A.z
						#define lumaS luma4A.x
						#define lumaSE luma4A.y
						#define lumaNW luma4B.w
						#define lumaN luma4B.z
						#define lumaW luma4B.x
				#else
						FxaaFloat4 rgbyM = FxaaTexTop(tex, posM);
						#if (FXAA_GREEN_AS_LUMA == 0)
								#define lumaM rgbyM.w
						#else
								#define lumaM rgbyM.y
						#endif
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 0.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 0.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 0.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaS = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaN = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 0,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 0), fxaaQualityRcpFrame.xy));
						#endif
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat maxSM = max(lumaS, lumaM);
				FxaaFloat minSM = min(lumaS, lumaM);
				FxaaFloat maxESM = max(lumaE, maxSM);
				FxaaFloat minESM = min(lumaE, minSM);
				FxaaFloat maxWN = max(lumaN, lumaW);
				FxaaFloat minWN = min(lumaN, lumaW);
				FxaaFloat rangeMax = max(maxWN, maxESM);
				FxaaFloat rangeMin = min(minWN, minESM);
				FxaaFloat rangeMaxScaled = rangeMax * fxaaQualityEdgeThreshold;
				FxaaFloat range = rangeMax - rangeMin;
				FxaaFloat rangeMaxClamped = max(fxaaQualityEdgeThresholdMin, rangeMaxScaled);
				FxaaBool earlyExit = range < rangeMaxClamped;
		/*--------------------------------------------------------------------------*/
				if(earlyExit)
						#if (FXAA_DISCARD == 1)
								FxaaDiscard;
						#else
								return rgbyM;
						#endif
		/*--------------------------------------------------------------------------*/
				#if (FXAA_GATHER4_ALPHA == 0)
						#if (FXAA_GLSL_100 == 1)
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0, 1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2( 1.0,-1.0), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaFloat2(-1.0, 1.0), fxaaQualityRcpFrame.xy));
						#else
							FxaaFloat lumaNW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1, 1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2( 1,-1), fxaaQualityRcpFrame.xy));
							FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
						#endif
				#else
						FxaaFloat lumaNE = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(1, -1), fxaaQualityRcpFrame.xy));
						FxaaFloat lumaSW = FxaaLuma(FxaaTexOff(tex, posM, FxaaInt2(-1, 1), fxaaQualityRcpFrame.xy));
				#endif
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNS = lumaN + lumaS;
				FxaaFloat lumaWE = lumaW + lumaE;
				FxaaFloat subpixRcpRange = 1.0/range;
				FxaaFloat subpixNSWE = lumaNS + lumaWE;
				FxaaFloat edgeHorz1 = (-2.0 * lumaM) + lumaNS;
				FxaaFloat edgeVert1 = (-2.0 * lumaM) + lumaWE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNESE = lumaNE + lumaSE;
				FxaaFloat lumaNWNE = lumaNW + lumaNE;
				FxaaFloat edgeHorz2 = (-2.0 * lumaE) + lumaNESE;
				FxaaFloat edgeVert2 = (-2.0 * lumaN) + lumaNWNE;
		/*--------------------------------------------------------------------------*/
				FxaaFloat lumaNWSW = lumaNW + lumaSW;
				FxaaFloat lumaSWSE = lumaSW + lumaSE;
				FxaaFloat edgeHorz4 = (abs(edgeHorz1) * 2.0) + abs(edgeHorz2);
				FxaaFloat edgeVert4 = (abs(edgeVert1) * 2.0) + abs(edgeVert2);
				FxaaFloat edgeHorz3 = (-2.0 * lumaW) + lumaNWSW;
				FxaaFloat edgeVert3 = (-2.0 * lumaS) + lumaSWSE;
				FxaaFloat edgeHorz = abs(edgeHorz3) + edgeHorz4;
				FxaaFloat edgeVert = abs(edgeVert3) + edgeVert4;
		/*--------------------------------------------------------------------------*/
				FxaaFloat subpixNWSWNESE = lumaNWSW + lumaNESE;
				FxaaFloat lengthSign = fxaaQualityRcpFrame.x;
				FxaaBool horzSpan = edgeHorz >= edgeVert;
				FxaaFloat subpixA = subpixNSWE * 2.0 + subpixNWSWNESE;
		/*--------------------------------------------------------------------------*/
				if(!horzSpan) lumaN = lumaW;
				if(!horzSpan) lumaS = lumaE;
				if(horzSpan) lengthSign = fxaaQualityRcpFrame.y;
				FxaaFloat subpixB = (subpixA * (1.0/12.0)) - lumaM;
		/*--------------------------------------------------------------------------*/
				FxaaFloat gradientN = lumaN - lumaM;
				FxaaFloat gradientS = lumaS - lumaM;
				FxaaFloat lumaNN = lumaN + lumaM;
				FxaaFloat lumaSS = lumaS + lumaM;
				FxaaBool pairN = abs(gradientN) >= abs(gradientS);
				FxaaFloat gradient = max(abs(gradientN), abs(gradientS));
				if(pairN) lengthSign = -lengthSign;
				FxaaFloat subpixC = FxaaSat(abs(subpixB) * subpixRcpRange);
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posB;
				posB.x = posM.x;
				posB.y = posM.y;
				FxaaFloat2 offNP;
				offNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;
				offNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;
				if(!horzSpan) posB.x += lengthSign * 0.5;
				if( horzSpan) posB.y += lengthSign * 0.5;
		/*--------------------------------------------------------------------------*/
				FxaaFloat2 posN;
				posN.x = posB.x - offNP.x * FXAA_QUALITY_P0;
				posN.y = posB.y - offNP.y * FXAA_QUALITY_P0;
				FxaaFloat2 posP;
				posP.x = posB.x + offNP.x * FXAA_QUALITY_P0;
				posP.y = posB.y + offNP.y * FXAA_QUALITY_P0;
				FxaaFloat subpixD = ((-2.0)*subpixC) + 3.0;
				FxaaFloat lumaEndN = FxaaLuma(FxaaTexTop(tex, posN));
				FxaaFloat subpixE = subpixC * subpixC;
				FxaaFloat lumaEndP = FxaaLuma(FxaaTexTop(tex, posP));
		/*--------------------------------------------------------------------------*/
				if(!pairN) lumaNN = lumaSS;
				FxaaFloat gradientScaled = gradient * 1.0/4.0;
				FxaaFloat lumaMM = lumaM - lumaNN * 0.5;
				FxaaFloat subpixF = subpixD * subpixE;
				FxaaBool lumaMLTZero = lumaMM < 0.0;
		/*--------------------------------------------------------------------------*/
				lumaEndN -= lumaNN * 0.5;
				lumaEndP -= lumaNN * 0.5;
				FxaaBool doneN = abs(lumaEndN) >= gradientScaled;
				FxaaBool doneP = abs(lumaEndP) >= gradientScaled;
				if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P1;
				if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P1;
				FxaaBool doneNP = (!doneN) || (!doneP);
				if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P1;
				if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P1;
		/*--------------------------------------------------------------------------*/
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P2;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P2;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P2;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P2;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 3)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P3;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P3;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P3;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P3;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 4)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P4;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P4;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P4;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P4;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 5)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P5;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P5;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P5;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P5;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 6)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P6;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P6;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P6;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P6;
		/*--------------------------------------------------------------------------*/
														#if (FXAA_QUALITY_PS > 7)
														if(doneNP) {
																if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
																if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
																if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
																if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
																doneN = abs(lumaEndN) >= gradientScaled;
																doneP = abs(lumaEndP) >= gradientScaled;
																if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P7;
																if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P7;
																doneNP = (!doneN) || (!doneP);
																if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P7;
																if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P7;
		/*--------------------------------------------------------------------------*/
				#if (FXAA_QUALITY_PS > 8)
				if(doneNP) {
						if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
						if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
						if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
						if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
						doneN = abs(lumaEndN) >= gradientScaled;
						doneP = abs(lumaEndP) >= gradientScaled;
						if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P8;
						if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P8;
						doneNP = (!doneN) || (!doneP);
						if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P8;
						if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P8;
		/*--------------------------------------------------------------------------*/
						#if (FXAA_QUALITY_PS > 9)
						if(doneNP) {
								if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
								if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
								if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
								if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
								doneN = abs(lumaEndN) >= gradientScaled;
								doneP = abs(lumaEndP) >= gradientScaled;
								if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P9;
								if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P9;
								doneNP = (!doneN) || (!doneP);
								if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P9;
								if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P9;
		/*--------------------------------------------------------------------------*/
								#if (FXAA_QUALITY_PS > 10)
								if(doneNP) {
										if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
										if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
										if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
										if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
										doneN = abs(lumaEndN) >= gradientScaled;
										doneP = abs(lumaEndP) >= gradientScaled;
										if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P10;
										if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P10;
										doneNP = (!doneN) || (!doneP);
										if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P10;
										if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P10;
		/*--------------------------------------------------------------------------*/
										#if (FXAA_QUALITY_PS > 11)
										if(doneNP) {
												if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
												if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
												if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
												if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
												doneN = abs(lumaEndN) >= gradientScaled;
												doneP = abs(lumaEndP) >= gradientScaled;
												if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P11;
												if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P11;
												doneNP = (!doneN) || (!doneP);
												if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P11;
												if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P11;
		/*--------------------------------------------------------------------------*/
												#if (FXAA_QUALITY_PS > 12)
												if(doneNP) {
														if(!doneN) lumaEndN = FxaaLuma(FxaaTexTop(tex, posN.xy));
														if(!doneP) lumaEndP = FxaaLuma(FxaaTexTop(tex, posP.xy));
														if(!doneN) lumaEndN = lumaEndN - lumaNN * 0.5;
														if(!doneP) lumaEndP = lumaEndP - lumaNN * 0.5;
														doneN = abs(lumaEndN) >= gradientScaled;
														doneP = abs(lumaEndP) >= gradientScaled;
														if(!doneN) posN.x -= offNP.x * FXAA_QUALITY_P12;
														if(!doneN) posN.y -= offNP.y * FXAA_QUALITY_P12;
														doneNP = (!doneN) || (!doneP);
														if(!doneP) posP.x += offNP.x * FXAA_QUALITY_P12;
														if(!doneP) posP.y += offNP.y * FXAA_QUALITY_P12;
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
				#endif
		/*--------------------------------------------------------------------------*/
														}
														#endif
		/*--------------------------------------------------------------------------*/
												}
												#endif
		/*--------------------------------------------------------------------------*/
										}
										#endif
		/*--------------------------------------------------------------------------*/
								}
								#endif
		/*--------------------------------------------------------------------------*/
						}
						#endif
		/*--------------------------------------------------------------------------*/
				}
		/*--------------------------------------------------------------------------*/
				FxaaFloat dstN = posM.x - posN.x;
				FxaaFloat dstP = posP.x - posM.x;
				if(!horzSpan) dstN = posM.y - posN.y;
				if(!horzSpan) dstP = posP.y - posM.y;
		/*--------------------------------------------------------------------------*/
				FxaaBool goodSpanN = (lumaEndN < 0.0) != lumaMLTZero;
				FxaaFloat spanLength = (dstP + dstN);
				FxaaBool goodSpanP = (lumaEndP < 0.0) != lumaMLTZero;
				FxaaFloat spanLengthRcp = 1.0/spanLength;
		/*--------------------------------------------------------------------------*/
				FxaaBool directionN = dstN < dstP;
				FxaaFloat dst = min(dstN, dstP);
				FxaaBool goodSpan = directionN ? goodSpanN : goodSpanP;
				FxaaFloat subpixG = subpixF * subpixF;
				FxaaFloat pixelOffset = (dst * (-spanLengthRcp)) + 0.5;
				FxaaFloat subpixH = subpixG * fxaaQualitySubpix;
		/*--------------------------------------------------------------------------*/
				FxaaFloat pixelOffsetGood = goodSpan ? pixelOffset : 0.0;
				FxaaFloat pixelOffsetSubpix = max(pixelOffsetGood, subpixH);
				if(!horzSpan) posM.x += pixelOffsetSubpix * lengthSign;
				if( horzSpan) posM.y += pixelOffsetSubpix * lengthSign;
				#if (FXAA_DISCARD == 1)
						return FxaaTexTop(tex, posM);
				#else
						return FxaaFloat4(FxaaTexTop(tex, posM).xyz, lumaM);
				#endif
		}
		/*==========================================================================*/
		#endif

		void main() {
			gl_FragColor = FxaaPixelShader(
				vUv,
				vec4(0.0),
				tDiffuse,
				tDiffuse,
				tDiffuse,
				resolution,
				vec4(0.0),
				vec4(0.0),
				vec4(0.0),
				0.75,
				0.166,
				0.0833,
				0.0,
				0.0,
				0.0,
				vec4(0.0)
			);

			// TODO avoid querying texture twice for same texel
			gl_FragColor.a = texture2D(tDiffuse, vUv).a;
		}`

};


THREE.CopyShader = {

	uniforms: {

		'tDiffuse': { value: null },
		'opacity': { value: 1.0 }

	},

	vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,

	fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );
			gl_FragColor = opacity * texel;

		}`

};


(function (a) {
    function b(a) {
        return !isNaN(a) && isFinite(a)
    }

    function c(a, b) {
        for (var c = 0, d = a.length; c < d; c++)if (a[c] === b)return c;
        return -1
    }

    a.Octree = function (c) {
        c = c || {};
        this.nodeCount = 0;
        this.INDEX_INSIDE_CROSS = -1;
        this.INDEX_OUTSIDE_OFFSET = 2;
        this.INDEX_OUTSIDE_POS_X = b(c.INDEX_OUTSIDE_POS_X) ? c.INDEX_OUTSIDE_POS_X : 0;
        this.INDEX_OUTSIDE_NEG_X = b(c.INDEX_OUTSIDE_NEG_X) ? c.INDEX_OUTSIDE_NEG_X : 1;
        this.INDEX_OUTSIDE_POS_Y = b(c.INDEX_OUTSIDE_POS_Y) ? c.INDEX_OUTSIDE_POS_Y : 2;
        this.INDEX_OUTSIDE_NEG_Y = b(c.INDEX_OUTSIDE_NEG_Y) ?
            c.INDEX_OUTSIDE_NEG_Y : 3;
        this.INDEX_OUTSIDE_POS_Z = b(c.INDEX_OUTSIDE_POS_Z) ? c.INDEX_OUTSIDE_POS_Z : 4;
        this.INDEX_OUTSIDE_NEG_Z = b(c.INDEX_OUTSIDE_NEG_Z) ? c.INDEX_OUTSIDE_NEG_Z : 5;
        this.INDEX_OUTSIDE_MAP = [];
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_X] = {
            index: this.INDEX_OUTSIDE_POS_X,
            count: 0,
            x: 1,
            y: 0,
            z: 0
        };
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_X] = {
            index: this.INDEX_OUTSIDE_NEG_X,
            count: 0,
            x: -1,
            y: 0,
            z: 0
        };
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Y] = {
            index: this.INDEX_OUTSIDE_POS_Y,
            count: 0,
            x: 0,
            y: 1,
            z: 0
        };
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Y] = {
            index: this.INDEX_OUTSIDE_NEG_Y,
            count: 0,
            x: 0,
            y: -1,
            z: 0
        };
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_POS_Z] = {
            index: this.INDEX_OUTSIDE_POS_Z,
            count: 0,
            x: 0,
            y: 0,
            z: 1
        };
        this.INDEX_OUTSIDE_MAP[this.INDEX_OUTSIDE_NEG_Z] = {
            index: this.INDEX_OUTSIDE_NEG_Z,
            count: 0,
            x: 0,
            y: 0,
            z: -1
        };
        this.FLAG_POS_X = 1 << this.INDEX_OUTSIDE_POS_X + 1;
        this.FLAG_NEG_X = 1 << this.INDEX_OUTSIDE_NEG_X + 1;
        this.FLAG_POS_Y = 1 << this.INDEX_OUTSIDE_POS_Y + 1;
        this.FLAG_NEG_Y = 1 << this.INDEX_OUTSIDE_NEG_Y + 1;
        this.FLAG_POS_Z =
            1 << this.INDEX_OUTSIDE_POS_Z + 1;
        this.FLAG_NEG_Z = 1 << this.INDEX_OUTSIDE_NEG_Z + 1;
        this.utilVec31Search = new a.Vector3;
        this.utilVec32Search = new a.Vector3;
        if (this.scene = c.scene)this.visualGeometry = new a.BoxBufferGeometry(1, 1, 1), this.visualGeometry.addTriangleOrderAttribute(), this.visualMaterial = new JMT.WireframeMaterial(new a.Color(65280));
        this.depthMax = b(c.depthMax) ? c.depthMax : Infinity;
        this.objectsThreshold = b(c.objectsThreshold) ? c.objectsThreshold : 8;
        this.overlapPct = b(c.overlapPct) ? c.overlapPct : .15;
        this.root =
            new a.OctreeNode({tree: this, parent: null, position: new a.Vector3})
    };
    a.Octree.prototype = {
        add: function (b, c, d) {
            this.root.addObject(new a.OctreeObjectData(b, c, d))
        }, search: function (b, c, d) {
            var f, e = [];
            this.root.appendObjectsFromNode(e);
            0 < c || (c = Number.MAX_VALUE);
            if (d instanceof a.Vector3) {
                d = this.utilVec31Search.copy(d).normalize();
                var g = this.utilVec32Search.set(1, 1, 1).divide(d)
            }
            var h = 0;
            for (f = this.root.nodesIndices.length; h < f; h++) {
                var q = this.root.nodesByIndex[this.root.nodesIndices[h]];
                q.search(b, c, d, g, e)
            }
            return e
        },
        setRoot: function (b) {
            b instanceof a.OctreeNode && (this.root = b, this.root.updateProperties())
        }, getDepthEnd: function () {
            return this.root.getDepthEnd()
        }, getNodeCountEnd: function () {
            return this.root.getNodeCountEnd()
        }, getObjectCountEnd: function () {
            return this.root.getObjectCountEnd()
        }, toConsole: function () {
            this.root.toConsole()
        }
    };
    a.OctreeObjectData = function (a, b, c) {
        this.object = a;
        b ? (this.radius = c, this.position = b) : (this.radius = this.object.geometry.boundingSphere.radius, this.position = this.object.geometry.boundingSphere.center)
    };
    var d = new a.Vector3, e = new a.Vector3;
    new a.Vector3;
    a.OctreeNode = function (b) {
        this.tree = b.tree;
        this.id = this.tree.nodeCount++;
        this.position = b.position;
        this.radius = 0 < b.radius ? b.radius : 1;
        this.indexOctant = b.indexOctant;
        this.depth = 0;
        this.reset();
        this.setParent(b.parent);
        this.overlap = this.radius * this.tree.overlapPct;
        this.radiusOverlap = this.radius + this.overlap;
        this.left = this.position.x - this.radiusOverlap;
        this.right = this.position.x + this.radiusOverlap;
        this.bottom = this.position.y - this.radiusOverlap;
        this.top = this.position.y +
            this.radiusOverlap;
        this.back = this.position.z - this.radiusOverlap;
        this.front = this.position.z + this.radiusOverlap;
        this.tree.scene && (this.visual = new a.Mesh(this.tree.visualGeometry, this.tree.visualMaterial), this.visual.scale.set(2 * this.radiusOverlap, 2 * this.radiusOverlap, 2 * this.radiusOverlap), this.visual.position.copy(this.position), this.tree.scene.add(this.visual), this.tree.scene.updateMatrixWorld())
    };
    a.OctreeNode.prototype = {
        setParent: function (a) {
            a !== this && this.parent !== a && (this.parent = a, this.updateProperties())
        },
        updateProperties: function () {
            var b;
            this.parent instanceof a.OctreeNode ? (this.tree = this.parent.tree, this.depth = this.parent.depth + 1) : this.depth = 0;
            var c = 0;
            for (b = this.nodesIndices.length; c < b; c++)this.nodesByIndex[this.nodesIndices[c]].updateProperties()
        }, reset: function (a, b) {
            var c, d = this.nodesIndices || [], f = this.nodesByIndex;
            this.objects = [];
            this.nodesIndices = [];
            this.nodesByIndex = {};
            var e = 0;
            for (c = d.length; e < c; e++) {
                var g = f[d[e]];
                g.setParent(void 0);
                !0 === a && g.reset(a, b)
            }
            !0 === b && this.visual && this.visual.parent &&
            this.visual.parent.remove(this.visual)
        }, addNode: function (a, b) {
            a.indexOctant = b;
            -1 === c(this.nodesIndices, b) && this.nodesIndices.push(b);
            this.nodesByIndex[b] = a;
            a.parent !== this && a.setParent(this)
        }, removeNode: function (a) {
            var b = c(this.nodesIndices, a);
            this.nodesIndices.splice(b, 1);
            var d = d || this.nodesByIndex[a];
            delete this.nodesByIndex[a];
            d.parent === this && d.setParent(void 0)
        }, addObject: function (b) {
            var d = this.getOctantIndex(b);
            -1 < d && 0 < this.nodesIndices.length ? (d = this.branch(d), d.addObject(b)) : -1 > d && this.parent instanceof
            a.OctreeNode ? this.parent.addObject(b) : (d = c(this.objects, b), -1 === d && this.objects.push(b), b.node = this, this.checkGrow())
        }, addObjectWithoutCheck: function (a) {
            var b;
            var c = 0;
            for (b = a.length; c < b; c++) {
                var d = a[c];
                this.objects.push(d);
                d.node = this
            }
        }, checkGrow: function () {
            this.objects.length > this.tree.objectsThreshold && 0 < this.tree.objectsThreshold && this.grow()
        }, grow: function () {
            var a = [], b = [], c = [], d = [], e = [], p;
            var l = 0;
            for (p = this.objects.length; l < p; l++) {
                var q = this.objects[l];
                var r = this.getOctantIndex(q);
                -1 < r ? (c.push(q),
                    d.push(r)) : -1 > r ? (a.push(q), b.push(r)) : e.push(q)
            }
            0 < c.length && (e = e.concat(this.split(c, d)));
            0 < a.length && (e = e.concat(this.expand(a, b)));
            this.objects = e;
            this.checkMerge()
        }, split: function (a, b) {
            var c;
            if (this.depth < this.tree.depthMax) {
                a = a || this.objects;
                b = b || [];
                var d = [];
                var f = 0;
                for (c = a.length; f < c; f++) {
                    var e = a[f];
                    var g = b[f];
                    -1 < g ? (g = this.branch(g), g.addObject(e)) : d.push(e)
                }
                a === this.objects && (this.objects = d)
            } else d = this.objects;
            return d
        }, branch: function (b) {
            if (this.nodesByIndex[b]instanceof a.OctreeNode)var c =
                this.nodesByIndex[b]; else {
                c = .5 * this.radiusOverlap;
                var e = c * this.tree.overlapPct;
                e = c - e;
                e = d.set(b & 1 ? e : -e, b & 2 ? e : -e, b & 4 ? e : -e);
                e = (new a.Vector3).addVectors(this.position, e);
                c = new a.OctreeNode({tree: this.tree, parent: this, position: e, radius: c, indexOctant: b});
                this.addNode(c, b)
            }
            return c
        }, expand: function (b, c) {
            var d, f = this.tree.INDEX_OUTSIDE_MAP;
            if (this.tree.root.getDepthEnd() < this.tree.depthMax) {
                b = b || this.objects;
                c = c || [];
                var g = [];
                var p = [];
                var l = 0;
                for (d = f.length; l < d; l++)f[l].count = 0;
                l = 0;
                for (d = b.length; l < d; l++) {
                    var q =
                        b[l];
                    var r = c[l];
                    -1 > r ? (r = -r - this.tree.INDEX_OUTSIDE_OFFSET, r & this.tree.FLAG_POS_X ? f[this.tree.INDEX_OUTSIDE_POS_X].count++ : r & this.tree.FLAG_NEG_X && f[this.tree.INDEX_OUTSIDE_NEG_X].count++, r & this.tree.FLAG_POS_Y ? f[this.tree.INDEX_OUTSIDE_POS_Y].count++ : r & this.tree.FLAG_NEG_Y && f[this.tree.INDEX_OUTSIDE_NEG_Y].count++, r & this.tree.FLAG_POS_Z ? f[this.tree.INDEX_OUTSIDE_POS_Z].count++ : r & this.tree.FLAG_NEG_Z && f[this.tree.INDEX_OUTSIDE_NEG_Z].count++, p.push(q)) : g.push(q)
                }
                if (0 < p.length) {
                    var m = f.slice(0);
                    m.sort(function (a,
                                     b) {
                        return b.count - a.count
                    });
                    r = m[0];
                    l = r.index | 1;
                    q = m[1];
                    f = m[2];
                    c = (q.index | 1) !== l ? q : f;
                    d = c.index | 1;
                    q = m[2];
                    f = m[3];
                    m = m[4];
                    var u = q.index | 1;
                    var x = f.index | 1;
                    q = u !== l && u !== d ? q : x !== l && x !== d ? f : m;
                    l = r.x + c.x + q.x;
                    d = r.y + c.y + q.y;
                    c = r.z + c.z + q.z;
                    r = this.getOctantIndexFromPosition(l, d, c);
                    c = this.getOctantIndexFromPosition(-l, -d, -c);
                    d = this.overlap;
                    q = this.radius;
                    l = 0 < this.tree.overlapPct ? d / (.5 * this.tree.overlapPct * (1 + this.tree.overlapPct)) : 2 * q;
                    f = l * this.tree.overlapPct;
                    d = l + f - (q + d);
                    e.set(r & 1 ? d : -d, r & 2 ? d : -d, r & 4 ? d : -d);
                    r = (new a.Vector3).addVectors(this.position,
                        e);
                    r = new a.OctreeNode({tree: this.tree, position: r, radius: l});
                    r.addNode(this, c);
                    this.tree.setRoot(r);
                    l = 0;
                    for (d = p.length; l < d; l++)this.tree.root.addObject(p[l])
                }
                b === this.objects && (this.objects = g)
            } else g = b;
            return g
        }, shrink: function () {
            this.checkMerge();
            this.tree.root.checkContract()
        }, checkMerge: function () {
            for (var b = this, c; b.parent instanceof a.OctreeNode && b.getObjectCountEnd() < this.tree.objectsThreshold;)c = b, b = b.parent;
            b !== this && b.merge(c)
        }, merge: function (a) {
            var b;
            a = a ? "[object Array]" === Object.prototype.toString.call(a) !== !0 ? [a] : a : [];
            var c = 0;
            for (b = a.length; c < b; c++) {
                var d = a[c];
                this.addObjectWithoutCheck(d.getObjectsEnd());
                d.reset(!0, !0);
                this.removeNode(d.indexOctant, d)
            }
            this.checkMerge()
        }, checkContract: function () {
            var b;
            if (0 < this.nodesIndices.length) {
                var c = 0;
                var d = this.objects.length;
                var e = 0;
                for (b = this.nodesIndices.length; e < b; e++) {
                    var n = this.nodesByIndex[this.nodesIndices[e]];
                    var p = n.getObjectCountEnd();
                    d += p;
                    if (!1 === l instanceof a.OctreeNode || p > c) {
                        var l = n;
                        c = p
                    }
                }
                d - c < this.tree.objectsThreshold && l instanceof a.OctreeNode &&
                this.contract(l)
            }
        }, contract: function (a) {
            var b;
            var c = 0;
            for (b = this.nodesIndices.length; c < b; c++) {
                var d = this.nodesByIndex[this.nodesIndices[c]];
                d !== a && (a.addObjectWithoutCheck(d.getObjectsEnd()), d.reset(!0, !0))
            }
            a.addObjectWithoutCheck(this.objects);
            this.reset(!1, !0);
            this.tree.setRoot(a);
            a.checkContract()
        }, getOctantIndex: function (b) {
            var c = this.position, d = this.radiusOverlap, e = this.overlap, g = 0;
            if (b instanceof a.OctreeObjectData) {
                var p = b.radius;
                var l = b.position
            } else b instanceof a.OctreeNode && (l = b.position,
                p = 0);
            var q = l.x - c.x;
            var r = l.y - c.y;
            l = l.z - c.z;
            c = Math.abs(q);
            var m = Math.abs(r);
            var u = Math.abs(l);
            if (Math.max(c, m, u) + p > d)return c + p > d && (g ^= 0 < q ? this.tree.FLAG_POS_X : this.tree.FLAG_NEG_X), m + p > d && (g ^= 0 < r ? this.tree.FLAG_POS_Y : this.tree.FLAG_NEG_Y), u + p > d && (g ^= 0 < l ? this.tree.FLAG_POS_Z : this.tree.FLAG_NEG_Z), b.indexOctant = -g - this.tree.INDEX_OUTSIDE_OFFSET, b.indexOctant;
            if (q - p > -e)g |= 1; else if (!(q + p < e))return b.indexOctant = this.tree.INDEX_INSIDE_CROSS, b.indexOctant;
            if (r - p > -e)g |= 2; else if (!(r + p < e))return b.indexOctant =
                this.tree.INDEX_INSIDE_CROSS, b.indexOctant;
            if (l - p > -e)g |= 4; else if (!(l + p < e))return b.indexOctant = this.tree.INDEX_INSIDE_CROSS, b.indexOctant;
            b.indexOctant = g;
            return b.indexOctant
        }, getOctantIndexFromPosition: function (a, b, c) {
            var d = 0;
            0 < a && (d |= 1);
            0 < b && (d |= 2);
            0 < c && (d |= 4);
            return d
        }, appendObjectsFromNode: function (a) {
            var b, c = this.objects;
            var d = 0;
            for (b = c.length; d < b; d += 1)a.push(c[d].object)
        }, search: function (a, b, c, d, e) {
            var f;
            if (!0 === this.intersectRay(a, c, b, d)) {
                this.appendObjectsFromNode(e);
                var g = 0;
                for (f = this.nodesIndices.length; g <
                f; g++) {
                    var k = this.nodesByIndex[this.nodesIndices[g]];
                    k.search(a, b, c, d, e)
                }
            }
        }, intersectRay: function (a, b, c, d) {
            b = (this.left - a.x) * d.x;
            var e = (this.right - a.x) * d.x, f = (this.bottom - a.y) * d.y, g = (this.top - a.y) * d.y, k = (this.back - a.z) * d.z;
            d = (this.front - a.z) * d.z;
            a = Math.min(Math.min(Math.max(b, e), Math.max(f, g)), Math.max(k, d));
            if (0 > a)return !1;
            b = Math.max(Math.max(Math.min(b, e), Math.min(f, g)), Math.min(k, d));
            return b > a || b > c ? !1 : !0
        }, getDepthEnd: function (a) {
            var b;
            if (0 < this.nodesIndices.length) {
                var c = 0;
                for (b = this.nodesIndices.length; c <
                b; c++) {
                    var d = this.nodesByIndex[this.nodesIndices[c]];
                    a = d.getDepthEnd(a)
                }
            } else a = !a || this.depth > a ? this.depth : a;
            return a
        }, getNodeCountEnd: function () {
            return this.tree.root.getNodeCountRecursive() + 1
        }, getNodeCountRecursive: function () {
            var a, b = this.nodesIndices.length;
            var c = 0;
            for (a = this.nodesIndices.length; c < a; c++)b += this.nodesByIndex[this.nodesIndices[c]].getNodeCountRecursive();
            return b
        }, getObjectsEnd: function (a) {
            var b;
            a = (a || []).concat(this.objects);
            var c = 0;
            for (b = this.nodesIndices.length; c < b; c++) {
                var d =
                    this.nodesByIndex[this.nodesIndices[c]];
                a = d.getObjectsEnd(a)
            }
            return a
        }, getObjectCountEnd: function () {
            var a, b = this.objects.length;
            var c = 0;
            for (a = this.nodesIndices.length; c < a; c++)b += this.nodesByIndex[this.nodesIndices[c]].getObjectCountEnd();
            return b
        }, getObjectCountStart: function () {
            for (var b = this.objects.length, c = this.parent; c instanceof a.OctreeNode;)b += c.objects.length, c = c.parent;
            return b
        }, toConsole: function (a) {
            var b;
            a = "string" === typeof a ? a : "   ";
            console.log(this.parent ? a + " octree NODE > " : " octree ROOT > ",
                this, " // id: ", this.id, " // indexOctant: ", this.indexOctant, " // position: ", this.position.x, this.position.y, this.position.z, " // radius: ", this.radius, " // depth: ", this.depth);
            console.log(this.parent ? a + " " : " ", "+ objects ( ", this.objects.length, " ) ", this.objects);
            console.log(this.parent ? a + " " : " ", "+ children ( ", this.nodesIndices.length, " )", this.nodesIndices, this.nodesByIndex);
            var c = 0;
            for (b = this.nodesIndices.length; c < b; c++) {
                var d = this.nodesByIndex[this.nodesIndices[c]];
                d.toConsole(a + "   ")
            }
        }
    }
})(THREE);

( function () {

	class EffectComposer {

		constructor( renderer, renderTarget ) {

			this.renderer = renderer;

			if ( renderTarget === undefined ) {

				const parameters = {
					minFilter: THREE.LinearFilter,
					magFilter: THREE.LinearFilter,
					format: THREE.RGBAFormat
				};
				const size = renderer.getSize( new THREE.Vector2() );
				this._pixelRatio = renderer.getPixelRatio();
				this._width = size.width;
				this._height = size.height;
				renderTarget = new THREE.WebGLRenderTarget( this._width * this._pixelRatio, this._height * this._pixelRatio, parameters );
				renderTarget.texture.name = 'EffectComposer.rt1';

			} else {

				this._pixelRatio = 1;
				this._width = renderTarget.width;
				this._height = renderTarget.height;

			}

			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();
			this.renderTarget2.texture.name = 'EffectComposer.rt2';
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;
			this.renderToScreen = true;
			this.passes = []; // dependencies

			if ( THREE.CopyShader === undefined ) {

				console.error( 'THREE.EffectComposer relies on THREE.CopyShader' );

			}

			if ( THREE.ShaderPass === undefined ) {

				console.error( 'THREE.EffectComposer relies on THREE.ShaderPass' );

			}

			this.copyPass = new THREE.ShaderPass( THREE.CopyShader );
			this.clock = new THREE.Clock();

		}

		swapBuffers() {

			const tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;

		}

		addPass( pass ) {

			this.passes.push( pass );
			pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		insertPass( pass, index ) {

			this.passes.splice( index, 0, pass );
			pass.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

		}

		removePass( pass ) {

			const index = this.passes.indexOf( pass );

			if ( index !== - 1 ) {

				this.passes.splice( index, 1 );

			}

		}

		isLastEnabledPass( passIndex ) {

			for ( let i = passIndex + 1; i < this.passes.length; i ++ ) {

				if ( this.passes[ i ].enabled ) {

					return false;

				}

			}

			return true;

		}

		render( deltaTime ) {

			// deltaTime value is in seconds
			if ( deltaTime === undefined ) {

				deltaTime = this.clock.getDelta();

			}

			const currentRenderTarget = this.renderer.getRenderTarget();
			let maskActive = false;

			for ( let i = 0, il = this.passes.length; i < il; i ++ ) {

				const pass = this.passes[ i ];
				if ( pass.enabled === false ) continue;
				pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass( i );
				pass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive );

				if ( pass.needsSwap ) {

					if ( maskActive ) {

						const context = this.renderer.getContext();
						const stencil = this.renderer.state.buffers.stencil; //context.stencilFunc( context.NOTEQUAL, 1, 0xffffffff );

						stencil.setFunc( context.NOTEQUAL, 1, 0xffffffff );
						this.copyPass.render( this.renderer, this.writeBuffer, this.readBuffer, deltaTime ); //context.stencilFunc( context.EQUAL, 1, 0xffffffff );

						stencil.setFunc( context.EQUAL, 1, 0xffffffff );

					}

					this.swapBuffers();

				}

				if ( THREE.MaskPass !== undefined ) {

					if ( pass instanceof THREE.MaskPass ) {

						maskActive = true;

					} else if ( pass instanceof THREE.ClearMaskPass ) {

						maskActive = false;

					}

				}

			}

			this.renderer.setRenderTarget( currentRenderTarget );

		}

		reset( renderTarget ) {

			if ( renderTarget === undefined ) {

				const size = this.renderer.getSize( new THREE.Vector2() );
				this._pixelRatio = this.renderer.getPixelRatio();
				this._width = size.width;
				this._height = size.height;
				renderTarget = this.renderTarget1.clone();
				renderTarget.setSize( this._width * this._pixelRatio, this._height * this._pixelRatio );

			}

			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();
			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;

		}

		setSize( width, height ) {

			this._width = width;
			this._height = height;
			const effectiveWidth = this._width * this._pixelRatio;
			const effectiveHeight = this._height * this._pixelRatio;
			this.renderTarget1.setSize( effectiveWidth, effectiveHeight );
			this.renderTarget2.setSize( effectiveWidth, effectiveHeight );

			for ( let i = 0; i < this.passes.length; i ++ ) {

				this.passes[ i ].setSize( effectiveWidth, effectiveHeight );

			}

		}

		setPixelRatio( pixelRatio ) {

			this._pixelRatio = pixelRatio;
			this.setSize( this._width, this._height );

		}

	}

	class Pass {

		constructor() {

			// if set to true, the pass is processed by the composer
			this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

			this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

			this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

			this.renderToScreen = false;

		}

		setSize( ) {}

		render( ) {

			console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

		}

	} // Helper for passes that need to fill the viewport with a single quad.


	const _camera = new THREE.OrthographicCamera( - 1, 1, 1, - 1, 0, 1 ); // https://github.com/mrdoob/three.js/pull/21358


	const _geometry = new THREE.BufferGeometry();

	_geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );

	_geometry.setAttribute( 'uv', new THREE.Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );

	class FullScreenQuad {

		constructor( material ) {

			this._mesh = new THREE.Mesh( _geometry, material );

		}

		dispose() {

			this._mesh.geometry.dispose();

		}

		render( renderer ) {

			renderer.render( this._mesh, _camera );

		}

		get material() {

			return this._mesh.material;

		}

		set material( value ) {

			this._mesh.material = value;

		}

	}

	THREE.EffectComposer = EffectComposer;
	THREE.FullScreenQuad = FullScreenQuad;
	THREE.Pass = Pass;

} )();

//ShaderPass
( function () {

	class ShaderPass extends THREE.Pass {

		constructor( shader, textureID ) {

			super();
			this.textureID = textureID !== undefined ? textureID : 'tDiffuse';

			if ( shader instanceof THREE.ShaderMaterial ) {

				this.uniforms = shader.uniforms;
				this.material = shader;

			} else if ( shader ) {

				this.uniforms = THREE.UniformsUtils.clone( shader.uniforms );
				this.material = new THREE.ShaderMaterial( {
					defines: Object.assign( {}, shader.defines ),
					uniforms: this.uniforms,
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				} );

			}

			this.fsQuad = new THREE.FullScreenQuad( this.material );

		}

		render( renderer, writeBuffer, readBuffer
			/*, deltaTime, maskActive */
		) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer.texture;

			}

			this.fsQuad.material = this.material;

			if ( this.renderToScreen ) {

				renderer.setRenderTarget( null );
				this.fsQuad.render( renderer );

			} else {

				renderer.setRenderTarget( writeBuffer ); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

				if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
				this.fsQuad.render( renderer );

			}

		}

	}

	THREE.ShaderPass = ShaderPass;

} )();

//RenderPass
( function () {

	class RenderPass extends THREE.Pass {

		constructor( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

			super();
			this.scene = scene;
			this.camera = camera;
			this.overrideMaterial = overrideMaterial;
			this.clearColor = clearColor;
			this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
			this.clear = true;
			this.clearDepth = false;
			this.needsSwap = false;
			this._oldClearColor = new THREE.Color();

		}

		render( renderer, writeBuffer, readBuffer
			/*, deltaTime, maskActive */
		) {

			const oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;
			let oldClearAlpha, oldOverrideMaterial;

			if ( this.overrideMaterial !== undefined ) {

				oldOverrideMaterial = this.scene.overrideMaterial;
				this.scene.overrideMaterial = this.overrideMaterial;

			}

			if ( this.clearColor ) {

				renderer.getClearColor( this._oldClearColor );
				oldClearAlpha = renderer.getClearAlpha();
				renderer.setClearColor( this.clearColor, this.clearAlpha );

			}

			if ( this.clearDepth ) {

				renderer.clearDepth();

			}

			renderer.setRenderTarget( this.renderToScreen ? null : readBuffer ); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			renderer.render( this.scene, this.camera );

			if ( this.clearColor ) {

				renderer.setClearColor( this._oldClearColor, oldClearAlpha );

			}

			if ( this.overrideMaterial !== undefined ) {

				this.scene.overrideMaterial = oldOverrideMaterial;

			}

			renderer.autoClear = oldAutoClear;

		}

	}

	THREE.RenderPass = RenderPass;

} )();


/***/ }),

/***/ "./src/extend/j3dWebGLRendererUtil.js":
/*!********************************************!*\
  !*** ./src/extend/j3dWebGLRendererUtil.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dWebGLRendererUtil": function() { return /* binding */ j3dWebGLRendererUtil; }
/* harmony export */ });
/**
 * #Created by: Jimuyida Martian
 * scene-mesh material
 * Date 2022/3/31
 */


function j3dWebGLRendererUtil(renderer) {

    let _tempCRT = undefined
    let gl = renderer.getContext();
    let state = renderer.state
    let properties = renderer.properties;
    

    //创建并初始化一个 CubeTexture
    function createCubeTexture(size, generateMipmaps, format = THREE.RGBAFormat) {
        //threejs 并没有暴露初始化CubeTexture的方法，这里将其伪装成 WebGLCubeRenderTarget
        //利用RT的初始化功能来进行初始化

        if (undefined == _tempCRT)
            _tempCRT = new THREE.WebGLCubeRenderTarget(size, { stencilBuffer: false })

        let texture = _tempCRT.texture ? _tempCRT.texture : new THREE.CubeTexture();
        _tempCRT.width = size;
		_tempCRT.height = size;
        
        _tempCRT.texture = texture
        texture.generateMipmaps = generateMipmaps;
        
        if (texture.generateMipmaps) {
            texture.magFilter = THREE.LinearFilter
            texture.minFilter = THREE.LinearMipMapLinearFilter
        }
        else {
            texture.magFilter = THREE.LinearFilter
            texture.minFilter = THREE.LinearFilter
        }

        texture.format = format;
        renderer.setRenderTarget(_tempCRT);
        renderer.setRenderTarget(null);
        
        //清空
        //注意, 这里创建的texture可能需要手动释放
        _tempCRT.texture = null

        //拿出来瞧瞧
        //const textureProperties = properties.get(texture);
        //textureProperties.__image__webglTextureCube = textureProperties.__webglTexture;
        return texture
    }

    //拷贝数据到,把RGBA数据上传到纹理
    function copyBufferToCubeFaceMip(level, size, face, pixels, texture) {
        
        if (!texture.isCubeTexture) return;

        const textureProperties = properties.get(texture);
        if (textureProperties && textureProperties.__webglTexture) {

            state.activeTexture(gl.TEXTURE0);
            state.bindTexture(gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            //gl.bindTexture(gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, level, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
            state.unbindTexture();

        }
       
    };

    //删除纹理
    function deleteTextureFromGpu(texture) {

        const textureProperties = properties.get(texture);
        if (textureProperties && textureProperties.__webglTexture) {
            gl.deleteTexture(textureProperties.__webglTexture)
        }
      
    }

    //读取当前帧缓存中的数据
    function readPixels(width, height, buffer){
        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, buffer)
    }

    return {
		createCubeTexture: createCubeTexture,
		copyBufferToCubeFaceMip: copyBufferToCubeFaceMip,
		deleteTextureFromGpu: deleteTextureFromGpu,
        readPixels: readPixels
		// dispose: dispose
	};
}


JMT.j3dWebGLRendererUtil = j3dWebGLRendererUtil


/***/ }),

/***/ "./src/extend/lights/j3dCubeMapFilterShader.js":
/*!*****************************************************!*\
  !*** ./src/extend/lights/j3dCubeMapFilterShader.js ***!
  \*****************************************************/
/***/ (function() {

/**
 * #Created by: Jimuyida Martian
 * light_probe's shader
 * Date 2022/3/31
 */

 JMT.j3dCubeMapFilterShader = {
    uniforms: {
        gloss: {type: "f", value: .9},
        face: {type: "f", value: 0},
        mipSize: {type: "f", value: 128},
        envMap: {type: "t", value: null}
    },

    vertexShader: JMT.getShader("cubemap_filter_vertex.glsl").code,
    fragmentShader: JMT.getShader("cubemap_filter_fragment.glsl").code
}

/***/ }),

/***/ "./src/extend/lights/j3dLightProbeMaker.js":
/*!*************************************************!*\
  !*** ./src/extend/lights/j3dLightProbeMaker.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _materials_AabbQueryMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../materials/AabbQueryMaterial.js */ "./src/materials/AabbQueryMaterial.js");
/* harmony import */ var _j3dCubeMapFilterShader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./j3dCubeMapFilterShader.js */ "./src/extend/lights/j3dCubeMapFilterShader.js");
/* harmony import */ var _j3dCubeMapFilterShader_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_j3dCubeMapFilterShader_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../cameras/CubeCamera.js */ "./src/cameras/CubeCamera.js");
/* harmony import */ var _cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_cameras_CubeCamera_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _j3dObjectDistanceQuery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./j3dObjectDistanceQuery.js */ "./src/extend/lights/j3dObjectDistanceQuery.js");
/* harmony import */ var _j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../j3dWebGLRendererUtil.js */ "./src/extend/j3dWebGLRendererUtil.js");
/**
 * #Created by: Jimuyida Martian
 */










function a(a, b) {
    b = b.target;
    a.deleteTexture(b.__webglTexture);
    b.__webglTexture = null;
    b.image = null
}

function readBuffer(renderer, size, buf) {
    let gl = renderer.getContext()

    for (var d = !0; d;) {

        gl.readPixels(0, 0, size, size, gl.RGBA, gl.UNSIGNED_BYTE, buf)
        for (var e = 0; e < size * size * 4; e += 4)
            if (0 !== buf[e] || 0 !== buf[e + 1] || 0 !== buf[e + 2]) {
                d = !1;
                break
            }

        if (d) {
            console.warn("Cube face has all pixels black.");
            break
        }
    }
}

function configureMaterial(configure, b) {
    var c = new Set;
    configure.traverse(function (a) {
        if (a instanceof THREE.Mesh && a.visible) {
            var d = a.material;
            if (a.userData.hideFromLightProbes || d.hideFromLightProbes) {
                (b.add(a), a.visible = !1)
            }
            else if (!c.has(d)) {
                c.add(d)
                if (d.configureTransparency) {
                    d.transparent = !1
                    d.blending = THREE.NoBlending
                    d.depthWrite = !0
                }
                void 0 !== d.hdrOutput && (d.hdrOutput = !0)
                void 0 !== d.specularOff && (d.specularOff += 1)
            }
        }
    });
    c = null
}

function restoreMaterial(threeScene, b) {
    var c = new Set;
    threeScene.traverse(function (a) {
        if (a instanceof THREE.Mesh) {
            var d = a.material;
            d.forceObjectUniformsRefresh && d.forceObjectUniformsRefresh();
            if (a.visible) {
                if (!c.has(d)) {
                    c.add(d)
                    void 0 !== d.hdrOutput && (d.hdrOutput = !1)
                    d.configureTransparency && d.configureTransparency()
                    void 0 !== d.specularOff && --d.specularOff
                }
            }
            else if (b.has(a)) {
                a.visible = !0
            }
        }
    });
    c = null
}

function j3dLightProbeMapHelper(renderer, appScene) {
  
    var options = {
        format : THREE.RGBAFormat,
        magFilter : THREE.LinearFilter,
        minFilter : THREE.LinearFilter,
        stencilBuffer : false,
        generateMipmaps : false
    }

    this.renderer = renderer;

    this.scene = appScene;

    this.threeScene = appScene.threeScene;

    this.aabbQueryMaterial = new JMT.AabbQueryMaterial;

    this.filterPass = new THREE.ShaderPass(JMT.j3dCubeMapFilterShader, "envMap");

    let size = JMT.LIGHT_PROBE_MAX_MIP_SIZE;

    this.pixelBuf = new Uint8Array(size * size * 4);

    this.targetCubeRaw = new THREE.WebGLCubeRenderTarget(size, options)

    options.depthBuffer = false;
    this.targetFiltered = new THREE.WebGLRenderTarget(size, size, options);


    this.autoClearAlter = new JMT.AutoClearAlter(renderer);

    this.dispose = function () {
        this.targetCubeRaw.dispose();
        this.targetFiltered.dispose();
        this.aabbQueryMaterial.dispose();
        this.filterPass.material.dispose();
        this.pixelBuf = null
    }
}

j3dLightProbeMapHelper.prototype.constructor = j3dLightProbeMapHelper;

function g(a, b) {

    var c = b.geometry.boundingSphere.center;

    if (null === b.lightProbe ||
        c.distanceTo(a.position) < c.distanceTo(b.lightProbe.position)) {

        b.lightProbe = a

    }
}

function f(a, b) {
    for (var c = 0; c < b.length; c += 1)
        g(a, b[c])
}

function h(a, b) {
    JMT.log("No visible light probe found for " + b.length + " objects. Assigning the closest ones.");

    for (var c = 0; c < b.length; c += 1) {

        for (var d = 0; d < a.length; d += 1) {

            g(a[d], b[c])

        }
    }
}

var k = function () {
    var a = null;
    return function (b, c) {
        var d = null, e = 0;
        c *= c;
        console.assert(c < Math.pow(2, 16));
        null === a && (a = new Uint16Array(65536));
        for (var f = 0; f < 4 * c; f += 4)a[256 * b[f] + b[f + 1]] += 1;
        a[0] > .7 * c && (e = a[0]);
        a[0] = 0;
        for (b = 1; b < a.length; b += 1) {
            if (a[b] > e) {
                e = a[b]
                d = Math.floor(b / 256) + b % 256 / 255
            }

            a[b] = 0;
        }
        return d
    }
}()

var n = function () {
    var a = null;
    return function (c, d, e) {
        var f = c.renderer
        var g = c.aabbQueryMaterial
        var h = c.pixelBuf
        var l = c.targetCubeRaw

        null === a && (a = new JMT.OrthoCubeCamera(.01, 255));
        a.position.copy(d.position);
        a.updateMatrixWorld();
        var n;
        for (n = 0; 6 > n; n += 1) {
            l.activeCubeFace = n;
            g.axis = Math.floor(n / 2);
            f.renderMeshes(c.scene.gpuMeshes, g, a.sideCameras[n], l);
            readBuffer(f, l.width, h);
            var p = k(h, l.width);
            if (null === p) {
                JMT.log("failed to find light probe bound");
                break
            }
            switch (n) {
                case 0:
                    e.boxMax.x = d.position.x + p;
                    break;
                case 1:
                    e.boxMin.x = d.position.x - p;
                    break;
                case 2:
                    e.boxMax.y = d.position.y + p;
                    break;
                case 3:
                    e.boxMin.y = d.position.y - p;
                    break;
                case 4:
                    e.boxMax.z = d.position.z + p;
                    break;
                case 5:
                    e.boxMin.z = d.position.z - p
            }
        }
        if (6 !== n) {
            JMT.log("Light probe bounds: X[" + e.boxMin.x.toFixed(2) + ":" + e.boxMax.x.toFixed(2) + "] Y[" + e.boxMin.y.toFixed(2) + ":" + e.boxMax.y.toFixed(2) + "] Z[" + e.boxMin.z.toFixed(2) + ":" + e.boxMax.z.toFixed(2) + "]")
            e.resetBoundingBox()
        }
    }
}();



JMT.j3dLightProbeMaker = function (appScene, webGLRenderer, q, mirrorCubeMaps, isEditor) {    // r, m

    let webglUtils = new _j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_5__.j3dWebGLRendererUtil(webGLRenderer)

    function generateEnvMap(lightProbe, d) {
        z.position.copy(lightProbe.position);
        z.updateMatrixWorld();
        var e;
        if ((e = mirrorCubeMaps) && !(e = isEditor)) {
            a:{
                for (var f = 0; f < appScene.gpuMeshes.length; f += 1) {
                    var k = appScene.gpuMeshes[f];
                    if (k.lightProbe === lightProbe && k.material.envMapMirror) {
                        e = !0;
                        break a
                    }
                }
                e = !1
            }
        }
        (f = e) && JMT.log("Mirror texture needed for the light probe.");
        w.reset();
        let _currRT = v.renderer.getRenderTarget();
        v.autoClearAlter.set(!0, !0, !1);
        if (f) {
            
            var h = JMT.LIGHT_PROBE_MIRROR_SIZE;
            h = new THREE.WebGLCubeRenderTarget(h, {
                format : THREE.RGBAFormat,
                magFilter : THREE.LinearFilter,
                minFilter : THREE.LinearFilter,
                stencilBuffer: false,
                generateMipmaps : false
            })
            for (k = 0; 6 > k; k += 1) {
                v.renderer.setRenderTarget(h, k);
                v.renderer.render(v.threeScene, z.sideCameras[k])
            }

            // let gl = v.renderer.getContext();
            // k = new THREE.Texture();
            // k.minFilter = THREE.LinearFilter
            // k.generateMipmaps = false;
            // k.needsUpdate = false;
            // k.isCube = true;
            // k.addEventListener("dispose", a.bind(void 0, gl));
            // k.__webglTexture = h.__webglTexture;
            // h.__webglTexture = null;
            // h.dispose();
            // h = k;
            //lightProbe.setMirrorTexture(h.texture)

            lightProbe.setMirrorTexture(h.texture)
            //h.texture.addEventListener("dispose", a.bind(void 0, gl))
            h = null;
        }

        if (d) {
            n(v, z, lightProbe);
        }

        for (k = 0; 6 > k; k += 1) {
            v.renderer.setRenderTarget(v.targetCubeRaw, k)
            v.renderer.render(v.threeScene, z.sideCameras[k]);
        }

        v.autoClearAlter.restore();
        //v.renderer.enableScissorTest(true);
        v.renderer.setScissorTest(true);
        v.autoClearAlter.set(false, false, false);
        if (q) {
            h = webglUtils.createCubeTexture(v.targetFiltered.width, true)
            lightProbe.setFilteredTexture(h)
        }
      
        for (d = 0; d < JMT.LIGHT_PROBE_MIPS_COUNT; d += 1) {
            f = d;
            let size = Math.pow(2, (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.log2)(v.targetFiltered.width) - f);
            v.renderer.setScissor(0, 0, size, size);
            v.filterPass.uniforms.mipSize.value = size;
            v.filterPass.uniforms.gloss.value = JMT.LIGHT_PROBE_GLOSS_FOR_MIP[d];
            if (!q) {
                
                h = webglUtils.createCubeTexture(size, false)
                lightProbe.setFilteredTextureNoLod(h, d)
            }

            var pixelBuf = v.pixelBuf
            let level = q ? d : 0
            let texture = h;
            if (JMT.DEBUG_LIGHT_PROBE_MIPS) {
                var A = pixelBuf
                var y = 255 * t / JMT.LIGHT_PROBE_MIPS_COUNT
                for (var D = 0; D < 4 * f * f; D += 4) {
                    A[D] = y
                    A[D + 1] = y
                    A[D + 2] = y
                    A[D + 3] = 31.875;
                }
            }

            for (let A = 0; 6 > A; A += 1) {
                if (!JMT.DEBUG_LIGHT_PROBE_MIPS) {
                    v.filterPass.uniforms.face.value = A
                    v.filterPass.render(v.renderer, v.targetFiltered, v.targetCubeRaw)
                    readBuffer(v.renderer, size, pixelBuf)
                }
                //level, size, face, pixels, texture
                webglUtils.copyBufferToCubeFaceMip(level, size, A, pixelBuf, texture)
            }
        }
        v.renderer.setScissorTest(false);
        v.autoClearAlter.restore();
        v.renderer.setRenderTarget(_currRT);

        JMT.log("Cube generation time " + w.elapsedSec())
    }

    var objDistanceQuery, threeScene = appScene.threeScene
    var v = new j3dLightProbeMapHelper(webGLRenderer, appScene)
    var w = new JMT.Timer, 
    z = new JMT.CubeCamera(.15, appScene.camera.far);
    this.assignLightProbesToObjects = function () {
        
        w.reset();

        if (undefined == objDistanceQuery) {
            objDistanceQuery = new _j3dObjectDistanceQuery_js__WEBPACK_IMPORTED_MODULE_4__.j3dObjectDistanceQuery(webGLRenderer, appScene.gpuMeshes, appScene.camera.far)
        }
        
        for (var a = 0; a < appScene.gpuMeshes.length; a += 1) {
            appScene.gpuMeshes[a].lightProbe = null;
        }
        
        for (a = 0; a < appScene.lightProbes.length; a += 1) {

            var b = appScene.lightProbes[a]

            var c = objDistanceQuery.updateCubeMapAndFindVisibleObjects(b.position);
            
            //JMT.log("Have visible objects " + c.length);

            f(b, c)
        }

        JMT.log("Light probe assigment time " + w.elapsedSec());

        h(appScene.lightProbes, (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_3__.filter)(appScene.gpuMeshes, function (a) {
            return null === a.lightProbe
        }))

    };

    this.findBounds = function (a) {
        z.position.copy(a.position);
        z.updateMatrixWorld();
        v.autoClearAlter.set(!0, !0, !1);
        n(v, z, a);
        v.autoClearAlter.restore()
    };

    this.createLightProbeTexture = function (a, b) {
        var e = new Set;
        configureMaterial(threeScene, e);
        generateEnvMap(a, b);
        restoreMaterial(threeScene, e)
    };

    this.createAllLightProbeTextures = function () {
        var a = new Set;
        configureMaterial(threeScene, a);
        for (var b = 0; b < appScene.lightProbes.length; b += 1) {
            generateEnvMap(appScene.lightProbes[b], !1);
        }
        restoreMaterial(threeScene, a)
    };

    this.dispose = function () {
        v.dispose();
        objDistanceQuery && objDistanceQuery.dispose()
    }
}

/***/ }),

/***/ "./src/extend/lights/j3dObjectDistanceQuery.js":
/*!*****************************************************!*\
  !*** ./src/extend/lights/j3dObjectDistanceQuery.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dObjectDistanceQuery": function() { return /* binding */ j3dObjectDistanceQuery; }
/* harmony export */ });
/* harmony import */ var _j3dObjectDistanceReader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dObjectDistanceReader.js */ "./src/extend/lights/j3dObjectDistanceReader.js");
/* harmony import */ var _material_j3dObjectDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../material/j3dObjectDistanceMaterial.js */ "./src/extend/material/j3dObjectDistanceMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */



function j3dObjectDistanceQuery (webGLRenderer, b, c) {
    var d = new _material_j3dObjectDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_1__.j3dObjectDistanceMaterial(!0)
    var cubeCamera = new JMT.CubeCamera(JMT.CAMERA_WALK_NEAR, c);
    let size = JMT.LIGHT_DISTANCE_PROBE_SIZE;
   
    var cubeRenderTarget = new THREE.WebGLRenderTarget(size, size, {
        format: THREE.RGBA,
        magFilter: THREE.NearestFilter,
        minFilter: THREE.NearestFilter,
        type: THREE.HalfFloatType,
        stencilBuffer: false,
        generateMipmaps: false
    })

    var f = new JMT.j3dObjectDistanceReader(webGLRenderer, JMT.OBJECT_VISIBILITY_PROBE_SIZE), 
    h = new JMT.AutoClearAlter(webGLRenderer), 
    k = new JMT.ClearColorAlter(webGLRenderer), 
    n = new THREE.Color(16777215);

    
    
    this.updateCubeMapAndFindVisibleObjects = function (c) {
        var l = [], 
        r = [];
        cubeCamera.position.copy(c);
        cubeCamera.updateMatrixWorld();

        let tempScene = new THREE.Scene();
        tempScene.overrideMaterial = d;
        let backParent = []
        let currentRT_ = webGLRenderer.getRenderTarget();
        
        for (c = 0; c < b.length; c += 1) {
            var m = b[c];
            console.assert(!m.visibilityId);
            m.visibilityId = c;
            
            backParent.push(m.parent)
            tempScene.add(m);
        }
        h.set(!0, !0, !1);
        k.set(n);

        //reset meshes parent
        for (c = 0; c < b.length; c += 1) {
            var m = b[c];
            backParent[c].add(m);
        }

        for (c = 0; 6 > c; c += 1) {
            webGLRenderer.setRenderTarget(cubeRenderTarget, c)
            //webGLRenderer.renderMeshes(q, d, cubeCamera.sideCameras[c]);
            webGLRenderer.render(tempScene, cubeCamera.sideCameras[c])
        }
        k.restore();
        h.restore();
        webGLRenderer.setRenderTarget(currentRT_);
        
        //reset meshes parent
        for (c = 0; c < b.length; c += 1) {
            var m = b[c];
            m.parent = backParent[c]
        }

        let q = f.readCubeMapToBuffer(cubeRenderTarget);
        c = q.length;
        for (m = 0; m < c; m += 4) {
            var p = Math.round(65536 * q[m] + 256 * q[m + 1] + q[m + 2]);
            16777215 !== p && (l[p] = !0)
        }
        for (var x in l) {
            l.hasOwnProperty(x) && r.push(b[x]);
        }
        for (l = 0; l < b.length; l += 1) {
            b[l].visibilityId = null;
        }
        return r
    };

    this.objectDistanceCubeMap = function () {
        return cubeRenderTarget
    };

    this.dispose = function () {
        d.dispose();
        cubeRenderTarget.dispose();
        cubeRenderTarget = null;
        f.dispose()
    }
};

j3dObjectDistanceQuery.prototype.constructor = j3dObjectDistanceQuery
JMT.j3dObjectDistanceQuery = j3dObjectDistanceQuery

/***/ }),

/***/ "./src/extend/lights/j3dObjectDistanceReader.js":
/*!******************************************************!*\
  !*** ./src/extend/lights/j3dObjectDistanceReader.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dObjectDistanceReader": function() { return /* binding */ j3dObjectDistanceReader; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
//var vertexShader = new JMT.InlineShader("attribute vec3 envLookup;\nvarying vec3 vEnvLookup;\nvoid main() {\nvEnvLookup = envLookup;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}")
//var fragmentShader = new JMT.InlineShader("uniform samplerCube envMap;\nvarying vec3 vEnvLookup;\nvoid main() {\nint objectId = int(textureCube(envMap, vEnvLookup).x);\nint x = objectId / (256 * 256);\nint y = (objectId - 256 * 256 * x) / 256;\nint z = (objectId - 256 * 256 * x - 256 * y);\ngl_FragColor = vec4(float(x) / 255.0, float(y) / 255.0,\nfloat(z) / 255.0, 1.0);\n}");

var vertexShader = `
attribute vec3 envLookup;
varying vec3 vEnvLookup;
void main() {
    vEnvLookup = envLookup;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`

var fragmentShader = `
uniform samplerCube envMap;
varying vec3 vEnvLookup;
void main() {
    int objectId = int(textureCube(envMap, vEnvLookup).x);
    int x = objectId / (256 * 256);
    int y = (objectId - 256 * 256 * x) / 256;
    int z = (objectId - 256 * 256 * x - 256 * y);
    gl_FragColor = vec4(float(x) / 255.0, float(y) / 255.0, float(z) / 255.0, 1.0);
}`

class j3dObjectDistanceReader {
    constructor(renderer, probeSize) { // c, d

        this.renderer = renderer
        this.probeSize = probeSize

        this.meshes = []
        this.width = 3 * probeSize
        this.height = 2 * probeSize;

        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene;
      
        this.renderTarget = new THREE.WebGLRenderTarget(this.width, this.height, {
            format: THREE.RGBAFormat,
            magFilter: THREE.NearestFilter,
            minFilter: THREE.NearestFilter,
            stencilBuffer: false,
            depthBuffer: false,
            generateMipmaps: false
        })
        this.buffer = new Uint8Array(4 * this.width * this.height);

        this.autoClearAlter = new JMT.AutoClearAlter(this.renderer);

        this.material = new THREE.ShaderMaterial({vertexShader, fragmentShader});
        this.material.uniforms = {envMap: {type: "t", value: null}};
        this.material.attributes = {envLookup: {type: "v3", value: null}};

        var a = [
            [[1, 1, 1], [1, 1, -1], [1, -1, 1], [1, -1, -1]],
            [[-1, 1, -1], [-1, 1, 1], [-1, -1, -1], [-1, -1, 1]],
            [[-1, 1, -1], [1, 1, -1], [-1, 1, 1], [1, 1, 1]],
            [[-1, -1, 1], [1, -1, 1], [-1, -1, -1], [1, -1, -1]],
            [[-1, 1, 1], [1, 1, 1], [-1, -1, 1], [1, -1, 1]],
            [[1, 1, -1], [-1, 1, -1], [1, -1, -1], [-1, -1, -1]]
        ]

        for (var b = 0; 6 > b; b += 1) {
            var c = new THREE.PlaneBufferGeometry(probeSize, probeSize),
                f = new Float32Array(12);
            c.addAttribute("envLookup", new THREE.BufferAttribute(f, 3));
            for (var k = 0; 4 > k; k += 1) {
                var h = k, q = a[b][k];
                f[3 * h] = q[0];
                f[3 * h + 1] = q[1];
                f[3 * h + 2] = q[2]
            }
            this.meshes[b] = new THREE.Mesh(c, this.material);
            this.scene.add(this.meshes[b])
        }

        var g = []
        var d = probeSize
        g[0] = [0, 0];
        g[1] = [d, 0];
        g[2] = [2 * d, 0];
        g[3] = [0, d];
        g[4] = [d, d];
        g[5] = [2 * d, d]
        this.g = g

        this.init(this.width, this.height)
    }

    init(a, b) {    // f, h
        a /= 2;
        var c = b / 2;
        this.camera.left = -a;
        this.camera.right = a;
        this.camera.top = c;
        this.camera.bottom = -c;
        this.camera.updateProjectionMatrix();
        let d = this.probeSize
        b = -a + d / 2;
        a = c - d / 2;
        for (c = 0; c < this.meshes.length; c += 1) {
            this.meshes[c].position.set(b + this.g[c][0], a - this.g[c][1], 0)
        }
    }

    readCubeMapToBuffer(a) {
        let currentRT_ = this.renderer.getRenderTarget();

        this.material.uniforms.envMap.value = a;
        this.autoClearAlter.set(!0, !1, !1);
        this.renderer.setRenderTarget(this.renderTarget);
        this.renderer.render(this.scene, this.camera);
        //this.renderer.readPixels(this.width, this.height, this.buffer);
        this.renderer.readRenderTargetPixels(this.renderTarget, 0, 0, this.width, this.height, this.buffer)
        this.autoClearAlter.restore();

        this.renderer.setRenderTarget(currentRT_);
        return this.buffer
    }

    dispose() {
        for (var a = 0; 6 > a; a += 1) {
            this.meshes[a].geometry.dispose();
        }
        this.material.dispose();
        this.renderTarget.dispose();
        this.buffer = null
    }
}


JMT.j3dObjectDistanceReader = j3dObjectDistanceReader


/***/ }),

/***/ "./src/extend/loaders/j3dCompressedTextureLoader.js":
/*!**********************************************************!*\
  !*** ./src/extend/loaders/j3dCompressedTextureLoader.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _texture_j3dCompressedTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../texture/j3dCompressedTexture.js */ "./src/extend/texture/j3dCompressedTexture.js");
/**
 * Created by Kai on 2020/12/18.
 */


JMT.j3dCompressedTextureLoader = function () {
    this._parser = null
};
JMT.j3dCompressedTextureLoader.prototype = {
    constructor: JMT.j3dCompressedTextureLoader,
    load: function (a, b, c, d) {
        var e = this, g = [] 
        var f = new JMT.j3dCompressedTexture();
        f.image = g;
        JMT.queueAjaxGet(a, b, !0, function (a) {
            a = e._parser(a, !0);
            if (a.isCubemap) for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d += 1) {
                g[d] = {mipmaps: []};
                for (var h = 0; h < a.mipmapCount; h += 1) {
                     g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + h]), 
                     g[d].format = a.format, 
                     g[d].width = a.width, 
                     g[d].height = a.height
                }
            }
            else {
                f.image.width = a.width
                f.image.height = a.height
                f.mipmaps = a.mipmaps;
            }
            
            if (1 === a.mipmapCount) {
                f.minFilter = THREE.LinearFilter
            }
             
            f.format = a.format;
            f.width = a.width;
            f.height = a.height;
            c && c(f)
        }, d);
        return f
    }
}

/***/ }),

/***/ "./src/extend/loaders/j3dKTXLoader.js":
/*!********************************************!*\
  !*** ./src/extend/loaders/j3dKTXLoader.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _j3dCompressedTextureLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dCompressedTextureLoader.js */ "./src/extend/loaders/j3dCompressedTextureLoader.js");
/**
 * Created by Kai on 2020/12/18.
 */



JMT.j3dKTXLoader = function () {
    this._parser = JMT.KTXLoader.parse
};
JMT.j3dKTXLoader.prototype = Object.create(JMT.j3dCompressedTextureLoader.prototype);
JMT.j3dKTXLoader.parse = function (a) {
    var b = [], c = new Int32Array(a, 0, 16);
    67305985 === c[3] && console.assert("Big endian machines not supported");
    console.assert(0 === c[4]);
    console.assert(1 === c[5]);
    console.assert(0 === c[6]);
    if (35842 === c[7]) {
        console.assert(6408 === c[8]);
        //var d = GLC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        var d = THREE.RGBA_PVRTC_4BPPV1_Format
    }
    else if(36196 === c[7]){
        console.assert(6407 === c[8])
        //d = GLC.COMPRESSED_RGB_ETC1_WEBGL
        d = THREE.RGB_ETC1_Format
    }
    else if(33776 === c[7]){
        console.assert(6407 === c[8])
        //d = GLC.COMPRESSED_RGB_S3TC_DXT1_EXT
        d = THREE.RGB_S3TC_DXT1_Format;
    }
    else if(33779 === c[7]){
        console.assert(6408 === c[8])
        //d = GLC.COMPRESSED_RGBA_S3TC_DXT5_EXT
        d = THREE.RGBA_S3TC_DXT5_Format;
    }
    else {
        console.error("Unknown KTX glInternalFormat: " + c[7]);
    }
    var e = c[9], g = c[10];
    console.assert(0 === (e & e - 1));
    console.assert(0 === (g & g - 1));
    console.assert(0 === c[11]);
    console.assert(0 === c[12]);
    console.assert(1 === c[13]);
    var f = c[14];
    c = c[15];
    console.assert(0 === c % 4);
    c = 64 + c;
    for (var h = new DataView(a, 0), k = e, n = g, p = 0; p < f; ++p) {
        var l = h.getUint32(c, !0);
        c += 4;
        var q = new Uint8Array(a,
            c, l);
        b.push({data: q, width: k, height: n});
        c += l + (3 - (l + 3) % 4);
        k = Math.max(k / 2, 1);
        n = Math.max(n / 2, 1)
    }
    console.assert(c === a.byteLength);
    return {format: d, width: e, height: g, mipmapCount: f, mipmaps: b}
}

/***/ }),

/***/ "./src/extend/material/j3dAnchorMaterial.js":
/*!**************************************************!*\
  !*** ./src/extend/material/j3dAnchorMaterial.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dAnchorMaterial": function() { return /* binding */ j3dAnchorMaterial; },
/* harmony export */   "j3dAnchorSpriteMaterial": function() { return /* binding */ j3dAnchorSpriteMaterial; }
/* harmony export */ });
/* harmony import */ var _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dStandardMaterial.js */ "./src/extend/material/j3dStandardMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */
//import './StandardMaterial.js'



class j3dAnchorMaterial extends _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dStandardMaterial {
    constructor(){
        super()
        //this._vertexShaderBody = JMT.getShader("anchor_vertex.glsl");
        this.vertexShader = JMT.getShader("anchor_vertex.glsl").code;
        this.hideFromLightProbes = !0
    }
}
JMT.j3dAnchorMaterial = j3dAnchorMaterial

class j3dAnchorSpriteMaterial extends _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dStandardMaterial {
    constructor(){
        super()
        //this._vertexShaderBody = JMT.getShader("anchor_sprite_vertex.glsl");
        this.vertexShader = JMT.getShader("anchor_sprite_vertex.glsl").code;
        this.hideFromLightProbes = !0
    }
}
JMT.j3dAnchorSpriteMaterial = j3dAnchorSpriteMaterial



/***/ }),

/***/ "./src/extend/material/j3dBaseMaterial.js":
/*!************************************************!*\
  !*** ./src/extend/material/j3dBaseMaterial.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dBaseMaterial": function() { return /* binding */ j3dBaseMaterial; }
/* harmony export */ });

/**
 * #Created by: Jimuyida Martian
 * scene-mesh material
 */

//  var a = 0, b = [0, 0]

//  var c = Object.freeze({
//     uv: b,
//     uv2: b,
//     uv2Mod: [0, 0, 1 / 65535, 1 / 65535],
//     t0: [1, 0, 0, 0],
//     t1: [0, 1, 0, 0],
//     t2: [0, 0, 1, 0]
// })


class j3dBaseMaterial extends THREE.ShaderMaterial {
    constructor(vertexShader, fragmentShader) {
        super()
        
        this.type = "j3dBaseMaterial";
        this.side = THREE.FrontSide;
        this.doNotOverrideSide = !1;
        
        this.opacity = 1;
        this.transparent = false;

        //this.transparentRenderOrder = 0;
        this.blending = THREE.NoBlending;
        this.blendSrc = THREE.SrcAlphaFactor;
        this.blendDst = THREE.OneMinusSrcAlphaFactor;
        this.blendEquation = THREE.AddEquation;
        this.blendEquationAlpha = null;
        this.blendDstAlpha = null;
        this.blendSrcAlpha = null;

        this.colorWrite = true;
        this.depthWrite = true;
        this.depthTest = true;

        this._hideFromLightProbes = false;
        //this._defines = new Set;
        //this._definesString = null;

        //this._textureLodExtension = false;
        //this._standardDerivativesExtension = false;

        //this.attributes = d;
        //this._vertexShaderBody = vertexShader;
        //this._fragmentShaderBody = fragmentShader;
        //this._fragmentShaderHooks = null;
        //this.defaultAttributeValues = c; //three130 不再支持
        //this.index0AttributeName = void 0;
        //this._programNeedsUpdate = this.visible = !0;
        //this.program = null

        if (vertexShader!=undefined)
            this.vertexShader = vertexShader;

        if (fragmentShader!=undefined)
            this.fragmentShader = fragmentShader;
    }

    get isPlaying() {
        return !1
    }

    update(a) {
    }
    play() {
        console.assert(!1)
    }
    pause() {
        console.assert(!1)
    }
    get hideFromLightProbes() {
     
        return this._hideFromLightProbes
    }
    set hideFromLightProbes(value) {
     
        this._hideFromLightProbes = value
    }
    get programNeedsUpdate() {
     
        return this._programNeedsUpdate
    }
    set programNeedsUpdate(value) {
     
        //this._definesString = null;
        this.needsUpdate = value
        this._programNeedsUpdate = value
    }

    hasDefine(key) {
     
        return this.defines.hasOwnProperty(key)
    }

    addDefine(key) {
     
        if (!this.hasDefine(key)) {
     
            this.defines[key]=''
     
            this.needsUpdate = true
     
        }
    }
    removeDefine(key) {
     
        if (this.hasDefine(key)) {
     
            delete this.defines[key]
     
            this.needsUpdate = true
     
        }
    }

    condDefine(isAdd, key) {
     
        isAdd ? this.addDefine(key) : this.removeDefine(key);
     
        return isAdd
    }

    // _getDefinesString() {
     
    //     if (null === this._definesString) {
     
    //         for (var a = [], b = $jscomp.makeIterator(this._defines), c = b.next(); !c.done; c = b.next())a.push("#define " + c.value);
     
    //         a.sort();
     
    //         this._definesString = a.join("\n")
     
    //     }
     
    //     return this._definesString
    // }
    // generateProgramId() {
    //     return [this._fragmentShaderBody.id, this._fragmentShaderHooks.id, this._getDefinesString(), this._vertexShaderBody.id, this._standardDerivativesExtension ? "+" : "", this._textureLodExtension ? "+" : ""].join("$")
    // }
    enableStandardDerivativesExtension() {
     
        if (!this.extensions.derivatives) {
            this.extensions.derivatives = true;
            this.programNeedsUpdate = true;

            this._standardDerivativesExtension = true;
        }

        //this._standardDerivativesExtension ||
        //    (this.programNeedsUpdate = this._standardDerivativesExtension = !0)
    }
    enableTextureLodExtension() {
     
        if (!this.extensions.shaderTextureLOD) {
            this.extensions.shaderTextureLOD = true;
            this.programNeedsUpdate = true;
            
            this._textureLodExtension = true;
        }
        //this._textureLodExtension || (this.programNeedsUpdate = this._textureLodExtension = !0)
    }
    
    // generateFragmentShader() {
     
    //     return [this._standardDerivativesExtension ? "#extension GL_OES_standard_derivatives : enable" : "", this._textureLodExtension ? "#extension GL_EXT_shader_texture_lod : require" : "", "precision " + JMT.DETECTOR.fragmentPrecision + " float;", "precision " + JMT.DETECTOR.fragmentPrecision + " int;", this._getDefinesString(), "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;", this._fragmentShaderBody.code, this._fragmentShaderHooks.code].join("\n")
    // }
    
    // dispose() {
    //     this.dispatchEvent({type: "dispose"})
    // }
    setUniform(key, type, value) {
        this.uniforms[key] = {type: type, value: value}
    }

    propertyFromUniform(a) {
     
        Object.defineProperty(this, a, {
     
            get() {
     
                return this.uniforms[a].value
     
            },

            set(b) {
     
                this.uniforms[a].value = b
     
            }
     
        })
    }

    hash() {
     
        console.assert(!1, "hash not implemented")
    }
    canMerge(a) {
        console.assert(!1, "canMerge not implemented")
    }
}



/***/ }),

/***/ "./src/extend/material/j3dEquirectSkyMaterial.js":
/*!*******************************************************!*\
  !*** ./src/extend/material/j3dEquirectSkyMaterial.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dEquirectSkyMaterial": function() { return /* binding */ j3dEquirectSkyMaterial; }
/* harmony export */ });
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");
/**
 * #Created by: Jimuyida Martian
 * scene-sky material
 * Date 2022/3/25
 */



//JMT.SHADERS["equirect_sky_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nfloat _g2l(in float x) {\nreturn (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\nvec3 gammaToLinear(in vec3 rgb) {\nreturn vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));\n}\nfloat _l2g(in float x) {\nreturn (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n}\nvec3 linearToGamma(in vec3 rgb) {\nreturn vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n}\nvec3 linearToGammaUnreal(in vec3 rgb) {\nreturn rgb / (rgb + 0.187) * 1.035;\n}\nvec3 hdrDecode(in vec4 rgbm) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\nreturn r * r;\n}\nvec4 hdrEncode(in vec3 rgb) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = sqrt(rgb) / rgbmScale;\nfloat m = max(max(r.r, r.g), r.b);\nm = clamp(m, 1.0 / 255.0, 1.0);\nm = ceil(m * 255.0) / 255.0;\nr /= m;\nreturn vec4(r.r, r.g, r.b, (1.0 - m));\n}\nuniform sampler2D map;\nuniform float exposure;\nuniform float cameraGamma;\nvarying vec2 vUv;\n#ifdef USE_COLORMAP\nvec3 colormap(in sampler2D texture, in vec3 color) {\nconst float resolution = 16.0;\nconst float maxValueIndex = resolution - 1.0;\nconst float sliceWidth = 1.0 / resolution;\nconst float slicePixelWidth = sliceWidth / resolution;\nconst float sliceMarginWidth = 0.5 * slicePixelWidth;\nconst float sliceInnerWidth = sliceWidth - slicePixelWidth;\nconst float slicePixelHeight = 1.0 / resolution;\nconst float sliceMarginHeight = 0.5 * slicePixelHeight;\nconst float sliceInnerHeight = 1.0 - slicePixelHeight;\nfloat bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);\nfloat bSlice1 = bSlice0 + 1.0;\nfloat bOffset = color.b * maxValueIndex - bSlice0;\nfloat rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;\nfloat gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;\nfloat rPos0 = rSlicePos + (bSlice0 * sliceWidth);\nfloat rPos1 = rSlicePos + (bSlice1 * sliceWidth);\nvec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;\nvec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;\nreturn mix(color0, color1, bOffset);\n}\nuniform sampler2D colorMap;\n#endif\nvoid main() {\n#ifdef USE_RGBM_MAP\nvec4 colorRgbm = texture2D(map, vUv);\nvec3 colorLinear = hdrDecode(colorRgbm);\n#else\nvec3 colorLinear = gammaToLinear(texture2D(map, vUv).xyz);\n#endif\n#ifdef HDR_OUTPUT\n#ifdef USE_RGBM_MAP\ngl_FragColor = colorRgbm;\n#else\ngl_FragColor = hdrEncode(10.0 * colorLinear);\n#endif\n#else\nvec3 colorExposed = pow(exposure * colorLinear, vec3(cameraGamma));\nvec3 colorGamma =  linearToGammaUnreal(colorExposed);\n#ifdef USE_COLORMAP\ngl_FragColor.xyz = colormap(colorMap, colorGamma);\n#else\ngl_FragColor.xyz = colorGamma;\n#endif\n#endif\n}\n";
//JMT.SHADERS["equirect_sky_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";

var equirect_sky_vertex = `//AUTO GENERATED
varying vec2 vUv;
void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`

var equirect_sky_fragment = ` //AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a)
{
    return clamp(a, 0.0, 1.0);
}
vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix)
{
    return normalize((vec4(normal, 0.0) * matrix).xyz);
}
float _g2l(in float x)
{
    return (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);
}
vec3 gammaToLinear(in vec3 rgb)
{
    return vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));
}
float _l2g(in float x)
{
    return (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;
}
vec3 linearToGamma(in vec3 rgb)
{
    return vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));
}
vec3 linearToGammaUnreal(in vec3 rgb)
{
    return rgb / (rgb + 0.187) * 1.035;
}
vec3 hdrDecode(in vec4 rgbm)
{
    const float rgbmScale = 2.82842712; // sqrt(8)
    vec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));
    return r * r;
}
vec4 hdrEncode(in vec3 rgb)
{
    const float rgbmScale = 2.82842712; // sqrt(8)
    vec3 r = sqrt(rgb) / rgbmScale;
    float m = max(max(r.r, r.g), r.b);
    m = clamp(m, 1.0 / 255.0, 1.0);
    m = ceil(m * 255.0) / 255.0;
    r /= m;
    return vec4(r.r, r.g, r.b, (1.0 - m));
}
uniform sampler2D map;
uniform float exposure;
uniform float cameraGamma;
varying vec2 vUv;
#ifdef USE_COLORMAP
vec3 colormap(in sampler2D texture, in vec3 color)
{
    const float resolution = 16.0;
    const float maxValueIndex = resolution - 1.0;
    const float sliceWidth = 1.0 / resolution;
    const float slicePixelWidth = sliceWidth / resolution;
    const float sliceMarginWidth = 0.5 * slicePixelWidth;
    const float sliceInnerWidth = sliceWidth - slicePixelWidth;
    const float slicePixelHeight = 1.0 / resolution;
    const float sliceMarginHeight = 0.5 * slicePixelHeight;
    const float sliceInnerHeight = 1.0 - slicePixelHeight;
    float bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);
    float bSlice1 = bSlice0 + 1.0;
    float bOffset = color.b * maxValueIndex - bSlice0;
    float rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;
    float gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;
    float rPos0 = rSlicePos + (bSlice0 * sliceWidth);
    float rPos1 = rSlicePos + (bSlice1 * sliceWidth);
    vec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;
    vec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;
    return mix(color0, color1, bOffset);
}
uniform sampler2D colorMap;
#endif
void main()
{
#ifdef USE_RGBM_MAP
    vec4 colorRgbm = texture2D(map, vUv);
    vec3 colorLinear = hdrDecode(colorRgbm);
#else
    vec3 colorLinear = gammaToLinear(texture2D(map, vUv).xyz);
#endif
#ifdef HDR_OUTPUT
#ifdef USE_RGBM_MAP
    gl_FragColor = colorRgbm;
#else
    gl_FragColor = hdrEncode(10.0 * colorLinear);
#endif
#else
    vec3 colorExposed = pow(exposure * colorLinear, vec3(cameraGamma));
    vec3 colorGamma = linearToGammaUnreal(colorExposed);
#ifdef USE_COLORMAP
    gl_FragColor.xyz = colormap(colorMap, colorGamma);
#else
    gl_FragColor.xyz = colorGamma;
#endif
#endif
}
`


class j3dEquirectSkyMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {

    constructor() {
        super();
 
        this.depthWrite = !1;
        this.side = THREE.FrontSide;
        this.uniforms = {
            map: {type: "t", value: null},
            colorMap: {type: "t", value: null},
            exposure: {type: "f", value: 1},
            cameraGamma: {type: "f", value: 1}
        }

        this.vertexShader = equirect_sky_vertex;
        this.fragmentShader = equirect_sky_fragment;
    }

}

Object.defineProperty(j3dEquirectSkyMaterial.prototype, "map", {
    get: function () {
        return this.uniforms.map.value
    }, set: function (a) {
        this.uniforms.map.value = a;
        this.condDefine(this.map.isRgbm, "USE_RGBM_MAP")
    }
});
Object.defineProperty(j3dEquirectSkyMaterial.prototype, "hdrOutput", {
    get: function () {
        return this.hasDefine("HDR_OUTPUT")
    }, set: function (a) {
        this.condDefine(a, "HDR_OUTPUT")
    }
});
Object.defineProperty(j3dEquirectSkyMaterial.prototype, "colorMap", {
    get: function () {
        return this.uniforms.colorMap.value
    }, set: function (a) {
        this.uniforms.colorMap.value =
            a;
        this.condDefine(a, "USE_COLORMAP")
    }
});
Object.defineProperty(j3dEquirectSkyMaterial.prototype, "cameraExposure", {
    get: function () {
        return Math.log2(this.uniforms.exposure.value)
    }, set: function (a) {
        this.uniforms.exposure.value = Math.pow(2, a)
    }
});
Object.defineProperty(j3dEquirectSkyMaterial.prototype, "cameraGamma", {
    get: function () {
        return this.uniforms.cameraGamma.value
    }, set: function (a) {
        this.uniforms.cameraGamma.value = a
    }
})

j3dEquirectSkyMaterial.prototype.isEquirectSkyMaterial = true;


JMT.j3dEquirectSkyMaterial = j3dEquirectSkyMaterial

/***/ }),

/***/ "./src/extend/material/j3dFlashMaterial.js":
/*!*************************************************!*\
  !*** ./src/extend/material/j3dFlashMaterial.js ***!
  \*************************************************/
/***/ (function() {

/**
 * #Created by: Jimuyida Martian
 * scene-mesh material
 * Date 2022/3/22
 */

function _onFlashBeforeCompile(shader) {

    let frag = shader.fragmentShader;
    
    frag = 'uniform vec3 flashlightColor;\n'+'uniform float flashlightMix;\n' + frag

    //
    // let srcCode = 'vec3 diffuseSpecular = addSpecularHook(baseColor, lightIntensity, alpha);'
    // frag = frag.replace( srcCode,
    //     'baseColor = mix(baseColor, flashlightColor, flashlightMix);\n' +
    //     'if (alpha > 0.1) \n' +
    //         'alpha = mix(alpha, 1.0, flashlightMix);\n' +
    //     srcCode )

    let srcCode = 'gl_FragColor.a = alpha;'
    frag = frag.replace( srcCode,
        'gl_FragColor.rgb = mix(gl_FragColor.rgb, flashlightColor, flashlightMix);\n' +
        srcCode )

    shader.fragmentShader = frag;
}

function _onUvAnimatedBeforeCompile(shader) {

    let vertex = shader.vertexShader;
    //let idx = frag.indexOf("uniform")
    vertex = vertex.replace("uniform",
        'uniform mat4 uvTransform;\n'+
        'uniform ')

    let src = 'vUv = uv * uvMod.zw + uvMod.xy;'
    vertex = vertex.replace(src,
        'vUv = ( uvTransform * vec4( uv, 1, 1 ) ).xy;')

    shader.vertexShader = vertex;
}

function _onAnimatBeforeComplile(mtl) {
    var material = mtl
    return function (shader) {
        if (material.hasUvAnimated) {
            _onUvAnimatedBeforeCompile(shader)
        }

        if (material.hasFlash) {
            _onFlashBeforeCompile(shader)
        }
    }
}

function _updateAnimated(mtl, time) {

    function updateMatrix(mat, tx, ty, sx, sy, rotation, cx, cy) {


        const c = Math.cos( rotation );
        const s = Math.sin( rotation );

        mat.set(
            sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx, 0,
            - sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty, 0,
            0, 0, 1, 0,
            0, 0, 0, 1
        );

        return mat
    }

    function getColorAndMix(c) {

        let m = 0
        let color = "#ffffff"
        if (typeof(c) === 'string') {
            //#00000000
            if (c.length === 9) {
                //最后2个字符表示混合度
                m = c.substring(7);
                m = parseInt( m.charAt( 0 ) + m.charAt( 1 ), 16 ) / 255;
                color = c.substr(0,7)
            }
            else if (c.length === 7) {
                m = 0.5
                color = c.substr(0,7)
            }
        }
        else if (typeof(c) === 'object' && !(c instanceof THREE.Color)) {
            //{r, g, b}
            color = new THREE.Color(c.r, c.g, c.b)
            m = c.mix
        }

        return {
            color: color,
            mix: m
        }


    }

    if (!mtl._isPlaying || mtl._sleeping)
        return;

    if (mtl._hasFlash) {
        if (mtl._flashlightColors === undefined || mtl._flashlightColors.length < 1)
            return

        if (mtl._flTime === void 0) mtl._flTime = 0;

        mtl._flTime += time
        let delay = mtl._flashDelay || 1
        let t = Math.floor(mtl._flTime / delay) % (mtl._flashlightColors.length+1)

        let c, m
        if (t == mtl._flashlightColors.length) {
            c = mtl.baseColor
            m = 0
        }
        else {
            c = mtl._flashlightColors[t]
            c = getColorAndMix(c)
            m = c.mix
            c = c.color
        }

        mtl._flashlightColor.set(c)
        mtl._flashlightMix = m
        mtl.setUniform("flashlightColor", "c", mtl._flashlightColor)
        mtl.setUniform("flashlightMix", "f", mtl._flashlightMix)
    }

    if (mtl._hasUvAnimated) {

        mtl._uvOffsetScale.x += mtl._uvMoveSpeed.x * time
        mtl._uvOffsetScale.y += mtl._uvMoveSpeed.y * time
        mtl._uvOffsetScale.z = mtl._uvRepeat.x
        mtl._uvOffsetScale.w = mtl._uvRepeat.y
        mtl._totalRad += THREE.Math.degToRad(mtl._uvRotateSpeed * time)

        updateMatrix(mtl._uvTransform, mtl._uvOffsetScale.x, mtl._uvOffsetScale.y,
            mtl._uvOffsetScale.z, mtl._uvOffsetScale.w,
            mtl._totalRad,0.5,0.5)

        mtl.setUniform("uvTransform", "m4", mtl._uvTransform)
    }
}

Object.defineProperty(JMT.j3dStandardMaterial.prototype, "hasFlash", {
    get: function () {
        return !!this._hasFlash;

    },

    set: function (value) {

        this._hasFlash = !!value
        this._isAnimated = this._hasFlash || this._hasUvAnimated
        this._initFlash()

        if (this._hasFlash) {

            JMT.ALWAYS_RENDER = !JMT.EDIT_MODE

            this.addDefine("USE_Flashlight")

            this.setUniform("flashlightColor", "c", this._flashlightColor)
            this.setUniform("flashlightMix", "f", this._flashlightMix)
            var that = this
            this.onBeforeCompile = _onAnimatBeforeComplile(that)
            this.setUniforms();

        }
        else {
            delete this.uniforms['flashlightColor']
            delete this.uniforms['flashlightMix']
            //this.onBeforeCompile = null
            this.removeDefine("USE_Flashlight")
        }

        //
        if (UjP.scene)
           UjP.scene._onMaterialUpdated({type: "materialUpdated", target:this})

        this._updated()
        this.programNeedsUpdate = !0
    }

});

Object.defineProperty(JMT.j3dStandardMaterial.prototype, "flashColors", {
    get: function () {
        return this._flashlightColors;
    },
    set: function (value) {
        this._flashlightColors = value;
    }
});

Object.defineProperty(JMT.j3dStandardMaterial.prototype, "flashDelay", {
    get: function () {
        return this._flashDelay;
    },
    set: function (value) {
        this._flashDelay = value;
    }
});

JMT.j3dStandardMaterial.prototype._initFlash = function () {

    //define useful props
    if (this._flashlightColors === undefined) this._flashlightColors = []
    if (this._flashlightColor === undefined) this._flashlightColor = new THREE.Color(1,1,1)
    if (this._flashlightMix === undefined) this._flashlightMix = 0

    if (this._flashDelay === undefined) this._flashDelay = 0.5

    {
        this.play = function () {
            //var a = this._isPlaying
            this._isPlaying = !0
            //this._isPlaying !== a && this._updated()
        };

        this.pause = function () {
            //var a = this._isPlaying;
            this._isPlaying = !1
            //this._isPlaying !== a && this._updated()
        };

        this.sleepAnimation = function () {
            this._sleeping = !0
        };

        this.wakeAnimation = function () {
            this._sleeping = !1
        };

        //rgb color ==> flashColor
        //mix ===> float
        this.update = function (time) {

            _updateAnimated(this, time)

        }
    }

    this.play()
}

////////////////////////////////////////////////////////////////////////
//UvAnimated

Object.defineProperty(JMT.j3dStandardMaterial.prototype, "hasUvAnimated", {
    get: function () {
        return !!this._hasUvAnimated;
    },

    set: function (value) {

        this._hasUvAnimated = !!value
        this._isAnimated = this._hasFlash || this._hasUvAnimated
        this._initUvAnimated()

        if (this._hasUvAnimated) {
            JMT.ALWAYS_RENDER = true

            this.addDefine("USE_UVAnimated")

            this.setUniform("uvTransform", "m4", this._uvTransform)
            var that = this
            this.onBeforeCompile = _onAnimatBeforeComplile(that)

        }
        else {

            this.removeDefine("USE_UVAnimated")
            delete this.uniforms['uvTransform']
            //this.onBeforeCompile = null

        }

        if (UjP.scene)
            UjP.scene._onMaterialUpdated({type: "materialUpdated", target:this})
        //
        this._updated()
        this.programNeedsUpdate = !0
    }

});

//每秒钟移动的uv单位
Object.defineProperty(JMT.j3dStandardMaterial.prototype, 'uvMoveSpeed', {
    get: function () {
        return this._uvMoveSpeed
    },
    set: function (value) {
        this._uvMoveSpeed = value
    }
})

Object.defineProperty(JMT.j3dStandardMaterial.prototype, 'uvRepeat', {
    get: function () {
        return this._uvRepeat
    },
    set: function (value) {
        this._uvRepeat = value
    }
})

Object.defineProperty(JMT.j3dStandardMaterial.prototype, 'uvRotate', {
    get: function () {
        return this._uvRotate
    },
    set: function (value) {
        this._uvRotate = value
        this._totalRad = THREE.Math.degToRad(this._uvRotate)
    }
})

Object.defineProperty(JMT.j3dStandardMaterial.prototype, 'uvRotateSpeed', {
    get: function () {
        return this._uvRotateSpeed
    },
    set: function (value) {
        this._uvRotateSpeed = value
        this._totalRad = THREE.Math.degToRad(this._uvRotate)
    }
})

JMT.j3dStandardMaterial.prototype._initUvAnimated = function () {

    if (this._moveTime === undefined) {
        this._moveTime = 0
        //this._backOffsetUv = this._uvOffsetScale ? this._uvOffsetScale.clone() : new THREE.Vector4(0, 0, 1, 1)
        this._uvMoveSpeed = new THREE.Vector2(0, 0)
        this._uvRepeat = new THREE.Vector2(1, 1)
        this._uvTransform = new THREE.Matrix4().identity()
        this._uvRotate = 0, this._uvRotateSpeed = 0, this._totalRad = 0
    }

    if (!this._uvOffsetScale)
        this._uvOffsetScale = new THREE.Vector4(0, 0, 1, 1)

    this.play = function () {
        this._isPlaying = !0
    };

    this.pause = function () {
        this._isPlaying = !1
    };

    this.sleepAnimation = function () {
        //this.baseColorTexture.sleepAnimation()
        this._sleeping = !0
    };

    this.wakeAnimation = function () {
        //this.baseColorTexture.wakeAnimation()
        this._sleeping = !1
    };

    this.update = function (time) {
        _updateAnimated(this, time)
    }

    this.play()
}


/***/ }),

/***/ "./src/extend/material/j3dLightMaterial.js":
/*!*************************************************!*\
  !*** ./src/extend/material/j3dLightMaterial.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */
 
//var a = JMT.getShader("editor_light_vertex.glsl")
//var b = JMT.getShader("editor_light_fragment.glsl");

var editor_light_vertex = `//AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a) {
return clamp(a, 0.0, 1.0);
}
vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {
return normalize((vec4(normal, 0.0) * matrix).xyz);
}
vec3 sphericalDecode(in vec2 spNormal) {
float theta = (spNormal.x / 254.0 + 0.5) * PI;
float phi = spNormal.y * (PI / 127.0);
float sinTheta = sin(theta);
return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
}

attribute vec2 sphericalNormal;
varying vec3 vNormal;
varying vec3 vViewPosition;
void main() {
vec3 normal = sphericalDecode(sphericalNormal);
vNormal = normalize(normalMatrix * normal);
vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
vViewPosition = -mvPosition.xyz;
gl_Position = projectionMatrix * mvPosition;
}
`;

var editor_light_fragment = `//AUTO GENERATED
float _l2g(in float x) {
return (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;
}
vec3 linearToGamma(in vec3 rgb) {
return vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));
}
vec3 linearToGammaUnreal(in vec3 rgb) {
return rgb / (rgb + 0.187) * 1.035;
}
uniform vec3 color;
uniform vec3 highlight;
uniform float highlightMix;
varying vec3 vNormal;
varying vec3 vViewPosition;
void main() {
vec3 lVector = normalize(vViewPosition.xyz);
float pointDiffuse = max(dot(normalize(vNormal), lVector), 0.0);
vec3 lightColor = color * pointDiffuse;
lightColor = mix(lightColor, highlight, highlightMix);
gl_FragColor.xyz = min(linearToGamma(lightColor), 1.0);
}
`

class j3dLightMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {
    constructor(c) {
        super(editor_light_vertex, editor_light_fragment);
        
        let color = new THREE.Color(c.color)
        this.setUniform("color", "c", color);
        this.setUniform("highlight", "c", JMT.EDITOR_SELECTION_COLOR);
        this.setUniform("highlightMix", "f", 0)

        this.propertyFromUniform("highlightMix")
    }    
};

//j3dLightMaterial.prototype.propertyFromUniform("highlightMix")

JMT.j3dLightMaterial = j3dLightMaterial

/***/ }),

/***/ "./src/extend/material/j3dMaterialsExtensions.js":
/*!*******************************************************!*\
  !*** ./src/extend/material/j3dMaterialsExtensions.js ***!
  \*******************************************************/
/***/ (function() {


THREE.MeshBasicMaterial.prototype.configureTransparency = function () {

    let alpha = this.map && this.map.hasAlpha;
    this.transparent = 1 > this.opacity || alpha;
    
    // if (this.transparent) {
    //     this.blending = THREE.NormalBlending
    //     this.transparentRenderOrder = a ? 0 : 1
    // } else {
    //     this.blending = THREE.NoBlending;
    // }
    this.depthWrite = !this.transparent || alpha
};


/***/ }),

/***/ "./src/extend/material/j3dObjectDistanceMaterial.js":
/*!**********************************************************!*\
  !*** ./src/extend/material/j3dObjectDistanceMaterial.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dObjectDistanceMaterial": function() { return /* binding */ j3dObjectDistanceMaterial; }
/* harmony export */ });
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderers/shaders/SHADERS.js */ "./src/renderers/shaders/SHADERS.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1__);
/**
 * #Created by: Jimuyida Martian
 * scene-mesh material
 * Date 2022/4/1
 */




var object_distance_vertex = `//AUTO GENERATED

attribute vec4 t0;
attribute vec4 t1;
attribute vec4 t2;

vec4 transformPosition() {
    return vec4(
    t0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,
    t1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,
    t2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,
    1.0);
}

varying vec3 vPositionW;
void main() {
    vec4 transformedPosition = transformPosition();
    vPositionW = (modelMatrix * transformedPosition).xyz;
    gl_Position = projectionMatrix * modelViewMatrix * transformedPosition;
}
`

var object_distance_float_fragment = `//AUTO GENERATED
uniform int objectId;
varying vec3 vPositionW;
void main(void){
    float cameraDistance = distance(cameraPosition, vPositionW);
    gl_FragColor = vec4(objectId, cameraDistance, 0.0, 1.0);
}
`

var object_distance_byte_fragment = `//AUTO GENERATED
uniform int objectId;
varying vec3 vPositionW;
void main(void) {
    float cameraDistance = min(distance(cameraPosition, vPositionW), 255.0);
    int x = objectId / 256;
    int y = objectId - 256 * x;
    float z = floor(cameraDistance);
    float a = fract(cameraDistance);
    gl_FragColor = vec4(float(x) / 255.0, float(y) / 255.0, z / 255.0, a);
}
`

class j3dObjectDistanceMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {
    constructor(floatType) {
        super(object_distance_vertex, floatType ? object_distance_float_fragment : object_distance_byte_fragment)

        this.doNotOverrideSide = !0;
        this.uniforms = {objectId: {type: "i", value: null}}
    }

    refreshPerObjectUniforms(a, b) {
        b.objectId.value = a.visibilityId;
        return !0
    }
}


JMT.j3dObjectDistanceMaterial = j3dObjectDistanceMaterial

/***/ }),

/***/ "./src/extend/material/j3dProceduralSkyMaterial.js":
/*!*********************************************************!*\
  !*** ./src/extend/material/j3dProceduralSkyMaterial.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dProceduralSkyMaterial": function() { return /* binding */ j3dProceduralSkyMaterial; }
/* harmony export */ });
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");

/**
 * #Created by: Jimuyida Martian
 * scene-sky material
 * Date 2022/3/25
 */




let procedural_sky_vertex = 
`
varying vec3 vWorldDirection;
void main() {
    vec3 positionW = (modelMatrix * vec4(position, 1.0)).xyz;
    vWorldDirection = positionW - cameraPosition;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`

var procedural_sky_fragment = ` //AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a)
{
    return clamp(a, 0.0, 1.0);
}
vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix)
{
    return normalize((vec4(normal, 0.0) * matrix).xyz);
}
uniform vec3 topColor;
uniform vec3 bottomColor;
uniform float sinBottomAngle;
uniform float exponent;
varying vec3 vWorldDirection;
#ifdef HDR_OUTPUT
float _g2l(in float x)
{
    return (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);
}
vec3 gammaToLinear(in vec3 rgb)
{
    return vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));
}
vec4 hdrEncode(in vec3 rgb)
{
    const float rgbmScale = 2.82842712; // sqrt(8)
    vec3 r = sqrt(rgb) / rgbmScale;
    float m = max(max(r.r, r.g), r.b);
    m = clamp(m, 1.0 / 255.0, 1.0);
    m = ceil(m * 255.0) / 255.0;
    r /= m;
    return vec4(r.r, r.g, r.b, (1.0 - m));
}
#endif
#ifdef USE_COLORMAP
vec3 colormap(in sampler2D texture, in vec3 color)
{
    const float resolution = 16.0;
    const float maxValueIndex = resolution - 1.0;
    const float sliceWidth = 1.0 / resolution;
    const float slicePixelWidth = sliceWidth / resolution;
    const float sliceMarginWidth = 0.5 * slicePixelWidth;
    const float sliceInnerWidth = sliceWidth - slicePixelWidth;
    const float slicePixelHeight = 1.0 / resolution;
    const float sliceMarginHeight = 0.5 * slicePixelHeight;
    const float sliceInnerHeight = 1.0 - slicePixelHeight;
    float bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);
    float bSlice1 = bSlice0 + 1.0;
    float bOffset = color.b * maxValueIndex - bSlice0;
    float rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;
    float gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;
    float rPos0 = rSlicePos + (bSlice0 * sliceWidth);
    float rPos1 = rSlicePos + (bSlice1 * sliceWidth);
    vec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;
    vec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;
    return mix(color0, color1, bOffset);
}
uniform sampler2D colorMap;
#endif
void main()
{
    float sinDirection = normalize(vWorldDirection).z;
    float w = max(0.0, (sinDirection - sinBottomAngle) / (1.0 - sinBottomAngle));
    vec3 colorGamma = mix(bottomColor, topColor, pow(w, exponent));
#ifdef HDR_OUTPUT
    vec3 colorLinear = gammaToLinear(colorGamma);
    gl_FragColor = hdrEncode(10.0 * colorLinear);
#else
#ifdef USE_COLORMAP
    gl_FragColor.xyz = colormap(colorMap, colorGamma);
#else
    gl_FragColor.xyz = colorGamma;
#endif
#endif
}
`;

class j3dProceduralSkyMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {
    constructor() {
        super()

        this.depthWrite = !1;
        this.side = THREE.BackSide;
        this.uniforms = {
            topColor: {type: "c", value: new THREE.Color(15135487)},
            bottomColor: {type: "c", value: new THREE.Color(16777215)},
            sinBottomAngle: {type: "f", value: Math.sin(THREE.Math.degToRad(-30))},
            exponent: {type: "f", value: .9},
            colorMap: {type: "t", value: null}

        }
 
        this.vertexShader = procedural_sky_vertex;
        this.fragmentShader = procedural_sky_fragment
    }

    //bool value 
    //enable/disable hdrOutput
    get hdrOutput() {
        return this.hasDefine("HDR_OUTPUT");
    }

    set hdrOutput(value) {
        this.condDefine(value, "HDR_OUTPUT")
    }

    get colorMap() {
        return this.uniforms.colorMap.value
    }

    set colorMap(value) {
        this.uniforms.colorMap.value = value;
        this.condDefine(value, "USE_COLORMAP")
    }
}




JMT.j3dProceduralSkyMaterial = j3dProceduralSkyMaterial;

/***/ }),

/***/ "./src/extend/material/j3dRotateGizmoMaterial.js":
/*!*******************************************************!*\
  !*** ./src/extend/material/j3dRotateGizmoMaterial.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */


var a = JMT.getShader("rotate_gizmo_material_vertex.glsl")
var b = JMT.getShader("rotate_gizmo_material_fragment.glsl");

var rotate_gizmo_material_vertex = `//AUTO GENERATED

varying vec4 mPosition;
void main() {
    vec4 p = vec4(position, 1.0);
    mPosition = modelMatrix * p;
    vec4 mvPosition = modelViewMatrix * p;
    gl_Position = projectionMatrix * mvPosition;
}
`

var rotate_gizmo_material_fragment = `//AUTO GENERATED
uniform vec3 color;
uniform float opacity;
uniform vec3 gizmoPosition;
uniform float sphereRadius;
varying vec4 mPosition;
void discardIfRayIntersectsSphere(vec3 r0, vec3 rd, vec3 s0, float sr) {
    float a = dot(rd, rd);
    vec3 s0_r0 = r0 - s0;
    float b = 2.0 * dot(rd, s0_r0);
    float c = dot(s0_r0, s0_r0) - (sr * sr);
    float delta = b * b - 4.0 * a * c;
    if (delta >= 0.0 && -b - sqrt(delta) > 0.0) {
        discard;
    }
}
void main() {
    vec4 outColor;
    outColor.rgb = color;
    outColor.a = opacity;
    vec3 toCamera = normalize(cameraPosition - gizmoPosition);
    discardIfRayIntersectsSphere(mPosition.xyz, toCamera, gizmoPosition, sphereRadius);
    gl_FragColor = outColor;
}
`

//class j3dRotateGizmoMaterial extends JMT.BaseMaterial {
class j3dRotateGizmoMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {
    constructor(color_, opacity_) {
        super(rotate_gizmo_material_vertex, rotate_gizmo_material_fragment)
        this.blending = THREE.NormalBlending;
        this.depthWrite = this.depthTest = !1;
        this.transparent = !0;
        this.transparentRenderOrder = 1E3;
        this.hideFromLightProbes = !0;
        this.uniforms = {
            opacity: {
                type: "f",
                value: 1
            },
            color: {
                type: "c",
                value: color_
            },
            gizmoPosition: {
                type: "v3",
                value: new THREE.Vector3(0, 0, 0)
            },
            sphereRadius: {
                type: "f",
                value: 1
            }
        };
        Object.defineProperty(this, "color", {
            get: function () {
                return this.uniforms.color.value
            }
        });
        Object.defineProperty(this, "opacity", {
            get: function () {
                return this.uniforms.opacity.value
            },
            set: function (a) {
                this.uniforms.opacity.value = a
            }
        });
        Object.defineProperty(this, "gizmoPosition", {
            get: function () {
                return this.uniforms.gizmoPosition.value
            }
        });
        Object.defineProperty(this, "sphereRadius", {
            get: function () {
                return this.uniforms.sphereRadius.value
            },
            set: function (a) {
                this.uniforms.sphereRadius.value = a
            }
        });
        this.opacity = opacity_;
        this.setUniforms = function () {}
    }
};

JMT.j3dRotateGizmoMaterial = j3dRotateGizmoMaterial

/***/ }),

/***/ "./src/extend/material/j3dStandardMaterial.js":
/*!****************************************************!*\
  !*** ./src/extend/material/j3dStandardMaterial.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dStandardMaterial": function() { return /* binding */ j3dStandardMaterial; }
/* harmony export */ });
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");

/**
 * #Created by: Jimuyida Martian
 * scene-mesh material
 * Date 2022/3/22
 */


 
var d = new THREE.Color;
 var e = new THREE.Vector3(0, 0, 0)
 var g = new THREE.Vector4(0, 0, 1, 1);

 var vertexShader = `

//#ifdef USE_INSTANCE_BUFFERS
attribute vec4 t0;
attribute vec4 t1;     
attribute vec4 t2;
//#endif

//AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a) {
	return clamp(a, 0.0, 1.0);
}

vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {
	return normalize((vec4(normal, 0.0) * matrix).xyz);
}

vec3 sphericalDecode(in vec2 spNormal) {
	float theta = (spNormal.x / 254.0 + 0.5) * PI;
	float phi = spNormal.y * (PI / 127.0);
	float sinTheta = sin(theta);
	return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
}


#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)
	varying vec2 vUv;
	uniform vec4 uvMod;
#endif


#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[128];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif

#ifdef USE_LIGHTMAP
	varying vec2 vUv2;
#endif

#ifdef USE_BUMP_TEXTURE
	varying vec3 vPositionV;
	varying vec3 vNormalV;
#endif

#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	varying vec3 vNormalW;
	varying vec3 vPositionW;
#endif



vec4 transformPosition() {

//#ifdef USE_INSTANCE_BUFFERS
    return vec4(
		t0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,
		t1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,
		t2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,
		1.0
	);
//#else
//    return vec4(position, 1.0);
//#endif
	
    
}


#ifdef USE_SKINNING

vec4 transformPositionOfSkinning(in mat4 boneMatX, in mat4 boneMatY, in mat4 boneMatZ, in mat4 boneMatW) {

	vec3 transformed = vec3( position );

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;


	return vec4(
		t0.x * transformed.x + t0.y * transformed.y + t0.z * transformed.z + t0.w,
		t1.x * transformed.x + t1.y * transformed.y + t1.z * transformed.z + t1.w,
		t2.x * transformed.x + t2.y * transformed.y + t2.z * transformed.z + t2.w,
		1.0
	);
}

#endif


void main() {


#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

	vec4 transformedPosition = transformPositionOfSkinning(boneMatX, boneMatY, boneMatZ, boneMatW);
#else

	vec4 transformedPosition = transformPosition();
    

#endif

#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)
	vUv = uv * uvMod.zw + uvMod.xy;
#endif

	vec4 mvPosition = modelViewMatrix * transformedPosition;

#ifdef USE_LIGHTMAP
	float zeroOrOne = clamp(ceil(uv2.x + uv2.y), 0.0, 1.0);
	vUv2 = uv2 * uv2Mod.zw + uv2Mod.xy * zeroOrOne;
#endif

#if defined(USE_BUMP_TEXTURE) || defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	vec3 n = sphericalDecode(sphericalNormal);

    //#ifdef USE_INSTANCE_BUFFERS
        vec3 normal = vec3(
            t0.x * n.x + t0.y * n.y + t0.z * n.z,
            t1.x * n.x + t1.y * n.y + t1.z * n.z,
            t2.x * n.x + t2.y * n.y + t2.z * n.z
        );
    //#else
    //    vec3 normal = n;
    //#endif
	
	#ifdef USE_SKINNING

		mat4 skinMatrix = mat4( 0.0 );
		skinMatrix += skinWeight.x * boneMatX;
		skinMatrix += skinWeight.y * boneMatY;
		skinMatrix += skinWeight.z * boneMatZ;
		skinMatrix += skinWeight.w * boneMatW;
		skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

		//normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;

		//#ifdef USE_TANGENT
		//	objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
		//#endif

	#endif

#endif

#if defined(USE_BUMP_TEXTURE)
	vPositionV = -mvPosition.xyz;
	vNormalV = normalize(normalMatrix * normal);
#endif

#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	vNormalW = mat3(modelMatrix[0].xyz,
	modelMatrix[1].xyz,
	modelMatrix[2].xyz) * normal;
	vNormalW = normalize(vNormalW);
	vPositionW = (modelMatrix * transformedPosition).xyz;
#endif

	gl_Position = projectionMatrix * mvPosition;
}


`

var fragmentShader = `//AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a) {
return clamp(a, 0.0, 1.0);
}
vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {
return normalize((vec4(normal, 0.0) * matrix).xyz);
}
float _g2l(in float x) {
return (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);
}
vec3 gammaToLinear(in vec3 rgb) {
return vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));
}
float _l2g(in float x) {
return (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;
}
vec3 linearToGamma(in vec3 rgb) {
return vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));
}
vec3 linearToGammaUnreal(in vec3 rgb) {
return rgb / (rgb + 0.187) * 1.035;
}
vec3 hdrDecode(in vec4 rgbm) {
const float rgbmScale = 2.82842712;  // sqrt(8)
vec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));
return r * r;
}
#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
varying vec3 vNormalW;
varying vec3 vPositionW;
#endif
#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)
varying vec2 vUv;
#endif
#if defined(USE_BUMP_TEXTURE)
varying vec3 vPositionV;
varying vec3 vNormalV;
uniform float bumpScale;
uniform sampler2D bumpTexture;
vec2 dBumpdxy() {
vec2 texdx = dFdx(vUv);
vec2 texdy = dFdy(vUv);
float Hll = bumpScale * texture2D(bumpTexture, vUv).x;
float dBx = bumpScale * texture2D(bumpTexture, vUv + texdx).x - Hll;
float dBy = bumpScale * texture2D(bumpTexture, vUv + texdy).x - Hll;
return vec2(dBx, dBy);
}
vec3 perturbNormal(in vec3 surfPos, in vec3 surfNorm) {
vec2 dBdxy = dBumpdxy();
vec3 vSigmaX = dFdx(surfPos);
vec3 vSigmaY = dFdy(surfPos);
vec3 R1 = cross(vSigmaY, surfNorm);
vec3 R2 = cross(surfNorm, vSigmaX);
float fDet = dot(vSigmaX, R1);
vec3 vGrad = sign(fDet) * (dBdxy.x * R1 + dBdxy.y * R2);
return normalize(abs(fDet) * surfNorm - vGrad);
}
#endif
#ifdef USE_BASE_COLOR_TEXTURE
uniform sampler2D baseColorTexture;
uniform vec4 baseColorAtlasUvMod;
uniform float alphaDiscardThreshold;
#ifdef USE_PARALLAX_CORRECTION
#endif
#else
uniform vec3 baseColor;
#endif
uniform float opacity;
uniform vec4 baseColorCorrection;
vec3 getBaseColor(out float alpha) {
#ifdef USE_BASE_COLOR_TEXTURE
#ifdef USE_PARALLAX_CORRECTION
#else
vec2 baseColorUv = vUv;
#endif
baseColorUv = baseColorUv * baseColorAtlasUvMod.zw + baseColorAtlasUvMod.xy;
#ifdef USE_ALPHA_IN_LOWER_HALF
vec4 baseColorGamma = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 + .5 * baseColorUv.y));
float textureAlpha = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 * baseColorUv.y)).r;
#else
vec4 baseColorGamma = texture2D(baseColorTexture, baseColorUv);
float textureAlpha = baseColorGamma.a;
#endif
vec3 baseColor = gammaToLinear(baseColorGamma.rgb);
alpha = opacity * textureAlpha;
#else // NOT USE_BASE_COLOR_TEXTURE
alpha = opacity;
#endif
vec3 baseColorCorrected = baseColorCorrection.a * baseColor +
baseColorCorrection.rgb;
return clamp(baseColorCorrected, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
}
#ifdef USE_LIGHTMAP
varying vec2 vUv2;
uniform sampler2D lightMap;
vec3 getLightIntensity() {
return hdrDecode(texture2D(lightMap, vUv2));
}
#else // NOT USE_LIGHTMAP
vec3 getLightIntensity() {
return vec3(1.0);
}
#endif
#ifdef USE_ROUGHNESS_TEXTURE
uniform sampler2D roughnessTexture;
#else
uniform float roughness;
#endif
#ifdef USE_METALLIC_TEXTURE
uniform sampler2D metallicTexture;
#else
uniform float metallic;
#endif
vec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity,
inout float opacity);
#if defined(USE_DYNAMIC_LIGHT) || defined(USE_ENVMAP)
const float DLT = 0.001;
#ifdef USE_ENVMAP
uniform samplerCube envMap;
uniform float envMipsCount;
#ifdef HAVE_TEXTURE_LOD
#else
uniform samplerCube envMap2;
#endif
#endif
struct Roughness {
#ifdef USE_DYNAMIC_LIGHT
#endif
#ifdef USE_ENVMAP
float envFresnel; // (1.0 - roughness)^2, used for Fresnel with env map
float envMipLevel0;
float envMipLevel1;
float envMipMixFactor;
#endif
};
Roughness getRoughnessFactors() {
Roughness r;
#ifdef USE_ROUGHNESS_TEXTURE
float roughness = texture2D(roughnessTexture, vUv).x;
#endif // else roughness is a uniform
float roughness2 = roughness * roughness;
#ifdef USE_DYNAMIC_LIGHT
#endif
#ifdef USE_ENVMAP
float maxMipLevel = envMipsCount - 1.0;
float mipSelector = roughness * maxMipLevel;
r.envMipLevel0 = floor(mipSelector);
r.envMipLevel1 = min(r.envMipLevel0 + 1.0, maxMipLevel);
r.envMipMixFactor = fract(mipSelector);
r.envFresnel = (roughness2 - 2.0 * roughness + 1.0);
#endif
return r;
}
#ifdef USE_ENVMAP
#ifdef USE_ENVMAP_PROJECT
uniform vec3 envBoxMin;
uniform vec3 envBoxMax;
uniform vec3 envMapPosW;
const vec3 infBox = vec3(1000.0);
vec3 cubeMapProject(vec3 reflectionW) {
vec3 firstPlaneIntersect = (envBoxMax - vPositionW) / reflectionW;
vec3 secondPlaneIntersect = (envBoxMin - vPositionW) / reflectionW;
vec3 furthestPlane = max(firstPlaneIntersect, secondPlaneIntersect);
vec3 furthestPlaneNonNeg =
step(0.0, -furthestPlane) * infBox + abs(furthestPlane);
float distance = min(min(furthestPlaneNonNeg.x, furthestPlaneNonNeg.y),
furthestPlaneNonNeg.z);
/*if (furthestPlane.x > 0.0){
distance = furthestPlane.x;
}
if (furthestPlane.y > 0.0) {
distance = min(distance, furthestPlane.y);
}
if (furthestPlane.z > 0.0) {
distance = min(distance, furthestPlane.z);
}*/
vec3 intersectionPosW = vPositionW + reflectionW * distance;
return intersectionPosW - envMapPosW;
}
#endif // USE_ENVMAP_PROJECT
vec3 fixSeams(vec3 vec, float mipLevel) {
float scale = 1.0 - exp2(mipLevel) / 128.0;
float M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));
if (abs(vec.x) != M) vec.x *= scale;
if (abs(vec.y) != M) vec.y *= scale;
if (abs(vec.z) != M) vec.z *= scale;
return vec;
}
vec3 getEnvColor(in samplerCube envMap, in Roughness roughness,
in vec3 reflectionW) {
vec3 reflectionNormW = normalize(reflectionW);
#ifdef USE_ENVMAP_PROJECT
if (envBoxMin.x != envBoxMax.x) {
reflectionNormW = cubeMapProject(reflectionNormW);
}
#endif
vec3 reflectionNormFixedW = fixSeams(reflectionNormW,
roughness.envMipLevel0);
#ifdef HAVE_TEXTURE_LOD
vec4 cubeColorRaw0 = textureCubeLodEXT(envMap, reflectionNormFixedW,
roughness.envMipLevel0);
#else
vec4 cubeColorRaw0 = textureCube(envMap, reflectionNormFixedW);
#endif
vec3 cubeColor0 = hdrDecode(cubeColorRaw0);
#ifdef HAVE_TEXTURE_LOD
vec4 cubeColorRaw1 = textureCubeLodEXT(envMap, reflectionNormFixedW,
roughness.envMipLevel1);
#else
vec4 cubeColorRaw1 = textureCube(envMap2, reflectionNormFixedW);
#endif
vec3 cubeColor1 = hdrDecode(cubeColorRaw1);
return mix(cubeColor0, cubeColor1, roughness.envMipMixFactor);
}
vec3 fresnelSchlickEnv(in vec3 specularColor, in Roughness roughness,
in float clampCosnv, inout float opacity) {
float fresnel = 1.0 - clampCosnv;
float fresnel2 = fresnel * fresnel;
fresnel *= fresnel2 * fresnel2;
fresnel *= roughness.envFresnel;
opacity = opacity + (1.0 - opacity) * fresnel;
return specularColor + (1.0 - specularColor) * fresnel;
}
#endif // USE_ENVMAP
#ifdef USE_DYNAMIC_LIGHT
#endif // USE_DYNAMIC_LIGHT
vec3 getSpecularColor(in vec3 baseColor, float metalic) {
const float dielectricF0 = 0.04;
return mix(vec3(dielectricF0), baseColor, metalic);
}
float getLuminance(in vec3 color) {
return 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;
}
vec4 lerpLightVisibility(in sampler2D map, in vec2 uv, in vec2 size) {
vec2 fragAddress = uv * size + 0.5;
vec2 weight = fract(fragAddress);
vec2 sizeInv = 1.0 / size;
vec2 uvlb = floor(fragAddress) * sizeInv;
vec4 lb = texture2D(map, uvlb);
vec4 lt = texture2D(map, uvlb + vec2(0.0, sizeInv.y));
vec4 rb = texture2D(map, uvlb + vec2(sizeInv.x, 0.0));
vec4 rt = texture2D(map, uvlb + vec2(sizeInv.x, sizeInv.y));
vec4 lb_idx = floor(lb);
vec4 lt_idx = floor(lt);
vec4 rb_idx = floor(rb);
vec4 rt_idx = floor(rt);
vec4 lt_idx_smaller_eq = step(lt_idx, lb_idx);
vec4 rb_idx_smaller_eq = step(rb_idx, lb_idx);
vec4 rt_idx_smaller_eq = step(rt_idx, lb_idx);
lt = clamp(lt, lb_idx, lb_idx + 0.999 * lt_idx_smaller_eq);
rb = clamp(rb, lb_idx, lb_idx + 0.999 * rb_idx_smaller_eq);
rt = clamp(rt, lb_idx, lb_idx + 0.999 * rt_idx_smaller_eq);
vec4 a = mix(lb, lt, weight.y);
vec4 b = mix(rb, rt, weight.y);
return mix(a, b, weight.x);
}
vec3 getNormalW() {
#ifdef USE_BUMP_TEXTURE
vec3 normalPerturbedV = perturbNormal(-vPositionV, normalize(vNormalV));
return normalize(
inverseTransformDirection(normalPerturbedV, viewMatrix));
#else
return normalize(vNormalW);
#endif
}
vec3 addSpecular(in vec3 baseColor, in vec3 totalIntensity,
inout float opacity) {
vec3 totalSpec = vec3(0.0, 0.0, 0.0);
#ifdef USE_METALLIC_TEXTURE
float metallic = texture2D(metallicTexture, vUv).x;
#endif // else metallic is a uniform
vec3 diffuseIntensity = totalIntensity * (1.0 - mix(0.04, 1.0, metallic));
vec3 viewW = normalize(cameraPosition - vPositionW);
vec3 normalW = getNormalW();
float clampCosnv = saturate(dot(normalW, viewW));
vec3 reflectionW = reflect(-viewW, normalW);
vec3 specularColor = getSpecularColor(baseColor, metallic);
Roughness roughness = getRoughnessFactors();
#ifdef USE_ENVMAP
vec3 envColor = getEnvColor(envMap, roughness, reflectionW);
vec3 fresnel = fresnelSchlickEnv(specularColor, roughness,
clampCosnv, opacity);
totalSpec = envColor * fresnel;
#endif
#ifdef USE_DYNAMIC_LIGHT
#endif
float luminance = getLuminance(totalIntensity);
return (baseColor * diffuseIntensity +
totalSpec * mix(0.4, 1.0, luminance));
}
#else // NOT (USE_DYNAMIC_LIGHT or USE_ENVMAP)
vec3 addSpecular(vec3 baseColor, in vec3 lightIntensity, in float opacity) {
return baseColor * lightIntensity;
}
#endif
#ifdef USE_HIGHLIGTH
uniform vec3 highlight;
uniform float highlightMix;
#endif
#if defined(HDR_OUTPUT)
vec4 hdrEncode(in vec3 rgb) {
const float rgbmScale = 2.82842712;  // sqrt(8)
vec3 r = sqrt(rgb) / rgbmScale;
float m = max(max(r.r, r.g), r.b);
m = clamp(m, 1.0 / 255.0, 1.0);
m = ceil(m * 255.0) / 255.0;
r /= m;
return vec4(r.r, r.g, r.b, (1.0 - m));
}
#endif
#ifdef USE_COLORMAP
vec3 colormap(in sampler2D texture, in vec3 color) {
const float resolution = 16.0;
const float maxValueIndex = resolution - 1.0;
const float sliceWidth = 1.0 / resolution;
const float slicePixelWidth = sliceWidth / resolution;
const float sliceMarginWidth = 0.5 * slicePixelWidth;
const float sliceInnerWidth = sliceWidth - slicePixelWidth;
const float slicePixelHeight = 1.0 / resolution;
const float sliceMarginHeight = 0.5 * slicePixelHeight;
const float sliceInnerHeight = 1.0 - slicePixelHeight;
float bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);
float bSlice1 = bSlice0 + 1.0;
float bOffset = color.b * maxValueIndex - bSlice0;
float rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;
float gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;
float rPos0 = rSlicePos + (bSlice0 * sliceWidth);
float rPos1 = rSlicePos + (bSlice1 * sliceWidth);
vec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;
vec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;
return mix(color0, color1, bOffset);
}
uniform sampler2D colorMap;
#endif
#ifdef USE_CHROMA_KEY
uniform vec3 chromaKeyColor;
uniform vec3 chromaKeyDeltaCoeff;
const float k32 = sqrt(3.0) / 2.0;
vec3 rgb2abi(vec3 color) {
float r = color.r;
float g = color.g;
float b = color.b;
return vec3(
r - 0.5 * g - 0.5 * b,
k32 * (g - b),
0.3333 * (r + g + b));
}
const float IPI2 = 0.5 / 3.1415926538;
vec3 rgb2hci(vec3 color) {
vec3 abi = rgb2abi(color);
return vec3(
atan(abi.y, abi.x) * IPI2,
length(abi.xy),
abi.z);
}
float chromaKeyShapeFn(vec3 delta, vec3 color, vec3 key) {
vec3 diff = color - key;
vec3 v = delta * vec3(
0.5 - abs(abs(diff.x) - 0.5),
abs(diff.y),
abs(diff.z));
float x = max(v.r, max(v.g, v.b));
return x * x;
}
float chromaKeyEdgeFn(float a) {
return clamp(.2/.5 * (a - 1.0), 0.0, 1.0);
}
#endif
uniform float emissionStrength;
uniform float exposure;
uniform float cameraGamma;
void main() {
    float alpha;
    vec3 baseColor = getBaseColor(alpha);
#ifdef USE_CHROMA_KEY
    float dist = chromaKeyShapeFn(chromaKeyDeltaCoeff, rgb2hci(baseColor), rgb2hci(chromaKeyColor));
    alpha *= chromaKeyEdgeFn(dist);
#endif
#ifdef USE_BASE_COLOR_TEXTURE
    if (alpha < alphaDiscardThreshold) {
        discard;
    }

#endif
    vec3 lightIntensity = getLightIntensity();
#ifdef USE_HIGHLIGTH
    baseColor = mix(baseColor, highlight, highlightMix);
    alpha = mix(alpha, 1.0, highlightMix);
#endif
    vec3 diffuseSpecular = addSpecularHook(baseColor, lightIntensity, alpha);
#ifdef USE_HEADLIGHT
    vec3 lightW = normalize(cameraPosition - vPositionW.xyz);
    float pointDiffuse = max(dot(normalize(vNormalW), lightW), 0.0);
    diffuseSpecular *= pointDiffuse;
#endif
    vec3 diffuseSpecularEmissive = diffuseSpecular + baseColor * emissionStrength;
#ifdef HDR_OUTPUT
    if (alpha < 0.5) {
        discard;
    }
    gl_FragColor = hdrEncode(diffuseSpecularEmissive);
#else // no HDR_OUTPUT
    vec3 exposedColor = pow(exposure * diffuseSpecularEmissive.xyz,
    vec3(cameraGamma));
    vec3 gammaColor =  linearToGammaUnreal(exposedColor);
#ifdef USE_COLORMAP
    gl_FragColor.rgb = colormap(colorMap, min(gammaColor, 1.0));
#else
    gl_FragColor.rgb = gammaColor;
#endif
    gl_FragColor.a = alpha;
#endif // no HDR_OUTPUT
}
`


var fragHooks = `
vec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity, inout float opacity)
{
    return addSpecular(baseColor, totalIntensity, opacity);
}
`

class j3dStandardMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {

    constructor() {
    	super()

    	this.type = "j3dStandardMaterial";

    	this.merged = !1;
    	this._opacity = 1;
    	Object.defineProperty(this, "opacity", {
    		get: function () {
    			return this._opacity
    		},

    		set: function (value) {
    			this._opacity = .99 < value ? 1 : value;
    			this.configureTransparency();
    			this.setUniforms();
    			this._updated()
    		}
    	});

    	this.baseColor = new THREE.Color(16777215);
    	this._baseColorTexture = null;
    	this._baseColorTextureCorrection = this.planarReflector = false;
    	this._baseColorTextureContrast = 0;
    	this.baseColorTextureHslOffset = {
    		h: 0,
    		s: 0,
    		l: 0
    	};

    	this._baseColorCorrectionUniform = new THREE.Vector4;
    	this.lightMapped = false;
    	this.lightVisibilityMap = null;
    	this._lightVisibilityMapSize = new THREE.Vector2;
    	this.lightAttrMap = null;
    	this.lightsCount = 0;
    	this._emissive = !1;
    	this._roughness = this._emissionStrength = 1;
    	this._metallic = 0;
    	this._lastUsedLightProbeId = this.cubeCameraIndex = null;
    	this._haveTextureLod = JMT.DETECTOR.textureLod;
    	this._mipLevel1 = this._mipLevel0 = null;
    	this.disableLightProbeTmp = this.disableLightProbe = !1;
    	this._envMapProject = !0;
    	this._hdrOutput = !1;
    	this._bumpScale = .001;
    	this.parallaxCorrection = !1;
    	this.parallaxMode = "basic";
    	this.parallaxScale = -.03;
    	this.parallaxMinLayers = 10;
    	this.parallaxMaxLayers = 15;
    	this.colorMap = null;
    	this.cameraExposure = 0;
    	this.cameraGamma = 1;
    	this.headLight = !1;
    	this._uvOffsetScale = null;
    	this.highlight = JMT.EDIT_MODE ? JMT.EDITOR_SELECTION_COLOR : JMT.APP_SELECTION_COLOR;
    	this._specularOff = this._highlightMix = 0;
    	this.doNotImport = {
    		baseColor: !1,
    		opacity: !1
    	};
    	this._updated = function () {
    		return this.dispatchEvent({
    			type: "materialUpdated",
    			target: this
    		})
    	};
    	this._alphaInLowerHalf = !1;
    	this._chromaKeyEnabled = void 0;
    	this.chromaKeyColor = (new THREE.Color).setRGB(0, .94, 0);
    	this._chromaKeyDelta = new THREE.Vector3(.1, .1, .1);
    	this._chromaKeyDeltaCoeff = new THREE.Vector3;

        //custom
        //this._uv2Mod = new THREE.Vector4(0, 0, 1 / 65535, 1 / 65535);
        this.lightMap = null;
        //this._useInstanceBuffer = false

		//custom
		//add textures
		// this.addTextureProperty("roughnessTexture");
		// this.addTextureProperty("metallicTexture");
		// this.addTextureProperty("bumpTexture");
		
    	///
    	let ver = [
    		"attribute vec2 sphericalNormal;",
    		"attribute vec2 uv2;",

    		"attribute vec4 uv2Mod;",
    		vertexShader

    	].join("\n")


    	let frag = [
    		fragmentShader,
    		this.fragmentShaderHooks()
    	].join("\n")


    	this.vertexShader = ver;
        this.fragmentShader = frag;

    }

    get uv2Mod() {
        return this._uv2Mod;
    }

    set uv2Mod(value) {
        this._uv2Mod.copy(value);
        this.setUniforms();
    	this._updated();
    }

    get color() {
    	return this.baseColor
    }

    set color(color) {
    	this.baseColor.copy(color)
    	this.setUniforms();
    	this._updated()
    }

    //mesh 是否为实例化的
    // get useInstanceBuffer () {
    //     return this._useInstanceBuffer;
    // }

    // set useInstanceBuffer(value) {
    //     if (this._useInstanceBuffer && this._useInstanceBuffer != value) {
    //         console.log("aaa")
    //     }
    //     this._useInstanceBuffer = value;
    //     this.setUniforms();
    // 	//this._updated()
    // }

	// addTextureProperty(a) {
	// 	var b = "_" + a;
	// 	Object.defineProperty(this, a, {
	// 		get: function () {
	// 			return this[b] || null
	// 		},
	// 		set: function (a) {
	// 			var c = this;
	// 			this[b] = a
	// 			if (this[b]) {
	// 				a.addLoadedListener(function () {
	// 					c.setUniforms();
	// 					c._updated();
	// 					c = a = null
	// 				})
	// 			} else {
	// 				c.setUniforms()
	// 				c._updated()
	// 			}
	// 		}
	// 	})
	// };

	
	fragmentShaderHooks () {
		return fragHooks
	};

    // _useChromaKey() {
    // 	return !(!this.isAnimated || !this.chromaKeyEnabled)
    // };
    // _useAlphaInLowerHalf() {
    // 	return !(!this.isAnimated || !this.alphaInLowerHalf)
    // };

    // _useBaseColorTextureAsCutout() {
    // 	var a = this._baseColorTexture;
    // 	return 1 === this.opacity && (a && a.isCutout || this._useAlphaInLowerHalf() || this._useChromaKey())
    // };

    // configureTransparency() {
    // 	var a = this._baseColorTexture;
    // 	a = a && (a.hasAlpha || this._useAlphaInLowerHalf() || this._useChromaKey());
    // 	this.transparent = 1 > this.opacity || a;
    // 	a = this._useBaseColorTextureAsCutout();
    // 	if (this.transparent) {
    // 		this.blending = THREE.NormalBlending
    // 		this.transparentRenderOrder = a ? 0 : 1
    // 	} else {
    // 		this.blending = THREE.NoBlending;
    // 	}
    // 	this.depthWrite = !this.transparent || a
    // };
}

j3dStandardMaterial.prototype.isJ3dStandardMaterial = true;

// Object.defineProperty(j3dStandardMaterial.prototype, "color", {
//     get: function () {
//         return this.baseColor
//     },
//     set: function (color) {
//         this.baseColor.copy(color)
//         this.setUniforms();
//         this._updated()
//     }
// });

j3dStandardMaterial.prototype.addTextureProperty = function (a) {
    var b = "_" + a;
    Object.defineProperty(this, a, {
        get: function () {
            return this[b] || null
        },
        set: function (a) {
            var c = this;
            this[b] = a
            if (this[b]) {
                a.addLoadedListener(function () {
                    c.setUniforms();
                    c._updated();
                    c = a = null
                })
            } else {
                c.setUniforms()
                c._updated()
            }
        }
    })
};

j3dStandardMaterial.prototype.addTextureProperty("roughnessTexture");
j3dStandardMaterial.prototype.addTextureProperty("metallicTexture");
j3dStandardMaterial.prototype.addTextureProperty("bumpTexture");
// j3dStandardMaterial.prototype.fragmentShaderHooks = function () {
//     return c
// };
j3dStandardMaterial.prototype._useChromaKey = function () {
    return !(!this.isAnimated || !this.chromaKeyEnabled)
};
j3dStandardMaterial.prototype._useAlphaInLowerHalf = function () {
    return !(!this.isAnimated || !this.alphaInLowerHalf)
};
j3dStandardMaterial.prototype._useBaseColorTextureAsCutout = function () {
    var a = this._baseColorTexture;
    return 1 === this.opacity && (a && a.isCutout || this._useAlphaInLowerHalf() || this._useChromaKey())
};
j3dStandardMaterial.prototype.configureTransparency = function () {
    var a = this._baseColorTexture;
    a = a && (a.hasAlpha || this._useAlphaInLowerHalf() || this._useChromaKey());
    this.transparent = 1 > this.opacity || a;
    a = this._useBaseColorTextureAsCutout();
    if (this.transparent) {
        this.blending = THREE.NormalBlending
        this.transparentRenderOrder = a ? 0 : 1
    } else {
        this.blending = THREE.NoBlending;
    }
    this.depthWrite = !this.transparent || a
};
Object.defineProperty(j3dStandardMaterial.prototype, "alphaInLowerHalf", {
    get: function () {
        return this._alphaInLowerHalf
    },
    set: function (a) {
        this._alphaInLowerHalf = a;
        this.configureTransparency();
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "chromaKeyEnabled", {
    get: function () {
        return !!this._chromaKeyEnabled
    },
    set: function (a) {
        this._chromaKeyEnabled = !!a;
        this.configureTransparency();
        this.setUniforms();
        this._updated()
    }
});
j3dStandardMaterial.prototype.setChromaKeyColorRGB = function (a, b, c) {
    this.chromaKeyColor.setRGB(a, b, c);
    this.setUniforms();
    this._updated()
};
j3dStandardMaterial.prototype.getChromaKeyDeltaComponent = function (a) {
    return this._chromaKeyDelta.getComponent(a)
};
j3dStandardMaterial.prototype.setChromaKeyDeltaComponent = function (a, b) {
    this._chromaKeyDelta.setComponent(a, b);
    this.setUniforms();
    this._updated()
};
Object.defineProperty(j3dStandardMaterial.prototype, "isAnimated", {
    get: function () {
        var a = this.baseColorTexture;
        return a && a.isAnimated || this._isAnimated
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "isPlaying", {
    get: function () {
        var a = this.baseColorTexture;
        return a && a.isAnimated && a.isPlaying || this._isPlaying
    }
});
j3dStandardMaterial.prototype.play = function () {
    console.assert(this.isAnimated);
    var a = this.baseColorTexture.isPlaying;
    this.baseColorTexture.play();
    this.baseColorTexture.isPlaying !== a && this._updated()
};
j3dStandardMaterial.prototype.pause = function () {
    console.assert(this.isAnimated);
    var a = this.baseColorTexture.isPlaying;
    this.baseColorTexture.pause();
    this.baseColorTexture.isPlaying !== a && this._updated()
};
j3dStandardMaterial.prototype.sleepAnimation = function () {
    console.assert(this.isAnimated);
    this.baseColorTexture.sleepAnimation()
};
j3dStandardMaterial.prototype.wakeAnimation = function () {
    console.assert(this.isAnimated);
    this.baseColorTexture.wakeAnimation()
};
Object.defineProperty(j3dStandardMaterial.prototype, "doubleSided", {
    get: function () {
        return this.side === THREE.DoubleSide
    },
    set: function (a) {
        this.side = a ? THREE.DoubleSide : THREE.FrontSide;
        //this.setUniforms();
        //this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "envMapMirror", {
    get: function () {
        return 0 === this.roughness && !this.roughnessTexture
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "hdrOutput", {
    get: function () {
        return this._hdrOutput
    },
    set: function (a) {
        a !== this._hdrOutput && (this._hdrOutput = a, this.setUniforms())
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "specularOff", {
    get: function () {
        return this._specularOff
    },
    set: function (a) {
        a !== this._specularOff && (this._specularOff = a, this.setUniforms())
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "highlightMix", {
    get: function () {
        return this._highlightMix
    },
    set: function (a) {
        a !== this._highlightMix && (this._highlightMix = a, this.uniforms.highlightMix.value = a)
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "cameraExposure", {
    get: function () {
        return this._cameraExposure
    },
    set: function (a) {
        this._cameraExposure = a;
        this.setUniform("exposure", "f", Math.pow(2, a))
    }
});
Object.defineProperty(j3dStandardMaterial.prototype,
    "cameraGamma", {
        get: function () {
            return this.uniforms.cameraGamma.value
        },
        set: function (a) {
            this.setUniform("cameraGamma", "f", a)
        }
    });
Object.defineProperty(j3dStandardMaterial.prototype, "baseColorTexture", {
    get: function () {
        return this._baseColorTexture
    },
    set: function (a) {
        var b = this;
        this._baseColorTexture = a
        if (this._baseColorTexture) {
            a.addLoadedListener(function () {
                b.configureTransparency();
                b.setUniforms();
                b._updated();
                b = a = null
            })
        } else {
            b.setUniforms()
            b._updated()
        }
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "baseColorTextureCorrection", {
    get: function () {
        return this._baseColorTextureCorrection
    },
    set: function (a) {
        this._baseColorTextureCorrection = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "baseColorTextureContrast", {
    get: function () {
        return this._baseColorTextureContrast
    },
    set: function (a) {
        this._baseColorTextureContrast = a;
        this.setUniforms();
        this._updated()
    }
});
j3dStandardMaterial.prototype.setBaseColorTextureHslOffset = function (a, b, c) {
    this.baseColorTextureHslOffset.h = a;
    this.baseColorTextureHslOffset.s = b;
    this.baseColorTextureHslOffset.l = c;
    this.setUniforms();
    this._updated()
};
Object.defineProperty(j3dStandardMaterial.prototype, "emissive", {
    get: function () {
        return this._emissive
    },
    set: function (a) {
        this._emissive = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "emissionStrength", {
    get: function () {
        return this._emissionStrength
    },
    set: function (a) {
        this._emissionStrength = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype,
    "roughness", {
        get: function () {
            return this._roughness
        },
        set: function (a) {
            this._roughness = a;
            this.setUniforms();
            this._updated()
        }
    });
Object.defineProperty(j3dStandardMaterial.prototype, "metallic", {
    get: function () {
        return this._metallic
    },
    set: function (a) {
        this._metallic = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "envMapProject", {
    get: function () {
        return this._envMapProject
    },
    set: function (a) {
        this._envMapProject = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterial.prototype, "bumpScale", {
    get: function () {
        return this._bumpScale
    },
    set: function (a) {
        this._bumpScale = a;
        this.setUniforms();
        this._updated()
    }
});
j3dStandardMaterial.prototype.setDoNotImport = function (a, b) {
    this.doNotImport[a] = b;
    this.setUniforms();
    this._updated()
};
j3dStandardMaterial.prototype.isLightProbeDisabled = function () {
    return this.disableLightProbe || this.disableLightProbeTmp || this.specularOff || 1 === this.roughness && !this._roughnessTexture || this.transparent && this.doubleSided
};
j3dStandardMaterial.prototype._setLightProbeUniforms = function () {
    this.setUniform("envMap", "t", null);
    if (!this.condDefine(this._haveTextureLod, "HAVE_TEXTURE_LOD")) {
        var a = JMT.LIGHT_PROBE_MIPS_COUNT - 1;
        this._mipLevel0 = Math.floor(this.roughness * a);
        this._mipLevel1 = Math.min(this._mipLevel0 + 1, a);
        this.setUniform("envMap2", "t", null)
    }

    if (this.envMapMirror) {
        this.setUniform("envMipsCount", "f", 1)
    } else {
        this.setUniform("envMipsCount", "f", 0);
    }

    if (this.condDefine(this.envMapProject, "USE_ENVMAP_PROJECT")) {
        this.setUniform("envMapPosW", "v3", e)
        this.setUniform("envBoxMin", "v3", e)
        this.setUniform("envBoxMax", "v3", e)
    }
    this._lastUsedLightProbeId = null
};
j3dStandardMaterial.prototype.setUvOffsetAndScale = function (a, b, c, d) {
    this._uvOffsetScale || (this._uvOffsetScale = new THREE.Vector4);
    console.assert(!this.baseColorTexture || !this.baseColorTexture.parentTexture, "Can't set uv offset and scale if baseColor texture is in atlas");
    this._uvOffsetScale.set(a, b, c, d)
};
j3dStandardMaterial.prototype.setUniforms = function () {

    if (this.condDefine(this.skinning, "USE_SKINNING")) {

    }

    this.setUniform("opacity", "f", this.opacity);

    var a = !this.isLightProbeDisabled()
    var b = !1
    var c = this.roughnessTexture;

    if (this.condDefine(c && c.loaded && a, "USE_ROUGHNESS_TEXTURE")) {
        this.setUniform("roughnessTexture", "t", c)
        b = !0
    } else {
        this.setUniform("roughness", "f", this.roughness);
    }

    c = this.metallicTexture;
    if (this.condDefine(c && c.loaded && a, "USE_METALLIC_TEXTURE")) {
        this.setUniform("metallicTexture", "t", c)
        b = !0
    } else {
        this.setUniform("metallic", "f", this.metallic);
    }


    this.setUniform("emissionStrength", "f", this.emissive ? this.emissionStrength : 0);

    if (this._baseColorTexture && this.baseColorTextureCorrection) {
        d.set(this.baseColor)
        d.offsetHSL(this.baseColorTextureHslOffset.h, this.baseColorTextureHslOffset.s, this.baseColorTextureHslOffset.l)
        c = Math.max(1 + this.baseColorTextureContrast, 0)
        this._baseColorCorrectionUniform.set(c * (d.r - this.baseColor.r - .5) + .5, c * (d.g - this.baseColor.g - .5) + .5, c * (d.b - this.baseColor.b - .5) + .5, c)
    } else {
        this._baseColorCorrectionUniform.set(0, 0, 0, 1);
    }

    this.setUniform("baseColorCorrection", "v4", this._baseColorCorrectionUniform);
    c = null;
    var e = null;
    if (this._baseColorTexture) {
        if (this._baseColorTexture.parentTexture) {
            c = this._baseColorTexture.parentTexture;
            e = this._baseColorTexture.uvOffsetScale
        } else {
            c = this._baseColorTexture
            e = g;
        }
    }
    if (this.condDefine(c && c.loaded, "USE_BASE_COLOR_TEXTURE")) {
        this.setUniform("baseColorTexture", "t", c)
        b = !0
        this.setUniform("baseColorAtlasUvMod", "v4", e)

        if (this._useBaseColorTextureAsCutout()) {
            this.setUniform("alphaDiscardThreshold", "f", .25)
        } else {
            this.setUniform("alphaDiscardThreshold", "f", 0)
        }
    } else {
        this.setUniform("baseColor", "c", this.baseColor);
    }

    this.condDefine(this._useAlphaInLowerHalf(), "USE_ALPHA_IN_LOWER_HALF");

    if (this.condDefine(this._useChromaKey(), "USE_CHROMA_KEY")) {
        this.setUniform("chromaKeyColor", "c", this.chromaKeyColor)
        e = this._chromaKeyDelta
        this._chromaKeyDeltaCoeff.x = 1 / (1.22 * e.x)
        this._chromaKeyDeltaCoeff.y = 1 / (1.22 * e.y)
        this._chromaKeyDeltaCoeff.z = 1 / (1.22 * e.z)
        this.setUniform("chromaKeyDeltaCoeff", "v3", this._chromaKeyDeltaCoeff)
    }

    c = this.bumpTexture;
    if (this.condDefine(c && c.loaded && a, "USE_BUMP_TEXTURE")) {
        this.enableStandardDerivativesExtension()
        this.setUniform("bumpTexture", "t", c)
        b = !0
        this.setUniform("bumpScale", "f", this.bumpScale)

        if (this.condDefine(this.parallaxCorrection, "USE_PARALLAX_CORRECTION")) {
            this.addDefine(JMT.ParallaxModes[this.parallaxMode])
            this.setUniform("parallaxScale", "f", this.parallaxScale)
            this.setUniform("parallaxMinLayers", "f", this.parallaxMinLayers)
            this.setUniform("parallaxMaxLayers", "f", this.parallaxMaxLayers)
        }
    }

    b && this.setUniform("uvMod", "v4", this._uvOffsetScale || g);

    if (this.condDefine(this.lightMapped, "USE_LIGHTMAP")) {
        this.setUniform("lightMap", "t", this.lightMap)
    }

    if (this.condDefine(this.lightAttrMap && !this.specularOff, "USE_DYNAMIC_LIGHT")) {
        console.assert(this.lightVisibilityMap)
        console.assert(this.lightsCount)
        console.assert(this.lightVisibilityMap.width)
        console.assert(this.lightVisibilityMap.height)
        this.setUniform("lightVisibilityMap", "t", this.lightVisibilityMap)
        this.setUniform("lightAttrMap", "t", this.lightAttrMap)
        this.setUniform("lightsCount", "f", this.lightsCount)
        this._lightVisibilityMapSize.set(this.lightVisibilityMap.width, this.lightVisibilityMap.height)
        this.setUniform("lightVisibilityMapSize", "v2", this._lightVisibilityMapSize)
    }

    if (this.condDefine(a, "USE_ENVMAP")) {
        this._haveTextureLod && this.enableTextureLodExtension()
        this._setLightProbeUniforms()
    }

    if (this.condDefine(this.highlight, "USE_HIGHLIGTH")) {
        this.setUniform("highlight", "c", this.highlight)
        this.setUniform("highlightMix", "f", this.highlightMix)
    }

    this.condDefine(this.hdrOutput, "HDR_OUTPUT");

    if (this.condDefine(!this.hdrOutput && this.colorMap, "USE_COLORMAP")) {
        this.setUniform("colorMap", "t", this.colorMap);
    }

    this.condDefine((this.headLight || !this.lightMapped) && !this.specularOff, "USE_HEADLIGHT")

    //uv2Mod
    //this.setUniform("uv2Mod", "v4", this.uv2Mod);

    //this.condDefine(this._useInstanceBuffer, "USE_INSTANCE_BUFFERS")
};

j3dStandardMaterial.prototype.forceObjectUniformsRefresh = function () {
    this._lastUsedLightProbeId = null
};

j3dStandardMaterial.prototype.textureNeedsUv0 = function (a) {
    return !0
};

j3dStandardMaterial.prototype.hash = function () {
    return this.baseColorTexture ? "standard" + this.baseColorTexture.name : "standard#" + this.baseColor.r + ":" + this.baseColor.g + ":" + this.baseColor.b
};

j3dStandardMaterial.prototype.canMerge = function (a) {

    if (this.type !== a.type || this.opacity !== a.opacity) {
        return !1;
    }

    if (this._baseColorTexture || a._baseColorTexture) {

        if (this._baseColorTexture !== a._baseColorTexture ||
            this.baseColorTextureCorrection !== a.baseColorTextureCorrection ||
            this.baseColorTextureContrast !== a.baseColorTextureContrast ||
            this.baseColorTextureHslOffset.h !== a.baseColorTextureHslOffset.h ||
            this.baseColorTextureHslOffset.s !== a.baseColorTextureHslOffset.s ||
            this.baseColorTextureHslOffset.l !== a.baseColorTextureHslOffset.l ||
            this._useAlphaInLowerHalf() !== a._useAlphaInLowerHalf() ||
            (this._useChromaKey() ? !(a._useChromaKey() && this.chromaKeyColor.equals(a.chromaKeyColor) && this._chromaKeyDelta.equals(a._chromaKeyDelta)) : a._useChromaKey())) {
            return !1
        }
    } else if (!this.baseColor.equals(a.baseColor)) {
        return !1;
    }

    if (this.emissive || a.emissive)
        if (this.emissive !== a.emissive || this.emissionStrength !== a.emissionStrength) {
            return !1;
        }

    if (this.roughnessTexture || a.roughnessTexture) {

        if (this.roughnessTexture !== a.roughnessTexture) return !1

    } else if (this.roughness !== a.roughness) {

        return !1;

    }
    if (this.metallicTexture || a.metallicTexture) {

        if (this.metallicTexture !== a.metallicTexture) {

            return !1

        }
    } else if (this.metallic !== a.metallic) {

        return !1;

    }
    return (this.bumpTexture || a.bumpTexture) &&
        (this.bumpTexture !== a.bumpTexture || this.bumpScale !== a.bumpScale) ||
        this.envMapProject !== a.envMapProject ||
        this.doubleSided !== a.doubleSided ||
        this.parallaxCorrection ||
        a.parallaxCorrection ? !1 : !0
};

j3dStandardMaterial.prototype.refreshPerObjectUniforms = function (a, b) {
    var c = !1;
    if (!this.isLightProbeDisabled()) {
        var d = a.lightProbe;

        if (!d) {
            JMT.log('未找到反射球', this);
        }

        if (d && this._lastUsedLightProbeId !== d.id) {
            c = !0;
            this._lastUsedLightProbeId = d.id;
            var f = this.envMapMirror ? d.getMirrorTexture() : this._haveTextureLod ? d.getFilteredTexture() : d.getFilteredTextureNoLod(this._mipLevel0);
            b.envMap.value = f;
            this._haveTextureLod ||
                (b.envMap2.value = d.getFilteredTextureNoLod(this._mipLevel1));
            this.envMapMirror || (b.envMipsCount.value = JMT.LIGHT_PROBE_MIPS_COUNT);
            this.envMapProject && (d.isBoundingBoxEnabled() ? (b.envMapPosW.value = d.position, b.envBoxMin.value = d.boxMin, b.envBoxMax.value = d.boxMax) : (b.envBoxMin.value = e, b.envBoxMax.value = e))
        }
    }
    a = a.lightMap;
    this.lightMapped && b.lightMap.value !== a && (c = !0, b.lightMap.value = a);
    return c
};
j3dStandardMaterial.prototype.setBaseColorRGB = function (a, b, c) {
    this.baseColor.setRGB(a, b, c);
    this.setUniforms();
    this._updated()
};
j3dStandardMaterial.prototype.setTexture = function (a, b) {
    if (b) {
        var c = this.baseColorTexture;
        if (c) {
            b.wrapS = c.wrapS
            b.wrapT = c.wrapT
            b.anisotropy = c.anisotropy
        }
    }
    this[a] = b || null;
    "baseColorTexture" === a ? (this._baseColorTextureCorrection = !1, this._baseColorTextureContrast = 0, this.baseColorTextureHslOffset.h = 0, this.baseColorTextureHslOffset.s = 0, this.baseColorTextureHslOffset.l = 0) : "bumpTexture" === a && (this._bumpScale = .001)
};

j3dStandardMaterial.prototype.deserialize = function (json, textureLoader) {

    let t = this

    t.name = json.name
    //t.type = json.type
    t.baseColor.setRGB(json.baseColor[0], json.baseColor[1], json.baseColor[2])
    t.baseColorTextureCorrection = !!json.baseColorTextureCorrection
    if (t.baseColorTextureCorrection) {
        let correction = json.baseColorTextureCorrection
        t.baseColorTextureContrast = correction.contrast
        t.baseColorTextureHslOffset = {
            h: correction.hslOffset[0],
            s: correction.hslOffset[1],
            l: correction.hslOffset[2]
        }
    }
    t.alphaInLowerHalf = !!json.alphaInLowerHalf
    t.opacity = json.opacity
    t.emissive = json.emissive
    t.emissionStrength = json.emissionStrength
    t.roughness = json.roughness
    t.metallic = json.metallic
    t.envMapProject = json.envMapProject
    t.bumpScale = json.bumpScale
    t.doubleSided = json.doubleSided
    t.doNotImport = json.doNotImport

    t.chromaKeyEnabled = json.chromaKeyEnabled
    if (!!json.chromaKeyEnabled) {
        t.chromaKeyColor.setRGB(json.chromaKeyColor[0], json.chromaKeyColor[1], json.chromaKeyColor[2])
        t._chromaKeyDelta.x = json.chromaKeyDelta[0]
        t._chromaKeyDelta.y = json.chromaKeyDelta[1]
        t._chromaKeyDelta.z = json.chromaKeyDelta[2]
    }

    t.hasFlash = json.hasFlash
    if (json.hasFlash) {
        t.flashColors = json.flashColors
        t.flashDelay = json.flashDelay
    }

    t.hasUvAnimated = json.hasUvAnimated
    if (json.hasUvAnimated) {
        // t.uvMoveSpeed = json.uvMoveSpeed
        // t.uvRepeat = json.uvRepeat
        t.uvRotate = json.uvRotate
        t.uvRotateSpeed = json.uvRotateSpeed
        t.uvMoveSpeed.fromArray(json.uvMoveSpeed)
        t.uvRepeat.fromArray(json.uvRepeat)
    }

    function solveTexture(type) {

        var sTex = json[type]

        if (sTex && sTex.id.indexOf('blob:http') !== 0) {
            // 替换贴图
            let texture = textureLoader.load(
                JMT.LOAD_PRIORITY.CORE_RESOURCE,
                sTex,
                !0,
                !0,
                JMT.DEFAULT_ANISOTROPY
            )
            t[type] = texture


        } else if (sTex === null) {

            t[type] && t[type].dispose()

            t[type] = null
        }
    }

    solveTexture("baseColorTexture");
    solveTexture("roughnessTexture");
    solveTexture("metallicTexture");
    solveTexture("bumpTexture");

    t.setUniforms()
}


j3dStandardMaterial.prototype.serialize = function (forceSerializeTexture) {
    var a = this
    var b = null;
    console.assert(!this.merged);

    if (this.baseColorTextureCorrection) {
        b = {
            contrast: this.baseColorTextureContrast,
            hslOffset: [
                this.baseColorTextureHslOffset.h,
                this.baseColorTextureHslOffset.s,
                this.baseColorTextureHslOffset.l
            ]
        }
    }
    var c = {
        name: this.name,
        type: this.type,
        baseColor: this.baseColor.roundChannels().toArray(),
        baseColorTextureCorrection: b,
        alphaInLowerHalf: this.alphaInLowerHalf,
        opacity: this.opacity,
        emissive: this.emissive,
        emissionStrength: this.emissionStrength,
        roughness: this.roughness,
        metallic: this.metallic,
        envMapProject: this.envMapProject,
        bumpScale: this.bumpScale,
        doubleSided: this.doubleSided,
        doNotImport: this.doNotImport,
        transparent: !!this.transparent
    };
    if (void 0 !== this._chromaKeyEnabled) {
        c.chromaKeyEnabled = this.chromaKeyEnabled
        c.chromaKeyColor = this.chromaKeyColor.roundChannels().toArray()
        c.chromaKeyDelta = this._chromaKeyDelta.toArray()
    }
    c.hasFlash = this.hasFlash
    if (this.hasFlash) {
        c.flashColors = this.flashColors
        c.flashDelay = this.flashDelay
    }
    c.hasUvAnimated = this.hasUvAnimated
    if (this.hasUvAnimated) {
        c.uvMoveSpeed = this.uvMoveSpeed.toArray()
        c.uvRepeat = this.uvRepeat.toArray()
        c.uvRotate = this.uvRotate
        c.uvRotateSpeed = this.uvRotateSpeed
    }

    let solveTexture = function (b) {
        var d = a[b];
        if (d) {
            (d.fromEditor || forceSerializeTexture) && (c[b] = d.serialize())
        } else {
            c[b] = null
        }
    };
    solveTexture("baseColorTexture");
    solveTexture("roughnessTexture");
    solveTexture("metallicTexture");
    solveTexture("bumpTexture");
    return c
}

j3dStandardMaterial.prototype.clone = function () {
    var newMaterial = new j3dStandardMaterial()

    newMaterial.name = this.name
    newMaterial.type = this.type
    newMaterial.baseColor.copy(this.baseColor)
    newMaterial.baseColorTextureCorrection = this.baseColorTextureCorrection
    newMaterial.alphaInLowerHalf = this.alphaInLowerHalf,
        newMaterial.opacity = this.opacity,
        newMaterial.emissive = this.emissive,
        newMaterial.emissionStrength = this.emissionStrength,
        newMaterial.roughness = this.roughness,
        newMaterial.metallic = this.metallic,
        newMaterial.envMapProject = this.envMapProject,
        newMaterial.bumpScale = this.bumpScale,
        newMaterial.doubleSided = this.doubleSided,
        newMaterial.doNotImport = this.doNotImport
    newMaterial.materialIndex = this.materialIndex

    if (void 0 !== this._chromaKeyEnabled) {
        newMaterial.chromaKeyEnabled = this.chromaKeyEnabled
        newMaterial.chromaKeyColor.copy(this.chromaKeyColor)
        newMaterial._chromaKeyDelta.fromArray(this._chromaKeyDelta.toArray())
    }

    newMaterial.baseColorTexture = this.baseColorTexture
    newMaterial.roughnessTexture = this.roughnessTexture
    newMaterial.metallicTexture = this.metallicTexture
    newMaterial.bumpTexture = this.bumpTexture

    return newMaterial
}


j3dStandardMaterial.prototype.fromGLTF = function (materialParams, materialIndex) {

    materialParams.color && this.baseColor.copy(materialParams.color)
    this._opacity = materialParams.opacity
    this._roughness = materialParams.roughness
    this._metallic = materialParams.metalness

    this.baseColorTexture = materialParams.map
    this.doNotImport.baseColor = !materialParams.map
    this.doNotImport.opacity = materialParams.transparent


    this.doubleSided = true;

    this.materialIndex = materialIndex

    this.setUniforms()
}




JMT.j3dStandardMaterial = j3dStandardMaterial;

/***/ }),

/***/ "./src/extend/material/j3dStandardMaterialWater.js":
/*!*********************************************************!*\
  !*** ./src/extend/material/j3dStandardMaterialWater.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dStandardMaterialWater": function() { return /* binding */ j3dStandardMaterialWater; }
/* harmony export */ });
/* harmony import */ var _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dStandardMaterial.js */ "./src/extend/material/j3dStandardMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */
 //import { j3dBaseMaterial } from './j3dBaseMaterial.js'
 

class j3dStandardMaterialWater extends _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dStandardMaterial {

    constructor() {
        super()
        this.type = "water";
        this._isPlaying = !0;
        this._isSleeping = !1;
        this.setUniform("time", "f", 0);
        this._roughness = 0;
        this.baseColor = new THREE.Color(0);
        this._wavesScale = this._wavesSpeed = 1;
        this._refractionFactor = 0;
        this.opacity = .2;
        this.doNotImport = {baseColor: !0, baseColorTexture: !0, opacity: !0}
        this.addTextureProperty("normalTexture");
    }


    textureNeedsUv0(a) {
        return !1
    }

    hash(a) {
        return "water"
    }

    canMerge(a) {
        return this.type === a.type && this.opacity === a.opacity && this.baseColor.equals(a.baseColor) && this.normalTexture === a.normalTexture && this.wavesSpeed === a.wavesSpeed && this.wavesScale === a.wavesScale && this.refractionFactor === a.refractionFactor
    }

    setUniforms() {

        _j3dStandardMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dStandardMaterial.prototype.setUniforms.call(this);

        var a = this.normalTexture;

        if(this.condDefine(a && a.loaded && !this.isLightProbeDisabled(), "USE_NORMAL_TEXTURE")){
            this.setUniform("normalTexture", "t", a)

            this.setUniform("wavesScale", "f", this.wavesScale)

            if(1 !== this.opacity){

                this.setUniform("refractionFactor", "f", this.refractionFactor)

            }
            else {

                this.setUniform("refractionFactor", "f", 0)

            }
        }
    }

    fragmentShaderHooks() {
        return JMT.getShader("water.glsl").code
    }


    play() {
        this._isPlaying = !0
    }

    pause() {
        this._isPlaying = !1
    }

    sleepAnimation() {
        this._isSleeping = !0
    }

    wakeAnimation() {
        this._isSleeping = !1
    }

    update(a) {
        this.uniforms.time.value += a * this.wavesSpeed * .1
    }

    serialize() {
        return {
            name: this.name,
            type: this.type,
            baseColor: this.baseColor.roundChannels().toArray(),
            baseColorTexture: null,
            opacity: this.opacity,
            normalTexture: this.normalTexture ? this.normalTexture.serialize() : null,
            wavesSpeed: this.wavesSpeed,
            wavesScale: this.wavesScale,
            refractionFactor: this.refractionFactor,
            doNotImport: this.doNotImport
        }
    }
}


Object.defineProperty(j3dStandardMaterialWater.prototype, "refractionFactor", {
    get: function () {
        return this._refractionFactor
    }, set: function (a) {
        this._refractionFactor = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterialWater.prototype, "wavesSpeed", {
    get: function () {
        return this._wavesSpeed
    }, set: function (a) {
        this._wavesSpeed = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterialWater.prototype, "wavesScale", {
    get: function () {
        return this._wavesScale
    },
    set: function (a) {
        this._wavesScale = a;
        this.setUniforms();
        this._updated()
    }
});
Object.defineProperty(j3dStandardMaterialWater.prototype, "hideFromLightProbes", {
    get: function () {
        return 1 !== this.opacity && 0 !== this.refractionFactor
    }
});
Object.defineProperty(j3dStandardMaterialWater.prototype, "isAnimated", {
    get: function () {
        return !0
    }
});
Object.defineProperty(j3dStandardMaterialWater.prototype, "isPlaying", {
    get: function () {
        return !this._isSleeping && this._isPlaying && 0 < this.wavesSpeed
    }
});

JMT.j3dStandardMaterialWater = j3dStandardMaterialWater


/***/ }),

/***/ "./src/extend/material/j3dWireframeMaterial.js":
/*!*****************************************************!*\
  !*** ./src/extend/material/j3dWireframeMaterial.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dBaseMaterial.js */ "./src/extend/material/j3dBaseMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */



var a = JMT.getShader("wireframe_vertex.glsl")
var b = JMT.getShader("wireframe_fragment.glsl");

var wireframe_vertex = `//AUTO GENERATED
attribute vec4 t0;
attribute vec4 t1;     
attribute vec4 t2;

vec4 transformPosition() {
    return vec4(
    t0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,
    t1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,
    t2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,
    1.0);
}

attribute float order;
varying vec3 vBaryCentric;
void main() {
    if (order == 0.0) {
        vBaryCentric = vec3(1.0, 0.0, 0.0);
    } else if (order == 1.0) {
        vBaryCentric = vec3(0.0, 1.0, 0.0);
    } else {
        vBaryCentric = vec3(0.0, 0.0, 1.0);
    }
    vec4 transformedPosition = transformPosition();
    gl_Position = projectionMatrix * modelViewMatrix * transformedPosition;
}
`;

class j3dWireframeMaterial extends _j3dBaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__.j3dBaseMaterial {
    constructor(lineColor) {
        super(wireframe_vertex, b.code)

        this.lineColor = lineColor;
        this.setUniform("lineColor", "c", lineColor);
        this.setUniform("lineMaxAlpha", "f", .65);
        this.setUniform("highlight", "c", JMT.EDITOR_SELECTION_COLOR);
        this.setUniform("highlightMix", "f", 0);
        this.customLightmapResolutionLineColor = new THREE.Color(170);
        this.autoLightmapResolutionLineColor = new THREE.Color(43690);
        this.meshSelectedLineColor = new THREE.Color(47872);
        this.meshSelectedSecondaryLineColor = new THREE.Color(13404160);
        this.transparent = !0;
        this.blending = THREE.NormalBlending;
        this.depthWrite = this.depthTest = !1;
        //this.attributes = this.attributes.concat(["order"]);
        this.enableStandardDerivativesExtension()
    }
}

j3dWireframeMaterial.prototype.propertyFromUniform("lineMaxAlpha");
j3dWireframeMaterial.prototype.propertyFromUniform("highlight");
j3dWireframeMaterial.prototype.propertyFromUniform("highlightMix");
j3dWireframeMaterial.prototype.refreshPerObjectUniforms = function (a, b) {
    var c = !1;
    null !== a.highlightMix && void 0 !== a.highlightMix && a.highlightMix !== b.highlightMix.value && (b.highlightMix.value = a.highlightMix, c = !0);
    return null !== a.selected && void 0 !== a.selected && (a = !0 === a.selected ? this.meshSelectedLineColor : !0 === a.selectedSecondary ? this.meshSelectedSecondaryLineColor : null !== a.node.lightmapResolution ? this.customLightmapResolutionLineColor :
        0 <= a.autoLightmapResolution ? this.autoLightmapResolutionLineColor : this.lineColor, b.lineColor.value !== a) ? (b.lineColor.value = a, !0) : c
}

JMT.j3dWireframeMaterial = j3dWireframeMaterial;

/***/ }),

/***/ "./src/extend/texture/j3dCompressedTexture.js":
/*!****************************************************!*\
  !*** ./src/extend/texture/j3dCompressedTexture.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dCompressedTexture": function() { return /* binding */ j3dCompressedTexture; }
/* harmony export */ });
/* harmony import */ var _j3dTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dTexture.js */ "./src/extend/texture/j3dTexture.js");



class j3dCompressedTexture extends _j3dTexture_js__WEBPACK_IMPORTED_MODULE_0__.j3dTexture {

    constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {
        super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);

        this.image = { width: width, height: height };
        this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

    }
    
    clone() {
        var a = new j3dCompressedTexture;
        _j3dTexture_js__WEBPACK_IMPORTED_MODULE_0__.j3dTexture.prototype.clone.call(this, a);
        return a
    }

}



j3dCompressedTexture.prototype.isCompressedTexture = true;


JMT.j3dCompressedTexture = j3dCompressedTexture;


/***/ }),

/***/ "./src/extend/texture/j3dGIFTexture.js":
/*!*********************************************!*\
  !*** ./src/extend/texture/j3dGIFTexture.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dGIFLoader": function() { return /* binding */ j3dGIFLoader; },
/* harmony export */   "j3dGIFTexture": function() { return /* binding */ j3dGIFTexture; }
/* harmony export */ });
/* harmony import */ var _vendor_gif_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../vendor/gif.js */ "./vendor/gif.js");
/* harmony import */ var _j3dTexture_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./j3dTexture.js */ "./src/extend/texture/j3dTexture.js");
/**
 * Created by Kai on 2021/4/27.
 */





class j3dGIFTexture extends _j3dTexture_js__WEBPACK_IMPORTED_MODULE_1__.j3dTexture {
    constructor(gif, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(gif ? gif.canvas : null, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

        //this.generateMipmaps = !1;
        this.isAnimated = !0;
        this.releaseOnLoadedToGpu = !1;
        this._isPlaying = !0;

        this.frame = -1;
        this.loaded = false;
        this.length = 1;
        this.time = 0;

        this.gif = gif

    }


    _updateCanvas(delayTime) {

        if(!this.gif){
            return
        }

        let frame = this.frame
        let curDelay = this.gif.images[(frame === -1) ? 0 : 1].delay * 0.01

        let ct = this.time + delayTime

        if (ct >= curDelay) {

            ct = ct - curDelay
            frame = (this.frame + 1) % this.gif.images.length

            if (ct > this.gif.images[frame].delay * 0.01)
                ct = 0
        }

        this.time = ct
        if (frame !== this.frame) {
            this.frame = frame
            let canvas = this.gif.canvas
            let ctx = this.gif.context
            let img = this.gif.images[this.frame];
            ctx.clearRect(img.leftPos, img.topPos, img.width, img.height);
            ctx.putImageData(img, img.leftPos, img.topPos);
            ctx.drawImage(canvas, 0, 0, img.width, img.height);
            this.needsUpdate = !0
            this.notifyLoaded()
        }

        //this.time = this.time % 6000000
    }


    reset(time) {
        this.time = 0;
    }

    setFps(fps) {
        this.length = this.tex.length / fps;
    }

    setLength(length) {
        this.length = length;
    }

    update(time) {
        //var f = (time - this.time) % this.length;
        //this.frame = Math.floor((f / this.length) * this.tex.length);

        this._updateCanvas(time)
    }

    getTexture() {
        return this.tex[this.frame];
    }
}


function j3dGIFLoader(img, onload) {
    // Init
    var canvas
    var context
    var images = []

    var meta

    var tmpCanvas = document.createElement('canvas');

    var transparency = null;
    var delay = null;
    var disposalMethod = null;
    var disposalRestoreFromIdx = null;
    var lastDisposalMethod = null;
    var frame = null;
    var lastImg = null;

    var frames = [];
    var frameCount = 0;

    var hdr;

    var clear = function () {
        transparency = null;
        delay = null;
        lastDisposalMethod = disposalMethod;
        disposalMethod = null;
        frame = null;
    };


    //post process
    function powerOfTwoImage() {

        function floorPowerOfTwo(value) {

            return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));

        }

        function ceilPowerOfTwo(value) {

            return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));

        }

        //找到离原始值最近的一个结果
        function appropriatePowerOfTwo(value) {
            let vn = floorPowerOfTwo(value)
            let vf = ceilPowerOfTwo(value)
            return Math.abs(vn - value) < Math.abs(vf - value) ? vn : vf
        }

        let powerOfTwo = THREE.Math.isPowerOfTwo(canvas.width) && THREE.Math.isPowerOfTwo(canvas.height)
        if (!powerOfTwo) {

            var scale = 1;
            var maxSize = 8192

            if (canvas.width > maxSize || canvas.height > maxSize) {
                scale = maxSize / Math.max(tmpCanvas.width, tmpCanvas.height);
            }

            var width = appropriatePowerOfTwo(scale * canvas.width);
            var height = appropriatePowerOfTwo(scale * canvas.height);

            canvas.width = width;
            canvas.height = height;

            images.forEach(function (img, i) {

                //context.fillStyle = 'black';
                //context.fillRect(0, 0, canvas.width, canvas.height);
                context.clearRect(0, 0, canvas.width, canvas.height)
                context.drawImage(frames[i], 0, 0, canvas.width, canvas.height)

                var cData = context.getImageData(0, 0, canvas.width, canvas.height)
                cData.leftPos = 0
                cData.topPos = 0
                cData.delay = images[i].delay
                images[i] = cData
            })

            if (images.length > 0) {
                context.clearRect(0, 0, canvas.width, canvas.height)
                context.drawImage(frames[0], 0, 0, canvas.width, canvas.height)
            }

        }

    }

    var pushFrame = function () {

        if (!frame) return;

        var tcanvas = document.createElement('canvas');
        tcanvas.width = tmpCanvas.width;
        tcanvas.height = tmpCanvas.height;
        var tctx = tcanvas.getContext('2d');
        tctx.drawImage(tmpCanvas, 0, 0, tcanvas.width, tcanvas.height);
        frames.push(tcanvas)

        var cData = tctx.getImageData(0, 0, hdr.width, hdr.height)
        cData.leftPos = cData.topPos = 0
        cData.delay = delay
        images.push(cData)

    };

    // Do nothing
    var doNothing = function () {

    };

    // Do header
    var doHdr = function (_hdr) {
        hdr = _hdr;

        canvas = document.createElement('canvas');
        context = canvas.getContext('2d')

        canvas.width = hdr.width;
        canvas.height = hdr.height;

        tmpCanvas.width = hdr.width;
        tmpCanvas.height = hdr.height;
    };

    var doGCE = function (gce) {

        meta = gce

        pushFrame();
        clear();
        transparency = gce.transparencyGiven ? gce.transparencyIndex : null;
        delay = gce.delayTime;
        disposalMethod = gce.disposalMethod;
    };

    // Do Image
    var doImg = function (img) {
        if (!frame)
            frame = tmpCanvas.getContext('2d')

        var currIdx = frames.length;

        // Load pixels
        var ct = img.lctFlag ? img.lct : hdr.gct;

        if (currIdx > 0) {
            if (lastDisposalMethod === 3) {
                // Restore to previous
                // If we disposed every frame including first frame up to this point, then we have
                // no composited frame to restore to. In this case, restore to background instead.
                if (disposalRestoreFromIdx !== null) {
                    frame.putImageData(frames[disposalRestoreFromIdx].data, 0, 0);
                } else {
                    frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
                }
            } else {
                disposalRestoreFromIdx = currIdx - 1;
            }

            if (lastDisposalMethod === 2) {
                // Restore to background color
                // Browser implementations historically restore to transparent; we do the same.
                // http://www.wizards-toolkit.org/discourse-server/viewtopic.php?f=1&t=21172#p86079
                frame.clearRect(lastImg.leftPos, lastImg.topPos, lastImg.width, lastImg.height);
            }
        }
        // else, Undefined/Do not dispose.
        // frame contains final pixel data from the last frame; do nothing

        //Get existing pixels for img region after applying disposal method
        var imgData = frame.getImageData(img.leftPos, img.topPos, img.width, img.height);

        //apply color table colors
        img.pixels.forEach(function (pixel, i) {
            // imgData.data === [R,G,B,A,R,G,B,A,...]
            if (pixel !== transparency) {
                imgData.data[i * 4 + 0] = ct[pixel][0];
                imgData.data[i * 4 + 1] = ct[pixel][1];
                imgData.data[i * 4 + 2] = ct[pixel][2];
                imgData.data[i * 4 + 3] = 255; // Opaque.
            }
        });

        frame.putImageData(imgData, img.leftPos, img.topPos);

        imgData.leftPos = img.leftPos
        imgData.topPos = img.topPos

        lastImg = img;
    };

    var doEof = function (block) {
        pushFrame()
        //powerOfTwoImage()
        if (onload) {
            onload({
                canvas: canvas,
                context: context,
                images: images,
                info: meta
            });
        }

        //clear canvas
        frames = null
    }

    // Gif Handler
    var gifHandler = {
        hdr: doHdr,
        gce: doGCE,
        com: doNothing,
        app: {NETSCAPE: doNothing},
        img: doImg,
        eof: doEof,
    };

    var xhr = new XMLHttpRequest();

    xhr.open("GET", img, true);

    xhr.overrideMimeType('text/plain; charset=x-user-defined');

    xhr.onload = function (e) {
        var buffer = xhr.responseText;
        (0,_vendor_gif_js__WEBPACK_IMPORTED_MODULE_0__.parseGIF)(new _vendor_gif_js__WEBPACK_IMPORTED_MODULE_0__.Stream(buffer), gifHandler);
    }

    xhr.send(null);

    return this;
}

JMT.j3dGIFLoader = j3dGIFLoader

/***/ }),

/***/ "./src/extend/texture/j3dTexture.js":
/*!******************************************!*\
  !*** ./src/extend/texture/j3dTexture.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dTexture": function() { return /* binding */ j3dTexture; }
/* harmony export */ });
/**
 * #Created by: Jimuyida Martian
 * Date 2022/3/22
 */

class j3dTexture extends THREE.Texture {

    constructor ( image, mapping, wrapS = THREE.ClampToEdgeWrapping, wrapT = THREE.ClampToEdgeWrapping, magFilter = THREE.LinearFilter, minFilter = THREE.LinearMipmapLinearFilter, format = THREE.RGBAFormat, type = THREE.UnsignedByteType, anisotropy = 1, encoding = THREE.LinearEncoding ) {
        super ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding)

        this.anisotropy = anisotropy ? anisotropy : 1;
   
        //extends property
        this.webFormats = this.stdExt = this.rawExt = null;
        this.isCube = !1;
        this.height = null;
        this.width = null;

        this.isRgbm = false;
        this.isCutout = false;
        this.hasAlpha = false;
        this.isAnimated = false;

        this._atlasEntries = null;

        this._needsUpdate = !1;

        this.releaseOnLoadedToGpu = !0;

        this.loaded = !1;

        this._loadingListeners = []

        this._loadedListeners = [];

        this.fromEditor = !1;

              
        //this.__webglSlot = this.__webglTexture = null
    }

    sleepAnimation() {
        console.assert(!1)
    }
    
    wakeAnimation() {
        console.assert(!1)
    }

    // get needsUpdate() {
    //     return this._needsUpdate
    // }
    //
    // set needsUpdate(a) {
    //     this._needsUpdate = a
    // }

    isAtlas() {
        return null !== this._atlasEntries
    }

    enableAtlas() {
        console.assert(!this.isAtlas());
        this._atlasEntries = {}
    }

    getAtlasEntry(name, atlasOffsetX, atlasOffsetY, atlasScaleX, atlasScaleY) {
        var fAtlasEntry = this._atlasEntries[name];
        if (fAtlasEntry)
            return fAtlasEntry;

        console.assert(!this.loaded);
        fAtlasEntry = new AtlasEntry(name, this, atlasOffsetX, atlasOffsetY, atlasScaleX, atlasScaleY);
        return this._atlasEntries[name] = fAtlasEntry
    }

    forEachAtlasEntry(a) {
        for (var b in this._atlasEntries) {
            if (this._atlasEntries.hasOwnProperty(b)) {
                a(this._atlasEntries[b])
            }
        }
    }

    clone(a) {
        void 0 === a && (a = new JMT.Texture);
        a.isCube = this.isCube;
        //a.image = this.image;
        //a.mipmaps = this.mipmaps.slice(0);
        //a.wrapS = this.wrapS;
        //a.wrapT = this.wrapT;
        //a.magFilter = this.magFilter;
        //a.minFilter = this.minFilter;
        //a.anisotropy = this.anisotropy;
        a.isCutout = this.isCutout;
        a.isAnimated = this.isAnimated;
        a.hasAlpha = this.hasAlpha;
        //a.format = this.format;
        a.url = this.url
        //a.type = this.type;
        //a.generateMipmaps = this.generateMipmaps;
        //a.premultiplyAlpha = this.premultiplyAlpha;
        //a.flipY = this.flipY;
        //a.unpackAlignment = this.unpackAlignment;
        return a
    }

    copy(source) {

        this.webFormats = source.webFormats
        this.stdExt = source.stdExt
        this.rawExt = source.rawExt;

        this.isRgbm = source.isRgbm;
        this.isCutout = source.isCutout;
        this.hasAlpha = source.hasAlpha;
        this.isAnimated = source.isAnimated;


        THREE.Texture.prototype.call(this, source)
    }


    serialize() {
        var a = {
            id: this.id,
            name: this.name,
            stdExt: this.stdExt,
            webFormats: this.webFormats,
            alpha: this.hasAlpha,
            url : this.url
        };
        this.rawExt && (a.rawExt = this.rawExt);
        this.isRgbm && (a.rgbm = !0);
        this.video && (a.video = !0);
        return a
    }

    dispose() {
        this._loadingListeners = []
        this._loadedListeners = [];
        this.dispatchEvent({type: "dispose"})
    }


    addLoadingListener(callback) {
        if (!this.loaded) {
            this._loadingListeners.push(callback)
        }
    }

    addLoadedListener(callback) {
        if (this.loaded) {
            callback(this)
        }
        else {
            this._loadedListeners.push(callback)
        }
    }

    notifyLoading(){
        this.loaded = !1;
        for (var a = this._loadingListeners, c = 0; c < a.length; c += 1) {
            a[c](this);
        }
        a.length = 0
    }

    notifyLoaded() {
        this.loaded = !0;
        for (var a = this._loadedListeners, c = 0; c < a.length; c += 1) {
            a[c](this);
        }
        a.length = 0
    }
}

class AtlasEntry {
    constructor(name, parentTexture, atlasOffsetX, atlasOffsetY, atlasScaleX, atlasScaleY) {
        this.name = name;
        this.parentTexture = parentTexture;
        this.uvOffsetScale = new THREE.Vector4(atlasOffsetX, atlasOffsetY, atlasScaleX, atlasScaleY);
        this.isCutout = !1
    }

    addLoadedListener(a) {
        this.parentTexture.addLoadedListener(a)
    }

    get hasAlpha() {
        return this.parentTexture.hasAlpha
    }
}

//export { j3dTexture };
JMT.j3dTexture = j3dTexture;

/***/ }),

/***/ "./src/extend/texture/j3dVideoTexture.js":
/*!***********************************************!*\
  !*** ./src/extend/texture/j3dVideoTexture.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dVideoTexture": function() { return /* binding */ j3dVideoTexture; }
/* harmony export */ });
/* harmony import */ var _j3dTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./j3dTexture.js */ "./src/extend/texture/j3dTexture.js");

/**
 * #Created by: Jimuyida Martian
 * Video Texture
 * Date 2022/3/25
 */




//THREE.VideoTexture
class j3dVideoTexture extends _j3dTexture_js__WEBPACK_IMPORTED_MODULE_0__.j3dTexture {
    constructor(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

        var n = this;
        this.generateMipmaps = false;
        this.isAnimated = true;
        this.releaseOnLoadedToGpu = false;
        this._isPlaying = false;
        this._pauseRequested = this._isSleeping = false;

        function _handlePaused() {
            if (n._pauseRequested) {
                n._isPlaying = !1
                n._pauseRequested = !1
            }
            else {
                n._isSleeping = !0
            }
        };

        function _handleEnded() {
            n._isPlaying = !1;
            n._isSleeping = !1
        }

        Object.defineProperty(this, "video", {
            get: function () {
                return this.image
            }, set: function (a) {
                this.image = a;
                this._isPlaying = !a.paused && !a.ended;
                a.addEventListener("pause", _handlePaused);
                a.addEventListener("ended", _handleEnded);
                this._isSleeping && this._isPlaying && this.video.pause()
            }
        })
        Object.defineProperty(this, "muted", {
            get: function () {
                return this.video.muted
            }, set: function (a) {
                this.video.muted = a
            }
        })
        Object.defineProperty(this, "loop", {
            get: function () {
                return this.video.loop
            }, set: function (a) {
                this.video.loop = a
            }
        })
        Object.defineProperty(this, "isPlaying", {
            get: function () {
                return !this._isSleeping && this._isPlaying
            }
        })

        Object.defineProperty(this, "needsUpdate", {
            get: function () {
                return this._needsUpdate || this.isPlaying && this.video &&
                    this.video.readyState >= this.video.HAVE_CURRENT_DATA
            }, set: function (a) {
                this._needsUpdate = a
                this.version++
            }
        })
    }


    play() {
        var a = this;
        if (!this._isPlaying) {
            if (this._isSleeping) {
                this._isPlaying = !0;
            } else {
                
                var b = this.video
                var c = b.play();
                if (c) {

                    this._isPlaying = !0

                    c.catch(function () {
                        a._isPlaying = !1
                    })
                }
                else {
                    this._isPlaying = !b.paused && !b.ended
                }
            }
        }
    }

    pause() {
        if (this._isPlaying) {
           
            if (this._isSleeping) {
                this._isPlaying = !1
            }
            else {
                this._pauseRequested = !0
                this.video.pause()
            }
        }
    }

    sleepAnimation() {
        this._isSleeping || (this._isPlaying && this.video && this.video.pause(), this._isSleeping = !0)
    }

    wakeAnimation() {
        this._isSleeping && (this._isPlaying && this.video && this.video.play(), this._isSleeping = !1)
    }

    update() {
        const video = this.image;
        if (video) {
            //const hasVideoFrameCallback = ('requestVideoFrameCallback' in video);
            //if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) 
            if (video.readyState >= video.HAVE_CURRENT_DATA && this.isPlaying) {
                this.needsUpdate = true;
            }
        }
        
    }
}

j3dVideoTexture.prototype.isVideoTexture = true;


JMT.j3dVideoTexture = j3dVideoTexture

/***/ }),

/***/ "./src/extend/utils/j3dGpuRaycaster.js":
/*!*********************************************!*\
  !*** ./src/extend/utils/j3dGpuRaycaster.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _material_j3dObjectDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../material/j3dObjectDistanceMaterial.js */ "./src/extend/material/j3dObjectDistanceMaterial.js");
/* harmony import */ var _j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../j3dWebGLRendererUtil.js */ "./src/extend/j3dWebGLRendererUtil.js");
/* harmony import */ var _j3dSubScene_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./j3dSubScene.js */ "./src/extend/utils/j3dSubScene.js");
/**
 * #Created by: Jimuyida Martian
 * GPU ray caster; GPU picker
 * Date 2022/4/14
 */

//j3dObjectDistanceQuery





// JMT.RaycasterConfig = function (a, b, c) {
//     b = b||new THREE.Vector3(0,0,0);
//     this.ray = new THREE.Ray(a, b);
//     this.far = c || Infinity;
//     this.ignoreVisibility = this.onlyGroundCollisions = this.respectColliderSettings = !1
// };
// JMT.RayIntersection = function () {
//     this.distance = Infinity;
//     this.point = new THREE.Vector3;
//     this.object = null
// };

JMT.j3dGpuRaycaster = function (renderer, camera) {

    function canPick(mesh, rayConfig) {
        if (!rayConfig.ignoreVisibility && !mesh.visible)
            return !1;
        var c = mesh.node || p;
        if (c.disableCollisions && rayConfig.respectColliderSettings || !c.ground && rayConfig.onlyGroundCollisions){
            return !1;
        }
        c = rayConfig.ray;

        //暂时这样吧，用于交互控件的拾取
        if (mesh.forcePick) return true;
        //if (mesh.matrixWorld) return !0;
            
        var d = mesh.geometry.boundingSphere;
        if (d.distanceToPoint(c.origin) > rayConfig.far || !1 === c.intersectsSphere(d)){
            return !1;
        }
        let a = mesh.geometry.boundingBox;
        return a.distanceToPoint(c.origin) > rayConfig.far || !c.intersectsBox(a) ? !1 : !0
    }

    var pickingTexture = new THREE.WebGLRenderTarget( 1, 1 , {
        format : THREE.RGBAFormat,
        magFilter : THREE.NearestMipmapNearestFilter,
        minFilter : THREE.NearestMipmapNearestFilter,
        stencilBuffer: false,
        depthBuffer : true
    });

    var pixelBuffer = new Uint8Array(4)
    var autoClearAlter = new JMT.AutoClearAlter(renderer)
    var clearColorAlter = new JMT.ClearColorAlter(renderer)
    var clearColor = new THREE.Color(16777215)
    var distMaterial = new JMT.j3dObjectDistanceMaterial(!1)//k
    var pickCamera = new THREE.PerspectiveCamera(1, 1, camera.near, camera.far) //n
    var p = {disableCollisions: !1, ground: !1};

    var pickScene = new _j3dSubScene_js__WEBPACK_IMPORTED_MODULE_2__.j3dSubScene()
    var rendererUtil = new JMT.j3dWebGLRendererUtil(renderer)
    //pickScene.overrideMaterial = d;

    this.closestIntersection = function (meshes, rayConfig, rayIntersection) {
        
        //var m = []
        for (var l = 0; l < meshes.length; l += 1) {
            var mesh = meshes[l];
            if (canPick(mesh, rayConfig)) {
                mesh.visibilityId = pickScene.objects.length
                //m.push(mesh.parent)
                pickScene.add(mesh);
            }
        }
        let m = pickScene.objects
        if (0 === m.length)
            return !1;

        pickCamera.position.set(0, 0, 0);
        pickCamera.lookAt(rayConfig.ray.direction);
        pickCamera.position.copy(rayConfig.ray.origin);
        pickCamera.updateMatrixWorld();

        autoClearAlter.set(true, true, false);
        clearColorAlter.set(clearColor);
        let sortObjects_ = renderer.sortObjects;
        renderer.sortObjects = false;

        pickScene.scene.autoUpdate = false
        pickScene.scene.overrideMaterial = distMaterial
        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickScene.scene, pickCamera)
        pickScene.scene.overrideMaterial = null
        
        renderer.sortObjects = sortObjects_;
        clearColorAlter.restore();
        autoClearAlter.restore();
        
        rendererUtil.readPixels(1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        let b = 256 * pixelBuffer[0] + pixelBuffer[1];
        l = pixelBuffer[2] + pixelBuffer[3] / 255;
        for (p = 0; p < m.length; p += 1) {
            m[p].visibilityId = null;
        }
        if (65535 === b || l > rayConfig.far) {
            pickScene.restore()
            return !1;
        }
        
        console.assert(b < m.length);

        rayIntersection.object = m[b];

        rayIntersection.distance = l;

        rayIntersection.direction = new THREE.Vector3().copy(rayConfig.ray.direction)

        rayIntersection.point.copy(rayConfig.ray.direction).multiplyScalar(l).add(rayConfig.ray.origin);

        pickScene.restore()
        return !0
    }

}

/***/ }),

/***/ "./src/extend/utils/j3dSubScene.js":
/*!*****************************************!*\
  !*** ./src/extend/utils/j3dSubScene.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "j3dSubScene": function() { return /* binding */ j3dSubScene; }
/* harmony export */ });
/**
 * #Created by: Jimuyida Martian
 * j3dSubScene
 * 构建一个子场景， 通常晴空下用于GPU Pick
 * 可能会有性能影响，慎用
 * Date 2022/4/14
 */

class j3dSubScene {
    constructor() {

        this.objects = []
        //this.parents = []
        this.scene = new THREE.Scene()

    }

    add(object) {

        //浏览模式下 可能没有parent
        // if (!object || !object.parent)
        //     return;

        //         this.objects.push(object)
        //         this.parents.push(object.parent)
        //         this.scene.add(object)
      

        if (!object) return;

        object._really_father_ = object.parent
        this.objects.push(object)
        this.scene.add(object)
    }

    restore() {

        for (let c = 0; c < this.objects.length; c += 1) {
            let m = this.objects[c];
            let p = m._really_father_
            m._really_father_ = null
            if (p) p.add(m)
        }

        this.objects = []
        this.scene.clear()
    }
}


JMT.j3dSubScene = j3dSubScene

/***/ }),

/***/ "./src/lib/jscomp.js":
/*!***************************!*\
  !*** ./src/lib/jscomp.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "$jscomp": function() { return /* binding */ $jscomp; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.arrayIteratorImpl = function (a) {
    var b = 0;
    return function () {
        return b < a.length ? {done: !1, value: a[b++]} : {done: !0}
    }
};
$jscomp.arrayIterator = function (a) {
    return {next: $jscomp.arrayIteratorImpl(a)}
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {
    a != Array.prototype && a != Object.prototype && (a[b] = c.value)
};
$jscomp.getGlobal = function (a) {
    a = ["object" == typeof window && window, "object" == typeof self && self, "object" == typeof __webpack_require__.g && __webpack_require__.g, a];
    for (var b = 0; b < a.length; ++b) {
        var c = a[b];
        if (c && c.Math == Math)return c
    }
    return globalThis
};
$jscomp.global = $jscomp.getGlobal(undefined);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function () {
    $jscomp.initSymbol = function () {
    };
    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol)
};
$jscomp.SymbolClass = function (a, b) {
    this.$jscomp$symbol$id_ = a;
    $jscomp.defineProperty(this, "description", {configurable: !0, writable: !0, value: b})
};
$jscomp.SymbolClass.prototype.toString = function () {
    return this.$jscomp$symbol$id_
};
$jscomp.Symbol = function () {
    function a(c) {
        if (this instanceof a)throw new TypeError("Symbol is not a constructor");
        return new $jscomp.SymbolClass($jscomp.SYMBOL_PREFIX + (c || "") + "_" + b++, c)
    }

    var b = 0;
    return a
}();
$jscomp.initSymbolIterator = function () {
    $jscomp.initSymbol();
    var a = $jscomp.global.Symbol.iterator;
    a || (a = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("Symbol.iterator"));
    "function" != typeof Array.prototype[a] && $jscomp.defineProperty(Array.prototype, a, {
        configurable: !0,
        writable: !0,
        value: function () {
            return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this))
        }
    });
    $jscomp.initSymbolIterator = function () {
    }
};
$jscomp.initSymbolAsyncIterator = function () {
    $jscomp.initSymbol();
    var a = $jscomp.global.Symbol.asyncIterator;
    a || (a = $jscomp.global.Symbol.asyncIterator = $jscomp.global.Symbol("Symbol.asyncIterator"));
    $jscomp.initSymbolAsyncIterator = function () {
    }
};
$jscomp.iteratorPrototype = function (a) {
    $jscomp.initSymbolIterator();
    a = {next: a};
    a[$jscomp.global.Symbol.iterator] = function () {
        return this
    };
    return a
};
$jscomp.makeIterator = function (a) {
    var b = "undefined" != typeof Symbol && Symbol.iterator && a[Symbol.iterator];
    return b ? b.call(a) : $jscomp.arrayIterator(a)
};
$jscomp.arrayFromIterator = function (a) {
    for (var b, c = []; !(b = a.next()).done;)c.push(b.value);
    return c
};
$jscomp.arrayFromIterable = function (a) {
    return a instanceof Array ? a : $jscomp.arrayFromIterator($jscomp.makeIterator(a))
};
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || "function" == typeof Object.create ? Object.create : function (a) {
    var b = function () {
    };
    b.prototype = a;
    return new b
};
$jscomp.underscoreProtoCanBeSet = function () {
    var a = {a: !0}, b = {};
    try {
        return b.__proto__ = a, b.a
    } catch (c) {
    }
    return !1
};
$jscomp.setPrototypeOf = "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function (a, b) {
    a.__proto__ = b;
    if (a.__proto__ !== b)throw new TypeError(a + " is not extensible");
    return a
} : null;
$jscomp.inherits = function (a, b) {
    a.prototype = $jscomp.objectCreate(b.prototype);
    a.prototype.constructor = a;
    if ($jscomp.setPrototypeOf) {
        var c = $jscomp.setPrototypeOf;
        c(a, b)
    } else for (c in b)if ("prototype" != c)if (Object.defineProperties) {
        var d = Object.getOwnPropertyDescriptor(b, c);
        d && Object.defineProperty(a, c, d)
    } else a[c] = b[c];
    a.superClass_ = b.prototype
};
$jscomp.polyfill = function (a, b, c, d) {
    if (b) {
        c = $jscomp.global;
        a = a.split(".");
        for (d = 0; d < a.length - 1; d++) {
            var e = a[d];
            e in c || (c[e] = {});
            c = c[e]
        }
        a = a[a.length - 1];
        d = c[a];
        b = b(d);
        b != d && null != b && $jscomp.defineProperty(c, a, {configurable: !0, writable: !0, value: b})
    }
};
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function (a) {
    function b() {
        this.batch_ = null
    }

    function c(a) {
        return a instanceof e ? a : new e(function (b, c) {
            b(a)
        })
    }

    if (a && !$jscomp.FORCE_POLYFILL_PROMISE)return a;
    b.prototype.asyncExecute = function (a) {
        if (null == this.batch_) {
            this.batch_ = [];
            var b = this;
            this.asyncExecuteFunction(function () {
                b.executeBatch_()
            })
        }
        this.batch_.push(a)
    };
    var d = $jscomp.global.setTimeout;
    b.prototype.asyncExecuteFunction = function (a) {
        d(a, 0)
    };
    b.prototype.executeBatch_ = function () {
        for (; this.batch_ && this.batch_.length;) {
            var a =
                this.batch_;
            this.batch_ = [];
            for (var b = 0; b < a.length; ++b) {
                var c = a[b];
                a[b] = null;
                try {
                    c()
                } catch (n) {
                    this.asyncThrow_(n)
                }
            }
        }
        this.batch_ = null
    };
    b.prototype.asyncThrow_ = function (a) {
        this.asyncExecuteFunction(function () {
            throw a;
        })
    };
    var e = function (a) {
        this.state_ = 0;
        this.result_ = void 0;
        this.onSettledCallbacks_ = [];
        var b = this.createResolveAndReject_();
        try {
            a(b.resolve, b.reject)
        } catch (k) {
            b.reject(k)
        }
    };
    e.prototype.createResolveAndReject_ = function () {
        function a(a) {
            return function (d) {
                c || (c = !0, a.call(b, d))
            }
        }

        var b = this, c = !1;
        return {resolve: a(this.resolveTo_), reject: a(this.reject_)}
    };
    e.prototype.resolveTo_ = function (a) {
        if (a === this)this.reject_(new TypeError("A Promise cannot resolve to itself")); else if (a instanceof e)this.settleSameAsPromise_(a); else {
            a:switch (typeof a) {
                case "object":
                    var b = null != a;
                    break a;
                case "function":
                    b = !0;
                    break a;
                default:
                    b = !1
            }
            b ? this.resolveToNonPromiseObj_(a) : this.fulfill_(a)
        }
    };
    e.prototype.resolveToNonPromiseObj_ = function (a) {
        var b = void 0;
        try {
            b = a.then
        } catch (k) {
            this.reject_(k);
            return
        }
        "function" == typeof b ?
            this.settleSameAsThenable_(b, a) : this.fulfill_(a)
    };
    e.prototype.reject_ = function (a) {
        this.settle_(2, a)
    };
    e.prototype.fulfill_ = function (a) {
        this.settle_(1, a)
    };
    e.prototype.settle_ = function (a, b) {
        if (0 != this.state_)throw Error("Cannot settle(" + a + ", " + b + "): Promise already settled in state" + this.state_);
        this.state_ = a;
        this.result_ = b;
        this.executeOnSettledCallbacks_()
    };
    e.prototype.executeOnSettledCallbacks_ = function () {
        if (null != this.onSettledCallbacks_) {
            for (var a = 0; a < this.onSettledCallbacks_.length; ++a)g.asyncExecute(this.onSettledCallbacks_[a]);
            this.onSettledCallbacks_ = null
        }
    };
    var g = new b;
    e.prototype.settleSameAsPromise_ = function (a) {
        var b = this.createResolveAndReject_();
        a.callWhenSettled_(b.resolve, b.reject)
    };
    e.prototype.settleSameAsThenable_ = function (a, b) {
        var c = this.createResolveAndReject_();
        try {
            a.call(b, c.resolve, c.reject)
        } catch (n) {
            c.reject(n)
        }
    };
    e.prototype.then = function (a, b) {
        function c(a, b) {
            return "function" == typeof a ? function (b) {
                try {
                    d(a(b))
                } catch (u) {
                    f(u)
                }
            } : b
        }

        var d, f, g = new e(function (a, b) {
            d = a;
            f = b
        });
        this.callWhenSettled_(c(a, d), c(b, f));
        return g
    };
    e.prototype.catch = function (a) {
        return this.then(void 0, a)
    };
    e.prototype.callWhenSettled_ = function (a, b) {
        function c() {
            switch (d.state_) {
                case 1:
                    a(d.result_);
                    break;
                case 2:
                    b(d.result_);
                    break;
                default:
                    throw Error("Unexpected state: " + d.state_);
            }
        }

        var d = this;
        null == this.onSettledCallbacks_ ? g.asyncExecute(c) : this.onSettledCallbacks_.push(c)
    };
    e.resolve = c;
    e.reject = function (a) {
        return new e(function (b, c) {
            c(a)
        })
    };
    e.race = function (a) {
        return new e(function (b, d) {
            for (var e = $jscomp.makeIterator(a), f = e.next(); !f.done; f = e.next())c(f.value).callWhenSettled_(b,
                d)
        })
    };
    e.all = function (a) {
        var b = $jscomp.makeIterator(a), d = b.next();
        return d.done ? c([]) : new e(function (a, e) {
            function f(b) {
                return function (c) {
                    g[b] = c;
                    k--;
                    0 == k && a(g)
                }
            }

            var g = [], k = 0;
            do g.push(void 0), k++, c(d.value).callWhenSettled_(f(g.length - 1), e), d = b.next(); while (!d.done)
        })
    };
    return e
}, "es6", "es3");
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function (a) {
    if (!(a instanceof Object))throw new TypeError("Iterator result " + a + " is not an object");
};
$jscomp.generator.Context = function () {
    this.isRunning_ = !1;
    this.yieldAllIterator_ = null;
    this.yieldResult = void 0;
    this.nextAddress = 1;
    this.finallyAddress_ = this.catchAddress_ = 0;
    this.finallyContexts_ = this.abruptCompletion_ = null
};
$jscomp.generator.Context.prototype.start_ = function () {
    if (this.isRunning_)throw new TypeError("Generator is already running");
    this.isRunning_ = !0
};
$jscomp.generator.Context.prototype.stop_ = function () {
    this.isRunning_ = !1
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function () {
    this.nextAddress = this.catchAddress_ || this.finallyAddress_
};
$jscomp.generator.Context.prototype.next_ = function (a) {
    this.yieldResult = a
};
$jscomp.generator.Context.prototype.throw_ = function (a) {
    this.abruptCompletion_ = {exception: a, isException: !0};
    this.jumpToErrorHandler_()
};
$jscomp.generator.Context.prototype.return = function (a) {
    this.abruptCompletion_ = {return: a};
    this.nextAddress = this.finallyAddress_
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function (a) {
    this.abruptCompletion_ = {jumpTo: a};
    this.nextAddress = this.finallyAddress_
};
$jscomp.generator.Context.prototype.yield = function (a, b) {
    this.nextAddress = b;
    return {value: a}
};
$jscomp.generator.Context.prototype.yieldAll = function (a, b) {
    a = $jscomp.makeIterator(a);
    var c = a.next();
    $jscomp.generator.ensureIteratorResultIsObject_(c);
    if (c.done)this.yieldResult = c.value, this.nextAddress = b; else return this.yieldAllIterator_ = a, this.yield(c.value, b)
};
$jscomp.generator.Context.prototype.jumpTo = function (a) {
    this.nextAddress = a
};
$jscomp.generator.Context.prototype.jumpToEnd = function () {
    this.nextAddress = 0
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function (a, b) {
    this.catchAddress_ = a;
    void 0 != b && (this.finallyAddress_ = b)
};
$jscomp.generator.Context.prototype.setFinallyBlock = function (a) {
    this.catchAddress_ = 0;
    this.finallyAddress_ = a || 0
};
$jscomp.generator.Context.prototype.leaveTryBlock = function (a, b) {
    this.nextAddress = a;
    this.catchAddress_ = b || 0
};
$jscomp.generator.Context.prototype.enterCatchBlock = function (a) {
    this.catchAddress_ = a || 0;
    a = this.abruptCompletion_.exception;
    this.abruptCompletion_ = null;
    return a
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function (a, b, c) {
    c ? this.finallyContexts_[c] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_];
    this.catchAddress_ = a || 0;
    this.finallyAddress_ = b || 0
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function (a, b) {
    b = this.finallyContexts_.splice(b || 0)[0];
    if (b = this.abruptCompletion_ = this.abruptCompletion_ || b) {
        if (b.isException)return this.jumpToErrorHandler_();
        void 0 != b.jumpTo && this.finallyAddress_ < b.jumpTo ? (this.nextAddress = b.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_
    } else this.nextAddress = a
};
$jscomp.generator.Context.prototype.forIn = function (a) {
    return new $jscomp.generator.Context.PropertyIterator(a)
};
$jscomp.generator.Context.PropertyIterator = function (a) {
    this.object_ = a;
    this.properties_ = [];
    for (var b in a)this.properties_.push(b);
    this.properties_.reverse()
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function () {
    for (; 0 < this.properties_.length;) {
        var a = this.properties_.pop();
        if (a in this.object_)return a
    }
    return null
};
$jscomp.generator.Engine_ = function (a) {
    this.context_ = new $jscomp.generator.Context;
    this.program_ = a
};
$jscomp.generator.Engine_.prototype.next_ = function (a) {
    this.context_.start_();
    if (this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_.next, a, this.context_.next_);
    this.context_.next_(a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.return_ = function (a) {
    this.context_.start_();
    var b = this.context_.yieldAllIterator_;
    if (b)return this.yieldAllStep_("return"in b ? b["return"] : function (a) {
        return {value: a, done: !0}
    }, a, this.context_.return);
    this.context_.return(a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.throw_ = function (a) {
    this.context_.start_();
    if (this.context_.yieldAllIterator_)return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"], a, this.context_.next_);
    this.context_.throw_(a);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function (a, b, c) {
    try {
        var d = a.call(this.context_.yieldAllIterator_, b);
        $jscomp.generator.ensureIteratorResultIsObject_(d);
        if (!d.done)return this.context_.stop_(), d;
        var e = d.value
    } catch (g) {
        return this.context_.yieldAllIterator_ = null, this.context_.throw_(g), this.nextStep_()
    }
    this.context_.yieldAllIterator_ = null;
    c.call(this.context_, e);
    return this.nextStep_()
};
$jscomp.generator.Engine_.prototype.nextStep_ = function () {
    for (; this.context_.nextAddress;)try {
        var a = this.program_(this.context_);
        if (a)return this.context_.stop_(), {value: a.value, done: !1}
    } catch (b) {
        this.context_.yieldResult = void 0, this.context_.throw_(b)
    }
    this.context_.stop_();
    if (this.context_.abruptCompletion_) {
        a = this.context_.abruptCompletion_;
        this.context_.abruptCompletion_ = null;
        if (a.isException)throw a.exception;
        return {value: a.return, done: !0}
    }
    return {value: void 0, done: !0}
};
$jscomp.generator.Generator_ = function (a) {
    this.next = function (b) {
        return a.next_(b)
    };
    this.throw = function (b) {
        return a.throw_(b)
    };
    this.return = function (b) {
        return a.return_(b)
    };
    $jscomp.initSymbolIterator();
    this[Symbol.iterator] = function () {
        return this
    }
};
$jscomp.generator.createGenerator = function (a, b) {
    b = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(b));
    $jscomp.setPrototypeOf && $jscomp.setPrototypeOf(b, a.prototype);
    return b
};
$jscomp.asyncExecutePromiseGenerator = function (a) {
    function b(b) {
        return a.next(b)
    }

    function c(b) {
        return a.throw(b)
    }

    return new Promise(function (d, e) {
        function g(a) {
            a.done ? d(a.value) : Promise.resolve(a.value).then(b, c).then(g, e)
        }

        g(a.next())
    })
};
$jscomp.asyncExecutePromiseGeneratorFunction = function (a) {
    return $jscomp.asyncExecutePromiseGenerator(a())
};
$jscomp.asyncExecutePromiseGeneratorProgram = function (a) {
    return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(a)))
};
$jscomp.polyfill("globalThis", function (a) {
    return a || $jscomp.global
}, "es_next", "es3");
$jscomp.iteratorFromArray = function (a, b) {
    $jscomp.initSymbolIterator();
    a instanceof String && (a += "");
    var c = 0, d = {
        next: function () {
            if (c < a.length) {
                var e = c++;
                return {value: b(e, a[e]), done: !1}
            }
            d.next = function () {
                return {done: !0, value: void 0}
            };
            return d.next()
        }
    };
    d[Symbol.iterator] = function () {
        return d
    };
    return d
};
$jscomp.polyfill("Array.prototype.keys", function (a) {
    return a ? a : function () {
        return $jscomp.iteratorFromArray(this, function (a) {
            return a
        })
    }
}, "es6", "es3");
$jscomp.checkEs6ConformanceViaProxy = function () {
    try {
        var a = {}, b = Object.create(new $jscomp.global.Proxy(a, {
            get: function (c, d, e) {
                return c == a && "q" == d && e == b
            }
        }));
        return !0 === b.q
    } catch (c) {
        return !1
    }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.owns = function (a, b) {
    return Object.prototype.hasOwnProperty.call(a, b)
};
$jscomp.polyfill("WeakMap", function (a) {
    function b() {
        if (!a || !Object.seal)return !1;
        try {
            var b = Object.seal({}), c = Object.seal({}), d = new a([[b, 2], [c, 3]]);
            if (2 != d.get(b) || 3 != d.get(c))return !1;
            d.delete(b);
            d.set(c, 4);
            return !d.has(b) && 4 == d.get(c)
        } catch (q) {
            return !1
        }
    }

    function c() {
    }

    function d(a) {
        var b = typeof a;
        return "object" === b && null !== a || "function" === b
    }

    function e(a) {
        if (!$jscomp.owns(a, f)) {
            var b = new c;
            $jscomp.defineProperty(a, f, {value: b})
        }
    }

    function g(a) {
        var b = Object[a];
        b && (Object[a] = function (a) {
            if (a instanceof
                c)return a;
            e(a);
            return b(a)
        })
    }

    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (a && $jscomp.ES6_CONFORMANCE)return a
    } else if (b())return a;
    var f = "$jscomp_hidden_" + Math.random();
    g("freeze");
    g("preventExtensions");
    g("seal");
    var h = 0, k = function (a) {
        this.id_ = (h += Math.random() + 1).toString();
        if (a) {
            a = $jscomp.makeIterator(a);
            for (var b; !(b = a.next()).done;)b = b.value, this.set(b[0], b[1])
        }
    };
    k.prototype.set = function (a, b) {
        if (!d(a))throw Error("Invalid WeakMap key");
        e(a);
        if (!$jscomp.owns(a, f))throw Error("WeakMap key fail: " +
            a);
        a[f][this.id_] = b;
        return this
    };
    k.prototype.get = function (a) {
        return d(a) && $jscomp.owns(a, f) ? a[f][this.id_] : void 0
    };
    k.prototype.has = function (a) {
        return d(a) && $jscomp.owns(a, f) && $jscomp.owns(a[f], this.id_)
    };
    k.prototype.delete = function (a) {
        return d(a) && $jscomp.owns(a, f) && $jscomp.owns(a[f], this.id_) ? delete a[f][this.id_] : !1
    };
    return k
}, "es6", "es3");
$jscomp.MapEntry = function () {
};
$jscomp.polyfill("Map", function (a) {
    function b() {
        if ($jscomp.ASSUME_NO_NATIVE_MAP || !a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal)return !1;
        try {
            var b = Object.seal({x: 4}), c = new a($jscomp.makeIterator([[b, "s"]]));
            if ("s" != c.get(b) || 1 != c.size || c.get({x: 4}) || c.set({x: 4}, "t") != c || 2 != c.size)return !1;
            var d = c.entries(), e = d.next();
            if (e.done || e.value[0] != b || "s" != e.value[1])return !1;
            e = d.next();
            return e.done || 4 != e.value[0].x || "t" != e.value[1] || !d.next().done ? !1 : !0
        } catch (q) {
            return !1
        }
    }

    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (a && $jscomp.ES6_CONFORMANCE)return a
    } else if (b())return a;
    $jscomp.initSymbolIterator();
    var c = new WeakMap, d = function (a) {
        this.data_ = {};
        this.head_ = f();
        this.size = 0;
        if (a) {
            a = $jscomp.makeIterator(a);
            for (var b; !(b = a.next()).done;)b = b.value, this.set(b[0], b[1])
        }
    };
    d.prototype.set = function (a, b) {
        a = 0 === a ? 0 : a;
        var c = e(this, a);
        c.list || (c.list = this.data_[c.id] = []);
        c.entry ? c.entry.value = b : (c.entry = {
            next: this.head_, previous: this.head_.previous, head: this.head_, key: a,
            value: b
        }, c.list.push(c.entry), this.head_.previous.next = c.entry, this.head_.previous = c.entry, this.size++);
        return this
    };
    d.prototype.delete = function (a) {
        a = e(this, a);
        return a.entry && a.list ? (a.list.splice(a.index, 1), a.list.length || delete this.data_[a.id], a.entry.previous.next = a.entry.next, a.entry.next.previous = a.entry.previous, a.entry.head = null, this.size--, !0) : !1
    };
    d.prototype.clear = function () {
        this.data_ = {};
        this.head_ = this.head_.previous = f();
        this.size = 0
    };
    d.prototype.has = function (a) {
        return !!e(this, a).entry
    };
    d.prototype.get = function (a) {
        return (a = e(this, a).entry) && a.value
    };
    d.prototype.entries = function () {
        return g(this, function (a) {
            return [a.key, a.value]
        })
    };
    d.prototype.keys = function () {
        return g(this, function (a) {
            return a.key
        })
    };
    d.prototype.values = function () {
        return g(this, function (a) {
            return a.value
        })
    };
    d.prototype.forEach = function (a, b) {
        for (var c = this.entries(), d; !(d = c.next()).done;)d = d.value, a.call(b, d[1], d[0], this)
    };
    d.prototype[Symbol.iterator] = d.prototype.entries;
    var e = function (a, b) {
        var d = b && typeof b;
        "object" ==
        d || "function" == d ? c.has(b) ? d = c.get(b) : (d = "" + ++h, c.set(b, d)) : d = "p_" + b;
        var e = a.data_[d];
        if (e && $jscomp.owns(a.data_, d))for (a = 0; a < e.length; a++) {
            var f = e[a];
            if (b !== b && f.key !== f.key || b === f.key)return {id: d, list: e, index: a, entry: f}
        }
        return {id: d, list: e, index: -1, entry: void 0}
    }, g = function (a, b) {
        var c = a.head_;
        return $jscomp.iteratorPrototype(function () {
            if (c) {
                for (; c.head != a.head_;)c = c.previous;
                for (; c.next != c.head;)return c = c.next, {done: !1, value: b(c)};
                c = null
            }
            return {done: !0, value: void 0}
        })
    }, f = function () {
        var a = {};
        return a.previous =
            a.next = a.head = a
    }, h = 0;
    return d
}, "es6", "es3");
$jscomp.polyfill("Object.is", function (a) {
    return a ? a : function (a, c) {
        return a === c ? 0 !== a || 1 / a === 1 / c : a !== a && c !== c
    }
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.includes", function (a) {
    return a ? a : function (a, c) {
        var b = this;
        b instanceof String && (b = String(b));
        var e = b.length;
        c = c || 0;
        for (0 > c && (c = Math.max(c + e, 0)); c < e; c++) {
            var g = b[c];
            if (g === a || Object.is(g, a))return !0
        }
        return !1
    }
}, "es7", "es3");
$jscomp.checkStringArgs = function (a, b, c) {
    if (null == a)throw new TypeError("The 'this' value for String.prototype." + c + " must not be null or undefined");
    if (b instanceof RegExp)throw new TypeError("First argument to String.prototype." + c + " must not be a regular expression");
    return a + ""
};
$jscomp.polyfill("String.prototype.includes", function (a) {
    return a ? a : function (a, c) {
        return -1 !== $jscomp.checkStringArgs(this, a, "includes").indexOf(a, c || 0)
    }
}, "es6", "es3");
$jscomp.polyfill("Set", function (a) {
    function b() {
        if ($jscomp.ASSUME_NO_NATIVE_SET || !a || "function" != typeof a || !a.prototype.entries || "function" != typeof Object.seal)return !1;
        try {
            var b = Object.seal({x: 4}), c = new a($jscomp.makeIterator([b]));
            if (!c.has(b) || 1 != c.size || c.add(b) != c || 1 != c.size || c.add({x: 4}) != c || 2 != c.size)return !1;
            var g = c.entries(), f = g.next();
            if (f.done || f.value[0] != b || f.value[1] != b)return !1;
            f = g.next();
            return f.done || f.value[0] == b || 4 != f.value[0].x || f.value[1] != f.value[0] ? !1 : g.next().done
        } catch (h) {
            return !1
        }
    }

    if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
        if (a && $jscomp.ES6_CONFORMANCE)return a
    } else if (b())return a;
    $jscomp.initSymbolIterator();
    var c = function (a) {
        this.map_ = new Map;
        if (a) {
            a = $jscomp.makeIterator(a);
            for (var b; !(b = a.next()).done;)this.add(b.value)
        }
        this.size = this.map_.size
    };
    c.prototype.add = function (a) {
        a = 0 === a ? 0 : a;
        this.map_.set(a, a);
        this.size = this.map_.size;
        return this
    };
    c.prototype.delete = function (a) {
        a = this.map_.delete(a);
        this.size = this.map_.size;
        return a
    };
    c.prototype.clear = function () {
        this.map_.clear();
        this.size = 0
    };
    c.prototype.has = function (a) {
        return this.map_.has(a)
    };
    c.prototype.entries = function () {
        return this.map_.entries()
    };
    c.prototype.values = function () {
        return this.map_.values()
    };
    c.prototype.keys = c.prototype.values;
    c.prototype[Symbol.iterator] = c.prototype.values;
    c.prototype.forEach = function (a, b) {
        var c = this;
        this.map_.forEach(function (d) {
            return a.call(b, d, d, c)
        })
    };
    return c
}, "es6", "es3");
$jscomp.assign = "function" == typeof Object.assign ? Object.assign : function (a, b) {
    for (var c = 1; c < arguments.length; c++) {
        var d = arguments[c];
        if (d)for (var e in d)$jscomp.owns(d, e) && (a[e] = d[e])
    }
    return a
};
$jscomp.polyfill("Object.assign", function (a) {
    return a || $jscomp.assign
}, "es6", "es3");
$jscomp.polyfill("Object.setPrototypeOf", function (a) {
    return a || $jscomp.setPrototypeOf
}, "es6", "es5");
$jscomp.findInternal = function (a, b, c) {
    a instanceof String && (a = String(a));
    for (var d = a.length, e = 0; e < d; e++) {
        var g = a[e];
        if (b.call(c, g, e, a))return {i: e, v: g}
    }
    return {i: -1, v: void 0}
};
$jscomp.polyfill("Array.prototype.findIndex", function (a) {
    return a ? a : function (a, c) {
        return $jscomp.findInternal(this, a, c).i
    }
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.find", function (a) {
    return a ? a : function (a, c) {
        return $jscomp.findInternal(this, a, c).v
    }
}, "es6", "es3");
$jscomp.polyfill("Math.sign", function (a) {
    return a ? a : function (a) {
        a = Number(a);
        return 0 === a || isNaN(a) ? a : 0 < a ? 1 : -1
    }
}, "es6", "es3");
$jscomp.polyfill("Math.log2", function (a) {
    return a ? a : function (a) {
        return Math.log(a) / Math.LN2
    }
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function (a) {
    return a ? a : function (a, c, d) {
        var b = this.length || 0;
        0 > c && (c = Math.max(0, b + c));
        if (null == d || d > b)d = b;
        d = Number(d);
        0 > d && (d = Math.max(0, b + d));
        for (c = Number(c || 0); c < d; c++)this[c] = a;
        return this
    }
}, "es6", "es3");
$jscomp.polyfill("Object.values", function (a) {
    return a ? a : function (a) {
        var b = [], d;
        for (d in a)$jscomp.owns(a, d) && b.push(a[d]);
        return b
    }
}, "es8", "es3");
$jscomp.polyfill("Object.entries", function (a) {
    return a ? a : function (a) {
        var b = [], d;
        for (d in a)$jscomp.owns(a, d) && b.push([d, a[d]]);
        return b
    }
}, "es8", "es3");
$jscomp.polyfill("String.prototype.endsWith", function (a) {
    return a ? a : function (a, c) {
        var b = $jscomp.checkStringArgs(this, a, "endsWith");
        a += "";
        void 0 === c && (c = b.length);
        c = Math.max(0, Math.min(c | 0, b.length));
        for (var e = a.length; 0 < e && 0 < c;)if (b[--c] != a[--e])return !1;
        return 0 >= e
    }
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.entries", function (a) {
    return a ? a : function () {
        return $jscomp.iteratorFromArray(this, function (a, c) {
            return [a, c]
        })
    }
}, "es6", "es3");

window.$jscomp = $jscomp

/***/ }),

/***/ "./src/lights/Light.js":
/*!*****************************!*\
  !*** ./src/lights/Light.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightInstance": function() { return /* binding */ LightInstance; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


class LightInstance {
    constructor(a, c, d) {
        this.light = a;
        this._position = c;
        this._rotation = d;
        this._directionW = new THREE.Vector3


        Object.defineProperty(this, "index", {
            get: ()=> {
                var a = this.light.instances.indexOf(this);
                console.assert(-1 !== a, "Light instance not found");
                return a
            }
        })

        Object.defineProperty(this, "position", {
            get: ()=> {
                return this._position
            },
            set: (value)=> {
                this.setPosition(value.x, value.y, value.z)
            }
        })


        Object.defineProperty(this, "rotation", {
            get: ()=> {
                return this._rotation
            },
            set: (value)=> {
                this.setRotation(value.x, value.y, value.z)
            }
        })

        Object.defineProperty(this, "rotationDeg", {
            get: ()=> {
                return {
                    x: this._rotation.yawDeg,
                    y: this._rotation.pitchDeg,
                    z: this._rotation.rollDeg
                }
            },
            set: (value)=> {
                if (undefined !== value._x) {
                    value = {
                        x: value._x,
                        y: value._y,
                        z: value._z
                    }
                }
                this.setRotationDeg(value.x, value.y, value.z)
            }
        })
    }

    directionW() {
        this._directionW.set(0, 1, 0);
        this._directionW.applyEuler(this.rotation);
        return this._directionW
    }

    setPosition(a, c, d) {
        this._position.set(a, c, d);
        this.light._updated()
    }

    setRotation(a, c, d) {
        this._rotation.yaw = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(a);
        this._rotation.pitch = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(c);
        this._rotation.roll = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(d);
        this.light._updated()
    }

    setRotationDeg(a, c, d) {
        a = THREE.Math.degToRad(a);
        c = THREE.Math.degToRad(c);
        d = void 0 === d ? this._rotation.roll : THREE.Math.degToRad(d);
        this.setRotation(a, c, d)
    }

    serialize() {
        return {position: this._position.toArray(), rotation: this._rotation.toDegTriple()}
    }
}

JMT.LightInstance = LightInstance

var a = "angle color height photometricProfile strength size type width".split(" ");

class Light extends THREE.EventDispatcher {
    constructor(b) {
        super()

        this.name = b.name;
        this._type = b.type || "spot";
        if (void 0 !== b.strength) {
            var c = b.strength;
        } else a:{
            switch (this._type) {
                case "point":
                case "spot":
                case "area":
                    c = 25;
                    break a;
                case "sun":
                    c = 8;
                    break a;
                default:
                    console.assert(!1)
            }
            c = void 0
        }
        this._strength = c;
        if (void 0 !== b.color) {
            c = (new THREE.Color).fromArray(b.color);
        }
        else a:{
            switch (this._type) {
                case "point":
                case "spot":
                case "area":
                    c = new THREE.Color(1, .88, .799);
                    break a;
                case "sun":
                    c = new THREE.Color(1, .8, .638);
                    break a;
                default:
                    console.assert(!1)
            }
            c = void 0
        }

        this._color = c;
        if (void 0 !== b.size) {
            c = b.size;
        }
        else a:{
            switch (this._type) {
                case "point":
                case "spot":
                case "area":
                    c = .1;
                    break a;
                case "sun":
                    c = .02;
                    break a;
                default:
                    console.assert(!1)
            }
            c = void 0
        }
        this._size = c;
        this._width = void 0 !== b.width ? b.width : .2;
        this._height = void 0 !== b.height ? b.height : .2;
        this._angle = void 0 !== b.angle ? b.angle : 140;
        this._photometricProfile = void 0 !== b.photometricProfile ? b.photometricProfile : null;
        if (!0 === b.doNotImport) {
            this.doNotImport = !0
        }
        else {
            this.doNotImport = {}
            b.doNotImport && (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyProperties)(b.doNotImport, a, this.doNotImport)
        }
        this.instances = []

        Object.defineProperty(this, "type", {
            get: ()=> {
                return this._type
            }, set: (a)=> {
                this._type = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "size", {
            get: ()=> {
                return this._size
            }, set: (a)=> {
                this._size = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "width", {
            get: ()=> {
                return this._width
            }, set: (a)=> {
                this._width = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "height", {
            get: ()=> {
                return this._height
            }, set: (a)=> {
                this._height = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "angle", {
            get: ()=> {
                return this._angle
            }, set: (a)=> {
                this._angle = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "color", {
            get: ()=> {
                let value = '#' + this._color.getHexString()
                return value
            },
            set: (value)=> {
                let strColor = value.substr(1)
                this._color.setHex(parseInt(strColor, 16))
                this._updated()
            }
        })

        Object.defineProperty(this, "strength", {
            get: ()=> {
                return this._strength
            }, set: (a)=> {
                this._strength = a;
                this._updated()
            }
        })

        Object.defineProperty(this, "photometricProfile", {
            get: ()=> {
                return this._photometricProfile
            }, set: (value)=> {
                this._photometricProfile = value;
                this._updated()
            }
        })

        Object.defineProperty(this, "uploadFile", {
            get: ()=> {
                return this._uploadFile
            },
            set: (value)=> {
                this._uploadFile = value
                //this._updated()
            }
        })
    }

    forEachLightInstance(a) {
        for (var b = 0; b < this.instances.length; b += 1) {
            a(this.instances[b])
        }
    }

    setDoNotImport(a, c) {
        this.doNotImport[a] = c;
        this._updated()
    }

    addInstance(a, c) {
        c = void 0 === c ? [0, -90, 0] : c;
        a = new THREE.Vector3().fromArray(a);
        c = new JMT.Euler().setFromDegTriple(c);
        c = new JMT.LightInstance(this, a, c);
        this.instances.push(c);
        this.dispatchEvent({type: "lightInstanceAdded", instance: c})
        return c
    }

    removeInstance(a) {
        (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.removeFromArray)(a, this.instances);
        this.dispatchEvent({type: "lightInstanceRemoved", instance: a})
    }

    serialize() {
        return {
            name: this.name,
            type: this.type,
            angle: this.angle,
            strength: this.strength,
            photometricProfile: this.photometricProfile,
            uploadFile: this.uploadFile,
            size: this.size,
            width: this.width,
            height: this.height,
            color: this._color.roundChannels().toArray(),
            doNotImport: this.doNotImport,
            instances: this.instances.map(function (a) {
                return a.serialize()
            })
        }
    }

    _updated() {
        this.dispatchEvent({type: "lightUpdated", light: this})
    }

    setColorRGB(a, c, d) {
        this._color.setRGB(a, c, d);
        this._updated()
    }
}

Light.iterateLightInstances = function (a, c) {
    for (var b = 1, e = 0; e < a.length; e += 1) {
        var g = a[e]
        for (var f = 0; f < g.instances.length; f += 1, b += 1) {
            c(g, g.instances[f], b)
        }
    }
}

JMT.Light = Light

/***/ }),

/***/ "./src/lights/LightProbe.js":
/*!**********************************!*\
  !*** ./src/lights/LightProbe.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightProbe": function() { return /* binding */ LightProbe; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

class LightProbe extends THREE.EventDispatcher {
    constructor(config = {}) {
        super()
        this.id = config.id;
        this._name = 'default_' + config.id
        this._position = new THREE.Vector3;
        config.position && this._position.fromArray(config.position);
        this._filteredCubeTexture = null;
        this._filteredCubeTextureNoLod = {};
        this._mirrorCubeTexture = null;
        this._boxEnabled = config.box ? !("enabled" in config.box) || config.box.enabled : !1;
        this.boxMin = new THREE.Vector3;
        this.boxMax = new THREE.Vector3;

        if(config.box){
            this.boxMin.fromArray(config.box.min)
            this._setClampedBoxMax(config.box.max[0], config.box.max[1], config.box.max[2])
        }

        Object.defineProperty(this, "position", {
            get : ()=>{
                return this._position
            },
            set : (value)=>{
                this.setPosition(value.x,value.y,value.z)
            }
        })


        Object.defineProperty(this, "name", {
            get : ()=>{
                return this._name
            },
            set : (value)=>{
                this._name = value
            }
        })
    }


    setFilteredTexture(a) {
        this._filteredCubeTexture && this._filteredCubeTexture.dispose();
        this._filteredCubeTexture = a
    }

    setFilteredTextureNoLod(a, b) {
        this._filteredCubeTextureNoLod[b] && this._filteredCubeTextureNoLod[b].dispose();
        this._filteredCubeTextureNoLod[b] = a
    }

    isBoundingBoxInitialized() {
        return !this.boxMin.equals(this.boxMax)
    }

    resetBoundingBox() {
        this.boxMin.set(0, 0, 0);
        this.boxMax.set(0, 0, 0)
    }

    isBoundingBoxEnabled() {
        return this._boxEnabled
    }

    disableBoundingBox() {
        this._boxEnabled = !1;
        this.dispatchEvent({type: "lightProbeBoundsUpdated", lightProbe: this})
    }

    enableBoundingBox() {
        this._boxEnabled = !0;
        this.isBoundingBoxInitialized() || this.dispatchEvent({type: "lightProbeBoundsInit", lightProbe: this});
        this.dispatchEvent({type: "lightProbeBoundsUpdated", lightProbe: this})
    }

    getFilteredTexture() {
        return this._filteredCubeTexture
    }

    getFilteredTextureNoLod(a) {
        return this._filteredCubeTextureNoLod[a]
    }

    setMirrorTexture(a) {
        this._mirrorCubeTexture && this._mirrorCubeTexture.dispose();
        this._mirrorCubeTexture = a
    }

    setPosition(a, b, c) {
        this._position.set(a, b, c);
        this.dispatchEvent({type: "lightProbePositionUpdated", lightProbe: this})
    }

    texturesReady() {
        return this._mirrorCubeTexture || this._filteredCubeTexture || this._filteredCubeTextureNoLod[0]
    }

    getMirrorTexture() {
        return this._mirrorCubeTexture || this._filteredCubeTexture || this._filteredCubeTextureNoLod[0]
    }

    _setClampedBoxMin(a, b, c) {
        a > this.boxMax.x - .1 && (a = this.boxMax.x - .1);
        b > this.boxMax.y - .1 && (b = this.boxMax.y -
            .1);
        c > this.boxMax.z - .1 && (c = this.boxMax.z - .1);
        this.boxMin.set(a, b, c)
    }

    isBoxMinValid(a, b, c) {
        return a > this.boxMax.x - .1 || b > this.boxMax.y - .1 || c > this.boxMax.z - .1 ? !1 : !0
    }

    isBoxMaxValid(a, b, c) {
        return a < this.boxMin.x + .1 || b < this.boxMin.y + .1 || c < this.boxMin.z + .1 ? !1 : !0
    }

    setBoxMin(a, b, c) {
        this._setClampedBoxMin(a, b, c);
        this.dispatchEvent({type: "lightProbeBoundsUpdated", lightProbe: this})
    }

    _setClampedBoxMax(a, b, c) {
        a < this.boxMin.x + .1 && (a = this.boxMin.x + .1);
        b < this.boxMin.y + .1 && (b = this.boxMin.y +
            .1);
        c < this.boxMin.z + .1 && (c = this.boxMin.z + .1);
        this.boxMax.set(a, b, c)
    }

    setBoxMax(a, b, c) {
        this._setClampedBoxMax(a, b, c);
        this.dispatchEvent({type: "lightProbeBoundsUpdated", lightProbe: this})
    }

    serialize() {
        var a = {id: this.id, position: this._position.toArray()};
        this.isBoundingBoxInitialized() && (a.box = {
            enabled: this._boxEnabled,
            min: this.boxMin.toArray(),
            max: this.boxMax.toArray()
        });
        return a
    }

    dispose() {
        this._filteredCubeTexture && (this._filteredCubeTexture.dispose(), this._filteredCubeTexture = null);
        for (var a in this._filteredCubeTextureNoLod)this._filteredCubeTextureNoLod.hasOwnProperty(a) && this._filteredCubeTextureNoLod[a].dispose();
        this._filteredCubeTextureNoLod = {};
        this._mirrorCubeTexture && (this._mirrorCubeTexture.dispose(), this._mirrorCubeTexture = null)
    }
}


JMT.LightProbe = LightProbe

/***/ }),

/***/ "./src/lights/arrangeLightProbes.js":
/*!******************************************!*\
  !*** ./src/lights/arrangeLightProbes.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrangeLightProbes": function() { return /* binding */ arrangeLightProbes; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */



function a(a) {
    if (a.empty())return 0;
    a.size(d);
    return d.x * d.y * d.z
}

function b(a) {
    if (a.empty())return 0;
    a.size(d);
    a = d.x * d.y;
    return 1 > d.x || 1 > d.y || 1.9 > d.z || 1.5 > a ? 0 : a * d.z
}

function c(c) {
    var d = [], e = [];
    d.push(c);
    this.addFilledBox = function (a) {
        e.push(a)
    };
    this.findBestFilledBoxes = function () {
        function b(a) {
            return a[1]
        }

        function c(a) {
            a = a[0];
            a = a.max.x < h.min.x + .2 || a.min.x > h.max.x - .2 || a.max.y < h.min.y + .2 || a.min.y > h.max.y - .2 || a.max.z < h.min.z + .2 || a.min.z > h.max.z - .2 ? !1 : !0;
            return !a
        }

        var d = [], f = [];
        for (e.forEach(function (b) {
            f.push([b,
                a(b)])
        }); 0 < f.length && 10 > d.length;) {
            var g = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.indexOfMax)(f, b);
            var h = f[g][0];
            d.push(h);
            f = f.filter(c)
        }
        return d
    };
    this.isEnclosedInFilledBox = function (a) {
        return (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.any)(e, function (b) {
            b = b.min.x - .1 <= a.min.x && a.max.x <= b.max.x + .1 && b.min.y - .1 <= a.min.y && a.max.y <= b.max.y + .1 && b.min.z - .1 <= a.min.z && a.max.z <= b.max.z + .1 ? !0 : !1;
            return b
        })
    };
    this.findLargestEmptyBox = function () {
        var b = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.indexOfMax)(d, a);
        return null !== b ? d[b] : null
    };
    var h = function () {
        var a = [];
        a[0] = new THREE.Box3;
        a[1] = new THREE.Box3;
        a[2] = new THREE.Box3;
        a[3] =
            new THREE.Box3;
        a[4] = new THREE.Box3;
        a[5] = new THREE.Box3;
        return function (c, d, e) {
            a[0].max.copy(c.max);
            a[0].min.copy(c.min);
            a[0].min.z = d.max.z;
            a[1].max.copy(c.max);
            a[1].max.z = d.min.z;
            a[1].min.copy(c.min);
            a[2].max.copy(c.max);
            a[2].min.copy(c.min);
            a[2].min.x = d.max.x;
            a[3].max.copy(c.max);
            a[3].max.x = d.min.x;
            a[3].min.copy(c.min);
            a[4].max.copy(c.max);
            a[4].min.copy(c.min);
            a[4].min.y = d.max.y;
            a[5].max.copy(c.max);
            a[5].max.y = d.min.y;
            a[5].min.copy(c.min);
            var f = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.indexOfMax)(a, b);
            0 !== b(a[f]) && (e.push(a[f].clone()),
                0 === f ? c.max.z = d.max.z : 1 === f ? c.min.z = d.min.z : 2 === f ? c.max.x = d.max.x : 3 === f ? c.min.x = d.min.x : 4 === f ? c.max.y = d.max.y : 5 === f && (c.min.y = d.min.y), h(c, d, e))
        }
    }();
    this.split = function (a) {
        for (var b = [], c = 0; c < d.length; c += 1) {
            var e = d[c];
            e.isIntersectionBox(a) ? h(e, a, b) : b.push(e)
        }
        d = b
    }
}

var d;


function arrangeLightProbes(e, g, f) {
    function h(a) {
        var b = new JMT.LightProbe({id: e.lightProbes.length});
        a.center(b.position);
        b.position.z = a.min.z + 1.3;
        b.enableBoundingBox();
        b.boxMin.copy(a.min);
        b.boxMax.copy(a.max);
        e.lightProbes.push(b)
    }

    var k = new c(e.boundingBox.clone()), n = new THREE.Box3, p = new THREE.Box3, l = new THREE.Vector3, q = new JMT.Timer;
    d = new THREE.Vector3;
    for (var r = new JMT.LightProbe({id: 0}), m = 0; 200 > m; m += 1) {
        var u = k.findLargestEmptyBox();
        if (null === u)break;
        u.center(r.position);
        r.position.z = u.min.z + 1.3;
        r.enableBoundingBox();
        p.makeEmpty();
        for (var x = 0; 5 > x; x += 1) {
            g.findBounds(r);
            if (!r.isBoundingBoxInitialized())break;
            n.set(r.boxMin, r.boxMax);
            var t = b(n);
            if (0 === t)break;
            if (k.isEnclosedInFilledBox(n))break;
            n.center(l);
            l.z = n.min.z + 1.3;
            var v = r.position.distanceToSquared(l);
            a(p) < t && .25 > v && p.set(n.min, n.max);
            if (.04 > v)break;
            r.position.copy(l)
        }
        p.empty() ? (u.center(n.min), u.center(n.max), k.split(n)) : (k.addFilledBox(p.clone()), k.split(p))
    }
    JMT.log("Light probes arrangement time " + q.elapsedSec());
    g = k.findBestFilledBoxes();
    (g.reduce(function (b, c) {
        return b + a(c)
    }, 0) > .2 * a(e.boundingBox) || f) && g.forEach(h);
    0 === e.lightProbes.length && f && h(e.boundingBox)
}



/***/ }),

/***/ "./src/loaders/BufferLoader.js":
/*!*************************************!*\
  !*** ./src/loaders/BufferLoader.js ***!
  \*************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.BufferLoader = function (a, b) {
    var c = {};
    this.onHaveBuffer = this.onFailure = this.onProgress = null;
    this._buffersDone = {};
    this.buffers = {
        meshes: null,
        transforms: null,
        bounds: null,
        faces16: null,
        faces: null,
        vertices: null,
        normals: null,
        uvs0: null,
        uvs1: null
    };
    this.haveAllBuffers = function () {
        for (var a in this.buffers)if (this.buffers.hasOwnProperty(a) && null === this.buffers[a])return !1;
        return !0
    };
    this.haveCoreBuffers = function () {
        var a = this.buffers;
        return a.faces16 && a.faces && a.vertices && a.normals && a.transforms
    };
    this.releaseCoreBuffers = function () {
        var a = this.buffers;
        a.faces16 = a.faces = a.vertices = a.normals = null
    };
    this.load = function () {
        function d(a) {
            return function (b) {
                g.buffers[a] = b;
                //console.log('loaded ' + a + ':' + b);
                g.onHaveBuffer()
            }
        }

        function e(a) {
            return function (b) {
                c[a] = b.loaded;
                g.onProgress()
            }
        }

        var g = this, f = JMT.LOAD_PRIORITY.CORE_RESOURCE, h = {
            meshes: f,
            transforms: f,
            bounds: f,
            faces16: f,
            faces: f,
            vertices: f,
            normals: f,
            uvs0: b ? f : JMT.LOAD_PRIORITY.UV0,
            uvs1: b ? f : JMT.LOAD_PRIORITY.LIGHTMAP
        };
        (function () {
            for (var b in g.buffers)if (g.buffers.hasOwnProperty(b)) {
                var c =
                    h[b];
                console.assert(void 0 !== c);
                JMT.queueAjaxGet(c, a + b + ".buf", !0, d(b), g.onFailure, e(b))
            }
        })()
    };
    this.totalDone = function () {
        var a = 0, b;
        for (b in c)c.hasOwnProperty(b) && (a += c[b]);
        return a
    }
}

/***/ }),

/***/ "./src/loaders/CompressedTextureLoader.js":
/*!************************************************!*\
  !*** ./src/loaders/CompressedTextureLoader.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _textures_CompressedTexture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../textures/CompressedTexture.js */ "./src/textures/CompressedTexture.js");
/**
 * Created by Kai on 2020/12/18.
 */


JMT.CompressedTextureLoader = function () {
    this._parser = null
};
JMT.CompressedTextureLoader.prototype = {
    constructor: JMT.CompressedTextureLoader, load: function (a, b, c, d) {
        var e = this, g = [], f = new JMT.CompressedTexture;
        f.image = g;
        JMT.queueAjaxGet(a, b, !0, function (a) {
            a = e._parser(a, !0);
            if (a.isCubemap)for (var b = a.mipmaps.length / a.mipmapCount, d = 0; d < b; d += 1) {
                g[d] = {mipmaps: []};
                for (var h = 0; h < a.mipmapCount; h += 1)g[d].mipmaps.push(a.mipmaps[d * a.mipmapCount + h]), g[d].format = a.format, g[d].width = a.width, g[d].height =
                    a.height
            } else f.image.width = a.width, f.image.height = a.height, f.mipmaps = a.mipmaps;
            1 === a.mipmapCount && (f.minFilter = GLC.LINEAR);
            f.format = a.format;
            f.width = a.width;
            f.height = a.height;
            c && c(f)
        }, d);
        return f
    }
}

/***/ }),

/***/ "./src/loaders/KTXLoader.js":
/*!**********************************!*\
  !*** ./src/loaders/KTXLoader.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _CompressedTextureLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CompressedTextureLoader.js */ "./src/loaders/CompressedTextureLoader.js");
/**
 * Created by Kai on 2020/12/18.
 */


JMT.KTXLoader = function () {
    this._parser = JMT.KTXLoader.parse
};
JMT.KTXLoader.prototype = Object.create(JMT.CompressedTextureLoader.prototype);
JMT.KTXLoader.parse = function (a) {
    var b = [], c = new Int32Array(a, 0, 16);
    67305985 === c[3] && console.assert("Big endian machines not supported");
    console.assert(0 === c[4]);
    console.assert(1 === c[5]);
    console.assert(0 === c[6]);
    if (35842 === c[7]) {
        console.assert(6408 === c[8]);
        var d = GLC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
    }
    else if(36196 === c[7]){
        console.assert(6407 === c[8])
        d = GLC.COMPRESSED_RGB_ETC1_WEBGL
    }
    else if(33776 === c[7]){
        console.assert(6407 === c[8])
        d = GLC.COMPRESSED_RGB_S3TC_DXT1_EXT
    }
    else if(33779 === c[7]){
        console.assert(6408 === c[8])
        d = GLC.COMPRESSED_RGBA_S3TC_DXT5_EXT
    }
    else {
        console.error("Unknown KTX glInternalFormat: " + c[7]);
    }
    var e = c[9], g = c[10];
    console.assert(0 === (e & e - 1));
    console.assert(0 === (g & g - 1));
    console.assert(0 === c[11]);
    console.assert(0 === c[12]);
    console.assert(1 === c[13]);
    var f = c[14];
    c = c[15];
    console.assert(0 === c % 4);
    c = 64 + c;
    for (var h = new DataView(a, 0), k = e, n = g, p = 0; p < f; ++p) {
        var l = h.getUint32(c, !0);
        c += 4;
        var q = new Uint8Array(a,
            c, l);
        b.push({data: q, width: k, height: n});
        c += l + (3 - (l + 3) % 4);
        k = Math.max(k / 2, 1);
        n = Math.max(n / 2, 1)
    }
    console.assert(c === a.byteLength);
    return {format: d, width: e, height: g, mipmapCount: f, mipmaps: b}
}

/***/ }),

/***/ "./src/loaders/LightmapLoader.js":
/*!***************************************!*\
  !*** ./src/loaders/LightmapLoader.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightmapLoader": function() { return /* binding */ LightmapLoader; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
function LightmapLoader(textureLoader, lightMapCount, lightMpaFormats) {
    function onLoaded() {
        --e;
        if (0 === e)
            THIS_.onComplete()
    }

    let stdExt = "png";
    if (lightMpaFormats) {
        if (-1 < lightMpaFormats.indexOf("webp"))
            stdExt = "webp";
    }

    var THIS_ = this, e = lightMapCount;
    this.lightmaps = [];
    this.onComplete = null;
    this.load = function () {
        for (let i = 0; i < lightMapCount; i += 1) {

            var d = {
                id: null,
                name: null,
                stdExt: stdExt,
                webFormats: ["large/std"],
                alpha: true,
                rgbm: true
            }

            d.id = d.name = "lightmap-rgbm" + i;
            var h = textureLoader.load(JMT.LOAD_PRIORITY.LIGHTMAP, d, !1, !1, JMT.NO_ANISOTROPY);
            h.addLoadedListener(onLoaded);
            this.lightmaps.push(h)
        }
    }
}

JMT.LightmapLoader = LightmapLoader

/***/ }),

/***/ "./src/loaders/MaterialLoader.js":
/*!***************************************!*\
  !*** ./src/loaders/MaterialLoader.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/* harmony import */ var _utils_ColorUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ColorUtils.js */ "./src/utils/ColorUtils.js");
/**
 * Created by Kai on 2020/12/18.
 */
//import {$jscomp} from '../../src_new/lib/jscomp.js'


//import '../materials/FlashLightMaterial.js'


function copyInnerProperties(a, b, c) {

    for (var d = 0; d < b.length; d += 1) {

        var e = b[d]

        var f = a[e];

        void 0 !== f && (c["_" + e] = f)

    }

}

var b = "doubleSided name opacity parallaxCorrection parallaxMode parallaxScale parallaxMinLayers parallaxMaxLayers planarReflector".split(" ")
var c = "bumpScale emissive emissionStrength envMapProject metallic roughness alphaInLowerHalf chromaKeyEnabled".split(" ")
var d = "baseColor bumpScale bumpTexture doubleSided emissive metallic opacity roughness".split(" ");


JMT.MaterialLoader = function (textureLoader, atlases, f) {

    var h = JMT.DETECTOR;

    this.load = function (k, n) {

        var p = new Map

        var l = 0

        for (var  q = 0; q < k.length; q += 1) {

            var r;

            var m = k[q];


            var material = JMT.createMaterialOfType(m.type);

            
            if ("water" === material.type) {

                material.name = m.name

                if(m.normalTexture){

                    material.normalTexture = textureLoader.load(JMT.LOAD_PRIORITY.SPECULARITY, m.normalTexture, !0, !1, JMT.DEFAULT_ANISOTROPY)

                }

                if(m.baseColor){

                    material.baseColor.fromArray(m.baseColor)

                }

                if(void 0 !== m.opacity){

                    material.opacity = m.opacity

                }

                copyInnerProperties(m, ["wavesSpeed", "wavesScale", "refractionFactor"], material)

                material.setUniforms();

            }
            else {

                (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyProperties)(m, b, material);

                copyInnerProperties(m, c, material);

                if(m.baseColor){

                    material.baseColor.fromArray(m.baseColor)

                    material.baseColor.roundChannels()

                }

                r = m.baseColorTextureCorrection

                if (r){

                    material._baseColorTextureCorrection = !0

                    if(void 0 !== r.contrast){

                        material._baseColorTextureContrast = r.contrast

                    }

                    material.baseColorTextureHslOffset.h = r.hslOffset[0]

                    material.baseColorTextureHslOffset.s = r.hslOffset[1]

                    material.baseColorTextureHslOffset.l = r.hslOffset[2];

                }


                if (m.baseColorTexture){


                    r = m.baseColorTexture

                    if(r.atlasId){


                        r = atlases[r.atlasId].getAtlasEntry(r.name, r.atlasOffset[0], r.atlasOffset[1], r.atlasScale[0], r.atlasScale[1])

                    }
                    else {

                        r = textureLoader.load(JMT.LOAD_PRIORITY.DIFFUSE, r, !0, !0, JMT.DEFAULT_ANISOTROPY)

                    }

                    r.isCutout =  null

                    material.baseColorTexture = r;
                }

                if(m.roughnessTexture){

                    material.roughnessTexture = textureLoader.load(JMT.LOAD_PRIORITY.SPECULARITY, m.roughnessTexture, !0, !0, JMT.DEFAULT_ANISOTROPY)

                }

                if(m.metallicTexture){

                    material.metallicTexture = textureLoader.load(JMT.LOAD_PRIORITY.SPECULARITY, m.metallicTexture, !0, !0, JMT.DEFAULT_ANISOTROPY)

                }

                if(m.bumpTexture && h.standardDerivatives){

                    material.bumpTexture = textureLoader.load(JMT.LOAD_PRIORITY.SPECULARITY, m.bumpTexture, !0, !0, JMT.DEFAULT_ANISOTROPY)

                }

                if(m.doNotImport){

                    (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.copyProperties)(m.doNotImport, d, material.doNotImport);

                }

                if(m.chromaKeyColor){

                    material.chromaKeyColor.fromArray(m.chromaKeyColor)

                    material.chromaKeyColor.roundChannels()
                }

                if(m.chromaKeyDelta){

                    material._chromaKeyDelta.fromArray(m.chromaKeyDelta)

                }

                if (m.hasFlash) {
                    material.hasFlash = true
                    material.flashColors = m.flashColors
                    material.flashDelay = m.flashDelay
                }

                if (m.hasUvAnimated) {
                    material.hasUvAnimated = true
                    material.uvMoveSpeed.fromArray(m.uvMoveSpeed)
                    material.uvRepeat.fromArray(m.uvRepeat)
                    material.uvRotate = m.uvRotate
                    material.uvRotateSpeed = m.uvRotate
                }

            }
            
            // if (JMT.j3dStandardMaterial) {
            //     material = new JMT.j3dStandardMaterial()
            //     material.name = m.name
            //     material.onBeforeCompile = (shader)=>{
            //         console.log(shader);
            //     }
            // }
                
            m = material;

            if (!f.isMaterialEditable(m.name)) {

                var u = m.hash&&m.hash();

                r = p.get(u) || [];

                for (var x = $jscomp.makeIterator(r), t = x.next(); !t.done; t = x.next()){

                    t = t.value

                    if (t.canMerge(m)) {

                        l += 1;

                        t.merged = !0;

                        m = t;

                        break

                    }

                }

                if(!m.merged){

                    r.push(m)

                    p.set(material, r)

                }

            }

            n.addMaterial(m);

            m.merged || m.setUniforms&&m.setUniforms()

        }

        JMT.log("Have " + k.length + " materials and " + (k.length - l) + " merged materials.")

    }

}

/***/ }),

/***/ "./src/loaders/SceneLoader.js":
/*!************************************!*\
  !*** ./src/loaders/SceneLoader.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneLoader": function() { return /* binding */ SceneLoader; }
/* harmony export */ });
/* harmony import */ var _utils_Timer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Timer.js */ "./src/utils/Timer.js");
/* harmony import */ var _utils_Timer_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils_Timer_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _BufferLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BufferLoader.js */ "./src/loaders/BufferLoader.js");
/* harmony import */ var _BufferLoader_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_BufferLoader_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _lights_Light_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lights/Light.js */ "./src/lights/Light.js");
/* harmony import */ var _objects_MergedMesh_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../objects/MergedMesh.js */ "./src/objects/MergedMesh.js");
/* harmony import */ var _objects_MergedMesh_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_objects_MergedMesh_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lights_LightProbe_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lights/LightProbe.js */ "./src/lights/LightProbe.js");
/* harmony import */ var _TextureLoader_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./TextureLoader.js */ "./src/loaders/TextureLoader.js");
/* harmony import */ var _TextureAtlasLoader_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TextureAtlasLoader.js */ "./src/loaders/TextureAtlasLoader.js");
/* harmony import */ var _MaterialLoader_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./MaterialLoader.js */ "./src/loaders/MaterialLoader.js");
/* harmony import */ var _SkyLoader_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./SkyLoader.js */ "./src/loaders/SkyLoader.js");
/* harmony import */ var _objects_Node_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../objects/Node.js */ "./src/objects/Node.js");
/* harmony import */ var _objects_Node_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_objects_Node_js__WEBPACK_IMPORTED_MODULE_9__);
/* harmony import */ var _objects_MeshMaker_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../objects/MeshMaker.js */ "./src/objects/MeshMaker.js");
/* harmony import */ var _LightmapLoader_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LightmapLoader.js */ "./src/loaders/LightmapLoader.js");
/* harmony import */ var _utils_asyncFillNotIndexedGeometry_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../utils/asyncFillNotIndexedGeometry.js */ "./src/utils/asyncFillNotIndexedGeometry.js");
/* harmony import */ var _utils_asyncFillNotIndexedGeometry_js__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_utils_asyncFillNotIndexedGeometry_js__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _objects_View_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../../objects/View.js */ "./objects/View.js");
/* harmony import */ var _objects_Tour_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../objects/Tour.js */ "./objects/Tour.js");
/* harmony import */ var _cameras_CameraVolume_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../cameras/CameraVolume.js */ "./src/cameras/CameraVolume.js");
/**
 * Created by Kai on 2020/12/18.
 */

















function addViews(views, scene) {    // a
    views.forEach(function (view) {
        scene.addView(new _objects_View_js__WEBPACK_IMPORTED_MODULE_13__.View(view))
    })
}

function addTours(tours, scene){
    tours.forEach(function(tour){
        scene.addTour(new _objects_Tour_js__WEBPACK_IMPORTED_MODULE_14__.Tour(tour))
    })
}

function addNodeConfigs(a, b, c) { // b
    a.forEach(function (a) {
        c.isNodeTypeEditable(a.name) && (a.editable = !0);
        b.addNodeConfig(new JMT.NodeConfig(a))
    })
}

function addLights(a, b) {  // c
    a.forEach(function (a) {
        var c = new JMT.Light(a);
        a = a.instances;
        for (var d = 0; d < a.length; d += 1) {
            var e = a[d];
            c.addInstance(e.position, e.rotation)
        }
        b.addLight(c)
    })
}

function addLightProbes(a, b) {  // d
    a.forEach(function (a) {
        b.addLightProbe(new JMT.LightProbe(a))
    })
}

function updateCamera(a, b, c) {   // e
    c = c.camera;
    if (a) {
        c.defaultFov = a.fov
        if (a.exposure) {
            c.defaultExposure = a.exposure
        }
        if (a.gamma) {
            c.defaultGamma = a.gamma
        }
        if (a.lutTexture) {
            b = b.load(JMT.LOAD_PRIORITY.COLORMAP, a.lutTexture, !1, !1, JMT.NO_ANISOTROPY)
            b.flipY = !1
            c.colorMap = b
        }
        c.autoClimb = !!a.autoClimb
        c.autoExposure = !!a.autoExposure
        if (void 0 !== a.autoExposureDarkness) {
            c.autoExposureDarkness = a.autoExposureDarkness
        }
        a.moveMaxSpeed && (c.moveMaxSpeed = a.moveMaxSpeed)
        c.updateProjectionMatrix()
    }
}

function addNodes(a, b) {    // g
    function createNode(a, d) {
        var e = b.findNodeConfig(d.config)
        var f = new JMT.Node(a, e, d);
        void 0 !== d.children && (f.children = d.children.map(function (a) {
            return createNode(f, a)
        }));
        return f
    }

    a.forEach(function (a) {
        b.addNode(createNode(null, a))
    })
}

function onError() {    // f

    JMT.USER_MSG.error("Scene failed to load. Reload the page to retry.")

}

function SceneLoader(scene, path, isEditor, p) {

    //isEditor = true;
    var l = !isEditor && JMT.DETECTOR.indexUint

    var q = !isEditor && !JMT.DEBUG_SHARED_BUFFERS

    var timer = new JMT.Timer;

    this.onComplete = this.onReadyToDisplay = this.onTextureLoaded = this.onMeshBuffersLoaded = this.onProgress = null;

    this.panoramas = [];

    this.load = function () {

        function m() {

            if (void 0 !== F.total) {

                Q.onProgress(F)

            }

        }

        function u() {

            if (!D) {

                D = !0

                Q.onReadyToDisplay(scene)

            }

        }

        function x(a) {

            if (0 === a.name.indexOf("lightmap-rgbm")) {

                F.texturesDone += 12582912

            }
            else {

                F.texturesDone += 524288;

            }

            m();

            Q.onTextureLoaded(a);

            P()

        }

        function t() {

            console.warn("Failed to load video texture");

            P()

        }

        function v() {

            if (0 === C.texturesToLoad && L) {

                C.clearCache();

                for (var a = 0, b = $jscomp.makeIterator(H.mergedMeshes), c = b.next(); !c.done; c = b.next()) {

                    a += c.value.geometry.gpuSize;

                }

                JMT.log("Total GPU geometry buffers size " + a + " bytes");

                C = B = H = null;

                JMT.defer(function () {

                    u();

                    Q.onComplete(scene)

                })

            }

        }

        function w() {

            if (W && J && N) {

                P = v

                if (R) {

                    scene.materials.forEach(function (a) {

                        if (!a.lightMapped) {

                            a.lightMapped = !0

                            a.setUniforms&&a.setUniforms()

                        }

                    })

                }

                P()

            }

        }

        function z(a) {

            a.geometry.addUv1Attribute();

            Q.onMeshBuffersLoaded(a)

        }

        function A() {

            if (B.buffers.uvs1) {

                P = w

                JMT.asyncFillIndexedUv1(B.buffers.uvs1, H.mergedMeshes, z, function () {

                    B.buffers.uvs1 = null;

                    W = !0;

                    //P()
                    w()

                })
            }
        }

        function y(a) {

            a.geometry.addUv0Attribute();

            Q.onMeshBuffersLoaded(a)

        }

        function E() {

            if (B.buffers.uvs0) {

                P = A

                JMT.asyncFillIndexedUv0(B.buffers.uvs0, H.mergedMeshes, isEditor, y,
                    function () {
                        B.buffers.uvs0 = null;
                        L = !0;
                        //P()
                        A()
                    }
                )

            }
        }

        function I() {

            N = !0;

            if (0 === scene.views.length) {

                scene.addView(new JMT.View({
                    id: 0,
                    name: "Start place",
                    hideFromMenu: !0,
                    position: scene.center.toArray(),
                    rotation: [0, 0],
                    internal: !0,
                    sky: JMT.EDITOR_CONTROLLED_SKY_NAME
                }));
            }

            if (!isEditor && !scene.disableProgressiveLoader) {

                var a = 1E3 * JMT.PROGRESSIVE_LOADER_AFTER_SEC - timer.elapsedMSec();

                0 >= a ? u() : setTimeout(u, a)

            }

            P()
        }

        function O(a) {
            scene.addGpuMesh(a)
        }

        function K(a) {
            a.geometry.addCoreAttributes();
            var b = a.logicalMeshes;
            console.assert(!b[0].node.editable || 1 === b.length);
            b[0].node.editable || !q ? b.forEach(O) : O(a);
            //b[0].node.editable ? b.forEach(O) : O(a);
            Q.onMeshBuffersLoaded(a)
        }

        function T(a) {
            a.geometry.uvs0 && a.geometry.addUv0Attribute();
            a.geometry.uvs1 && a.geometry.addUv1Attribute();
            K(a)
        }

        function fillGeometries() {
            if (l) {
                if (!B.haveCoreBuffers()) {
                    return;
                }
                JMT.log("Using indexed geometry");
                P = E;
                JMT.asyncFillIndexedCoreGeometry(B.buffers, H.mergedMeshes, K, I)
            }
            else {
                if (!B.haveAllBuffers()) {
                    return;
                }
                P = w;
                JMT.asyncFillNotIndexedGeometry(B.buffers, H.mergedMeshes, isEditor, T, function () {
                    W = L = !0;
                    I()
                })
            }
            B && B.releaseCoreBuffers()
        }

        var Q = this,
            C = null, B = null, H = null, D = !1, L = !1, M = null, R = !1

        var W = !1, J = !1, N = !1
        var F = {
            total: void 0,
            texturesDone: 0,
            totalDone: function () {
                return this.texturesDone + B.totalDone()
            }
        };

        timer.reset();

        var P = function () {

            if (M && B.buffers.meshes && B.buffers.bounds) {

                P = fillGeometries;

                if (void 0 !== M.autoAddLightProbes) {

                    scene.autoAddLightProbes = M.autoAddLightProbes

                }

                scene.disableProgressiveLoader = M.disableProgressiveLoader || !1;

                if (void 0 !== M.autoTour) {

                    scene.autoTour.disabled = M.autoTour.disabled || !1

                    scene.autoTour.startOnLoad = M.autoTour.startOnLoad || !1

                }

                addLights(M.lights, scene);

                addLightProbes(M.lightProbes || [], scene);

                if (M.cameraVolumes) {

                    M.cameraVolumes.forEach(function (a) {

                        return scene.addCameraVolume(new _cameras_CameraVolume_js__WEBPACK_IMPORTED_MODULE_15__["CameraVolume"](a))

                    });
                }

                C = (JMT.j3dTextureLoader!=undefined) ? new JMT.j3dTextureLoader(path, JMT.DETECTOR, x, onError, t, !1) : 
                    new JMT.TextureLoader(path, JMT.DETECTOR, x, onError, t, !1);

                updateCamera(M.camera, C, scene);

                var m = new JMT.TextureAtlasLoader(C);

                m.load(M.atlases || []);

                (new JMT.MaterialLoader(C, m.atlases, p)).load(M.materials || [], scene);

                (new JMT.SkyLoader(C)).load(M.skies || [], scene);

                if (null === scene.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME)) {

                    console.error("A sky with name " + JMT.EDITOR_CONTROLLED_SKY_NAME + " is missing.");

                }

                addViews(M.views || [], scene);

                addTours(M.tours || [], scene)

                if (M.hideViewsMenu) {

                    scene.hideViewsMenu = !0

                }

                addNodeConfigs(M.nodeConfigs, scene, p);

                addNodes(M.nodes, scene);

                H = new JMT.MeshMaker(scene, B.buffers.meshes, B.buffers.bounds, l);

                m = null;

                if (0 !== H.lightmapCount) {

                    R = !0;

                    var lightMpaFormats = M.lightmap && M.lightmap.formats;
                    var n = new JMT.LightmapLoader(C, H.lightmapCount, lightMpaFormats);

                    n.onComplete = function () {

                        J = !0;

                        //P()
                        w()

                    };

                    n.load();

                    m = n.lightmaps;

                    n = null

                }
                else {

                    J = !0;

                }

                H.createMeshes(m);

                F.total = H.geometryDownloadSize + 524288 * (C.texturesToLoad - H.lightmapCount) + 12582912 * H.lightmapCount;

                if (M.panoramas) {

                    Q.panoramas = M.panoramas

                }

                M = null;

                //P()
                fillGeometries()
            }
        };

        JMT.queueAjaxGet(JMT.LOAD_PRIORITY.CORE_RESOURCE, path + "scene.json", !1, function (a) {

            M = a;

            P()

        }, onError);

        B = new JMT.BufferLoader(path, !l);

        B.onProgress = m;

        B.onFailure = onError;

        B.onHaveBuffer = function () {

            P()

        };

        B.load()
    };

    this.elapsedLoadTimeSec = function () {

        return timer.elapsedSec()

    }
}

/***/ }),

/***/ "./src/loaders/SkyLoader.js":
/*!**********************************!*\
  !*** ./src/loaders/SkyLoader.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkyLoader": function() { return /* binding */ SkyLoader; }
/* harmony export */ });
/* harmony import */ var _extend_material_j3dEquirectSkyMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extend/material/j3dEquirectSkyMaterial.js */ "./src/extend/material/j3dEquirectSkyMaterial.js");
/* harmony import */ var _extend_material_j3dProceduralSkyMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extend/material/j3dProceduralSkyMaterial.js */ "./src/extend/material/j3dProceduralSkyMaterial.js");
/* harmony import */ var _objects_SkyMesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../objects/SkyMesh.js */ "./src/objects/SkyMesh.js");
/**
 * Created by Kai on 2020/12/18.
 */





function getSkyMesh(name, material, center) {
    var geometry = new THREE.SphereBufferGeometry(1, 64, 64);
    return new _objects_SkyMesh_js__WEBPACK_IMPORTED_MODULE_2__.SkyMesh(name, geometry, material, center)
}

function getProceduralSkyMesh(a) {
    var material = (JMT.j3dProceduralSkyMaterial != undefined) ?
        new JMT.j3dProceduralSkyMaterial: new JMT.ProceduralSkyMaterial;
    return getSkyMesh(a.name, material, a.center)
}

class SkyLoader {
    constructor(textureLoader) {
        this.textureLoader = textureLoader

    }

    loadSkyTexture(b, c) {
        b.material.map && b.material.map.dispose();
        b.material.map = this.textureLoader.load(JMT.LOAD_PRIORITY.SKY, c, !1, !1, JMT.NO_ANISOTROPY);
        b.yawRotationDeg = 0
    }

    loadSingleSky(d, scene) {

        if ("procedural" === d.type || void 0 === d.type) {

            d = getProceduralSkyMesh(d);

        }
        else if ("equirect" === d.type) {

            var g = (JMT.j3dEquirectSkyMaterial != undefined) ?
                new JMT.j3dEquirectSkyMaterial : new JMT.EquirectSkyMaterial;

            g.map = this.textureLoader.load(JMT.LOAD_PRIORITY.SKY, d.texture, !1, !1, JMT.NO_ANISOTROPY);

            g = getSkyMesh(d.name, g, d.center);

            g.geometry.applyMatrix((new THREE.Matrix4).makeScale(1, 1, -1));

            g.rotation.x = Math.PI / 2;

            g.yawRotationDeg = d.yawRotation || 0;

            d = g

        }
        else {

            console.warn("Unknown sky type: ", d.type)

            d = getProceduralSkyMesh(d);

        }

        scene.addSkyMesh(d)
    }

    load(skysCfg, scene) {

        this.loadSingleSky({name: JMT.DEFAULT_SKY_NAME, type: "procedural"}, scene);

        for (var c = 0; c < skysCfg.length; c += 1) {

            this.loadSingleSky(skysCfg[c], scene)

        }

    }
}

JMT.SkyLoader = SkyLoader

/***/ }),

/***/ "./src/loaders/TextureAtlasLoader.js":
/*!*******************************************!*\
  !*** ./src/loaders/TextureAtlasLoader.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureAtlasLoader": function() { return /* binding */ TextureAtlasLoader; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

class TextureAtlasLoader {

    constructor(textureLoader) {

        this.atlases = {};

        this.textureLoader = textureLoader

    }


    load(atlas) {

        for (var c = 0; c < atlas.length; ++c) {

            var texture = this.textureLoader.load(JMT.LOAD_PRIORITY.DIFFUSE, atlas[c], !1, !0, JMT.DEFAULT_ANISOTROPY);

            texture.flipY = !1;

            texture.enableAtlas();

            this.atlases[atlas[c].id] = texture

        }
    }
}

JMT.TextureAtlasLoader = TextureAtlasLoader

/***/ }),

/***/ "./src/loaders/TextureLoader.js":
/*!**************************************!*\
  !*** ./src/loaders/TextureLoader.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureLoader": function() { return /* binding */ TextureLoader; }
/* harmony export */ });
/* harmony import */ var _KTXLoader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./KTXLoader.js */ "./src/loaders/KTXLoader.js");
/* harmony import */ var _createBasisLoader_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./createBasisLoader.js */ "./src/loaders/createBasisLoader.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */




function Cache() {  // a
    var a = {};
    this.cacheKey = function (a, b, c, d, e) {
        return a + "@" + b + "@" + c + "@" + d + "@" + e
    };
    this.get = function (b) {
        return a[b]
    };
    this.insert = function (b, c) {
        a[b] = c
    }
}

var d = !1;

function loadNormalTexture(priority, url, format, onload, onerror) {
    function onprocess(a) {
        texture.image = a;
        texture.width = a.width;
        texture.height = a.height;
        onload(texture)
    }

    var texture = new JMT.Texture;
    texture.format = format;
    JMT.queueImageGet(priority, url, d ? function (data) {
        createImageBitmap(data, {
            premultiplyAlpha: "none",
            imageOrientation: texture.flipY ? "flipY" : "none"
        }).then(onprocess).catch(onerror)
    } : onprocess, onerror);
    return texture
}

function loadVideoTexture(priority, url, format, onload, onerror) {
    var texture = new JMT.VideoTexture;
    texture.format = format;
    JMT.queueVideoGet(priority, url, function (a) {
        texture.video = a;
        texture.width = a.videoWidth;
        texture.height = a.videoHeight;
        if (!(THREE.Math.isPowerOfTwo(texture.width) && THREE.Math.isPowerOfTwo(texture.height))) {
            texture.wrapS = GLC.CLAMP_TO_EDGE
            texture.wrapT = GLC.CLAMP_TO_EDGE
        }
        onload(texture)
    }, onerror);
    return texture
}


function TextureLoader(path, detector, onLoad, onError, onVideoError, noCache) {

    function resolveURL(a) {

        if (a.url) {
            return a.url
        }

        var b = a.id

        var c = a.webFormats;

        if (a.video) {
            return path + "video/" + c[0] + "/" + b + "." + a.stdExt;
        }
        var e = path + "img/"

        var f = detector.ios && a.rgbm;

        if (_basisLoader && !f) {
            if (!detector.mobile && -1 < c.indexOf("large/basis")) {
                return e + "large/basis/" + b + ".basis";
            }
            if (-1 < c.indexOf("small/basis")) {
                return e + "small/basis/" + b + ".basis"
            }
        }

        if (detector.pvrtcTextures && !f && -1 < c.indexOf("small/pvr")) {
            return e + "small/pvr/" + b + ".ktx";
        }

        if (detector.etc1Textures && -1 < c.indexOf("small/etc1")) {
            return e + "small/etc1/" + b + ".ktx";
        }

        if (detector.dxtTextures && -1 < c.indexOf("large/dxt")) {
            return e + "large/dxt/" + b + ".ktx";
        }

        f = -1 < c.indexOf("small/std");

        if (!(-1 < c.indexOf("large/std")) || detector.mobile && f) {
            return e + "small/std/" + b + "." + a.stdExt
        }
        else {
            return e + "large/std/" + b + "." + a.stdExt
        }

    }

    function _onload(texture) {
        --u.texturesToLoad;
        texture.needsUpdate = !0;

        texture.notifyLoading()

        var c = THREE.Math.isPowerOfTwo(texture.image.width) && THREE.Math.isPowerOfTwo(texture.image.height)

        if (!c) {

            //TODO: resize image
            if(texture.url.indexOf("/fire/7.png") >= 0){
                texture.image = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_2__.resizeImage)(texture.image, true, 0, 8192)
                texture.width = texture.image.width
                texture.height = texture.image.height
            }

            //a.hasAlpha = true
            //a.minFilter = t.minFilter;
            //a.loaded = !0;
            //a.needsUpdate = !0;
        }

        onLoad(texture);
        texture.notifyLoaded()
    }

    function _onerror() {
        --u.texturesToLoad;
        onError()
    }

    function _onvideoerror() {
        --u.texturesToLoad;
        onVideoError()
    }

    function loadBufferTexture(priority, url, format, onload, onerror) {
        var texture = new JMT.DataTexture;
        JMT.queueAjaxGet(priority, url, !0, function (data) {
            data = new Uint8Array(data, 0, data.byteLength);
            texture.image.width = Math.pow(2, data[0]);
            texture.image.height = Math.pow(2, data[1]);
            texture.format = format;
            texture.type = GLC.UNSIGNED_BYTE;
            texture.image.data = data.subarray(2);
            onload && onload(texture);
            f = null
        }, onerror);
        return texture
    }

    var u = this

    var _cache = new Cache()

    var _ktxLoader = new JMT.KTXLoader

    var _basisLoader = !JMT.urlHashContains("nobasis") && JMT.createBasisLoader(detector);

    noCache && (_cache.insert = function () {
    });

    this.texturesToLoad = 0;

    this.clearCache = function () {
        _cache = null
    };

    this.load = function (priority, loadArgs, isRepeat, mipmap, anisotropy) {

        var format = loadArgs.alpha ? GLC.RGBA : GLC.RGB

        var url = resolveURL(loadArgs)

        var isBasis = /\.basis$/.test(url)
        var isKTX = /\.ktx$/.test(url)
        var isBinary = /\.buf$/.test(url)
        var video = loadArgs.video
        var isNormal = !(isKTX || isBinary || video)

        var texture = null
        if (!loadArgs.noCache) {
            var cacheKey = _cache.cacheKey(url, isRepeat, mipmap, anisotropy, format)
            texture = _cache.get(cacheKey);
        }

        if (texture) {

            return texture;

        }

        u.texturesToLoad += 1;

        if (isBinary) {
            texture = loadBufferTexture(priority, url, format, _onload, _onerror)
        }
        else if (isBasis) {
            texture = _basisLoader.load(priority, url, _onload, _onerror)
        }
        else if (isKTX) {
            texture = _ktxLoader.load(priority, url, _onload, _onerror)
        }
        else if (isNormal) {
            texture = loadNormalTexture(priority, url, format, _onload, _onerror)
        }
        else {
            console.assert(video)
            texture = loadVideoTexture(JMT.LOAD_PRIORITY.VIDEO, url, format, _onload, _onvideoerror)
        }

        texture.hasAlpha = !!loadArgs.alpha;

        texture.isRgbm = !!loadArgs.rgbm;

        if (isRepeat) {
            texture.wrapS = GLC.REPEAT
            texture.wrapT = GLC.REPEAT
        }

        if (mipmap && !video) {
            texture.minFilter = GLC.LINEAR_MIPMAP_LINEAR
            texture.generateMipmaps = !isKTX
        }
        else {
            texture.minFilter = GLC.LINEAR
            texture.generateMipmaps = !1
        }

        if (anisotropy) {
            texture.anisotropy = anisotropy
        }

        if (!loadArgs.noCache) {
            _cache.insert(cacheKey, texture);
        }

        texture.id = loadArgs.id;

        texture.name = loadArgs.name;

        texture.webFormats = loadArgs.webFormats;

        loadArgs.rawExt && (texture.rawExt = loadArgs.rawExt);

        texture.stdExt = loadArgs.stdExt;

        texture.url = url

        return texture
    }
}

JMT.TextureLoader = TextureLoader

/***/ }),

/***/ "./src/loaders/createBasisLoader.js":
/*!******************************************!*\
  !*** ./src/loaders/createBasisLoader.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */



 function gpuFromat2ThreeFormat(gpuFormat) {
     if (GLC.COMPRESSED_RGB_S3TC_DXT1_EXT == gpuFormat)
        return THREE.RGB_S3TC_DXT1_Format
    if (GLC.RGBA == gpuFormat) return THREE.RGBAFormat

    if (GLC.COMPRESSED_RGBA8_ETC2_EAC == gpuFormat)
        return THREE.RGBA_ETC2_EAC_Format;

    if (GLC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG == gpuFormat)
        return THREE.RGBA_PVRTC_4BPPV1_Format;

    if (GLC.COMPRESSED_RGBA_S3TC_DXT5_EXT == gpuFormat)
        return THREE.RGBA_S3TC_DXT5_Format;

    if (GLC.COMPRESSED_RGB_ETC1_WEBGL == gpuFormat)
        return THREE.RGB_ETC1_Format;

    if (GLC.COMPRESSED_RGB8_ETC2 == gpuFormat)
        return THREE.RGB_ETC2_Format;
    
    if (GLC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG == gpuFormat)
        return THREE.RGB_PVRTC_4BPPV1_Format;
    
    if (GLC.COMPRESSED_RGB_S3TC_DXT1_EXT == gpuFormat)
        return THREE.RGB_S3TC_DXT1_Format;

	// RGBA_ASTC_4x4_Format,
	// RGBA_BPTC_Format,
	// RGBA_ETC2_EAC_Format,1
	// RGBA_PVRTC_4BPPV1_Format, 1 
	// RGBA_S3TC_DXT5_Format, 1
	// RGB_ETC1_Format, 1
	// RGB_ETC2_Format, 1
	// RGB_PVRTC_4BPPV1_Format, 1
	// RGB_S3TC_DXT1_Format,

    return null;
}


function a(a, b, c, d, k) {
    a({wasmBinary: b}).then(function (a) {
        function b(a, b, e) {
            var f = 0 === Math.log2(b) % 1 && 0 === Math.log2(e) % 1;
            return d.dxtTextures ? a ? c.BC3 : c.BC1 : d.pvrtcTextures && b === e && f ? a ? c.PVRTC1_4_RGBA : c.PVRTC1_4_RGB : d.etc1Textures && !a ? c.ETC1 : d.astcTextures ? c.ASTC_4x4 : c.RGBA32
        }

        a.initializeBasis();
        k(function (c) {
            var d = new a.BasisFile(new self.Uint8Array(c));
            c = function (a) {
                d.close();
                d.delete();
                throw a;
            };
            var e = d.getHasAlpha(), f = d.getNumImages(), g = d.getNumLevels(0), k = d.getImageWidth(0, 0), h = d.getImageHeight(0,
                0);
            0 !== k && 0 !== h && 0 !== f && 0 !== g || c("Invalid .basis file");
            1 < f && c("Missing multiple images handling");
            f = b(e, k, h);
            k = f.formatIdx;
            d.startTranscoding() || c("startTranscoding failed");
            h = [];
            for (var l = 0; l < g; ++l) {
                var n = d.getImageWidth(0, l), p = d.getImageHeight(0, l), A = d.getImageTranscodedSizeInBytes(0, l, k);
                A = new self.Uint8Array(new self.ArrayBuffer(A));
                d.transcodeImage(A, 0, l, k, 0, e) || c(".transcodeImage failed");
                h.push({data: A, width: n, height: p})
            }
            d.close();
            d.delete();
            return {gpuFormat: f.gpuFormat, mipmaps: h}
        })
    })
}

function b(a) {
    var b =
        new window.SharedArrayBuffer(a.byteLength);
    (new Uint8Array(b)).set(new Uint8Array(a), 0);
    return b
}

function c(c, g, f, h) {
    function e() {
        if (0 < r.length)if (0 < q.length)q.shift().handleTexItem(r.shift()), e(); else if (l < h && !p) {
            l++;
            p = !0;
            var a = new window.Worker(n), b = function (a) {
                throw"Worker error @L" + a.lineno + ": " + a.message;
            };
            a.addEventListener("error", b);
            var c = function () {
                function d() {
                    0 < r.length ? (q.push(g), e()) : (l--, a.terminate())
                }

                a.removeEventListener("error", b);
                a.removeEventListener("message", c);
                p = !1;
                var f, g =
                {
                    handleTexItem: function (b) {
                        f = b;
                        a.postMessage(b.texBuffer, [b.texBuffer])
                    }
                };
                a.addEventListener("error", function (a) {
                    f.onError("Worker error @L" + a.lineno + ": " + a.message)
                });
                a.addEventListener("message", function (a) {
                    f.callback(a.data);
                    d()
                });
                d()
            };
            a.addEventListener("message", c);
            a.postMessage(m)
        }
    }

    if(JMT.DEBUG){
        c = 'http://localhost:63342/YunzhanV3_Engine/jmk/' + c
    }

    c = "\nself.importScripts(" + JSON.stringify(c) + ");\nconst initBasis = " + a.toString() + ";\nconst basisFormats = " + JSON.stringify(d) + ";\nconst detector = " + JSON.stringify({
            astcTextures: g.astcTextures, dxtTextures: g.dxtTextures,
            etc1Textures: g.etc1Textures, pvrtcTextures: g.pvrtcTextures
        }) + ";\n\nfunction initHandler(evt) {\n  self.removeEventListener('message', initHandler);\n\n  const wasmBinary = evt.data;\n  initBasis(BASIS, wasmBinary, basisFormats, detector, decodeTexBuffer => {\n    self.addEventListener('message', function(evt) {\n        const texBuffer = evt.data;\n        const texDatas = decodeTexBuffer(texBuffer);\n        // second argument to transfer ownership to the main thread\n        self.postMessage(texDatas, texDatas.mipmaps.map(t => t.data.buffer));\n    });\n    self.postMessage({}); // communicate end of init\n  });\n}\n\nself.addEventListener('message', initHandler);\n";
    var n = window.URL.createObjectURL(new window.Blob([c])), p = !1, l = 0, q = [], r = [], m = window.SharedArrayBuffer ? b(f) : f;
    return function (a, b, c) {
        r.push({texBuffer: a, onError: b, callback: c});
        e()
    }
}

var d = function () {
    function a(a, b) {
        return {formatIdx: a, gpuFormat: b}
    }

    return {
        ETC1: a(0, GLC.COMPRESSED_RGB_ETC1_WEBGL),
        BC1: a(2, GLC.COMPRESSED_RGB_S3TC_DXT1_EXT),
        BC3: a(3, GLC.COMPRESSED_RGBA_S3TC_DXT5_EXT),
        PVRTC1_4_RGB: a(8, GLC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG),
        PVRTC1_4_RGBA: a(9, GLC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG),
        ASTC_4x4: a(10, GLC.COMPRESSED_RGBA_ASTC_4x4_KHR),
        RGBA32: a(13, GLC.RGBA)
    }
}();
JMT.createBasisLoader = function (b) {
    if (!window.WebAssembly || !(b.pvrtcTextures || b.etc1Textures || b.dxtTextures || b.astcTextures))return null;
    var e = function () {
        var e = !1, g = null, k = [];
        return function (f) {
            var h = function () {
                return f(g)
            };
            g ? h() : k.push(h);
            if (!e) {
                e = !0

                JMT.ajaxGet(
                    (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.getViewerAssetUrl)("lib/basis/basis_transcoder.wasm"),
                    !0,
                    function (e) {

                        var f = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.getViewerAssetUrl)("lib/basis/basis_transcoder.js")

                        var h = b.BASIS_DECODE_WORKERS;

                        if (0 >= h) {

                            var m = window.document.createElement("script");

                            m.addEventListener("load", function x() {

                                m.removeEventListener("load", x);

                                a(window.BASIS, e, d, b, function (a) {

                                    g = function (b, c, d) {

                                        try {

                                            d(a(b))

                                        }
                                        catch (A) {

                                            c(A)

                                        }
                                    };

                                    k.forEach(function (a) {

                                        return a()

                                    });

                                    k.length = 0
                                })
                            });

                            m.src = f;

                            window.document.head.appendChild(m)

                        }
                        else {
                            g = c(f, b, e, h)

                            k.forEach(function (a) {

                                return a()

                            })

                            k.length = 0
                        }
                    }, function (a) {

                        throw a;

                    }
                )
            }
        }
    }();

    return {
        load: function (a, b, c, d) {
            var f = (JMT.j3dCompressedTexture != undefined ) ?
                new JMT.j3dCompressedTexture() : new JMT.CompressedTexture();
            e(function (e) {
                JMT.queueAjaxGet(a, b, !0, function (a) {
                    e(a, d, function (a) {
                        f.format = a.gpuFormat;
                        if (JMT.j3dCompressedTexture != undefined )
                            f.format = gpuFromat2ThreeFormat(f.format)
                        a = a.mipmaps;
                        f.mipmaps = a;
                        f.width = a[0].width;
                        f.height = a[0].height;
                        f.generateMipmaps = !1;
                        if (JMT.j3dCompressedTexture != undefined )
                            f.minFilter = 1 === a.length ? THREE.LinearFilter : THREE.LinearMipmapLinearFilter;
                        else 
                            f.minFilter = 1 === a.length ? GLC.LINEAR : GLC.LINEAR_MIPMAP_LINEAR;
                        f.flipY = !1;
                        f.needsUpdate = !0;
                        c(f)
                    })
                }, d)
            });
            return f
        }
    }
}

/***/ }),

/***/ "./src/materials/AabbQueryMaterial.js":
/*!********************************************!*\
  !*** ./src/materials/AabbQueryMaterial.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseMaterial.js */ "./src/materials/BaseMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */


var a = JMT.getShader("aabb_query_vertex.glsl")
var b = JMT.getShader("aabb_query_fragment.glsl");


class AabbQueryMaterial  extends JMT.BaseMaterial{
    constructor(){
        super(a, b)
        this.side = THREE.DoubleSide;
        this.uniforms = {axis: {type: "i", value: 0}}
    }
}

Object.defineProperty(AabbQueryMaterial.prototype, "axis", {
    get: function () {
        return this.uniforms.axis.value
    }, set: function (a) {
        console.assert(0 === a || 1 === a || 2 === a);
        this.uniforms.axis.value = a
    }
})

JMT.AabbQueryMaterial = AabbQueryMaterial

/***/ }),

/***/ "./src/materials/BaseMaterial.js":
/*!***************************************!*\
  !*** ./src/materials/BaseMaterial.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderers/shaders/SHADERS.js */ "./src/renderers/shaders/SHADERS.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */

//import {$jscomp} from '../../src_new/lib/jscomp.js'

var a = 0, b = [0, 0], c = Object.freeze({
    uv: b,
    uv2: b,
    uv2Mod: [0, 0, 1 / 65535, 1 / 65535],
    t0: [1, 0, 0, 0],
    t1: [0, 1, 0, 0],
    t2: [0, 0, 1, 0]
})

var d = Object.freeze("position sphericalNormal uv uv2 uv2Mod t0 t1 t2 skinIndex skinWeight".split(" "))

var e = new JMT.InlineShader("");

class BaseMaterial extends THREE.EventDispatcher {
    constructor(vertexShader, fragmentShader, h) {
        super()

        h = void 0 === h ? e : h;
        a += 1;
        Object.defineProperty(this, "id", {value: a});
        this.name = "";
        this.side = THREE.FrontSide;
        this.doNotOverrideSide = !1;
        this.opacity = 1;
        this.transparent = !1;
        this.transparentRenderOrder = 0;
        this.blending = THREE.NoBlending;
        this.blendSrc = GLC.SRC_ALPHA;
        this.blendDst = GLC.ONE_MINUS_SRC_ALPHA;
        this.blendEquation = GLC.FUNC_ADD;
        this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null;
        this.colorWrite = this.depthWrite = this.depthTest = !0;
        this._hideFromLightProbes = !1;
        this._defines = new Set;
        this._definesString = null;
        this._textureLodExtension = this._standardDerivativesExtension = !1;
        this.uniforms = {};
        this.attributes = d;
        this._vertexShaderBody = vertexShader;
        this._fragmentShaderBody = fragmentShader;
        this._fragmentShaderHooks = h;
        this.defaultAttributeValues = c;
        this.index0AttributeName = void 0;
        this._programNeedsUpdate = this.visible = !0;
        this.program = null
    }

    get isPlaying() {
        return !1
    }

    update(a) {
    }
    play() {
        console.assert(!1)
    }
    pause() {
        console.assert(!1)
    }
    get hideFromLightProbes() {
     
        return this._hideFromLightProbes
    }
    set hideFromLightProbes(a) {
     
        this._hideFromLightProbes = a
    }
    get programNeedsUpdate() {
     
        return this._programNeedsUpdate
    }
    set programNeedsUpdate(a) {
     
        this._definesString = null;
     
        this._programNeedsUpdate = a
    }
    hasDefine(a) {
     
        return this._defines.has(a)
    }

    addDefine(a) {
     
        if (!this.hasDefine(a)) {
     
            this._defines.add(a)
     
            this.programNeedsUpdate = !0
     
        }
    }
    removeDefine(a) {
     
        if (this.hasDefine(a)) {
     
            this._defines.delete(a)
     
            this.programNeedsUpdate = !0
     
        }
    }
    condDefine(a, b) {
     
        a ? this.addDefine(b) : this.removeDefine(b);
     
        return a
    }
    _getDefinesString() {
     
        if (null === this._definesString) {
     
            for (var a = [], b = $jscomp.makeIterator(this._defines), c = b.next(); !c.done; c = b.next())a.push("#define " + c.value);
     
            a.sort();
     
            this._definesString = a.join("\n")
     
        }
     
        return this._definesString
    }
    generateProgramId() {
        return [this._fragmentShaderBody.id, this._fragmentShaderHooks.id, this._getDefinesString(), this._vertexShaderBody.id, this._standardDerivativesExtension ? "+" : "", this._textureLodExtension ? "+" : ""].join("$")
    }
    enableStandardDerivativesExtension() {
     
        this._standardDerivativesExtension || (this.programNeedsUpdate = this._standardDerivativesExtension = !0)
    }
    enableTextureLodExtension() {
     
        this._textureLodExtension || (this.programNeedsUpdate = this._textureLodExtension = !0)
    }
    generateVertexShader() {
     
        return [
     
            "precision highp float;",
     
            "precision highp int;",
     
            this._getDefinesString(),
     
            "uniform mat4 modelMatrix;",
     
            "uniform mat4 modelViewMatrix;",
     
            "uniform mat4 projectionMatrix;",
     
            "uniform mat4 viewMatrix;",
     
            "uniform mat3 normalMatrix;",
     
            "uniform vec3 cameraPosition;",
     
            "attribute vec3 position;",
     
            "attribute vec2 sphericalNormal;",
     
            "attribute vec2 uv;",
     
            "attribute vec2 uv2;",
     
            "attribute vec4 uv2Mod;",
     
            "attribute vec4 t0;",
     
            "attribute vec4 t1;",
     
            "attribute vec4 t2;",
     
            this.skinning ? "attribute vec4 skinIndex;\nattribute vec4 skinWeight;" : "",
     
            this._vertexShaderBody.code
     
        ].join("\n")
    }
    generateFragmentShader() {
     
        return [this._standardDerivativesExtension ? "#extension GL_OES_standard_derivatives : enable" : "", this._textureLodExtension ? "#extension GL_EXT_shader_texture_lod : require" : "", "precision " + JMT.DETECTOR.fragmentPrecision + " float;", "precision " + JMT.DETECTOR.fragmentPrecision + " int;", this._getDefinesString(), "uniform mat4 viewMatrix;\nuniform vec3 cameraPosition;", this._fragmentShaderBody.code, this._fragmentShaderHooks.code].join("\n")
    }
    
    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
    setUniform(a, b, c) {
     
        this.uniforms[a] = {type: b, value: c}
    }
    propertyFromUniform(a) {
     
        Object.defineProperty(this, a, {
     
            get() {
     
                return this.uniforms[a].value
     
            }, set(b) {
     
                this.uniforms[a].value = b
     
            }
     
        })
    }
    hash() {
     
        console.assert(!1, "hash not implemented")
    }
    canMerge(a) {
        console.assert(!1, "canMerge not implemented")
    }
}


JMT.BaseMaterial = BaseMaterial


/***/ }),

/***/ "./src/materials/GazePointerMaterial.js":
/*!**********************************************!*\
  !*** ./src/materials/GazePointerMaterial.js ***!
  \**********************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
var a = JMT.getShader("gaze_pointer_vertex.glsl")
var b = JMT.getShader("gaze_pointer_fragment.glsl");

class GazePointerMaterial extends JMT.BaseMaterial {
    constructor () {
        super(a, b)
    
        this.blending = THREE.NormalBlending;
        this.transparent = !0;
        this.transparentRenderOrder = 2;
        this.setUniform("circleSpan", "f", 0)
    }
};

Object.defineProperty(GazePointerMaterial.prototype,
    "circleSpan", {
        set: function (a) {
            console.assert(1 >= a);
            this.uniforms.circleSpan.value = 2 * Math.PI * a - Math.PI
        }
    })

JMT.GazePointerMaterial = GazePointerMaterial;

/***/ }),

/***/ "./src/materials/ObjectDistanceMaterial.js":
/*!*************************************************!*\
  !*** ./src/materials/ObjectDistanceMaterial.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _BaseMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BaseMaterial.js */ "./src/materials/BaseMaterial.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderers/shaders/SHADERS.js */ "./src/renderers/shaders/SHADERS.js");
/* harmony import */ var _renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_renderers_shaders_SHADERS_js__WEBPACK_IMPORTED_MODULE_1__);
/**
 * Created by Kai on 2020/12/18.
 */



var a = JMT.getShader("object_distance_vertex.glsl"), b = JMT.getShader("object_distance_float_fragment.glsl"), c = JMT.getShader("object_distance_byte_fragment.glsl");

class ObjectDistanceMaterial extends JMT.BaseMaterial {
    constructor(d) {
        super(a, d ? b : c)

        this.doNotOverrideSide = !0;
        this.uniforms = {objectId: {type: "i", value: null}}
    }

    refreshPerObjectUniforms(a, b) {
        b.objectId.value = a.visibilityId;
        return !0
    }
}

JMT.ObjectDistanceMaterial = ObjectDistanceMaterial

/***/ }),

/***/ "./src/materials/createBoundingBoxMaterial.js":
/*!****************************************************!*\
  !*** ./src/materials/createBoundingBoxMaterial.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extend_material_j3dWireframeMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extend/material/j3dWireframeMaterial.js */ "./src/extend/material/j3dWireframeMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */
//import './WireframeMaterial.js'


JMT.createBoundingBoxMaterial = function () {
    var a = new JMT.j3dWireframeMaterial(JMT.EDITOR_SELECTION_COLOR);
    a.depthTest = !0;
    a.depthWrite = !1;
    a.side = THREE.DoubleSide;
    a.hideFromLightProbes = !0;
    return a
}

/***/ }),

/***/ "./src/math/Euler.js":
/*!***************************!*\
  !*** ./src/math/Euler.js ***!
  \***************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
// JMT.Euler = function (a, b, c) {
//     THREE.Euler.call(this, b, c, a, "ZXY")
// };
//JMT.Euler.prototype = Object.create(THREE.Euler.prototype);
//JMT.Euler.prototype.constructor = JMT.Euler;
class Euler extends THREE.Euler{
    constructor(a, b, c) {
        super(b, c, a, "ZXY")
    }
}

JMT.Euler = Euler;

Object.defineProperty(JMT.Euler.prototype, "yaw", {
    get: function () {
        return this.z
    }, set: function (a) {
        this.z = a
    }
});
Object.defineProperty(JMT.Euler.prototype, "pitch", {
    get: function () {
        return this.x
    }, set: function (a) {
        this.x = a
    }
});
Object.defineProperty(JMT.Euler.prototype, "roll", {
    get: function () {
        return this.y
    }, set: function (a) {
        this.y = a
    }
});
Object.defineProperty(JMT.Euler.prototype, "yawDeg", {
    get: function () {
        return THREE.Math.radToDeg(this.yaw)
    }, set: function (a) {
        this.yaw = THREE.Math.degToRad(a)
    }
});
Object.defineProperty(JMT.Euler.prototype, "pitchDeg", {
    get: function () {
        return THREE.Math.radToDeg(this.pitch)
    }, set: function (a) {
        this.pitch = THREE.Math.degToRad(a)
    }
});
Object.defineProperty(JMT.Euler.prototype, "rollDeg", {
    get: function () {
        return THREE.Math.radToDeg(this.roll)
    }, set: function (a) {
        this.roll = THREE.Math.degToRad(a)
    }
});
JMT.Euler.prototype.setFromDegTriple = function (a) {
    var b = THREE.Math.degToRad(a[0]), c = THREE.Math.degToRad(a[1]);
    a = THREE.Math.degToRad(a[2]);
    this.set(c, a, b);
    return this
};
JMT.Euler.prototype.toDegTriple = function () {
    return [this.yawDeg, this.pitchDeg, this.rollDeg]
};
JMT.Euler.prototype.setFromDirection = function (a) {
    this.set(Math.asin(a.z), 0, Math.atan2(-a.x, a.y));
    return this
};
JMT.Euler.prototype.toQuaternion = function () {
    var a = new THREE.Quaternion;
    a.setFromEuler(this);
    return a
};
JMT.Euler.prototype.toRotationMatrix = function () {
    var a = new THREE.Matrix4;
    a.makeRotationFromEuler(this);
    return a
}

/***/ }),

/***/ "./src/math/Frustum.js":
/*!*****************************!*\
  !*** ./src/math/Frustum.js ***!
  \*****************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
var a = new THREE.Sphere;
JMT.Frustum = function () {
    this.planes = [new THREE.Plane, new THREE.Plane, new THREE.Plane, new THREE.Plane, new THREE.Plane, new THREE.Plane]
};
JMT.Frustum.prototype = {
    constructor: JMT.Frustum, setFromMatrix: function (a) {
        var b = this.planes, d = a.elements;
        a = d[0];
        var e = d[1], g = d[2], f = d[3], h = d[4], k = d[5], n = d[6], p = d[7], l = d[8], q = d[9], r = d[10], m = d[11], u = d[12], x = d[13], t = d[14];
        d = d[15];
        b[0].setComponents(f - a, p - h, m - l, d - u).normalize();
        b[1].setComponents(f + a, p + h, m + l, d + u).normalize();
        b[2].setComponents(f +
            e, p + k, m + q, d + x).normalize();
        b[3].setComponents(f - e, p - k, m - q, d - x).normalize();
        b[4].setComponents(f - g, p - n, m - r, d - t).normalize();
        b[5].setComponents(f + g, p + n, m + r, d + t).normalize();
        return this
    }, intersectsObject: function (b) {
        var c = b.geometry;
        null === c.boundingSphere && c.computeBoundingSphere();
        b.matrixWorld ? (a.copy(c.boundingSphere), a.applyMatrix4(b.matrixWorld), b = a) : b = c.boundingSphere;
        return this.intersectsSphere(b)
    }, nearPlaneDistanceToCenter: function (b) {
        var c = b.geometry, d = this.planes[5];
        b.matrixWorld ? (a.copy(c.boundingSphere),
            a.applyMatrix4(b.matrixWorld), b = a) : b = c.boundingSphere;
        return d.distanceToPoint(b.center)
    }, intersectsSphere: function (a) {
        var b = this.planes, d = a.center;
        a = -a.radius;
        for (var e = 0; 6 > e; e += 1)if (b[e].distanceToPoint(d) < a)return !1;
        return !0
    }, intersectsBox: function () {
        var a = new THREE.Vector3, c = new THREE.Vector3;
        return function (b) {
            for (var d = this.planes, g = 0; 6 > g; g += 1) {
                var f = d[g];
                a.x = 0 < f.normal.x ? b.min.x : b.max.x;
                c.x = 0 < f.normal.x ? b.max.x : b.min.x;
                a.y = 0 < f.normal.y ? b.min.y : b.max.y;
                c.y = 0 < f.normal.y ? b.max.y : b.min.y;
                a.z = 0 <
                f.normal.z ? b.min.z : b.max.z;
                c.z = 0 < f.normal.z ? b.max.z : b.min.z;
                var h = f.distanceToPoint(a);
                f = f.distanceToPoint(c);
                if (0 > h && 0 > f)return !1
            }
            return !0
        }
    }(), containsPoint: function (a) {
        for (var b = this.planes, d = 0; 6 > d; d += 1){
            if (0 > b[d].distanceToPoint(a)){
                return !1;
            }
        }
        return !0
    }
}

/***/ }),

/***/ "./src/math/Math.js":
/*!**************************!*\
  !*** ./src/math/Math.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JMTMath": function() { return /* binding */ JMTMath; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
/*
 Copyright (C) 2017-present M.K.
 */
var a = new THREE.Vector3;
const JMTMath = {
    toSnorm8: function (a) {
        return Math.round(127 * THREE.Math.clamp(a, -1, 1))
    }, minBytesToHold: function (a) {
        return 127 >= a ? 1 : 32767 >= a ? 2 : 4
    }, anyPositiveRootOfQuadraticEquation: function (a, c, d) {
        d = c * c - 4 * a * d;
        if (0 > d)return null;
        d = Math.sqrt(d);
        var b = (-c - d) / (2 * a);
        if (0 < b)return b;
        a = (-c + d) / (2 * a);
        return 0 < a ? a : null
    }, spheresUnion: function (b, c) {
        if (c.isEmpty())c.copy(b); else {
            var d = c.center.distanceTo(b.center);
            if (b.radius > c.radius) {
                var e = b;
                b = c
            } else e = c;
            var g = (e.radius + b.radius + d) /
                2;
            g <= e.radius ? c.copy(e) : (d = (g - e.radius) / d, console.assert(0 < d), a.copy(b.center).sub(e.center).multiplyScalar(d), c.center.copy(e.center).add(a), c.radius = g)
        }
    }
}

JMT.Math = JMTMath

/***/ }),

/***/ "./src/objects/Anchor.js":
/*!*******************************!*\
  !*** ./src/objects/Anchor.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _extend_material_j3dAnchorMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../extend/material/j3dAnchorMaterial.js */ "./src/extend/material/j3dAnchorMaterial.js");
/* harmony import */ var _ui_Icons_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../ui/Icons.js */ "./ui/Icons.js");
/* harmony import */ var _ui_Icons_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_ui_Icons_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _textures_Texture_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../textures/Texture.js */ "./src/textures/Texture.js");
/* harmony import */ var _extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../extend/texture/j3dGIFTexture.js */ "./src/extend/texture/j3dGIFTexture.js");
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */




//import {GIFLoader, GIFTexture} from '../textures/GIFTexture.js'





function getAutoFontSize(canvas, text, fontFamily, margin) {

    var e = JMT.SPRITE_ANCHOR_FONT_SIZE

    var f = canvas.getContext("2d");

    f.font = "700 " + e + "px " + fontFamily;

    var g = text

    for (var k = text.length - 1, h; ;) {

        h = f.measureText(g).width;

        h += 2 * margin;

        if (1024 >= h) {
            break;
        }

        g = text.substring(0, k);

        --k
    }

    return h
}

function fillText(config, canvas, context, w, h) {


    let text = config.text

    let autoSize = !config.noAutoFontSize

    if (autoSize) {

        let fontSize = config.fontSize || 60

        let fontFamily = config.fontFamily || "Noto Sans";

        let textMargin = config.textMargin || 20;


        if (!!config.image) {
            fontSize = 60
        }
        else {
            fontSize = getAutoFontSize(canvas, text, fontFamily, textMargin)
        }

        context.font = '700 ' + fontSize + 'px ' + fontFamily;
    }

    context.fillStyle = config.color || "#4c9ed9";

    context.textAlign = config.textAlign || "center";

    context.textBaseline = config.textBaseline || "middle";

    context.shadowColor = config.shadowColor || "black";

    context.shadowBlur = config.shadowBlur || 16;

    let offsetH = config.offsetH || 0;

    w = undefined !== w ? w : canvas.width
    h = undefined !== h ? h : canvas.height

    context.fillText(text, w / 2, h / 2 + offsetH);
}

function drawImage(config, texture, canvas, context) {

    let w = canvas.width,
        h = canvas.height,
        oy = 0


    // 重新计算画布宽度
    let autoSize = !config.noAutoFontSize

    if (autoSize && config.showTitle) {

        let textMargin = config.textMargin || 10;

        oy = 60 + textMargin * 2

        let text = config.text

        // 重新计算画布高度
        //canvas.height += oy

        config._offsetH = -canvas.height / 2 + 30

        let fontSize = config.fontSize || 60

        let fontFamily = config.fontFamily || "Noto Sans";

        if (!!config.image) {
            fontSize = 60
        }
        else {
            fontSize = getAutoFontSize(canvas, text, fontFamily, textMargin)
        }
        config._fontSize = fontSize

        context.font = "700 " + fontSize + "px " + fontFamily


        let textWidth = Math.ceil(context.measureText(text).width)

        w = Math.max(textWidth, canvas.width)

        canvas.width = w
    }

    let destImageSize = h - oy

    if (config.isGIF) {
        // TODO: GIF图标

        (0,_extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_3__.j3dGIFLoader)(config.image, gif=> {

            canvas.width = Math.max(canvas.width, gif.canvas.width)
            let textMargin = config.textMargin || 0
            canvas.height = Math.max(canvas.height, gif.canvas.height + oy + textMargin)

            texture.image = canvas
            texture.gif = gif
            texture.update(0)

            config.onImageLoaded && config.onImageLoaded(canvas)

            JMT.ALWAYS_RENDER = true

        })
    }
    else {
        // 普通图片图标
        let image = new Image()
        image.crossOrigin = 'anonymous';

        image.onload = ()=> {

            canvas.width = Math.max(canvas.width, image.width)
            let textMargin = config.textMargin || 0
            canvas.height = Math.max(canvas.height, image.height + oy + textMargin)

            texture.image = canvas

            let ix = (canvas.width - image.width) / 2,
                iy = oy
            // 画Icon
            context.drawImage(image, 0, 0, image.width, image.height, ix, iy, image.width, image.height);

            if (config.showTitle) {

                fillText(config, canvas, context, canvas.width, -config.offsetH * 2 + oy)
            }

            texture.needsUpdate = !0;

            config.onImageLoaded && config.onImageLoaded(
                canvas,
                [(ix + image.width / 2) / canvas.width, (iy + config.offsetH * 2 + image.height / 2) / canvas.height],
                [canvas.width / image.width, canvas.height / image.height]
            )

            image.onload = null

            //let u = canvas.toDataURL("image/jpeg", 1)
            //console.log(u);
        }

        image.src = config.image
    }
}

function resolveCanvas(config) {

    var d = config.icon && JMT.ICONS[config.icon]

    var e = d ? d.value : (config.text || config.title || 'NONAME')

    var f = d ? d.fontFamily : "Noto Sans";

    var g = config.color || "#4c9ed9";

    var h = config.opacity;

    if (!(void 0 === h || 1 <= h)) {
        k.setStyle(g)
        g = "rgba(" + (255 * k.r | 0) + "," + (255 * k.g | 0) + "," + (255 * k.b | 0) + "," + h + ")"
    }

    var p = g;

    h = config.color || "#ffffff";

    g = void 0 !== config.opacity && 1 > config.opacity;

    var t = "sphere" === config.style
    var v = t || void 0 === config.textMargin ? 20 : config.textMargin;

    if(!config.isTag){
        d = [d || "", e, f, p, t, v, config.borderRadius || 0, g].join("_");

        var w = n.get(d);

        if (w) {
            w.usedTimes++
            return [d, w.texture];

        }
    }

    var canvas = document.getElementById("anchor-canvas");

    if (!canvas) {
        canvas = document.createElement("canvas")
        canvas.id = "anchor-canvas"
    }

    canvas.width = 2
    canvas.height = 2

    var texture = config.isGIF ? new AnchorGIFTexture(canvas, config) : new JMT.j3dTexture(canvas);
    texture.hasAlpha = true

    let context = canvas.getContext("2d")

    if (t) {
        t = canvas

        v = e

        t.width = 512

        t.height = 512

        context.clearRect(0, 0, canvas.width, canvas.height);

        context.font = "700 128px " + f

        v = context.measureText(v).width

        v = Math.floor(c / v * 128)

        v = Math.min(v, c)

        context.font = "700 " + v + "px " + f

        f = context
    }

    context.fillStyle = p;

    if (config.image) {
        drawImage(config, texture, canvas, context)
    }
    else {
        if (config.borderRadius) {

            p = context

            t = canvas.width

            v = canvas.height

            var b = .5 * config.borderRadius * Math.min(t, v)

            p.beginPath()

            p.moveTo(0 + b, 0)

            p.lineTo(0 + t - b, 0)

            p.quadraticCurveTo(0 + t, 0, 0 + t, 0 + b)

            p.lineTo(0 + t, 0 + v - b)

            p.quadraticCurveTo(0 + t, 0 + v, 0 + t - b, 0 + v)

            p.lineTo(0 + b, 0 + v)

            p.quadraticCurveTo(0, 0 + v, 0, 0 + v - b)

            p.lineTo(0, 0 + b)

            p.quadraticCurveTo(0, 0, 0 + b, 0)

            p.closePath()

            p.fill()
        }

        if (config.showTitle) {

            e = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_4__.resolveText)(canvas, e, f, v)

            context = e[0]

            e = e[1]

            //context = e.next().value
            //
            //e = e.next().value

            config.noAutoFontSize = !0

            fillText(config, canvas, context)
        }
    }

    texture.width = canvas.width;

    texture.height = canvas.height;

    texture.hasAlpha = true //g;

    //texture.minFilter = GLC.LINEAR;
    texture.minFilter = THREE.LinearFilter

    texture.loaded = !0;

    texture.needsUpdate = !0;

    if(!config.isTag) {
        // tag 不缓存
        n.set(d, {usedTimes: 1, texture: texture});
    }

    return [d, texture]
}

var c = 512 - 2 * Math.floor(512 * (.5 - .5 * Math.sin(70 / 180 * Math.PI / 2)))

var d = null

var e
var g
var f = null
var h
var k = new THREE.Color
var n = new Map;

//JMT.Anchor = function (scene, config) {
class Anchor extends THREE.Mesh {

    constructor(scene, config) {
        
        if (!(d && f === scene.id)) {

            d = new THREE.SphereBufferGeometry(1, 32, 16)

            d.convertNormalsToSpherical()

            e = new THREE.PlaneBufferGeometry(1, 1)

            e.convertNormalsToSpherical()

            g = new THREE.CylinderBufferGeometry(.5, .5, 1, 16, 1)

            if (!h) {

                h = new THREE.Matrix4

                h.makeRotationX(Math.PI / 2)
            }

            g.applyMatrix4(h)

            g.convertNormalsToSpherical()

            f = scene.id
        }

        var k = new THREE.Vector3;

        k.fromArray(config.position);

        function resize(canvas, center, scale) {

            if (canvas) {

                let image = canvas //l.image || texture.image

                config.height || (config.height = .1)

                p = [config.height * image.width / image.height, config.height, config.height];

                mesh.scale.fromArray(p);

                mesh.updateMatrixWorld(!0);

                l.image || (l.image = image)
            }

            mesh.dispatchEvent({type: 'centerChanged', center: center, scale: scale})
        }

        var l = $jscomp.makeIterator(resolveCanvas(config))

        config.onImageLoaded = resize

        var m = l.next().value;

        l = l.next().value;


        if ("sphere" === config.type) {

            m = d;

            var n = new JMT.j3dAnchorMaterial;

            var p = null;

            var t = Infinity;

            var a = $jscomp.makeIterator(scene.lightProbes);

            for (var v = a.next(); !v.done; v = a.next()) {

                v = v.value;

                var w = k.distanceTo(v.position);

                if (w < t) {

                    t = w

                    p = v
                }
            }

            t = p;

            n.bumpTexture = l;

            n.disableLightProbe = null === t || !t.texturesReady();

            n.headLight = !0;

            p = [config.radius, config.radius, config.radius]

        }
        else {

            m = e;

            n = new JMT.j3dAnchorSpriteMaterial;

            t = null;

            n.disableLightProbe = !0;

            n.headLight = !1;

            n.specularOff = 1;

            let height = config.height

            p = [height * l.width / l.height, height, height];

            var z = new THREE.Mesh(g, null)
        }


        n.baseColorTexture = l;

        n.configureTransparency();

        n.setUniforms();

        //THREE.Mesh.call(this, m, n);
        super(m, n);
        this.config = config
        this._textureSignature = m;

        let mesh = this

        mesh.position.copy(k);

        if(l.loaded){

            l.image && resize(l.image)

        }
        else {

            l.addLoadedListener(resize)

        }

        mesh.lightProbe = t;

        if (z) {

            z.position.copy(k)

            k = Math.max(p[0], p[1])

            z.scale.fromArray([k, k, config.height])

            z.updateMatrixWorld(!0)

            this.colliderMesh = z
        }
        else {

            this.colliderMesh = this;

        }

        this.colliderMesh.visibilityId = null;

        this.colliderMesh.anchor = this;

        this.extension = null
    
    }
};

//JMT.Anchor.prototype = Object.create(THREE.Mesh.prototype);
JMT.Anchor = Anchor

JMT.Anchor.prototype.dispose = function () {

    var a = this.material;

    a.dispose();

    var b = this._textureSignature

    var c = n.get(b)

    if(c){

        var d = c.texture;

        console.assert(a.baseColorTexture === d);

        c.usedTimes--;

        if (0 === c.usedTimes) {

            d.dispose()

            n.delete(b)

        }
    }

};

JMT.Anchor.prototype.enableLightProbe = function () {

    if (this.lightProbe) {

        console.assert(this.lightProbe.texturesReady());

        var a = this.material;

        a.disableLightProbe = !1;

        a.setUniforms()
    }
}

JMT.Anchor.prototype._updateText = function (text) {

    let config = this.config

    config.text = config.title = text

    let newTexture = resolveCanvas(config)

    var b = this._textureSignature

    var c = n.get(b)

    var d = c.texture;

    var a = this.material;

    console.assert(a.baseColorTexture === d);

    c.usedTimes--;

    if (0 === c.usedTimes) {

        d.dispose()

        n.delete(b)

    }

    this._textureSignature = newTexture[0]

    a.baseColorTexture = newTexture[1];

    a.configureTransparency();

    a.setUniforms();
}


class AnchorGIFTexture extends _extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_3__.j3dGIFTexture {
    constructor(destImage, config, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(null, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

        this.image = destImage
        this.isAnimated = !0;
        this.releaseOnLoadedToGpu = !1;
        this._isPlaying = !0;

        this.frame = -1;
        this.loaded = false;
        this.length = 1;
        this.time = 0;

        this.gif = undefined
        this.config = config
        this.isAnimate = true;

    }

    _updateCanvas(delayTime) {
        let lastFrame = this.frame;

        //更新gif图像
        //super._updateCanvas(delayTime);
        _extend_texture_j3dGIFTexture_js__WEBPACK_IMPORTED_MODULE_3__.j3dGIFTexture.prototype._updateCanvas.call( this, delayTime );

        //如果改变了，融合gif图像和文字
        if (lastFrame != this.frame) {
            let canvas = this.image
            let context = canvas.getContext('2d')
            let config = this.config

            let w = canvas.width,
                h = canvas.height,
                oy = 0

            // 重新计算画布宽度
            let autoSize = !config.noAutoFontSize

            if (autoSize && config.showTitle) {

                let textMargin = config.textMargin || 10;

                oy = 60 + textMargin * 2

                let text = config.text

                // 重新计算画布高度
                //canvas.height += oy

                config._offsetH = -canvas.height / 2 + 30

                let fontSize = config.fontSize || 60

                let fontFamily = config.fontFamily || "Noto Sans";

                if (!!config.image) {
                    fontSize = 60
                }
                else {
                    fontSize = getAutoFontSize(canvas, text, fontFamily, textMargin)
                }
                config._fontSize = fontSize

                context.font = "700 " + fontSize + "px " + fontFamily


                let textWidth = Math.ceil(context.measureText(text).width)

                w = Math.max(textWidth, canvas.width)

                canvas.width = w
            }

            let destImageSize = h - oy

            //         let ctx = this.gif.canvas.getContext('2d')
            //         let curFrameImg = this.gif.images[this.frame]
            //         ctx.putImageData(curFrameImg, curFrameImg.leftPos, curFrameImg.topPos);

            canvas.width = Math.max(canvas.width, this.gif.canvas.width)
            let textMargin = config.textMargin || 0
            canvas.height = Math.max(canvas.height, this.gif.canvas.height + oy + textMargin)

            let ix = (canvas.width - this.gif.canvas.width) / 2,
                iy = oy

            // 画Icon
            context.drawImage(this.gif.canvas, 0, 0, this.gif.canvas.width, this.gif.canvas.height, ix, iy, this.gif.canvas.width, this.gif.canvas.height);

            if (config.showTitle) {
                fillText(config, canvas, context, canvas.width, -config.offsetH * 2 + oy)
            }

            this.needsUpdate = !0;
            this.notifyLoaded()
        }
    }

}


/***/ }),

/***/ "./src/objects/Avatar.js":
/*!*******************************!*\
  !*** ./src/objects/Avatar.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _core_Geometry_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/Geometry.js */ "./src/core/Geometry.js");
/* harmony import */ var _Anchor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Anchor.js */ "./src/objects/Anchor.js");
/**
 * Created by Kai on 2020/12/18.
 */


var a = null, b = null, c = null, d = null;
JMT.Avatar = function (e, uuid, f) {
    THREE.Object3D.call(this);
    uuid && (this._uuid = uuid);
    this.displayName = f.displayName;
    if (!(b && a === e.id)) {
        c = new THREE.SphereBufferGeometry(.08, 32, 16)
        c.convertNormalsToSpherical()
        d = new THREE.TorusBufferGeometry(.03, -.011, 8, 6)
        d.convertNormalsToSpherical()
        b = new THREE.PlaneBufferGeometry(1, 1)
        b.convertNormalsToSpherical()
        a = e && e.id
    }
    var g = new JMT.StandardMaterial;
    g.baseColor.setStyle(f.color).convertGammaToLinear();
    g.disableLightProbe = !0;
    g.headLight = !0;
    g.setUniforms();
    this._body = new THREE.Object3D;
    this._head = new THREE.Mesh(c, g);
    this._head.rotation.order = "ZXY";
    var h = new THREE.Mesh(d, g);
    h.rotateX(Math.PI / 2);
    h.position.set(.05, .09, 0);
    var k = new THREE.Mesh(d, g);
    k.rotateX(Math.PI / 2);
    k.position.set(-.05, .09, 0);
    this._head.add(h);
    this._head.add(k);
    this._displayNameAnchor = new JMT.Anchor(e, {
        type: "sprite",
        position: [0, 0, .15],
        height: .1,
        text: f.displayName,
        textColor: f.color,
        opacity: 0
    });
    this._pointer = new THREE.Mesh(c, g);
    this._pointer.scale.set(.4, .4, .4);
    this._pointer.visible = !1;
    this._body.add(this._head);
    this.add(this._body);
    this.add(this._displayNameAnchor);
    this.add(this._pointer);
    f.position && this.position.fromArray(f.position);
    this.updateMatrixWorld(!0);
    this._videoTexture1 = this._videoTexture0 = this._videoScreenBack = this._videoScreen = null
};
JMT.Avatar.prototype = Object.create(THREE.Object3D.prototype);
JMT.Avatar.prototype.constructor = JMT.Avatar;
JMT.Avatar.prototype.hideBody = function () {
    this._head && (this._head.visible = !1)
    this._displayNameAnchor && (this._displayNameAnchor.visible = !1)
};
JMT.Avatar.prototype._updated = function () {
    this.dispatchEvent({type: "avatarUpdated", target: this})
};
JMT.Avatar.prototype.rotate = function (a, b) {
    this._body.rotation.z = a;
    this._head.rotation.x = b
};
JMT.Avatar.prototype._addVideoScreen = function () {
    if (!this._videoScreen) {
        var a = new JMT.StandardMaterial;
        this._videoScreen = new THREE.Mesh(b, a);
        this._videoScreen.rotateZ(Math.PI);
        this._videoScreen.rotateX(Math.PI / 2);
        this._videoScreen.position.set(0, 0, -.26);
        console.assert(!this._videoScreenBack);
        this._videoScreenBack = new THREE.Mesh(b, this.getMainMaterial());
        this._videoScreenBack.rotateZ(Math.PI);
        this._videoScreenBack.rotateX(-Math.PI / 2);
        this._videoScreenBack.position.set(0, 0, -.26);
        this._videoScreen.visible = !1;
        this._videoScreenBack.visible = !1;
        this._body.add(this._videoScreen);
        this._body.add(this._videoScreenBack)
    }
};
JMT.Avatar.prototype._removeVideoScreen = function () {
    this._videoScreen && (this._body.remove(this._videoScreen), this._body.remove(this._videoScreenBack), this._videoScreen.material.dispose(), this._videoScreenBack = this._videoScreen = null)
};
JMT.Avatar.prototype.setVideoTexture0 =
    function (a) {
        var b = this;
        this._videoTexture0 && (this._videoTexture0.dispose(), this._videoTexture0 = null, this._updated());
        null === a ? this._removeVideoScreen() : (this._addVideoScreen(), a.addLoadedListener(function () {
            b._videoScreen.material.baseColorTexture = a;
            var c = a.width / a.height;
            b._videoScreen.scale.set(.3 * c, .3, 1);
            b._videoScreenBack.scale.set(.3 * c, .3, 1);
            b._videoScreen.visible = !0;
            b._videoScreenBack.visible = !0;
            b.updateMatrixWorld(!0);
            b._videoTexture0 = a;
            b._updated()
        }))
    };
JMT.Avatar.prototype.getVideoTexture0 =
    function () {
        return this._videoTexture0
    };
JMT.Avatar.prototype.setVideoTexture1 = function (a) {
    var b = this;
    this._videoTexture1 && (this._videoTexture1.dispose(), this._videoTexture1 = null, this._updated());
    a && a.addLoadedListener(function () {
        b._videoTexture1 = a;
        b._updated()
    })
};
JMT.Avatar.prototype.getVideoTexture1 = function () {
    return this._videoTexture1
};
JMT.Avatar.prototype.getMainMaterial = function () {
    return this._head.material
};
JMT.Avatar.prototype.placePointer = function (a, b, c) {
    this._pointer.position.set(a - this.position.x,
        b - this.position.y, c - this.position.z);
    this._pointer.visible = !0
};
JMT.Avatar.prototype.hidePointer = function () {
    this._pointer.visible = !1
};
JMT.Avatar.prototype.dispose = function () {
    this._head.material.dispose();
    this._videoTexture0 && this._videoTexture0.dispose();
    this._videoTexture1 && this._videoTexture1.dispose();
    this._videoScreen && this._videoScreen.material.dispose();
    this._displayNameAnchor.dispose();
    this.dispatchEvent({type: "dispose"})
};
JMT.Avatar.prototype.enableLightProbe = function () {
}

/***/ }),

/***/ "./src/objects/GazePointer.js":
/*!************************************!*\
  !*** ./src/objects/GazePointer.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GazePointer": function() { return /* binding */ GazePointer; }
/* harmony export */ });
/* harmony import */ var _materials_GazePointerMaterial_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../materials/GazePointerMaterial.js */ "./src/materials/GazePointerMaterial.js");
/* harmony import */ var _materials_GazePointerMaterial_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_materials_GazePointerMaterial_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */


function createGeometry() { // a
    var a = new THREE.BufferGeometry
    var b = new Float32Array(18);
    a.addAttribute("position", new THREE.BufferAttribute(b, 3));
    b[0] = .05;
    b[1] = -.05;
    b[2] = -2;
    b[3] = .05;
    b[4] = .05;
    b[5] = -2;
    b[6] = -.05;
    b[7] = -.05;
    b[8] = -2;
    b[9] = .05;
    b[10] = .05;
    b[11] = -2;
    b[12] = -.05;
    b[13] = .05;
    b[14] = -2;
    b[15] = -.05;
    b[16] = -.05;
    b[17] = -2;
    a.computeBoundingSphere();
    return a
}

console.assert(JMT.GAZE_POINTER_SHOW_LOADING_AFTER_S <= JMT.GAZE_POINTER_ACTIVATE_AFTER_S);

var b = Math.PI / 60;

// scene, controls, onrequestFrame, this.gazeModeObserver
function GazePointer(c, d, e, g) {
    function f() {
        k = n = null;
        p = 0;
        l = !1;
        q && q.setCircleSpan(0)
    }

    var h = g.modeIsEnabled(), k, n, p, l, q = null, r = null, m = null;
    this.setGazeHandlers = function (a, b) {
        r = a;
        m = b
    };
    var u = function () {
        if (!h) {
            f();
        }
        else if (!q) {
            var b = new JMT.GazePointerMaterial
            var g = new THREE.Mesh(createGeometry(), b);
            c.addAuxiliaryObject(g);
            g.frustumCulled = !1;
            g.matrixWorld = d.camera().matrixWorld;
            q = {
                setVisible: function (a) {
                    g.visible = a;
                    e()
                }, setCircleSpan: function (a) {
                    b.circleSpan = a;
                    e()
                }
            };
            f()
        }
        q && q.setVisible(h)
    };
    g.addEventListener("modeDisabled", function () {
        h = !1;
        u()
    });
    g.addEventListener("modeEnabled", function () {
        h = !0;
        u()
    });
    this.reset = function () {
        null !== k && f()
    };
    this.update = function (a) {
        if (h) {
            var c = d.getPitchAngle()
            var e = d.getYawAngle();
            if (null === k) {
                k = c
                n = e
            }
            else if (Math.abs(k - c) > b || Math.abs(n - e) > b) {
                f()
            }
            else {
                p += a
                if (p >= JMT.GAZE_POINTER_SHOW_LOADING_AFTER_S) {
                    if (l) {
                        q.setCircleSpan(Math.min((p - JMT.GAZE_POINTER_SHOW_LOADING_AFTER_S) / (JMT.GAZE_POINTER_ACTIVATE_AFTER_S - JMT.GAZE_POINTER_SHOW_LOADING_AFTER_S), 1))

                        if (p >= JMT.GAZE_POINTER_ACTIVATE_AFTER_S) {
                            m && m()
                            f()
                        }
                    }
                    else if (r && r()) {
                        l = !0
                    }
                    else {
                        f()
                    }
                }
            }
        }
    };
    u()
}

/***/ }),

/***/ "./src/objects/MergedMesh.js":
/*!***********************************!*\
  !*** ./src/objects/MergedMesh.js ***!
  \***********************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

class Mesh extends THREE.Mesh {
    constructor(node, geometry, material) {
        super(geometry, material);

        this.type = 'JMT.Mesh';

        this._visible = !0;
        this.node = node;
        this.useFaces16 = !1;
        this.quantUv0Max = this.quantUv0Range = this.quantVertexMax = this.quantVertexRange = this.transformByteOffset = this.uv1CoordVOffset = this.uv1CoordUOffset = this.uv1CoordVScale = this.uv1CoordUScale = this.lightMapIdx = this.uv1ByteOffset = this.uv0ByteOffset = this.normalByteOffset = this.vertexCnt = this.vertexByteOffset = this.faceCnt = this.faceByteOffset = 0;
        this.lightMap = null;
        this.autoLightmapResolution = -1;
        this.lightProbe = null;
        this.matrixAutoUpdate = this.rotationAutoUpdate = !1;
        this.selected = this.highlightMix = null;
        this.selectedSecondary = !1;
        this.visibilityId = null;
        this.cameraDistance = 0;
        if (!this.isMesh) {
            this.matrix = this.matrixWorld = null;
        }
        else {
            this.matrix.identity();
            this.matrixWorld.identity();
        }
        this.sharedBuffersDebug = 0;
        this._mergedMesh = null
    }
};

JMT.Mesh = Mesh;
JMT.Mesh.prototype.clone = void 0;
JMT.Mesh.prototype.updateMatrixWorld = function () {
};
JMT.Mesh.prototype.uv0InBuffers = function () {
    return -1 !== this.uv0ByteOffset
};
JMT.Mesh.prototype.uv1InBuffers = function () {
    return -1 !== this.uv1ByteOffset
};
JMT.Mesh.prototype.quantVertexFactor = function () {
    return this.quantVertexRange / this.quantVertexMax
};
JMT.Mesh.prototype.quantUv0Disabled = function () {
    return 0 === this.quantUv0Max
};
JMT.Mesh.prototype.quantUv0Factor = function () {
    return this.quantUv0Range / this.quantUv0Max
};
JMT.Mesh.prototype.update = function (a, b) {
    this.node.faceCamera && (this.matrixWorld = this.node.getFaceCameraMatrix(b))
};
Object.defineProperty(JMT.Mesh.prototype, "hideInViews", {
    get: function () {
        return this.node.hideInViews
    }, set: function (a) {
        console.assert(!1)
    }
});
Object.defineProperty(JMT.Mesh.prototype, "visible", {
    get: function () {
        return this._visible
    }, set: function (a) {
        if(a !== this._visible){
            this._visible = a
            if(this._mergedMesh && !JMT.EDIT_MODE){
                this._mergedMesh.visible = a
            }
        }
    }
});
Object.defineProperty(JMT.Mesh.prototype, "isAnimated", {
    get: function () {
        return null !== this.node.faceCamera
    }
});

class MergedMesh extends THREE.Mesh {
    constructor (geometry, material) {
        super(geometry, material)

        this.type = 'JMT.MergedMesh';

        this._visible = !0;
        this.anyLogicalMeshHasUvs = !1;
        this.lightProbe = this.lightMap = null;
        this.matrixAutoUpdate = this.rotationAutoUpdate = !1;
        this.hideInViews = null;
        this.matrixAutoUpdate = this.rotationAutoUpdate = !1;
        this.center = null;
        this.cameraDistance = 0;
        if (!this.isMesh) {
            this.matrix = this.matrixWorld = null;
        }
        else {
            this.matrix.identity();
            this.matrixWorld.identity();
        }
        this.logicalMeshes = []

        Object.defineProperty(this, "visible", {
            get: function () {
                return this._visible
            },

            set: function (a) {
                if (a !== this._visible) {
                    this._visible = a;
                    for (var b = 0; b < this.logicalMeshes.length; b += 1){
                        this.logicalMeshes[b]._visible = a
                    }
                }
            }
        });
    }

};

JMT.MergedMesh = MergedMesh;

JMT.MergedMesh.prototype.clone = void 0;
JMT.MergedMesh.prototype.updateMatrixWorld = function () {
};
JMT.MergedMesh.prototype.addLogicalMesh = function (a) {
    this.logicalMeshes.push(a);
    a._mergedMesh = this
};

Object.defineProperty(JMT.MergedMesh.prototype, "isAnimated", {
    get: function () {
        return !1
    }
})

// Object.defineProperty(THREE.Object3D.prototype, 'uuid', {
//     get: function () {
//         if (!this._uuid) {
//             this._uuid = JMT.genUUID()
//         }
//         return this._uuid
//     }
// })

/***/ }),

/***/ "./src/objects/MeshMaker.js":
/*!**********************************!*\
  !*** ./src/objects/MeshMaker.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MeshMaker": function() { return /* binding */ MeshMaker; }
/* harmony export */ });
/* harmony import */ var _math_Math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Math.js */ "./src/math/Math.js");
/* harmony import */ var _core_Geometry_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/Geometry.js */ "./src/core/Geometry.js");
/**
 * Created by Kai on 2020/12/18.
 */
//import {$jscomp} from '../../src_new/lib/jscomp.js'


//import {DebugUtils} from '../../utils/debugUtil.js'

function parseMeshesBuffer(meshesBuf, boundsBuf, meshPropsArray) {
    var c = new Int32Array(meshesBuf);
    var a = new Float32Array(meshesBuf);
    var d = new Float32Array(boundsBuf)
    var meshesSet = {}, k = c[0], n = c[1], p = 2;
    var lightMapCount = 0
    for (;p < c.length;) {
        var curMeshInfo = {
            nodeId: c[p],
            materialIdx: c[p + 1],
            useFaces16: 1 === c[p + 2],
            faceByteOffset: c[p + 3],
            faceCnt: c[p + 4],
            vertexByteOffset: c[p + 5],
            vertexCnt: c[p + 6],
            normalByteOffset: c[p + 7],
            uv0ByteOffset: c[p + 8],
            uv1ByteOffset: c[p + 9],
            lightMapIdx: c[p + 10],
            uv1CoordUScale: a[p + 11],
            uv1CoordVScale: a[p + 12],
            uv1CoordUOffset: c[p + 13],
            uv1CoordVOffset: c[p + 14],
            transformByteOffset: c[p + 15],
            boundsByteOffset: c[p + 16],
            quantVertexRange: a[p + 17],
            quantVertexMax: c[p + 18],
            quantUv0Range: a[p + 19],
            quantUv0Max: c[p + 20],
            autoLightmapResolution: 2 <= k ? c[p + 21] : -1,
            useInstances: !1,
            hasCopies: !1,
            isMasterCopy: !1
        };
        curMeshInfo.boundingBox = new THREE.Box3;
        curMeshInfo.boundingSphere = new THREE.Sphere;
        a:{
            for (var q = curMeshInfo.boundingBox, r = curMeshInfo.boundingSphere, m = curMeshInfo.boundsByteOffset / 4, u = 0; 6 > u; ++u)
                if (!isFinite(d[m + u]))
                    break a;
            q.max.x = d[m];
            q.max.y = d[m + 1];
            q.max.z = d[m + 2];
            q.min.x = d[m + 3];
            q.min.y = d[m + 4];
            q.min.z = d[m + 5];
            //q.center(r.center);
            q.getCenter(r.center);
            r.radius = d[m + 6]
        }
        lightMapCount = Math.max(lightMapCount, curMeshInfo.lightMapIdx + 1);
        
        if (JMT.DETECTOR.instances) {
            q = curMeshInfo.vertexByteOffset
            //如果顶点数据相同 则geometry数据是共享的
            if (meshesSet.hasOwnProperty(q)) {
                q = meshesSet[q] 
                let sharedMesh = q[0]
                sharedMesh.isMasterCopy = !0
                sharedMesh.hasCopies = !0
                curMeshInfo.hasCopies = !0
                q.push(curMeshInfo)
            }
            else {
                meshesSet[q] = [curMeshInfo];
            }
        }
         
        meshPropsArray.push(curMeshInfo);
        p += n
    }

    //判断是否使用Instances
    var e = $jscomp.makeIterator(Object.values(meshesSet));
    for (c = e.next(); !c.done; c = e.next())
        if (c = c.value, a = c.length, 1 < a && 500 < a * c[0].faceCnt)
            for (c = $jscomp.makeIterator(c), a = c.next(); !a.done; a = c.next())
                a.value.useInstances = !0;
                
    return lightMapCount
}

var MeshRenderInfo = function (meshProp, material, lightMap, lightProbe, hideInViews) {
    this.meshPropsSet = new Set;
    this.meshPropsSet.add(meshProp);
    this.material = material;
    this.lightMap = lightMap;
    this.lightProbe = lightProbe;
    this.hideInViews = hideInViews;
    this.anyLogicalMeshHasUvs = -1 !== meshProp.uv0ByteOffset;
    this.sharedGeometryId = meshProp.useInstances ? meshProp.vertexByteOffset : null
};
MeshRenderInfo.prototype.canUseLightMap = function (a) {
    return null === this.lightMap || null === a || this.lightMap === a
};

function MeshMaker (scene, meshesBuf, boundsBuf, indexUint) {

    function generateMeshesInfo(lightMapArray) {
        var meshRenderInfoArray = []
        var mtlMeshMap = new Map;   //{material, [meshRenderInfos]}
        meshPropsArray.forEach(function (f) {
            var node = scene.findNode(f.nodeId)
            var material = scene.materials[f.materialIdx]
            var lightProbe = null;

            null !== node.initialLightProbeId && (lightProbe = scene.findLightProbe(node.initialLightProbeId));

            var lightMap = null;

            -1 !== f.lightMapIdx && (lightMap = lightMapArray[f.lightMapIdx]);

            var l = node.hideInViews || [];

            if (node.editable || 1 !== material.opacity) {
                meshRenderInfoArray.push(new MeshRenderInfo(f, material, lightMap, lightProbe, l));
            }
            else {

                var q = f.useInstances ? f.vertexByteOffset : null;

                var g = mtlMeshMap.get(material) || [];

                for (var n = $jscomp.makeIterator(g), r = n.next(); !r.done; r = n.next()) {

                    r = r.value;

                    var p;

                    if (p = r.lightProbe === h && r.canUseLightMap(lightMap) && r.sharedGeometryId === q) a:if (p = r.hideInViews, p.length !== l.length)p = !1; else {

                        for (var I = 0; I < p.length; I += 1) {

                            if (p[I] !== l[I]) {

                                p = !1;

                                break a

                            }
                        }

                        p = !0

                    }

                    if (p) {

                        null !== lightMap && (r.lightMap = lightMap);

                        r.anyLogicalMeshHasUvs = r.anyLogicalMeshHasUvs || -1 !== f.uv0ByteOffset;

                        r.meshPropsSet.add(f);

                        return
                    }
                }

                let meshRenderInfo = new MeshRenderInfo(f, material, lightMap, lightProbe, l);

                g.push(meshRenderInfo);

                mtlMeshMap.set(material, g);

                meshRenderInfoArray.push(meshRenderInfo)
            }
        });
        return meshRenderInfoArray
    }

    var h = this, meshPropsArray = [], n = meshesBuf.byteLength, p = 0;
    this.mergedMeshes = [];
    this.lightmapCount = this.geometryDownloadSize = this.coreGeometryDownloadSize = 0;
    this.createMeshes = function (lightMapArray) {
        var b = lightMapArray ? lightMapArray[0] : null;
        var meshRenderInfoArray = generateMeshesInfo(lightMapArray);
        var sharedGeometries = {};
        var d = $jscomp.makeIterator(meshRenderInfoArray);

        //test instances buffer
        if (undefined != THREE.InstancedBufferAttribute) {
            var t0 = new THREE.InstancedBufferAttribute(new Float32Array([1, 0, 0, 0]), 4);
            var t1 = new THREE.InstancedBufferAttribute(new Float32Array([0, 1, 0, 0]), 4);
            var t2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1, 0]), 4);

            //uv2Mod
            var uv = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
            var uv2 = new THREE.InstancedBufferAttribute(new Float32Array([0, 0]), 2);
            var uv2Mod = new THREE.InstancedBufferAttribute(new Float32Array([0, 0, 1 / 65535, 1 / 65535]), 4);
        }
        

        for (var e = d.next(); !e.done; e = d.next()) {
            var k = e.value;
            var geometry = k.sharedGeometryId;
            if (null !== geometry) {

                //共享几何信息
                var sharedGeom = sharedGeometries[geometry]

                var ownsGpuBuffers = false;
                //sharedGeom || (sharedGeom = new JMT.Geometry, l = !0, sharedGeometries[geometry] = sharedGeom);
                if (sharedGeom == undefined) {
                    sharedGeom = new JMT.Geometry
                    ownsGpuBuffers = true
                    sharedGeometries[geometry] = sharedGeom;

                    sharedGeom.sid = k.sharedGeometryId
                    sharedGeom.sc = 0
                }
                else {
                    //console.log("find shared geometry")
                    //测试 计数
                    sharedGeom.sc += 1
                }

                geometry = new JMT.InstancedGeometry(sharedGeom, ownsGpuBuffers)
                geometry.sharedGeometryId = k.sharedGeometryId
            }
            else {
                geometry = new JMT.Geometry;
            }

             //test
             if (undefined != THREE.InstancedBufferAttribute) {
                 
                geometry.setAttribute("t0", t0)
                geometry.setAttribute("t1", t1)
                geometry.setAttribute("t2", t2)

                geometry.setAttribute("uv", uv)
                geometry.setAttribute("uv2", uv2)
                geometry.setAttribute("uv2Mod", uv2Mod)
            }

            //浏览模式使用mergedMesh
            let mergedMesh = new JMT.MergedMesh(geometry, k.material);
            mergedMesh.lightProbe = k.lightProbe;
            mergedMesh.lightMap = k.lightMap || b;
            mergedMesh.hideInViews = k.hideInViews;
            mergedMesh.anyLogicalMeshHasUvs = k.anyLogicalMeshHasUvs;
            this.mergedMeshes.push(mergedMesh);

            //
            mergedMesh.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{
                //mergedMesh.material.lightMap = mergedMesh.lightMap
                //mergedMesh.material.lightMapped = true;
                //material.uniforms.lightMap.value = mergedMesh.lightMap
                material.refreshPerObjectUniforms(mergedMesh, material.uniforms)

                //强制刷新uniforms
                material.uniformsNeedUpdate = true
            }

            //编辑模式使用logicalMesh
            let prosIter = $jscomp.makeIterator(k.meshPropsSet);
            for (let itr = prosIter.next(); !itr.done; itr = prosIter.next()) {
                let l = itr.value;
                //var w = geometry;

                let indexCnt = indexUint ? (3 * l.faceCnt) : 0;
                let vertexCnt = indexUint ? l.vertexCnt : (3 * l.faceCnt);

                var indexOffset = 0, vertexOffset = 0;
                if (!geometry.isInstanced) {
                    indexOffset = geometry.indexCnt;
                    vertexOffset = geometry.vertexCnt;
                }
             
                let subGeometry = new JMT.SubGeometry(indexCnt, vertexCnt, geometry, indexOffset, vertexOffset, l.boundingBox, l.boundingSphere);
                geometry.boundingBox.union(l.boundingBox);
                JMT.Math.spheresUnion(l.boundingSphere, geometry.boundingSphere);
                //geometry.isInstanced ? (subGeometry.instanceId = w.instanceCount, w.instanceCount += 1, w.indexCnt = indexCnt, w.vertexCnt = vertexCnt) : (w.indexCnt += indexCnt, w.vertexCnt += vertexCnt);
                
                if (geometry.isInstanced) {
                    subGeometry.instanceId = geometry.instanceCount
                    geometry.instanceCount += 1
                    geometry.indexCnt = indexCnt
                    geometry.vertexCnt = vertexCnt
                }
                else {
                    geometry.indexCnt += indexCnt
                    geometry.vertexCnt += vertexCnt
                }
                
                let node = scene.findNode(l.nodeId);
                let mesh = new JMT.Mesh(node, subGeometry, mergedMesh.material);
                mesh.lightMap = mergedMesh.lightMap;
                mesh.lightProbe = mergedMesh.lightProbe;
                mesh.autoLightmapResolution = l.autoLightmapResolution;
                mesh.useFaces16 = l.useFaces16;
                mesh.faceByteOffset = l.faceByteOffset;
                mesh.faceCnt = l.faceCnt;
                mesh.vertexByteOffset = l.vertexByteOffset;
                mesh.vertexCnt = l.vertexCnt;
                mesh.normalByteOffset = l.normalByteOffset;
                mesh.uv0ByteOffset = l.uv0ByteOffset;
                mesh.uv1ByteOffset = l.uv1ByteOffset;
                mesh.lightMapIdx = l.lightMapIdx;
                mesh.uv1CoordUScale = l.uv1CoordUScale;
                mesh.uv1CoordVScale = l.uv1CoordVScale;
                mesh.uv1CoordUOffset = l.uv1CoordUOffset;
                mesh.uv1CoordVOffset = l.uv1CoordVOffset;
                mesh.transformByteOffset = l.transformByteOffset;
                mesh.quantVertexRange = l.quantVertexRange;
                mesh.quantVertexMax = l.quantVertexMax;
                mesh.quantUv0Range = l.quantUv0Range;
                mesh.quantUv0Max = l.quantUv0Max;
                l.hasCopies && (mesh.sharedBuffersDebug = l.isMasterCopy ? 1 : 2);
                p += 1;
                mergedMesh.addLogicalMesh(mesh);
                node.mesh = mesh
                mesh.name = node.config.name
                mergedMesh.name = node.config.name


                //martian 
                //set lightmap to uniform
                //if (mesh.lightMap &&  mesh.material.isJ3dStandardMaterial) 
                {

                    mesh.material.lightMap = mesh.lightMap
                    mesh.material.lightMapped = (mesh.lightMap &&  mesh.material.isJ3dStandardMaterial)?true:false;

                    //共享材质，但是光照贴图不同，这里暂时强制刷新
                    mesh.onBeforeRender = (renderer, scene, camera, geometry, material, group)=>{
                        //material.lightMap = mesh.lightMap
                        //material.lightMapped = true;
                        //material.uniforms.lightMap.value = mesh.lightMap
                        material.refreshPerObjectUniforms(mesh, material.uniforms)

                        //强制刷新uniforms
                        material.uniformsNeedUpdate = true
                    }
                }
            }
        }
        JMT.log("Have " + p + " meshes and " + this.mergedMeshes.length + " merged meshes.")
    };

    this.lightmapCount = parseMeshesBuffer(meshesBuf, boundsBuf, meshPropsArray);
    meshesBuf = boundsBuf = null;
    (function () {

        var a = 0, b = 0, c = 0, d = 0, e = 0, f = 0, g = 0
        var w

        for (var p = $jscomp.makeIterator(meshPropsArray), w = p.next(); !w.done; w = p.next()) {
            w = w.value;
            var z = w.vertexCnt;
            a = Math.max(a, w.faceByteOffset + 3 * w.faceCnt * (w.useFaces16 ? 2 : 4));
            b = Math.max(b, w.vertexByteOffset + 3 * z * JMT.Math.minBytesToHold(w.quantVertexMax) + 3 & -4);
            c = Math.max(c, w.normalByteOffset + 2 * z);
            d = Math.max(d, w.transformByteOffset + 64);
            e = Math.max(e, w.boundsByteOffset + 28);

            if(-1 !== w.uv0ByteOffset){
                f = Math.max(f, w.uv0ByteOffset + 2 * z * JMT.Math.minBytesToHold(w.quantVertexMax) + 3 & -4)
            }

            -1 !== w.uv1ByteOffset && (g = Math.max(g, w.uv1ByteOffset + 4 * z))
        }

        h.coreGeometryDownloadSize = n + a + b + c + d + e;

        h.geometryDownloadSize += h.coreGeometryDownloadSize + f + g

    })()
}

JMT.MeshMaker = MeshMaker

/***/ }),

/***/ "./src/objects/Node.js":
/*!*****************************!*\
  !*** ./src/objects/Node.js ***!
  \*****************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function a(a) {
    return null !== a && void 0 !== a
}

function b(a) {
    a.configure()
}

function c(a) {
    a.visitSubtree(b)
}

function d(a) {
    var b = new THREE.Vector3(Infinity, Infinity, Infinity), c = new THREE.Matrix4, d = new THREE.Matrix4, e = new THREE.Matrix4, n, p = new THREE.Vector3, l = new JMT.Euler;
    return function (f) {
        if (b.equals(f))return c;
        b.copy(f);
        if (!n) {
            n = new THREE.Vector3;
            var g = new THREE.Box3;
            a.visitSubtree(function (a) {
                (a = a.mesh) && g.union(a.geometry.boundingBox)
            });
            g.center(n);
            e.elements[12] = -n.x;
            e.elements[13] = -n.y;
            e.elements[14] = -n.z
        }
        p.copy(f).sub(n).normalize();
        l.setFromDirection(p);
        "yaw" === a.faceCamera && (l.pitch = 0);
        d.makeRotationFromEuler(l);
        c.identity().setPosition(n).multiply(d).multiply(e);
        return c
    }
}

JMT.NodeConfig = function (b) {
    var c = this;
    this.name = b.name;
    this._editable = b.editable || !1;
    this._setsDisableCollisions = a(b.disableCollisions);
    this._disableCollisions = b.disableCollisions || !1;
    this._setsHideInViews = a(b.hideInViews);
    this.hideInViews = null;
    if(b.hideInViews){
        this.hideInViews = b.hideInViews
        this.hideInViews.sort()
    }
    this._lightmapResolution = (this._setsLightmapResolution = a(b.lightmapResolution)) ? b.lightmapResolution : 75;
    this._ground = a(b.ground) ? b.ground : !1;
    this._faceCamera = b.faceCamera || null;
    this._isolateShadows = a(b.isolateShadows) ? b.isolateShadows : !1;
    this.nodes = [];
    var d = {type: "configUpdated", target: this};
    this._updated = function () {
        return c.dispatchEvent(d)
    }
};
//JMT.NodeConfig.prototype.constructor = JMT.NodeConfig;
//THREE.EventDispatcher.prototype.apply(JMT.NodeConfig.prototype);
JMT.NodeConfig.prototype = Object.create(THREE.EventDispatcher.prototype);
JMT.NodeConfig.prototype.constructor = JMT.NodeConfig;

JMT.NodeConfig.prototype._configUpdated = function () {
    this.nodes.forEach(c);
    this._updated()
};
JMT.NodeConfig.prototype.addNode = function (a) {
    this.nodes.push(a)
};
JMT.NodeConfig.prototype.isOnHideInViews = function (a) {
    return -1 !== this.hideInViews.indexOf(a)
};
JMT.NodeConfig.prototype.addToHideInViews = function (a) {
    console.assert(this.setsHideInViews);
    console.assert(!this.isOnHideInViews(a));
    this.hideInViews.push(a);
    this._updated()
};
JMT.NodeConfig.prototype.removeFromHideInViews = function (a) {
    if (this.hideInViews){
        for (var b = 0; b < this.hideInViews.length;){
            if(this.hideInViews[b] === a){
                this.hideInViews.splice(b, 1)
            }
            else {
                b += 1;
            }
        }
    }
    this._updated()
};
JMT.NodeConfig.prototype.serialize = function () {
    return {
        name: this.name,
        disableCollisions: this.setsDisableCollisions ? this.disableCollisions : null,
        hideInViews: this.setsHideInViews ? this.hideInViews : null,
        lightmapResolution: this.setsLightmapResolution ? this.lightmapResolution : null,
        ground: this.ground ? !0 : null,
        faceCamera: this.faceCamera,
        isolateShadows: this.isolateShadows ? !0 : null
    }
};
Object.defineProperty(JMT.NodeConfig.prototype, "setsDisableCollisions", {
    get: function () {
        return this._setsDisableCollisions
    },
    set: function (a) {
        this._setsDisableCollisions = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype, "disableCollisions", {
    get: function () {
        return this._disableCollisions
    }, set: function (a) {
        console.assert(this._setsDisableCollisions);
        this._disableCollisions = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype, "editable", {
    get: function () {
        return this._editable || null !== this.faceCamera
    }, set: function (a) {
        this._editable = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype,
    "ground", {
        get: function () {
            return this._ground
        }, set: function (a) {
            this._ground = a;
            this._configUpdated()
        }
    });
Object.defineProperty(JMT.NodeConfig.prototype, "faceCamera", {
    get: function () {
        return this._faceCamera
    }, set: function (a) {
        this._faceCamera = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype, "setsLightmapResolution", {
    get: function () {
        return this._setsLightmapResolution
    }, set: function (a) {
        this._setsLightmapResolution = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype,
    "lightmapResolution", {
        get: function () {
            return this._lightmapResolution
        }, set: function (a) {
            console.assert(this._setsLightmapResolution);
            this._lightmapResolution = a;
            this._configUpdated()
        }
    });
Object.defineProperty(JMT.NodeConfig.prototype, "isolateShadows", {
    get: function () {
        return this._isolateShadows
    }, set: function (a) {
        this._isolateShadows = a;
        this._configUpdated()
    }
});
Object.defineProperty(JMT.NodeConfig.prototype, "setsHideInViews", {
    get: function () {
        return this._setsHideInViews
    }, set: function (a) {
        this._setsHideInViews = a;
        null === this.hideInViews && (this.hideInViews = []);
        this._configUpdated()
    }
});
JMT.Node = function (a, b, c) {
    this.id = c.id;
    this.initialLightProbeId = void 0 === c.lightProbeId ? null : c.lightProbeId;
    this.parent = a;
    this.config = b;
    this.children = [];
    this.shadowsIsolatedWithin = this.lightmapResolution = this.hideInViews = this.getFaceCameraMatrix = this.faceCamera = this.ground = this.disableCollisions = this._facesCnt = this.mesh = null;
    this.editable = !1;
    b.addNode(this);
    this.configure()
};
JMT.Node.prototype.constructor = JMT.Node;
JMT.Node.prototype.configure = function () {
    this.ground = (this.disableCollisions = this.config.setsDisableCollisions ? this.config.disableCollisions : this.parent ? this.parent.disableCollisions : !1) ? !1 : this.config.ground;
    if (this.mesh){
        console.log(this.mesh.name, this.mesh.matrixWorld)
    }
    //this.config.faceCamera ? (this.faceCamera = this.config.faceCamera, this.getFaceCameraMatrix = d(this)) : (this.parent ? (this.faceCamera = this.parent.faceCamera, this.getFaceCameraMatrix = this.parent.getFaceCameraMatrix) : this.getFaceCameraMatrix = this.faceCamera = null, this.mesh && (this.mesh.matrixWorld = null));
    if (this.config.faceCamera) {
        this.faceCamera = this.config.faceCamera;
        this.getFaceCameraMatrix = d(this);
    }
    else {
        //线框模式
        if (this.parent) { 
            this.faceCamera = this.parent.faceCamera;
            this.getFaceCameraMatrix = this.parent.getFaceCameraMatrix;
        }
        else {
            this.getFaceCameraMatrix = this.faceCamera = null;
            //this.mesh && (this.mesh.matrixWorld = null);
        }
        
    }
       
    if (this.mesh){
        console.log(this.mesh.name, this.mesh.matrixWorld)
    }
    this.hideInViews = this.config.setsHideInViews ? this.config.hideInViews : this.parent ? this.parent.hideInViews : null;
    this.lightmapResolution = this.config.setsLightmapResolution ? this.config.lightmapResolution : this.parent ? this.parent.lightmapResolution : null;
    this.shadowsIsolatedWithin = this.config.isolateShadows ? this.config.name : this.parent && this.parent.shadowsIsolatedWithin ? this.parent.shadowsIsolatedWithin : null;
    this.editable = this.config.editable;
    this.parent && (this.editable = this.editable || this.parent.editable)
};
JMT.Node.prototype.visitSubtree = function (a) {
    a(this);
    var b = this.children;
    if (b)for (var c = 0; c < b.length; c += 1)b[c].visitSubtree(a)
};
JMT.Node.prototype.facesInSubtree = function () {
    var a = this;
    null === a._facesCnt && (a._facesCnt = 0, a.visitSubtree(function (b) {
        b.mesh && (a._facesCnt += b.mesh.geometry.vertexCnt / 3)
    }));
    return a._facesCnt
};
JMT.Node.prototype.hide = function () {
    this.visitSubtree(function (a) {
        a.mesh && (a.mesh.visible = !1)
    })
};
JMT.Node.prototype.show = function () {
    this.visitSubtree(function (a) {
        a.mesh && (a.mesh.visible = !0)
    })
};
JMT.Node.prototype.serialize = function () {
    var a =
    {
        id: this.id, children: this.children.map(function (a) {
        return a.serialize()
    })
    }, b = this.mesh;
    b && (a.lightProbeId = b.lightProbe ? b.lightProbe.id : null, a.mesh = !0);
    return a
};
Object.defineProperty(JMT.Node.prototype, "type", {
    get: function () {
        return this.config.name
    }
});
Object.defineProperty(JMT.Node.prototype, "highlightMix", {
    set: function (a) {
        this.visitSubtree(function (b) {
            b.mesh && (b.mesh.highlightMix = a)
        })
    }
});
Object.defineProperty(JMT.Node.prototype, "selected", {
    set: function (a) {
        this.visitSubtree(function (b) {
            b.mesh &&
            (b.mesh.selected = a)
        })
    }
});
Object.defineProperty(JMT.Node.prototype, "selectedSecondary", {
    set: function (a) {
        this.visitSubtree(function (b) {
            b.mesh && (b.mesh.selectedSecondary = a)
        })
    }
})

/***/ }),

/***/ "./src/objects/SkyMesh.js":
/*!********************************!*\
  !*** ./src/objects/SkyMesh.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkyMesh": function() { return /* binding */ SkyMesh; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

class SkyMesh extends THREE.Mesh {
    constructor(name, geometry, material, center) {
        super(geometry, material)

        center && this.position.fromArray(center);
        this.autoPosition = !center;
        this.name = name;
        var e = this;
        this._updated = function () {
            return e.dispatchEvent({type: "skyMeshUpdated", target: this})
        }


        Object.defineProperty(this, "yawRotationDeg", {
            get: function () {
                return THREE.Math.radToDeg(this.rotation.y)
            }, set: function (a) {
                a = THREE.Math.degToRad(a);
                this.rotation.y = a;
                this.updateMatrixWorld();
                this._updated()
            }
        });

        Object.defineProperty(this, "isEquirect", {
            get: function () {
                return this.material instanceof JMT.j3dEquirectSkyMaterial
                //return this.material.isEquirectSkyMaterial;
            }
        });

        Object.defineProperty(this, "radius", {
            get: function () {
                return this.scale.x
            }, set: function (a) {
                this.scale.set(a, a, a);
                this.updateMatrixWorld(!0);
                this._updated()
            }
        })
    }

    serialize() {
        var a = {name: this.name};
        if (!this.autoPosition) {
            a.center = this.position.toArray()
        }
        if (this.isEquirect) {
            a.type = "equirect"
            a.yawRotation = this.yawRotationDeg
            a.texture = this.material.map ? this.material.map.serialize() : null
        }
        else {
            a.type = "procedural";
        }
        return a
    }
}

SkyMesh.prototype.clone = void 0;

//JMT.SkyMesh = SkyMesh;



/***/ }),

/***/ "./src/objects/bone/Bone.js":
/*!**********************************!*\
  !*** ./src/objects/bone/Bone.js ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Bone": function() { return /* binding */ Bone; }
/* harmony export */ });
/**
 * Created by Kai on 2021/3/3.
 */
//import { Object3D } from '../core/Object3D.js';

function Bone() {

    THREE.Object3D.call( this );

    this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {

    constructor: Bone,

    isBone: true

} );




/***/ }),

/***/ "./src/objects/bone/Skeleton.js":
/*!**************************************!*\
  !*** ./src/objects/bone/Skeleton.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Skeleton": function() { return /* binding */ Skeleton; }
/* harmony export */ });
//import { Matrix4 } from '../math/Matrix4.js';

var Matrix4 = THREE.Matrix4

const _offsetMatrix = new Matrix4();
const _identityMatrix = new Matrix4();

function Skeleton( bones, boneInverses ) {

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );
	this.boneMatrices = new Float32Array( this.bones.length * 16 );

	this.frame = - 1;

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );

			this.boneInverses = [];

			for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.getInverse( this.bones[ i ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ i ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: function () {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArrayEx( boneMatrices, i * 16 );

		}

		if ( boneTexture !== undefined ) {

			boneTexture.needsUpdate = true;

		}

	},

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses );

	},

	getBoneByName: function ( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	},

	dispose: function ( ) {

		if ( this.boneTexture ) {

			this.boneTexture.dispose();

			this.boneTexture = undefined;

		}

	}

} );





/***/ }),

/***/ "./src/objects/bone/SkinnedMesh.js":
/*!*****************************************!*\
  !*** ./src/objects/bone/SkinnedMesh.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkinnedMesh": function() { return /* binding */ SkinnedMesh; }
/* harmony export */ });
//import { Mesh } from './Mesh.js';
//import { Matrix4 } from '../math/Matrix4.js';
//import { Vector3 } from '../math/Vector3.js';
//import { Vector4 } from '../math/Vector4.js';

var Mesh = THREE.Mesh
var Matrix4 = THREE.Matrix4
var Vector3 = THREE.Vector3
var Vector4 = THREE.Vector4

function SkinnedMesh( geometry, material ) {

	if ( geometry && geometry.isGeometry ) {

		console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

	}

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	boneTransform: ( function () {

		const basePosition = new Vector3();

		const skinIndex = new Vector4();
		const skinWeight = new Vector4();

		const vector = new Vector3();
		const matrix = new Matrix4();

		return function ( index, target ) {

			const skeleton = this.skeleton;
			const geometry = this.geometry;

			skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
			skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

			basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

			target.set( 0, 0, 0 );

			for ( let i = 0; i < 4; i ++ ) {

				const weight = skinWeight.getComponent( i );

				if ( weight !== 0 ) {

					const boneIndex = skinIndex.getComponent( i );

					matrix.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

					target.addScaledVector( vector.copy( basePosition ).applyMatrix4( matrix ), weight );

				}

			}

			return target.applyMatrix4( this.bindMatrixInverse );

		};

	}() )

} );





/***/ }),

/***/ "./src/objects/bone/index.js":
/*!***********************************!*\
  !*** ./src/objects/bone/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Bone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Bone.js */ "./src/objects/bone/Bone.js");
/* harmony import */ var _Skeleton_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Skeleton.js */ "./src/objects/bone/Skeleton.js");
/* harmony import */ var _SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./SkinnedMesh.js */ "./src/objects/bone/SkinnedMesh.js");
/**
 * Created by Kai on 2021/3/3.
 */





function inject(t){
    t.Bone = _Bone_js__WEBPACK_IMPORTED_MODULE_0__.Bone
    t.Skeleton = _Skeleton_js__WEBPACK_IMPORTED_MODULE_1__.Skeleton
    t.SkinnedMesh = _SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_2__.SkinnedMesh
}

/* harmony default export */ __webpack_exports__["default"] = ({
    inject,
    Bone: _Bone_js__WEBPACK_IMPORTED_MODULE_0__.Bone,
    Skeleton: _Skeleton_js__WEBPACK_IMPORTED_MODULE_1__.Skeleton,
    SkinnedMesh: _SkinnedMesh_js__WEBPACK_IMPORTED_MODULE_2__.SkinnedMesh
});

/***/ }),

/***/ "./src/renderers/Renderer.js":
/*!***********************************!*\
  !*** ./src/renderers/Renderer.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _WebGLRenderer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderer.js */ "./src/renderers/WebGLRenderer.js");
/* harmony import */ var _SsaaRenderer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SsaaRenderer.js */ "./src/renderers/SsaaRenderer.js");
/**
 * Created by Kai on 2020/12/18.
 */




//import '../../vendor/__three-new/examples/js/shaders/CopyShader.js'
//import '../../vendor/__three-new/examples/js/postprocessing/EffectComposer.js'
//import '../../vendor/__three-new/examples/js/postprocessing/ShaderPass.js'

//var a = {minFilter: GLC.LINEAR, magFilter: GLC.LINEAR, format: GLC.RGBA, stencilBuffer: !1, generateMipmaps: !1};


JMT.createGlobalDetector = function (gl) {
    let a = new JMT.Detector(gl);
    a.reportToConsole();
    JMT.DETECTOR = a
};

JMT.createRenderer = function (canvas, c) {
    
    void 0 === c.alpha && (c.alpha = false);
    void 0 === c.depth && (c.depth = true);
    void 0 === c.stencil && (c.stencil = true);
    void 0 === c.premultipliedAlpha && (c.premultipliedAlpha = true);
    void 0 === c.antialias && (c.antialias = !0);
    void 0 === c.preserveDrawingBuffer && (c.preserveDrawingBuffer = false);
    try {
        var gl = canvas.getContext("webgl", c) || canvas.getContext("experimental-webgl", c)
    } catch (e) {
        console.log('getContext error ', e)
    }
    
    if (!gl) {
        return null;
    }

    JMT.createGlobalDetector(gl);

    if (THREE.WebGLRenderer != undefined) {
        c.context = gl
        c.canvas = canvas
        return new THREE.WebGLRenderer(c);
    }
    else {
        

        return new JMT.WebGLRenderer(canvas, gl)
    }
    
};

JMT.createJMTRenderer = function (canvas) {
    var renderer
    if (renderer = JMT.createRenderer(canvas, {antialias: !JMT.FORCE_FXAA})) {
        renderer.autoClear = true;
        renderer.autoClearColor = true;
        renderer.autoClearDepth = true;
        renderer.autoClearStencil = false;
        renderer.sortObjects = true;
    }
        
    return renderer
};

JMT.Renderer = function (renderer, vrMgr, spScene, exposureCtrl) {
    var fxaaPass = null
    var composer
    var h
    var camera = spScene.camera   // k
    var scene = spScene.threeScene    // n

    var p = function () {
        var a = new JMT.Frustum
        var c = new THREE.Matrix4;
        return function (e) {
            if (0 !== spScene.mirrors.length) {
                e.matrixWorldInverse.getInverse(e.matrixWorld);
                c.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
                a.setFromMatrix(c);
                for (var f = 0; f < spScene.mirrors.length; f += 1) {
                    var g = spScene.mirrors[f];
                    g.updateCameraPosition(e, a);
                    g.inFrustum() && g.render(b)
                }
            }
        }
    }();

    this.resize = function (vrEnabled) {
        if (!vrEnabled) {
            var e = window.innerWidth;
            var l = window.innerHeight;
            var m = e * window.devicePixelRatio;
            var n = l * window.devicePixelRatio;
            camera.aspect = m / n;
            camera.updateProjectionMatrix();

            
            if ((THREE.WebGLRenderer != undefined)  && (renderer instanceof THREE.WebGLRenderer)) {
				renderer.setSize( window.innerWidth, window.innerHeight );
            }
            else {
                renderer.setCanvasSize && renderer.setCanvasSize(m, n);
                renderer.domElement.style.width = e + "px";
                renderer.domElement.style.height = l + "px";
            }

            if(composer){

                //composer.configureTarget(m, n, a)
                composer.setPixelRatio(window.devicePixelRatio)
                composer.setSize(window.innerWidth, window.innerHeight)
                

                h && h.setTargets(composer.renderTarget1, composer.renderTarget2)

            }
            
            fxaaPass && fxaaPass.uniforms.resolution.value.set(1 / m, 1 / n)

        }

        e = n;

        let c
        vrEnabled ? (c = m / 2, m = 70) : (c = m, m = camera.fov);

        l = c / e;

        for (n = 0; n < spScene.mirrors.length; n += 1){

            spScene.mirrors[n].configure(c, e, l, m)

        }

    };

    this.renderIdle = function (time, aniCount) {
        if(0 === aniCount){
            exposureCtrl.adaptExposure()
            h && h.reset()
        }
        if (exposureCtrl.exposureNeedsUpdate())
            return this.renderToScreen(time, !1), !0;

        if (!h) {
            return !1;
        }
        h.renderSample();
        4 <= h.renderedSamplesCount() && h.renderAccumulatedSamplesToScreen();
        return !h.allSamplesRendered()
    };

    this.renderToScreen = function (time, isVrRendering) {

        exposureCtrl.update(time);

        if( isVrRendering ){

            vrMgr.render(scene, camera.matrixWorld, p)

        }
        else {

            p(camera)

            if(fxaaPass){

                renderPass.render(time)

            }
            else {

                renderer.render(scene, camera)

            }

        }

    };
    this.enableAutoExposure = function () {
        exposureCtrl.enableAutoExposure()
    };
    this.disableAutoExposure = function () {
        exposureCtrl.disableAutoExposure()
    };

    (function () {
        if (JMT.DETECTOR.antialiasPostprocess) {
            let rt = new THREE.WebGLRenderTarget(1,1,{
                minFilter: THREE.LinearFilter,
                magFilter: THREE.LinearFilter,
                format: THREE.RGBAFormat,
                stencilBuffer:false,
                generateMipmaps:false
            })
            composer = new THREE.EffectComposer(renderer, rt);
            if (!JMT.DETECTOR.antialiasNative) {
                JMT.log("using FXAA");
                renderer.autoClear = !1;
                fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
                fxaaPass.clear = !1;
                fxaaPass.renderToScreen = !0;
                fxaaPass.material.depthTest = !1;
                fxaaPass.material.depthWrite = !1;
                fxaaPass.uniforms.resolution.value.set(1 / window.innerWidth, 1 / window.innerHeight);
                var renderPass = new THREE.RenderPass(scene, camera);
                composer.addPass(renderPass);
                composer.addPass(fxaaPass)
            }

            h = new JMT.SsaaRenderer(renderer, spScene)
        }
    })()
}

/***/ }),

/***/ "./src/renderers/SsaaRenderer.js":
/*!***************************************!*\
  !*** ./src/renderers/SsaaRenderer.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_AutoClearAlter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/AutoClearAlter.js */ "./src/utils/AutoClearAlter.js");
/* harmony import */ var _utils_AutoClearAlter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils_AutoClearAlter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _extend_j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../extend/j3dWebGLRendererUtil.js */ "./src/extend/j3dWebGLRendererUtil.js");
/**
 * Created by Kai on 2020/12/18.
 */



function accumulatedPass() {
    var a = {
        uniforms: {inputBuffer: {type: "t", value: null}, weight: {type: "f", value: 1}},
        vertexShader: JMT.getShader("accumulate_vertex.glsl").code,
        fragmentShader: JMT.getShader("accumulate_fragment.glsl").code
    };
    a = new THREE.ShaderPass(a, "inputBuffer");
    a.material.depthTest = !1;
    a.material.depthWrite = !1;
    a.material.blending = THREE.CustomBlending;
    a.material.blendEquation = THREE.AddEquation;
    a.material.blendDst = THREE.OneMinusSrcAlphaFactor;
    a.material.blendSrc = THREE.SrcAlphaFactor;
    return a
}

JMT.SsaaRenderer = function (b, c) {
    var d,
        e, g = 0, f = [[.375, .4375], [.625, .0625], [.875, .1875], [.125, .0625], [.375, .6875], [.875, .4375], [.625, .5625], [.375, .9375], [.625, .3125], [.125, .5625], [.125, .8125], [.375, .1875], [.875, .9375], [.875, .6875], [.125, .3125], [.625, .8125]]
    var h = new THREE.RenderPass(c.threeScene, c.camera), 
    k = accumulatedPass(), 
    n = new THREE.ShaderPass(THREE.CopyShader);
    n.renderToScreen = !0;
    var p = new JMT.AutoClearAlter(b);
    this.reset = function () {
        g = 0
    };
    this.renderSample = function () {
        console.assert(g < f.length);
        p.set(!0, !0, !1);
        var a = e.width, n = e.height, r = f[g][0] - .5,
            m = f[g][1] - .5, u = c.camera, x = a / n, t = Math.tan(.5 * THREE.Math.degToRad(u.fov));
        t = u.near * t / u.zoom;
        var v = -t, w = v * x;
        x *= t;
        a = (x - w) / a;
        n = (t - v) / n;
        //u.projectionMatrix.makeFrustum(w - r * a, x - r * a, v - m * n, t - m * n, u.near, u.far);
        u.projectionMatrix.makePerspective(w - r * a, x - r * a, t - m * n, v - m * n, u.near, u.far);
        h.render(b, null, d);
        p.restore();
        p.set(!1, !1, !1);
        k.uniforms.weight.value = 1 / (g + 1);
        k.render(b, e, d);
        p.restore();
        c.camera.updateProjectionMatrix();
        g += 1
    };
    this.renderedSamplesCount = function () {
        return g
    };
    this.allSamplesRendered = function () {
        return g === f.length
    };
    this.renderAccumulatedSamplesToScreen = function () {
        p.set(!0, !0, !1);
        n.render(b, void 0, e);
        p.restore()
    };
    this.copyAccumulatedSamplesToBuffer = function () {
        let utils = new _extend_j3dWebGLRendererUtil_js__WEBPACK_IMPORTED_MODULE_1__.j3dWebGLRendererUtil(b)
        var a = e.width
        var c = e.height
        var d = new Uint8Array(a * c * 4);
        utils.readPixels(a, c, d);
        return d
    };
    this.setTargets = function (a, b) {
        console.assert(a.width === b.width && a.height === b.height);
        d = a;
        e = b
    };
    this.dispose = function () {
        k.material.dispose()
    }
}


/***/ }),

/***/ "./src/renderers/WebGLInfo.js":
/*!************************************!*\
  !*** ./src/renderers/WebGLInfo.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLInfo": function() { return /* binding */ WebGLInfo; }
/* harmony export */ });
function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case gl.TRIANGLES:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case gl.LINES:
				render.lines += instanceCount * ( count / 2 );
				break;

			case gl.LINE_STRIP:
				render.lines += instanceCount * ( count - 1 );
				break;

			case gl.LINE_LOOP:
				render.lines += instanceCount * count;
				break;

			case gl.POINTS:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}





/***/ }),

/***/ "./src/renderers/WebGLMorphtargets.js":
/*!********************************************!*\
  !*** ./src/renderers/WebGLMorphtargets.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebGLMorphtargets": function() { return /* binding */ WebGLMorphtargets; }
/* harmony export */ });
function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( let i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		// Collect influences

		for ( let i = 0; i < length; i ++ ) {

			const influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		for ( let i = 0; i < 8; i ++ ) {

			if ( i < length && influences[ i ][ 1 ] ) {

				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			} else {

				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				workInfluences[ i ][ 1 ] = 0;

			}

		}

		workInfluences.sort( numericalSort );

		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < 8; i ++ ) {

			const influence = workInfluences[ i ];
			const index = influence[ 0 ];
			const value = influence[ 1 ];

			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				}

				morphInfluences[ i ] = value;
				morphInfluencesSum += value;

			} else {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== undefined ) {

					geometry.deleteAttribute( 'morphTarget' + i );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== undefined ) {

					geometry.deleteAttribute( 'morphNormal' + i );

				}

				morphInfluences[ i ] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}





/***/ }),

/***/ "./src/renderers/WebGLProgramStore.js":
/*!********************************************!*\
  !*** ./src/renderers/WebGLProgramStore.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _renderers_shaders_createWebGLShader_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderers/shaders/createWebGLShader.js */ "./src/renderers/shaders/createWebGLShader.js");
/* harmony import */ var _renderers_shaders_createWebGLShader_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_renderers_shaders_createWebGLShader_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */


function injectLogDepthBuf(shader, material) {

    function insertStr(soure, start, newStr){

        return soure.slice(0, start) + newStr + soure.slice(start);
    }

    if (JMT.DETECTOR.logarithmicDepthBuffer) {

        var regex = /void[ \t]main/
        let c = shader.vertex.search(regex)
        if (c !== -1) {

            let strLogDep = `
#ifdef USE_LOGDEPTHBUF

	#ifdef USE_LOGDEPTHBUF_EXT

		varying float vFragDepth;
		varying float vIsPerspective;

	#else

		uniform float logDepthBufFC;

	#endif

#endif
`
            shader.vertex = insertStr(shader.vertex, c, strLogDep)

            if (shader.vertex.search(/bool[ \t]isPerspectiveMatrix/) == -1) {

                let strfun = "bool isPerspectiveMatrix( mat4 m ) { return m[ 2 ][ 3 ] == - 1.0; }\n"
                c = shader.vertex.search(regex)
                shader.vertex = insertStr(shader.vertex, c, strfun)
            }

            let sss = `
                #ifdef USE_LOGDEPTHBUF

                    #ifdef USE_LOGDEPTHBUF_EXT
                
                        vFragDepth = 1.0 + gl_Position.w;
                        vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
                
                    #else
                
                        if ( isPerspectiveMatrix( projectionMatrix ) ) {
                
                            gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
                
                            gl_Position.z *= gl_Position.w;
                
                        }
                
                    #endif
            
                #endif
                `

            c = shader.vertex.lastIndexOf("}");
            shader.vertex = insertStr(shader.vertex, c, sss);
        }
        else {

            console.warn("can not match [void main] in vertex shader")

        }



        shader.fragment = "#extension GL_EXT_frag_depth : enable\n" + shader.fragment
        c = shader.fragment.search(regex)
        if (c !== -1) {

let strLogDep = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
//#define gl_FragDepthEXT gl_FragDepth
    
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;

#endif
`

            shader.fragment = insertStr(shader.fragment, c, strLogDep)


strLogDep = `
#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )

	// Doing a strict comparison with == 1.0 can cause noise artifacts
	// on some platforms. See issue #17623.
	
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;

#endif
`
            c = shader.fragment.search(regex)
            c = shader.fragment.indexOf("{", c)
            shader.fragment = insertStr(shader.fragment, c+1, strLogDep)
        }
        else {
            console.warn("can not match [void main] in fragment shader")
        }
    }

}

function WebGLProgram(gl, material) {

    var attributeName = material.index0AttributeName

    var program = gl.createProgram()

    let shader = {
        vertexShader : material.generateVertexShader(),
        fragmentShader: material.generateFragmentShader()
    }

    injectLogDepthBuf(shader, material)

    material.onBeforeCompile && material.onBeforeCompile(shader)

    var vertexShader = JMT.createWebGLShader(gl, gl.VERTEX_SHADER, shader.vertexShader)

    var fragmentShader = JMT.createWebGLShader(gl, gl.FRAGMENT_SHADER, shader.fragmentShader);

    gl.attachShader(program, vertexShader);

    gl.attachShader(program, fragmentShader);

    void 0 !== attributeName && gl.bindAttribLocation(program, 0, attributeName);

    gl.linkProgram(program);

    var infoLog = gl.getProgramInfoLog(program);

    if(!1 === gl.getProgramParameter(program, gl.LINK_STATUS)){

        console.error("Shader link error: " + gl.getError(), "validate status: ",
            gl.getProgramParameter(program, gl.VALIDATE_STATUS));

    }

    if("" !== infoLog && "\x00" !== infoLog){

        console.warn("program info log: " + infoLog);

    }

    gl.deleteShader(vertexShader);

    gl.deleteShader(fragmentShader);

    var uniformCache = {};

    // transform uniforms

    for (var index = 0; index < properties.length; index++) {

        var property = properties[index];

        uniformCache[property] = gl.getUniformLocation(program, property)

    }

    this.transformUniformCache = uniformCache;

    // material unifoms

    var uniforms = material.uniforms;

    uniformCache = {i: [], f: [], v2: [], v3: [], c: [], v4: [], m4: [], t: []};

    var value;

    for (property in uniforms){

        if(uniforms.hasOwnProperty(property)){

            var location = gl.getUniformLocation(program, property)

            if(location){

                var type = uniforms[property].type

                console.assert(uniformCache.hasOwnProperty(type))

                if("i" === type || "f" === type || "t" === type){

                    value = null

                }
                else if("v2" === type){

                    value = [null, null]

                }
                else if("v3" === type || "c" === type){

                    value = [null, null, null]

                }
                else if("v4" === type){

                    value = [null, null, null, null]

                }
                else if("m4" === type){

                    value = null

                }
                else {

                    console.assert(!1)

                }

                uniformCache[type].push({id: property, value: value, location: location})
            }

        }
    }

    this.materialUniformCache = uniformCache;

    var attributes = material.attributes;

    var attributeLocations = {};


    for (var index = 0 ; index < attributes.length; index++){

        var attribute = attributes[index]

        attributeLocations[attribute] = gl.getAttribLocation(program, attribute);

    }

    this.attributes = attributeLocations;

    this.attributesKeys = Object.keys(this.attributes);

    this.id = _Id++;

    this.usedTimes = 1;

    this.program = program;


    return this
}

var properties = "viewMatrix modelViewMatrix projectionMatrix normalMatrix modelMatrix cameraPosition boneMatrices boneTexture boneTextureSize bindMatrix bindMatrixInverse".split(" ")

var _Id = 0;

JMT.WebGLProgramStore = function (gl) {

    var _programeCaches = new Map;

    this.assignProgramToMaterial = function (material) {

        console.assert(material instanceof JMT.BaseMaterial);

        var programId = material.generateProgramId()

        var program = _programeCaches[programId];

        if(program){

            program.usedTimes++

        }
        else {

            program = new WebGLProgram(gl, material)

            _programeCaches[programId] = program

        }

        material.program && this.resetProgramAssignment(material);

        material.program = program

    };

    this.resetProgramAssignment = function (material) {

        var program = material.program;

        material.program = null;

        --program.usedTimes;

        if (0 === material.usedTimes) {

            for (var programId in _programeCaches){

                if (_programeCaches.hasOwnProperty(programId) && _programeCaches[programId] === program) {

                    delete _programeCaches[programId];

                    break

                }
            }

            gl.deleteProgram(material.program)

        }
    }
}

/***/ }),

/***/ "./src/renderers/WebGLRenderTarget.js":
/*!********************************************!*\
  !*** ./src/renderers/WebGLRenderTarget.js ***!
  \********************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

class WebGLRenderTarget extends THREE.EventDispatcher {
    constructor(a, b, c) {
        super()

        this.y = this.x = 0;
        this.width = a;
        this.height = b;
        c = c || {};
        this.wrapS = void 0 !== c.wrapS ? c.wrapS : GLC.CLAMP_TO_EDGE;
        this.wrapT = void 0 !== c.wrapT ? c.wrapT : GLC.CLAMP_TO_EDGE;
        this.magFilter = void 0 !== c.magFilter ? c.magFilter : GLC.LINEAR;
        this.minFilter = void 0 !== c.minFilter ? c.minFilter : GLC.LINEAR_MIPMAP_LINEAR;
        this.anisotropy = void 0 !== c.anisotropy ? c.anisotropy : 1;
        this.offset = new THREE.Vector2(0, 0);
        this.repeat = new THREE.Vector2(1, 1);
        this.format = void 0 !== c.format ? c.format : GLC.RGBA;
        this.type = void 0 !== c.type ? c.type : GLC.UNSIGNED_BYTE;
        this.depthBuffer = void 0 !== c.depthBuffer ? c.depthBuffer : !0;
        this.stencilBuffer = void 0 !== c.stencilBuffer ? c.stencilBuffer : !0;
        this.generateMipmaps = c.generateMipmaps || !1;
        this.shareDepthFrom = void 0 !== c.shareDepthFrom ? c.shareDepthFrom : null;
        this.isCube = !1;
        this.__webglSlot = this.__webglTexture = this.__webglRenderbuffer = this.__webglFramebuffer = null
    }

    dispose() {
        this.dispatchEvent({type: "dispose"})
    }
}
;
JMT.WebGLRenderTarget = WebGLRenderTarget


class WebGLRenderTargetVR extends THREE.EventDispatcher {
    constructor(a) {
        super()
        this.__webglFramebuffer = a;
        this.height = this.width = this.y = this.x = null;
        this.isCube = !1
    }

    dispose() {
        this.__webglFramebuffer = null;
        this.dispatchEvent({type: "dispose"})
    }
}

JMT.WebGLRenderTargetVR = WebGLRenderTargetVR

/***/ }),

/***/ "./src/renderers/WebGLRenderTargetCube.js":
/*!************************************************!*\
  !*** ./src/renderers/WebGLRenderTargetCube.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "./src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Created by Kai on 2020/12/18.
 */


class WebGLRenderTargetCube extends JMT.WebGLRenderTarget{
    constructor(a, b, c){
        super(a, b, c)
        this.activeCubeFace = 0;
        this.isCube = !0;
        this.__webglFramebuffer = [];
        this.__webglRenderbuffer = []
    }
}

JMT.WebGLRenderTargetCube = WebGLRenderTargetCube

/***/ }),

/***/ "./src/renderers/WebGLRenderer.js":
/*!****************************************!*\
  !*** ./src/renderers/WebGLRenderer.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/Frustum.js */ "./src/math/Frustum.js");
/* harmony import */ var _math_Frustum_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_math_Frustum_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl/WebGLState.js */ "./src/renderers/webgl/WebGLState.js");
/* harmony import */ var _webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_webgl_WebGLState_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _WebGLProgramStore_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WebGLProgramStore.js */ "./src/renderers/WebGLProgramStore.js");
/* harmony import */ var _textures_WebGLTextureSlotter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../textures/WebGLTextureSlotter.js */ "./src/textures/WebGLTextureSlotter.js");
/* harmony import */ var _textures_WebGLTextureSlotter_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_textures_WebGLTextureSlotter_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WebGLRenderTarget.js */ "./src/renderers/WebGLRenderTarget.js");
/* harmony import */ var _WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_WebGLRenderTarget_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _textures_DataTexture_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../textures/DataTexture.js */ "./src/textures/DataTexture.js");
/* harmony import */ var _WebGLRenderTargetCube_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./WebGLRenderTargetCube.js */ "./src/renderers/WebGLRenderTargetCube.js");
/* harmony import */ var _WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WebGLMorphtargets.js */ "./src/renderers/WebGLMorphtargets.js");
/* harmony import */ var _WebGLInfo_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./WebGLInfo.js */ "./src/renderers/WebGLInfo.js");
/**
 * Created by Kai on 2020/12/18.
 */




//import {$jscomp} from '../../src_new/lib/jscomp.js'







function a(a, b) {
    var c = {
        HALF_FLOAT_OES: "OES_texture_half_float",
        COMPRESSED_RGB_S3TC_DXT1_EXT: "WEBGL_compressed_texture_s3tc",
        COMPRESSED_RGBA_S3TC_DXT1_EXT: "WEBGL_compressed_texture_s3tc",
        COMPRESSED_RGBA_S3TC_DXT3_EXT: "WEBGL_compressed_texture_s3tc",
        COMPRESSED_RGBA_S3TC_DXT5_EXT: "WEBGL_compressed_texture_s3tc",
        COMPRESSED_RGB_PVRTC_4BPPV1_IMG: "WEBGL_compressed_texture_pvrtc",
        COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: "WEBGL_compressed_texture_pvrtc",
        COMPRESSED_RGB_PVRTC_2BPPV1_IMG: "WEBGL_compressed_texture_pvrtc",
        COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: "WEBGL_compressed_texture_pvrtc",
        COMPRESSED_RGB_ETC1_WEBGL: "WEBGL_compressed_texture_etc1",
        COMPRESSED_RGBA_ASTC_4x4_KHR: "WEBGL_compressed_texture_astc"
    }
    for (var d = $jscomp.makeIterator(Object.entries(GLC)), f = d.next(); !f.done; f = d.next()) {
        var h = $jscomp.makeIterator(f.value);
        f = h.next().value;
        h = h.next().value;
        var k = c[f];
        void 0 !== k ? (k = b.extension(k)) && console.assert(k[f] === h) : console.assert(a[f] === h)
    }
}

function b(a) {
    if (JMT.DETECTOR.disableTextureSlotReuse) {
        return new JMT.WebGLTextureSlotterSequential(a)
    }
    else {
        return new JMT.WebGLTextureSlotter(a)
    }
}
let _gl = null;

JMT.WebGLRenderer = function (c, gl) {

    function e() {

        _glInstances = JMT.DETECTOR.instances;
        K = O = null;
        _currentMaterialId = -1;
        Q = Y = null;
        state = new JMT.WebGLState(gl, _glInstances);
        programCacheStore = new JMT.WebGLProgramStore(gl);
        gl.clearColor(0, 0, 0, 1);
        gl.clearDepth(1);
        gl.clearStencil(0);
        gl.enable(gl.DEPTH_TEST);
        gl.depthFunc(gl.LEQUAL);
        gl.frontFace(gl.CCW);
        gl.cullFace(gl.BACK);
        gl.enable(gl.CULL_FACE);
        gl.enable(gl.BLEND);
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        state.setViewport(0, 0, c.width, c.height);
        gl.clearColor(z.r, z.g, z.b, A);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE)


        morphtargets = new _WebGLMorphtargets_js__WEBPACK_IMPORTED_MODULE_7__.WebGLMorphtargets(gl);
    }

    function onBufferDispose(a) {   // g

        a = a.target;

        a.removeEventListener("dispose", onBufferDispose);

        delete a.__webglInit;

        a = a.attributes;

        for (var b in a) {

            if (a.hasOwnProperty(b)) {

                var c = a[b];

                if (void 0 !== c.buffer) {

                    gl.deleteBuffer(c.buffer)

                    delete c.buffer
                }

            }
        }

        state.disableAttributeStates();

        Y = null

    }

    function onTextureDispose(a) {  // f

        a = a.target;

        a.removeEventListener("dispose", onTextureDispose);

        L.freeSlot(a);

        if (a.__webglTexture) {

            gl.deleteTexture(a.__webglTexture)

            a.__webglTexture = null

        }

    }

    function onRenderTargetDispose(a) { // h

        a = a.target;

        a.removeEventListener("dispose", onRenderTargetDispose);

        L.freeSlot(a);

        if (a.__webglTexture) {

            gl.deleteTexture(a.__webglTexture)

            a.__webglTexture = null

        }

        if (a.isCube) {

            for (var b = 0; 6 > b; b++) {

                gl.deleteFramebuffer(a.__webglFramebuffer[b])

                gl.deleteRenderbuffer(a.__webglRenderbuffer[b]);

            }
        }
        else {

            gl.deleteFramebuffer(a.__webglFramebuffer)

            gl.deleteRenderbuffer(a.__webglRenderbuffer);

        }

        a.__webglFramebuffer = null;

        a.__webglRenderbuffer = null

    }

    function onMaterialDispose(a) { // k

        a = a.target;

        a.removeEventListener("dispose", onMaterialDispose);

        programCacheStore.resetProgramAssignment(a)

    }

    function setupVertexAttributes(material, program, geometry) {

        var e = geometry.attributes

        var f = program.attributes;

        let b = program.attributesKeys;

        let c = 16 * (geometry.instanceId || 0);

        //if(a.skinning){
        //    console.log(a);
        //}

        for (var g = 0, k = b.length; g < k; g++) {

            var h = b[g]

            var l = f[h];

            if (0 <= l) {

                var m = e[h];

                if (void 0 !== m) {

                    h = m.itemSize;

                    var n = m.glType;

                    gl.bindBuffer(gl.ARRAY_BUFFER, m.buffer);

                    m = m.divisor || 0;

                    state.enableAttributeArray(l);

                    gl.vertexAttribPointer(l, h, n, !1, 0, c * m);

                    _glInstances && state.setAttributeDivisor(l, m)

                }
                else {

                    state.disableAttributeArray(l, material.defaultAttributeValues[h])

                }
            }
        }
    }

    function setTextureParameters(textureType, texture) {

        var c = JMT.DETECTOR;

        console.assert(texture.wrapS && texture.wrapT && texture.magFilter && texture.minFilter)

        gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, texture.wrapS);

        gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, texture.wrapT);

        gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, texture.magFilter);

        gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, texture.minFilter);

        var e = c.extension("EXT_texture_filter_anisotropic");

        if (e && 1 < b.anisotropy) {

            gl.texParameterf(textureType, e.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, c.maxAnisotropy))

        }
    }

    function _opaqueSort(a, b) {    // l
        var c = a.material, d = b.material, e = c.program, f = gl.program;
        return e && f && e.id !== f.id ? e.id - f.id : c.id - gl.id || a.id - b.id
    }

    function _transparentSort(a, b) {   // q
        var c = a.material.transparentRenderOrder - b.material.transparentRenderOrder;
        return c ? c : b.cameraDistance - a.cameraDistance || a.id - b.id
    }

    function projectObject(object, overrideMaterial, visible) {   // r

        if (visible || !1 !== object.visible) {

            if (object instanceof THREE.Points || object instanceof THREE.Mesh) {

                /////////////////////////////////////////////////////////////
                // TODO: bone test
                if ( object.isSkinnedMesh ) {

                    // update skeleton only once in a frame

                    if ( object.skeleton.frame !== info.render.frame ) {

                        object.skeleton.update();
                        object.skeleton.frame = info.render.frame;

                    }

                }
                /////////////////////////////////////////////////////////////

                if (!1 === object.frustumCulled || !0 === N.intersectsObject(object)) {

                    if ((overrideMaterial || object.material).transparent) {

                        if (!0 === I.sortObjects) {

                            object.cameraDistance = N.nearPlaneDistanceToCenter(object)

                        }

                        transparentObjects.push(object)

                    }
                    else {

                        opaqueObjects.push(object)

                    }

                }

            }

            for (var d = 0, e = object.children.length; d < e; d++) {

                projectObject(object.children[d], overrideMaterial, visible)

            }
        }
    }

    function m(a) {

        state.setDoubleSided(a.side === THREE.DoubleSide);

        state.setFlipSided(a.side === THREE.BackSide)

    }

    function copyTextureToTexture(a) {  // u

        if (!a.__webglTexture) {

            a.addEventListener("dispose", onTextureDispose)

            a.__webglTexture = gl.createTexture()
        }

        gl.activeTexture(gl.TEXTURE0 + a.__webglSlot);

        gl.bindTexture(gl.TEXTURE_2D, a.__webglTexture);

        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, a.flipY);

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, a.premultiplyAlpha);

        gl.pixelStorei(gl.UNPACK_ALIGNMENT, a.unpackAlignment);

        var b = a.image

        var c = THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height)

        var e = a.format

        var g = a.type;

        setTextureParameters(gl.TEXTURE_2D, a);

        var k = a.mipmaps;

        if (a instanceof JMT.DataTexture) {

            if (0 < k.length && c) {

                for (var h = 0, l = k.length; h < l; h++) {

                    b = k[h]

                    gl.texImage2D(gl.TEXTURE_2D, h, e, b.width, b.height, 0, e, g, b.data)

                    a.releaseOnLoadedToGpu && (b.data = null);
                }

                a.generateMipmaps = !1

            }
            else {

                gl.texImage2D(gl.TEXTURE_2D, 0, e, b.width, b.height, 0, e, g, b.data)

                a.releaseOnLoadedToGpu && (b.data = null);
            }
        }
        else if (a instanceof JMT.CompressedTexture) {

            for (h = 0, l = k.length; h < l; h++) {

                b = k[h]

                if (a.format !== GLC.RGBA && a.format !== GLC.RGB) {

                    gl.compressedTexImage2D(gl.TEXTURE_2D, h, e, b.width, b.height, 0, b.data)

                }
                else {

                    gl.texImage2D(gl.TEXTURE_2D, h, e, b.width, b.height, 0, e, g, b.data), a.releaseOnLoadedToGpu && (b.data = null);

                }
            }

        }
        else if (0 < k.length && c) {

            h = 0;

            for (l = k.length; h < l; h++) {

                b = k[h]

                gl.texImage2D(gl.TEXTURE_2D, h, e, e, g, b);

            }

            a.releaseOnLoadedToGpu && (a.mipmaps = null);

            a.generateMipmaps = !1
        }
        else {

            gl.texImage2D(gl.TEXTURE_2D, 0, e, e, g, a.image)

            a.releaseOnLoadedToGpu && (a.image = null);

        }

        a.generateMipmaps && c && gl.generateMipmap(gl.TEXTURE_2D);

        a.needsUpdate = !1

    }

    function x(a) {
        state.setBlending(a);
        state.setDepthTest(a.depthTest);
        state.setDepthWrite(a.depthWrite);
        state.setColorWrite(a.colorWrite)
    }

    function renderObjects(objects, camera, overrideMaterial) {   // t

        if (overrideMaterial) {

            var e = overrideMaterial;

            x(e);

            m(e)
        }

        for (var f = 0, g = objects.length; f < g; f += 1) {

            var object = objects[f]

            var geometry = object.geometry

            var material = object.material;

            if (overrideMaterial) {

                overrideMaterial.doNotOverrideSide && material && m(material)

            }
            else {

                e = material

                x(e)

                m(e);

            }

            material = e;

            if (!1 !== material.visible && 0 !== geometry.vertexCnt) {

                var r = camera;

                var t = material;

                if (material.programNeedsUpdate || !material.program) {


                    programCacheStore.assignProgramToMaterial(material)

                    material.addEventListener("dispose", onMaterialDispose)

                    material.programNeedsUpdate = !1
                }


                var v = !1

                var w = !1;

                var program = material.program; // z

                if(!program){
                    console.log(material);
                }

                var F = program.transformUniformCache;

                var A = material.uniforms;

                console.assert(!material.morphTargets);

                ////////////////////////////////////////////////////////////////////
                // 可能不对，等待进一步测试

                if (material.morphTargets || material.morphNormals) {

                    morphtargets.update(object, geometry, material, program);


                    const programAttributes = program.getAttributes();

                    if ( material.morphTargets ) {

                        material.numSupportedMorphTargets = 0;

                        for ( let i = 0; i < _this.maxMorphTargets; i ++ ) {

                            if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {

                                material.numSupportedMorphTargets ++;

                            }

                        }

                    }

                    if ( material.morphNormals ) {

                        material.numSupportedMorphNormals = 0;

                        for ( let i = 0; i < _this.maxMorphNormals; i ++ ) {

                            if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

                                material.numSupportedMorphNormals ++;

                            }

                        }

                    }

                }


                ////////////////////////////////////////////////////////////////////
                //
                if (program.id !== O) {

                    gl.useProgram(program.program)

                    O = program.id

                    w = v = !0

                }

                if (material.id !== _currentMaterialId) {

                    _currentMaterialId = material.id

                    w = !0
                }



                if (v || camera !== Q) {

                    gl.uniformMatrix4fv(F.projectionMatrix, !1, camera.projectionMatrix.elements)

                    camera !== Q && (Q = camera)

                    console.assert(material instanceof JMT.BaseMaterial)

                    if (null !== F.cameraPosition) {

                        J.setFromMatrixPosition(r.matrixWorld)

                        gl.uniform3f(F.cameraPosition, J.x, J.y, J.z)
                    }

                    if (null !== F.viewMatrix) {

                        gl.uniformMatrix4fv(F.viewMatrix, !1, camera.matrixWorldInverse.elements)

                    }

                    if (!!JMT.DETECTOR.rendererExtensionFragDepth) {
                        material._logDepthBufFC = 2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 );
                        material.setUniform("logDepthBufFC","f", material._logDepthBufFC);
                    }
                }

                if (material.refreshPerObjectUniforms && material.refreshPerObjectUniforms(object, A)) {

                    w = !0

                }

                if (w) {

                    var P = program;

                    w = A;

                    v = program.materialUniformCache.i;

                    var t = 0;

                    for (A = v.length; t < A; t += 1) {

                        var y = v[t];

                        var D = y.id;

                        var N = w[D].value;

                        if (y.value !== N) {

                            gl.uniform1i(y.location, N)

                            y.value = N

                        }

                    }

                    v = program.materialUniformCache.f;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        N = w[D].value

                        if (y.value !== N) {

                            gl.uniform1f(y.location, N)

                            y.value = N

                        }

                    }

                    v = program.materialUniformCache.v2;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t];

                        D = y.id;

                        N = w[D].value;

                        var E = N.x;

                        var V = N.y;

                        if (y.value[0] !== E || y.value[1] !== V) {

                            gl.uniform2f(y.location, E, V)

                            y.value[0] = E

                            y.value[1] = V

                        }
                    }

                    v = program.materialUniformCache.v3;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        N = w[D].value

                        E = N.x

                        V = N.y

                        D = N.z

                        if (y.value[0] !== E || y.value[1] !== V || y.value[2] !== D) {

                            gl.uniform3f(y.location, E, V, D)

                            y.value[0] = E

                            y.value[1] = V

                            y.value[2] = D;

                        }

                    }

                    v = program.materialUniformCache.c;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        N = w[D].value

                        E = N.r

                        V = N.g

                        D = N.b

                        if (y.value[0] !== E || y.value[1] !== V || y.value[2] !== D) {

                            gl.uniform3f(y.location, E, V, D)

                            y.value[0] = E

                            y.value[1] = V

                            y.value[2] = D;

                        }

                    }

                    v = program.materialUniformCache.v4;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        N = w[D].value

                        E = N.x

                        V = N.y

                        D = N.z

                        N = N.w

                        if (y.value[0] !== E || y.value[1] !== V || y.value[2] !== D || y.value[3] !== N) {

                            gl.uniform4f(y.location, E, V, D, N)

                            y.value[0] = E

                            y.value[1] = V

                            y.value[2] = D

                            y.value[3] = N;

                        }

                    }

                    v = program.materialUniformCache.m4;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        try {

                            gl.uniformMatrix4fv(y.location, !1, w[D].value.elements);

                        }
                        catch (ex) {

                            console.log(ex);

                        }
                    }

                    v = program.materialUniformCache.t;

                    t = 0;

                    for (A = v.length; t < A; t += 1) {

                        y = v[t]

                        D = y.id

                        V = w[D].value

                        D = L.setSlot(V, !0)

                        P = V ? V.__webglSlot : null

                        if (y.value !== P) {

                            gl.uniform1i(y.location, P)

                            y.value = P
                        }

                        if (D || V.needsUpdate) {

                            if (V) {

                                if (V.isCube) {

                                    y = V

                                    gl.activeTexture(gl.TEXTURE0 + y.__webglSlot)

                                    gl.bindTexture(gl.TEXTURE_CUBE_MAP, y.__webglTexture)

                                    if (y.needsUpdate) {

                                        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, y.flipY);

                                        P = y instanceof JMT.CompressedTexture;

                                        D = y.image;

                                        V = y.format;

                                        E = y.type;

                                        p(gl.TEXTURE_CUBE_MAP, y);

                                        for (N = 0; 6 > N; N++) {

                                            if (P) {

                                                var K = D[N].mipmaps

                                                var Aa = K.length

                                                for (var I = 0; I < Aa; I++) {

                                                    var ta = K[I];

                                                    if (y.format !== GLC.RGBA && y.format !== GLC.RGB) {

                                                        gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + N, I, V, ta.width, ta.height, 0, ta.data)

                                                    }
                                                    else {

                                                        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + N, I, V, ta.width, ta.height, 0, V, E, ta.data)

                                                    }

                                                    y.releaseOnLoadedToGpu && (ta.data = null)

                                                }

                                            }
                                            else {

                                                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + N, 0, V, V, E, D[N])

                                                y.releaseOnLoadedToGpu && (D[N] = null);
                                            }
                                        }

                                        y.generateMipmaps && gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

                                        y.needsUpdate = !1
                                    }
                                }
                                else {

                                    y = V

                                    if (y.needsUpdate) {

                                        copyTextureToTexture(y)

                                    }
                                    else {

                                        gl.activeTexture(gl.TEXTURE0 + y.__webglSlot)

                                        gl.bindTexture(gl.TEXTURE_2D, y.__webglTexture)

                                    }
                                }
                            }
                        }
                    }

                    L.unlockAllSlots()

                }

                A = r;

                r = F;

                if (object.matrixWorld) {

                    M.multiplyMatrices(A.matrixWorldInverse, object.matrixWorld)

                    A = M

                }
                else {

                    A = A.matrixWorldInverse;

                }

                gl.uniformMatrix4fv(r.modelViewMatrix, !1, A.elements);

                if (r.normalMatrix) {

                    R.getNormalMatrix(A)

                    gl.uniformMatrix3fv(r.normalMatrix, !1, R.elements)
                }

                if (null !== F.modelMatrix) {

                    if (object.matrixWorld) {

                        gl.uniformMatrix4fv(F.modelMatrix, !1, object.matrixWorld.elements)

                    }
                    else {

                        gl.uniformMatrix4fv(F.modelMatrix, !1, W)

                    }
                }

                ////////////////////////////////////////////////////////////////////

                // skinning uniforms must be set even if material didn't change
                // auto-setting of texture unit for bone texture must go before other textures
                // otherwise textures used for skinning can take over texture units reserved for other material textures

                if ( material.skinning ) {

                    gl.uniformMatrix4fv(F.bindMatrix, !1, object.bindMatrix.elements)
                    gl.uniformMatrix4fv(F.bindMatrixInverse, !1, object.bindMatrixInverse.elements)

                    const skeleton = object.skeleton;


                    if ( skeleton ) {

                        const bones = skeleton.bones;

                        if ( _glInstances.floatVertexTextures ) {

                            if ( skeleton.boneTexture === undefined ) {

                                // layout (1 matrix = 4 pixels)
                                //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
                                //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
                                //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
                                //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
                                //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


                                let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
                                size = MathUtils.ceilPowerOfTwo( size );
                                size = Math.max( size, 4 );

                                const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
                                boneMatrices.set( skeleton.boneMatrices ); // copy current values

                                const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

                                skeleton.boneMatrices = boneMatrices;
                                skeleton.boneTexture = boneTexture;
                                skeleton.boneTextureSize = size;

                            }

                            //p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
                            //p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

                        } else {

                            //p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
                            gl.uniformMatrix4fv(F.boneMatrices, !1, skeleton.boneMatrices)

                        }

                    }
                }

                r = program;

                A = !1;

                if (geometry.id !== Y || r.id !== O) {

                    Y = geometry.id

                    A = !0;

                }

                //console.assert(object instanceof THREE.Mesh);

                if (object instanceof THREE.Points)
                    var h = gl.POINTS;
                else if (object instanceof THREE.Mesh)
                    var h = gl.TRIANGLES;

                t = geometry.attributes.index

                if (t) {

                    var z = t.glType

                    F = geometry.indexUint ? 4 : 2

                    if (A) {

                        setupVertexAttributes(material, program, geometry)

                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, t.buffer)

                    }

                    if (void 0 !== geometry.indexOffset) {

                        var q = geometry.indexCnt

                        F *= geometry.indexOffset
                    }
                    else {
                        var q = t.length

                        F = 0
                    }

                    if (geometry.isInstanced) {

                        _glInstances.drawElementsInstancedANGLE(h, q, z, F, geometry.instanceCount)

                    }
                    else {

                        //if(material.skinning ){
                        //    console.log(h, q, z, F);
                        //}

                        gl.drawElements(h, q, z, F)

                    }
                }
                else {

                    A && setupVertexAttributes(material, program, geometry)

                    var q = geometry.attributes.position

                    if (void 0 !== geometry.vertexOffset) {

                        z = geometry.vertexCnt

                        q = geometry.vertexOffset
                    }
                    else {

                        z = q.length / q.itemSize

                        q = 0
                    }

                    if (geometry.isInstanced) {

                        _glInstances.drawArraysInstancedANGLE(h, q, z, geometry.instanceCount)

                    }
                    else {

                        gl.drawArrays(h, q, z)

                    }
                }

                _glInstances && state.resetAttributeDivisors()
            }
        }
    }

    function v(a, b) {

        gl.bindRenderbuffer(gl.RENDERBUFFER, a);

        if (b.depthBuffer) {

            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, b.width, b.height)

            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, a)

        }
        else {

            gl.renderbufferStorage(gl.RENDERBUFFER, gl.RGBA4, b.width, b.height)

        }

    }

    function bindRenderTarget(isCube, b) {

        b.addEventListener("dispose", onRenderTargetDispose);

        b.__webglTexture = gl.createTexture();

        var c = b.format,
            e = b.type;

        L.setSlot(b, !1);

        gl.activeTexture(gl.TEXTURE0 + b.__webglSlot);

        if (isCube) {

            gl.bindTexture(gl.TEXTURE_CUBE_MAP, b.__webglTexture);

            setTextureParameters(gl.TEXTURE_CUBE_MAP, b);

            for (var a = 0; 6 > a; a++) {

                b.__webglFramebuffer[a] = gl.createFramebuffer();

                b.__webglRenderbuffer[a] = gl.createRenderbuffer();

                gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + a, 0, c, b.width, b.height, 0, c, e, null);

                var f = gl.TEXTURE_CUBE_MAP_POSITIVE_X + a, g = b.__webglTexture;

                gl.bindFramebuffer(gl.FRAMEBUFFER, b.__webglFramebuffer[a]);

                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, f, g, 0);

                v(b.__webglRenderbuffer[a], b)

            }

            b.generateMipmaps && gl.generateMipmap(gl.TEXTURE_CUBE_MAP)

        }
        else {

            b.__webglFramebuffer = gl.createFramebuffer()

            if (b.shareDepthFrom) {

                b.__webglRenderbuffer = b.shareDepthFrom.__webglRenderbuffer

            }
            else {

                b.__webglRenderbuffer = gl.createRenderbuffer()

            }

            gl.bindTexture(gl.TEXTURE_2D, b.__webglTexture)

            setTextureParameters(gl.TEXTURE_2D, b)

            gl.texImage2D(gl.TEXTURE_2D, 0, c, b.width, b.height, 0, c, e, null)

            c = gl.TEXTURE_2D

            e = b.__webglTexture

            gl.bindFramebuffer(gl.FRAMEBUFFER, b.__webglFramebuffer)

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, c, e, 0)

            if (b.shareDepthFrom) {

                b.depthBuffer && gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, b.__webglRenderbuffer)

            }
            else {

                v(b.__webglRenderbuffer, b)

            }

            b.generateMipmaps && gl.generateMipmap(gl.TEXTURE_2D)

        }

        gl.bindRenderbuffer(gl.RENDERBUFFER, null);

        gl.bindFramebuffer(gl.FRAMEBUFFER, null)

    }

    var z = new THREE.Color(0), A = 0
    var opaqueObjects = []  // y
    var transparentObjects = [];    // E
    this.domElement = c;
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0;
    var I = this, O, K, _currentMaterialId, Y, Q
    var _glInstances
    var state, programCacheStore, N = new JMT.Frustum, D = new THREE.Matrix4, J = new THREE.Vector3;

    e();
    a(gl, JMT.DETECTOR);
    this.webGLContextRestored = function () {
        e()
    };
    this.context = gl;
    this.state = state;


    /////////////////////////////////////////////////////
    // TODO: bone test
    var morphtargets


    _gl = gl

    var info = new _WebGLInfo_js__WEBPACK_IMPORTED_MODULE_8__.WebGLInfo( _gl );
    //info.programs = programCacheStore.programs;

    this.info = info

    // morphs

    this.maxMorphTargets = 8;
    this.maxMorphNormals = 4;


    /////////////////////////////////////////////////////


    var L = b(gl), W = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this.setCanvasSize = function (a, b) {
        c.width = a;
        c.height = b;
        null === K && this.setViewport(0, 0, a, b)
    };
    this.setViewport = function (a, b, c, d) {
        state.setViewport(a, b, c, d)
    };
    this.setScissor = function (a, b, c, e) {
        gl.scissor(a, b, c, e)
    };
    this.enableScissorTest = function (a) {
        a ? gl.enable(gl.SCISSOR_TEST) : gl.disable(gl.SCISSOR_TEST)
    };
    this.setClearColor = function (a, b) {
        z.copy(a);
        A = void 0 !== b ? b : 1;
        gl.clearColor(z.r, z.g, z.b, A)
    };
    this.getClearColor = function () {
        return z
    };
    this.getClearAlpha = function () {
        return A
    };
    this.clear = function (a, b, c) {
        var e = 0;
        a && (e |= gl.COLOR_BUFFER_BIT);
        b && (e |= gl.DEPTH_BUFFER_BIT);
        c && (e |= gl.STENCIL_BUFFER_BIT);
        gl.clear(e)
    };
    this.clearColor = function () {
        gl.clear(gl.COLOR_BUFFER_BIT)
    };
    this.clearDepth = function () {
        gl.clear(gl.DEPTH_BUFFER_BIT)
    };
    this.clearStencil = function () {
        gl.clear(gl.STENCIL_BUFFER_BIT)
    };
    var M = new THREE.Matrix4, R = new THREE.Matrix3;

    this.setRenderTarget = function (a) {
        if (a) {
            var b

            if (a.isCube) {
                b = a.__webglFramebuffer[a.activeCubeFace]
            }
            else {
                b = a.__webglFramebuffer;
            }

            var e = a.x;

            var f = a.y;

            var g = a.width;

            a = a.height

        }
        else {

            b = null

            f = e = 0

            g = c.width

            a = c.height;
        }

        if (b !== K) {

            gl.bindFramebuffer(gl.FRAMEBUFFER, b)

            K = b

        }

        state.setViewport(e, f, g, a)
    };

    this.render = function (scene, camera, renderTarget, forceClear) {

        this.renderMeshes(scene.children, scene.overrideMaterial, camera, renderTarget, forceClear)

    };

    this.renderMeshes = function (meshes, overrideMaterial, camera, renderTarget, forceClear, forceVisile) {

        Y = null;

        _currentMaterialId = -1;

        Q = null;

        camera.matrixWorldInverse.getInverse(camera.matrixWorld);

        D.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

        N.setFromMatrix(D);

        opaqueObjects.length = 0;

        transparentObjects.length = 0;

        forceVisile = void 0 === forceVisile ? !1 : forceVisile;

        for (var h = 0; h < meshes.length; h += 1) {

            projectObject(meshes[h], overrideMaterial, forceVisile);

        }


        //


        if ( this.info.autoReset === true ) this.info.reset();

        //

        if (!0 === I.sortObjects) {

            opaqueObjects.sort(_opaqueSort)

            transparentObjects.sort(_transparentSort)

        }

        this.setRenderTarget(renderTarget);

        if (this.autoClear || forceClear) {
            this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil);
        }

        renderObjects(opaqueObjects, camera, overrideMaterial);

        renderObjects(transparentObjects, camera, overrideMaterial);

        if (renderTarget && renderTarget.generateMipmaps) {

            // Generate mipmap if we're using any kind of mipmap filtering
            // resolve multisample renderbuffers to a single-sample texture if necessary

            var a = L.setSlot(renderTarget, !1)

            gl.activeTexture(gl.TEXTURE0 + renderTarget.__webglSlot)

            if (renderTarget.isCube) {

                a && gl.bindTexture(gl.TEXTURE_CUBE_MAP, renderTarget.__webglTexture)

                gl.generateMipmap(gl.TEXTURE_CUBE_MAP)
            }
            else {

                a && gl.bindTexture(gl.TEXTURE_2D, renderTarget.__webglTexture)

                gl.generateMipmap(gl.TEXTURE_2D)
            }
        }

        // Ensure depth buffer writing is enabled so it can be cleared on next render

        state.setDepthTest(!0);

        state.setDepthWrite(!0);

        state.setColorWrite(!0);

        state.resetAttributeStates()

    };

    this.uploadNewBuffers = function (mesh) {

        var b = mesh.geometry;

        var a = b.attributes;

        var c = b.attributesKeys;

        if (void 0 === b.__webglInit) {

            b.__webglInit = !0

            b.addEventListener("dispose", onBufferDispose)
        }

        console.assert(b instanceof THREE.BufferGeometry);

        b = 0;

        for (var e = c.length; b < e; b += 1) {

            var f = c[b], h = a[f];

            if ("index" === f) {
                f = gl.ELEMENT_ARRAY_BUFFER
            }
            else {
                f = gl.ARRAY_BUFFER;
            }

            if (h.buffer) {
                !0 === h.needsUpdate && console.assert(!1);

                h.releaseOnLoadedToGpu && (h.array = null);
            }
            else {
                h.buffer = gl.createBuffer();

                gl.bindBuffer(f, h.buffer);

                var k = h.array;

                if (JMT.DETECTOR.ios && f === gl.ARRAY_BUFFER) {

                    console.assert(0 === h.itemSize * k.BYTES_PER_ELEMENT % 4);

                }

                //gl.bufferData(f, k, gl.STATIC_DRAW);
                let usage = (h.usage === undefined) ? gl.STATIC_DRAW : h.usage;
                gl.bufferData(f, k, usage);

                if (k instanceof Float32Array) {

                    h.glType = gl.FLOAT

                }
                else if (k instanceof Int8Array) {

                    h.glType = gl.BYTE

                }
                else if (k instanceof Int16Array) {

                    h.glType = gl.SHORT

                }
                else if (k instanceof Uint16Array) {

                    h.glType = gl.UNSIGNED_SHORT

                }
                else if (k instanceof Uint32Array) {

                    h.glType = gl.UNSIGNED_INT

                }
                else if (k instanceof Uint8Array) {
                    h.glType = gl.UNSIGNED_BYTE
                }
                else {

                    console.assert(!1);

                }

                h.releaseOnLoadedToGpu && (h.array = null);

                h.needsUpdate = !1
            }
        }
    };

    this.updateBuffers = function (mesh) {
        var b = mesh.geometry;

        var a = b.attributes;

        var c = b.attributesKeys;

        if (b.__webglInit) {

            b = 0;

            for (var e = c.length; b < e; b += 1) {

                var f = c[b], h = a[f];

                if ("index" === f) {
                    f = gl.ELEMENT_ARRAY_BUFFER
                }
                else {
                    f = gl.ARRAY_BUFFER;
                }

                if (h.buffer && !0 === h.needsUpdate) {

                    gl.bindBuffer(f, h.buffer);
                    //gl.bufferData(f, h.array, gl.STATIC_DRAW);
                    //gl.bufferSubData( bufferType, 0, array );
                    gl.bufferSubData(f, 0, h.array)

                    h.releaseOnLoadedToGpu && (h.array = null);
                }

            }

        }

    }

    this.uploadTexture = function (a) {

        L.setSlot(a, !1);

        copyTextureToTexture(a)

    };

    this.copyBufferToCubeFaceMip = function (a, b, c, e, f) {
        L.setSlot(f, !1);
        gl.activeTexture(gl.TEXTURE0 + f.__webglSlot);
        gl.bindTexture(gl.TEXTURE_CUBE_MAP, f.__webglTexture);
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + c, a, gl.RGBA, b, b, 0, gl.RGBA, gl.UNSIGNED_BYTE, e)
    };
    this.createCubeTexture = function (a, b) {

        var c = new JMT.Texture;

        c.isCube = !0;

        c.minFilter = b ? GLC.LINEAR_MIPMAP_NEAREST : GLC.LINEAR;

        c.generateMipmaps = !1;

        c.needsUpdate = !1;

        c.addEventListener("dispose", onTextureDispose);

        c.__webglTexture = gl.createTexture();

        L.setSlot(c, !1);

        gl.activeTexture(gl.TEXTURE0 + c.__webglSlot);

        gl.bindTexture(gl.TEXTURE_CUBE_MAP, c.__webglTexture);

        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !1);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

        if (b) {

            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST)

        }
        else {

            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        }

        for (var e = 0; 6 > e; e += 1) {

            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + e, 0, gl.RGBA, a, a, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

        }

        b && gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

        return c
    };
    this.createFrameBufferRenderTarget = function (a) {
        return new JMT.WebGLRenderTargetVR(a)
    };
    this.createRenderTarget = function (a, b, c) {
        a = new JMT.WebGLRenderTarget(a, b, c);
        bindRenderTarget(!1, a);
        return a
    };
    this.createRenderTargetCube = function (a, b, c) {
        a = new JMT.WebGLRenderTargetCube(a, b, c);
        bindRenderTarget(!0, a);
        return a
    };
    this.readPixels = function (a, b, c) {
        gl.readPixels(0, 0, a, b, gl.RGBA, gl.UNSIGNED_BYTE, c)
    }
}

/***/ }),

/***/ "./src/renderers/shaders/SHADERS.js":
/*!******************************************!*\
  !*** ./src/renderers/shaders/SHADERS.js ***!
  \******************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

JMT.SHADERS = {};
JMT.SHADERS["aabb_query_fragment.glsl"] = "//AUTO GENERATED\nvarying vec3 vPositionW;\nuniform int axis;\nvec4 encodeFloat(in float x) {\nfloat xabs = abs(x);\nfloat r = floor(xabs);\nfloat g = fract(xabs);\nreturn vec4(r / 255.0, g, 0.0, 0.0);\n}\nvoid main() {\nvec3 viewW = cameraPosition - vPositionW;\nif (axis == 0) {\ngl_FragColor = encodeFloat(viewW.x);\n} else if (axis == 1) {\ngl_FragColor = encodeFloat(viewW.y);\n} else if (axis == 2) {\ngl_FragColor = encodeFloat(viewW.z);\n}\n}\n";
JMT.SHADERS["aabb_query_vertex.glsl"] = "//AUTO GENERATED\nvec4 transformPosition() {\nreturn vec4(\nt0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\nt1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\nt2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n1.0);\n}\nvarying vec3 vPositionW;\nvoid main() {\nvec4 transformedPosition = transformPosition();\nvPositionW = (modelMatrix * transformedPosition).xyz;\ngl_Position = projectionMatrix * modelViewMatrix * transformedPosition;\n}\n";
JMT.SHADERS["accumulate_fragment.glsl"] = "//AUTO GENERATED\nuniform float weight;\nuniform sampler2D inputBuffer;\nvarying vec2 vUv;\nvoid main() {\nvec3 inputColor = texture2D(inputBuffer, vUv).rgb;\ngl_FragColor = vec4(inputColor, weight);\n}\n";
JMT.SHADERS["accumulate_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["alpha_stats_combine_fragment.glsl"] = "//AUTO GENERATED\nuniform sampler2D map;\nuniform vec2 mapUvStep;\nuniform vec2 mapUvScale;\nvarying vec2 vUv;\nvoid main() {\nvec2 corner = vUv * mapUvScale- mapUvStep;\nvec2 uv = corner + 0.5 * mapUvStep;\nvec4 p0 = texture2D(map, uv);\nvec4 p1 = texture2D(map, uv + vec2(0.0, mapUvStep.y));\nvec4 p2 = texture2D(map, uv + vec2(mapUvStep.x, 0.0));\nvec4 p3 = texture2D(map, uv + vec2(mapUvStep.x, mapUvStep.y));\ngl_FragColor = vec4((p0.r + p1.r + p2.r + p3.r) / 4.0,\n(p0.g + p1.g + p2.g + p3.g) / 4.0, 0.0, 1.0);\nreturn;\n}\n";
JMT.SHADERS["alpha_stats_fragment.glsl"] = "//AUTO GENERATED\nuniform sampler2D map;\nuniform vec2 mapUvStep;\nuniform vec4 mapUvOffsetScale;\nvarying vec2 vUv;\nvoid main() {\nvec2 corner = vUv * mapUvOffsetScale.zw + mapUvOffsetScale.xy - mapUvStep;\nvec2 uv = corner + 0.5 * mapUvStep;\nconst float bias = -1.0;\nfloat a0 = texture2D(map, uv, bias).a;\nfloat a1 = texture2D(map, uv + vec2(0.0, mapUvStep.y), bias).a;\nfloat a2 = texture2D(map, uv + vec2(mapUvStep.x, 0.0), bias).a;\nfloat a3 = texture2D(map, uv + vec2(mapUvStep.x, mapUvStep.y), bias).a;\nfloat fully_transparent_count = step(0.0, -a0) + step(0.0, -a1) +\nstep(0.0, -a2) + step(0.0, -a3);\nfloat partialy_transparent_count =\nstep(0.0, -abs(clamp(a0, 0.05, 0.95) - a0)) +\nstep(0.0, -abs(clamp(a1, 0.05, 0.95) - a1)) +\nstep(0.0, -abs(clamp(a2, 0.05, 0.95) - a2)) +\nstep(0.0, -abs(clamp(a3, 0.05, 0.95) - a3));\ngl_FragColor = vec4(step(4.0, partialy_transparent_count),\nfully_transparent_count / 4.0,\n0.0, 1.0);\nreturn;\n}\n";
JMT.SHADERS["alpha_stats_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["anchor_sprite_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main() {\nvUv = uv;\nvec4 mvPosition = modelViewMatrix * vec4(0.0, 0.0, 0.0, 1.0);\nvec2 scale;\nscale.x = length(modelMatrix[0].xyz);\nscale.y = length(modelMatrix[1].xyz);\nvec2 alignedPosition = position.xy * scale;\nmvPosition.xy += alignedPosition;\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["anchor_vertex.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nvec3 sphericalDecode(in vec2 spNormal) {\nfloat theta = (spNormal.x / 254.0 + 0.5) * PI;\nfloat phi = spNormal.y * (PI / 127.0);\nfloat sinTheta = sin(theta);\nreturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));\n}\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\nvarying vec2 vUv;\n#endif\n#if defined(USE_BUMP_TEXTURE)\nvarying vec3 vNormalV;\nvarying vec3 vPositionV;\n#endif\n#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT)\nvarying vec3 vNormalW;\nvarying vec3 vPositionW;\n#endif\nvoid main() {\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_ENVMAP) || defined(USE_HEADLIGHT)\nvec3 positionW = (modelMatrix * vec4(position, 1.0)).xyz;\nvec3 normal = sphericalDecode(sphericalNormal);\nvec3 normalW = mat3(modelMatrix[0].xyz,\nmodelMatrix[1].xyz,\nmodelMatrix[2].xyz) * normal;\nnormalW = normalize(normalW);\n#endif\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE)\nvec3 anchorCenterW = vec3(modelMatrix[3].xyz);\nvec3 cameraUpW = vec3(modelViewMatrix[0].y,\nmodelViewMatrix[1].y,\nmodelViewMatrix[2].y);\nvec3 forwardW = normalize(anchorCenterW - cameraPosition);\nvec3 rightW = cross(forwardW, cameraUpW);\nrightW.z = 0.0;\nrightW = normalize(rightW);\nvec3 upW = cross(rightW, forwardW);\nvUv = vec2(dot(normalW, rightW) * 0.5 + 0.5, dot(normalW, upW) * 0.5 + 0.5);\n#endif\nvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n#if defined(USE_BUMP_TEXTURE)\nvPositionV = -mvPosition.xyz;\nvNormalV = normalize(normalMatrix * normal);\n#endif\n#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT)\nvNormalW = normalW;\nvPositionW = positionW;\n#endif\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["cubemap_filter_fragment.glsl"] = "//AUTO GENERATED\nvec3 hdrDecode(in vec4 rgbm) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\nreturn r * r;\n}\nvec4 hdrEncode(in vec3 rgb) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = sqrt(rgb) / rgbmScale;\nfloat m = max(max(r.r, r.g), r.b);\nm = clamp(m, 1.0 / 255.0, 1.0);\nm = ceil(m * 255.0) / 255.0;\nr /= m;\nreturn vec4(r.r, r.g, r.b, (1.0 - m));\n}\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nfloat rnd(vec2 uv) {\nreturn fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) {\nfloat phi = uv.y * 2.0 * PI;\nfloat cosTheta = sqrt(1.0 - uv.x);\nfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\nvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\nreturn normalize(mix(vecSpace * sampleDir, cubeDir, gloss));\n}\nmat3 matrixFromVector(vec3 n) { // frisvad\nfloat a = 1.0 / (1.0 + n.z);\nfloat b = -n.x * n.y * a;\nvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\nvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\nreturn mat3(b1, b2, n);\n}\nuniform samplerCube envMap;\nuniform float mipSize;\nuniform float face;\nuniform float gloss;\nvoid main(void) {\nvec2 st = 2.0 * floor(gl_FragCoord.xy) / (mipSize - 1.0) - 1.0;\nvec3 vec;\nif (face == 0.0) {\nvec = vec3(1, -st.y, -st.x);\n} else if (face == 1.0) {\nvec = vec3(-1, -st.y, st.x);\n} else if (face == 2.0) {\nvec = vec3(st.x, 1, st.y);\n} else if (face == 3.0) {\nvec = vec3(st.x, -1, -st.y);\n} else if (face == 4.0) {\nvec = vec3(st.x, -st.y, 1);\n} else {\nvec = vec3(-st.x, -st.y, -1);\n}\nmat3 vecSpace = matrixFromVector(normalize(vec));\nvec3 color = vec3(0.0);\nconst int samples = 200;\nvec3 vect;\nfor(int i = 0; i < samples; i++) {\nfloat sini = sin(float(i));\nfloat cosi = cos(float(i));\nfloat rand = rnd(vec2(sini, cosi));\nvect = hemisphereSample_cos(\nvec2(float(i) / float(samples), rand), vecSpace, vec, gloss);\ncolor += hdrDecode(textureCube(envMap, vect));\n}\ncolor /= float(samples);\ngl_FragColor = hdrEncode(color);\n}\n";
JMT.SHADERS["cubemap_filter_vertex.glsl"] = "//AUTO GENERATED\nvoid main() {\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["cube_to_equirect_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nuniform samplerCube panoramaCube;\nvarying vec2 vUv;\nvoid main() {\nvec2 uv = vUv;\nfloat longitude = uv.x * 2. * PI;\nfloat latitude = uv.y * PI;\nvec3 dir = vec3(\nsin(longitude) * sin(latitude),\ncos(longitude) * sin(latitude),\ncos(latitude));\ngl_FragColor = textureCube(panoramaCube, normalize(dir));\n}\n";
JMT.SHADERS["cube_to_equirect_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main()  {\nvUv = vec2(uv.x, uv.y - 1.0);\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["editor_light_fragment.glsl"] = "//AUTO GENERATED\nfloat _l2g(in float x) {\nreturn (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n}\nvec3 linearToGamma(in vec3 rgb) {\nreturn vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n}\nvec3 linearToGammaUnreal(in vec3 rgb) {\nreturn rgb / (rgb + 0.187) * 1.035;\n}\nuniform vec3 color;\nuniform vec3 highlight;\nuniform float highlightMix;\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvoid main() {\nvec3 lVector = normalize(vViewPosition.xyz);\nfloat pointDiffuse = max(dot(normalize(vNormal), lVector), 0.0);\nvec3 lightColor = color * pointDiffuse;\nlightColor = mix(lightColor, highlight, highlightMix);\ngl_FragColor.xyz = min(linearToGamma(lightColor), 1.0);\n}\n";
JMT.SHADERS["editor_light_vertex.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nvec3 sphericalDecode(in vec2 spNormal) {\nfloat theta = (spNormal.x / 254.0 + 0.5) * PI;\nfloat phi = spNormal.y * (PI / 127.0);\nfloat sinTheta = sin(theta);\nreturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));\n}\nvarying vec3 vNormal;\nvarying vec3 vViewPosition;\nvoid main() {\nvec3 normal = sphericalDecode(sphericalNormal);\nvNormal = normalize(normalMatrix * normal);\nvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\nvViewPosition = -mvPosition.xyz;\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["equirect_sky_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nfloat _g2l(in float x) {\nreturn (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\nvec3 gammaToLinear(in vec3 rgb) {\nreturn vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));\n}\nfloat _l2g(in float x) {\nreturn (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n}\nvec3 linearToGamma(in vec3 rgb) {\nreturn vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n}\nvec3 linearToGammaUnreal(in vec3 rgb) {\nreturn rgb / (rgb + 0.187) * 1.035;\n}\nvec3 hdrDecode(in vec4 rgbm) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\nreturn r * r;\n}\nvec4 hdrEncode(in vec3 rgb) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = sqrt(rgb) / rgbmScale;\nfloat m = max(max(r.r, r.g), r.b);\nm = clamp(m, 1.0 / 255.0, 1.0);\nm = ceil(m * 255.0) / 255.0;\nr /= m;\nreturn vec4(r.r, r.g, r.b, (1.0 - m));\n}\nuniform sampler2D map;\nuniform float exposure;\nuniform float cameraGamma;\nvarying vec2 vUv;\n#ifdef USE_COLORMAP\nvec3 colormap(in sampler2D texture, in vec3 color) {\nconst float resolution = 16.0;\nconst float maxValueIndex = resolution - 1.0;\nconst float sliceWidth = 1.0 / resolution;\nconst float slicePixelWidth = sliceWidth / resolution;\nconst float sliceMarginWidth = 0.5 * slicePixelWidth;\nconst float sliceInnerWidth = sliceWidth - slicePixelWidth;\nconst float slicePixelHeight = 1.0 / resolution;\nconst float sliceMarginHeight = 0.5 * slicePixelHeight;\nconst float sliceInnerHeight = 1.0 - slicePixelHeight;\nfloat bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);\nfloat bSlice1 = bSlice0 + 1.0;\nfloat bOffset = color.b * maxValueIndex - bSlice0;\nfloat rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;\nfloat gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;\nfloat rPos0 = rSlicePos + (bSlice0 * sliceWidth);\nfloat rPos1 = rSlicePos + (bSlice1 * sliceWidth);\nvec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;\nvec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;\nreturn mix(color0, color1, bOffset);\n}\nuniform sampler2D colorMap;\n#endif\nvoid main() {\n#ifdef USE_RGBM_MAP\nvec4 colorRgbm = texture2D(map, vUv);\nvec3 colorLinear = hdrDecode(colorRgbm);\n#else\nvec3 colorLinear = gammaToLinear(texture2D(map, vUv).xyz);\n#endif\n#ifdef HDR_OUTPUT\n#ifdef USE_RGBM_MAP\ngl_FragColor = colorRgbm;\n#else\ngl_FragColor = hdrEncode(10.0 * colorLinear);\n#endif\n#else\nvec3 colorExposed = pow(exposure * colorLinear, vec3(cameraGamma));\nvec3 colorGamma =  linearToGammaUnreal(colorExposed);\n#ifdef USE_COLORMAP\ngl_FragColor.xyz = colormap(colorMap, colorGamma);\n#else\ngl_FragColor.xyz = colorGamma;\n#endif\n#endif\n}\n";
JMT.SHADERS["equirect_sky_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 vUv;\nvoid main() {\nvUv = uv;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["gaze_pointer_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nconst float pointRadius = 0.01;\nconst float pointBorder = 0.005;\nconst float timerRadius = 0.04;\nconst float timerBorder = 0.02;\nconst vec3 timerColor =  vec3(0.298, 0.619, 0.851);\nvarying vec2 coords;\nuniform float circleSpan;\nvoid main() {\nfloat dist =  sqrt(dot(coords, coords));\nif (dist < pointRadius) {\nfloat a = 1.0 - smoothstep(pointRadius - pointBorder, pointRadius, dist);\ngl_FragColor= vec4(1.0, 1.0, 1.0, a);\n} else if (-atan(coords.x, -coords.y) < circleSpan) {\nfloat a2 = smoothstep(timerRadius - timerBorder, timerRadius, dist) -\nsmoothstep(timerRadius, timerRadius + timerBorder, dist);\ngl_FragColor = vec4(timerColor, a2);\n} else {\ndiscard;\n}\n}\n";
JMT.SHADERS["gaze_pointer_vertex.glsl"] = "//AUTO GENERATED\nvarying vec2 coords;\nvoid main() {\ncoords = vec2(position.x, position.y);\nvec4 outPosition = projectionMatrix *  modelViewMatrix * vec4(position, 1.0);\noutPosition.z = -0.1;\ngl_Position = outPosition;\n}\n";
JMT.SHADERS["light_visibility_dilate_fragment.glsl"] = "//AUTO GENERATED\nuniform sampler2D lightVisibilityMap;\nvarying vec2 vUv;\nuniform vec2 sizeInv;\nvoid main() {\nvec4 zero = vec4(0.0);\nvec4 visibility = texture2D(lightVisibilityMap, vUv);\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv - vec2(sizeInv.x, 0.0));\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv - vec2(0.0, sizeInv.y));\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv + vec2(sizeInv.x, 0.0));\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv + vec2(0.0, sizeInv.y));\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv + sizeInv);\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv - sizeInv);\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv + vec2(sizeInv.x, -sizeInv.y));\nif (!all(equal(visibility, zero))) {\ngl_FragColor = visibility;\nreturn;\n}\nvisibility = texture2D(lightVisibilityMap, vUv + vec2(-sizeInv.x, sizeInv.y));\ngl_FragColor = visibility;\n}\n";
JMT.SHADERS["light_visibility_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nfloat rnd(vec2 uv) {\nreturn fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);\n}\nvec3 hemisphereSample_cos(vec2 uv, mat3 vecSpace, vec3 cubeDir, float gloss) {\nfloat phi = uv.y * 2.0 * PI;\nfloat cosTheta = sqrt(1.0 - uv.x);\nfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\nvec3 sampleDir = vec3(cos(phi) * sinTheta, sin(phi) * sinTheta, cosTheta);\nreturn normalize(mix(vecSpace * sampleDir, cubeDir, gloss));\n}\nmat3 matrixFromVector(vec3 n) { // frisvad\nfloat a = 1.0 / (1.0 + n.z);\nfloat b = -n.x * n.y * a;\nvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\nvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\nreturn mat3(b1, b2, n);\n}\n#define SPOT_PROPERTIES_NEEDED\n#define POINT_LIGHT_TYPE 0.0\n#define SPOT_LIGHT_TYPE 1.0\nuniform sampler2D lightAttrMap;\nuniform float lightsCount;\nstruct Light {\nvec3 positionW;\nfloat strength; // TODO: rename to intensity\nfloat size; // radius\nvec3 color;\n#ifdef SPOT_PROPERTIES_NEEDED\nfloat type; // POINT_LIGHT_TYPE or SPOT_LIGHT_TYPE\nvec3 spotDirectionW;\nfloat spotHalfAngle;\n#endif\n};\nconst float lightAttrFragments = 4.0;\nvoid readLightProperties(in float lightId, out Light light) {\nfloat lightAttrFragmentOffset = 1.0 / (lightAttrFragments * lightsCount);\nvec2 offset = vec2(lightId / lightsCount + 0.5 * lightAttrFragmentOffset,\n0.0);\nvec4 lightAttr = texture2D(lightAttrMap, offset);\nlight.positionW.xyz = lightAttr.xyz;\nlight.size = lightAttr.w;\noffset.x += lightAttrFragmentOffset;\nlightAttr = texture2D(lightAttrMap, offset);\nlight.color.xyz = lightAttr.xyz;\nlight.strength = lightAttr.w;\n#ifdef SPOT_PROPERTIES_NEEDED\noffset.x += lightAttrFragmentOffset;\nlightAttr = texture2D(lightAttrMap, offset);\nlight.type = lightAttr.x;\nlight.spotDirectionW.xyz = lightAttr.yzw;\noffset.x += lightAttrFragmentOffset;\nlightAttr = texture2D(lightAttrMap, offset);\nlight.spotHalfAngle = lightAttr.x;\n#endif\n}\n#define LENGTH_EPSILON 0.001\nuniform samplerCube objectDistanceMap;\nuniform sampler2D combineWithMap;\nuniform float objectId;\nuniform float lightId;\nvarying vec3 vNormalW;\nvarying vec3 vPositionW;\nvarying vec2 vUv2;\nvoid markAsReached(vec4 currentVisibility) {\nconst float fragmentReached = 0.01;\ngl_FragColor = max(currentVisibility, fragmentReached);\n}\nvoid main(void){\nvec4 currentVisibility = texture2D(combineWithMap, vUv2);\nLight light;\nreadLightProperties(lightId, light);\nvec3 normalW = normalize(vNormalW);\nvec3 toLightW = light.positionW - vPositionW;\nvec3 toLastVisiblePointW = toLightW + normalW * light.size;\nif (dot(normalW, toLastVisiblePointW) <= 0.0) {\nmarkAsReached(currentVisibility);\nreturn;\n}\nfloat lightDistance = length(toLightW);\nfloat spotStrengthFactor = 1.0;\nif (lightDistance >= LENGTH_EPSILON && light.type == SPOT_LIGHT_TYPE) {\nfloat spotHeight = dot(light.spotDirectionW, -toLightW);\nif (spotHeight < LENGTH_EPSILON) {\nmarkAsReached(currentVisibility);\nreturn;\n}\nfloat cosPointDir = spotHeight / lightDistance;\nfloat spotSlantHeight = spotHeight / cos(light.spotHalfAngle);\nfloat spotSinHalfFalloffRange = light.size / spotSlantHeight;\nfloat pointDirAngle = acos(cosPointDir);\nfloat spotHalfFalloffRange;\nif (spotSinHalfFalloffRange > 1.0) {\nspotHalfFalloffRange = light.spotHalfAngle / 6.0;\n} else {\nspotHalfFalloffRange =\nmin(asin(spotSinHalfFalloffRange), light.spotHalfAngle / 6.0);\n}\nfloat spotFalloffBegin = light.spotHalfAngle - spotHalfFalloffRange;\nif (pointDirAngle < spotFalloffBegin) {\nspotStrengthFactor = cos(pointDirAngle);\n} else {\nfloat linearFalloffWeight =\n(pointDirAngle - spotFalloffBegin) / (2.0 * spotHalfFalloffRange);\nspotStrengthFactor = mix(cos(spotFalloffBegin), 0.0, linearFalloffWeight);\n}\nif (spotStrengthFactor <= 0.0) {\nmarkAsReached(currentVisibility);\nreturn;\n}\n}\nvec3 cubeDir = -toLightW / lightDistance;\nfloat bias = 0.05;\nfloat visibility = 0.0;\nfloat diskRadius = 1.0 - light.size / (2.0 * lightDistance);\ndiskRadius = 0.97;\nmat3 cubeDirSpace = matrixFromVector(cubeDir);\nconst int samples = 50;\nvec3 newCubeDir;\nfor(int i = 0; i < samples; i++) {\nfloat sini = sin(float(i));\nfloat cosi = cos(float(i));\nfloat rand = rnd(vec2(sini, cosi));\nnewCubeDir = hemisphereSample_cos(vec2(float(i) / float(samples), rand),\ncubeDirSpace, cubeDir, diskRadius);\nvec4 objectDistance = textureCube(objectDistanceMap, newCubeDir);\nfloat collisionObjectId = objectDistance.x;\nfloat collisionDistance = objectDistance.y;\nif (objectId == collisionObjectId ||\ncollisionDistance > lightDistance - bias) {\nvisibility += 1.0;\n}\n}\nvisibility /= float(samples);\nvisibility *= spotStrengthFactor;\nif (visibility != 0.0) {\nconst float channelTaken = 1025.0;\nvec4 outputVisibility = min(channelTaken * currentVisibility, channelTaken);\nfloat visibilityChannel = float(lightId) + clamp(visibility, 0.001, 0.999);\ngl_FragColor = max(outputVisibility, visibilityChannel);\n} else {\nmarkAsReached(currentVisibility);\n}\n}\n";
JMT.SHADERS["light_visibility_free_channel_fragment.glsl"] = "//AUTO GENERATED\nuniform sampler2D lightVisibilityMap;\nvarying vec2 vUv;\nuniform vec2 sizeInv;\nuniform float threshold;\nvoid main() {\nvec2 corner = vUv - sizeInv;\nvec2 uv = corner + 0.5 * sizeInv;\nvec4 visibility0 = texture2D(lightVisibilityMap, uv);\nvec4 visibility1 = texture2D(lightVisibilityMap, uv + vec2(0.0, sizeInv.y));\nvec4 visibility2 = texture2D(lightVisibilityMap, uv + vec2(sizeInv.x, 0.0));\nvec4 visibility3 = texture2D(lightVisibilityMap,\nuv + vec2(sizeInv.x, sizeInv.y));\ngl_FragColor = step(threshold, visibility0) + step(threshold, visibility1) +\nstep(threshold, visibility2) + step(threshold, visibility3);\n}\n";
JMT.SHADERS["light_visibility_vertex.glsl"] = "//AUTO GENERATED\nvarying vec3 vNormalW;\nvarying vec3 vPositionW;\nvarying vec2 vUv2;\nvoid main() {\nvNormalW = mat3(modelMatrix[0].xyz,\nmodelMatrix[1].xyz,\nmodelMatrix[2].xyz) * normal;\nvNormalW = normalize(vNormalW);\nvPositionW = (modelMatrix * vec4(position, 1.0)).xyz;\nvUv2 = uv2;\ngl_Position = vec4(2.0 * uv2.x - 1.0, 2.0 * uv2.y - 1.0, 1.0, 1.0);\n}\n";
JMT.SHADERS["luma_fragment.glsl"] = "//AUTO GENERATED\nvec3 hdrDecode(in vec4 rgbm) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\nreturn r * r;\n}\n#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\nvec3 getLightIntensity() {\nreturn hdrDecode(texture2D(lightMap, vUv2));\n}\n#else // NOT USE_LIGHTMAP\nvec3 getLightIntensity() {\nreturn vec3(1.0);\n}\n#endif\nuniform vec3 color;\nvoid main() {\nvec3 receivedLight = getLightIntensity();\nvec3 diffuseLight = receivedLight * color;\nfloat luma = 0.299 * diffuseLight.r +\n0.587 * diffuseLight.g +\n0.114 * diffuseLight.b;\ngl_FragColor.r = fract(luma);\ngl_FragColor.g = floor(luma) / 255.0;\n}\n";
JMT.SHADERS["mirror_fragment.glsl"] = "//AUTO GENERATED\nuniform vec3 mirrorColor;\nuniform sampler2D mirrorSampler;\nvarying vec4 mirrorCoord;\nfloat blendOverlay(float base, float blend) {\nreturn (base < 0.5 ? (2.0 * base * blend) :\n(1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));\n}\nvoid main() {\nvec4 color = texture2DProj(mirrorSampler, mirrorCoord);\ncolor = vec4(blendOverlay(mirrorColor.r, color.r),\nblendOverlay(mirrorColor.g, color.g),\nblendOverlay(mirrorColor.b, color.b), 1.0);\ngl_FragColor = color;\n}\n";
JMT.SHADERS["mirror_vertex.glsl"] = "//AUTO GENERATED\nuniform mat4 textureMatrix;\nvarying vec4 mirrorCoord;\nvoid main() {\nvec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\nvec4 worldPosition = modelMatrix * vec4(position, 1.0);\nmirrorCoord = textureMatrix * worldPosition;\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["object_distance_byte_fragment.glsl"] = "//AUTO GENERATED\nuniform int objectId;\nvarying vec3 vPositionW;\nvoid main(void) {\nfloat cameraDistance = min(distance(cameraPosition, vPositionW), 255.0);\nint x = objectId / 256;\nint y = objectId - 256 * x;\nfloat z = floor(cameraDistance);\nfloat a = fract(cameraDistance);\ngl_FragColor = vec4(float(x) / 255.0, float(y) / 255.0,\nz / 255.0, a);\n}\n";
JMT.SHADERS["object_distance_float_fragment.glsl"] = "//AUTO GENERATED\nuniform int objectId;\nvarying vec3 vPositionW;\nvoid main(void){\nfloat cameraDistance = distance(cameraPosition, vPositionW);\ngl_FragColor = vec4(objectId, cameraDistance, 0.0, 1.0);\n}\n";
JMT.SHADERS["object_distance_vertex.glsl"] = "//AUTO GENERATED\nvec4 transformPosition() {\nreturn vec4(\nt0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\nt1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\nt2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n1.0);\n}\nvarying vec3 vPositionW;\nvoid main() {\nvec4 transformedPosition = transformPosition();\nvPositionW = (modelMatrix * transformedPosition).xyz;\ngl_Position = projectionMatrix * modelViewMatrix * transformedPosition;\n}\n";
JMT.SHADERS["procedural_sky_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nuniform vec3 topColor;\nuniform vec3 bottomColor;\nuniform float sinBottomAngle;\nuniform float exponent;\nvarying vec3 vWorldDirection;\n#ifdef HDR_OUTPUT\nfloat _g2l(in float x) {\nreturn (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\nvec3 gammaToLinear(in vec3 rgb) {\nreturn vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));\n}\nvec4 hdrEncode(in vec3 rgb) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = sqrt(rgb) / rgbmScale;\nfloat m = max(max(r.r, r.g), r.b);\nm = clamp(m, 1.0 / 255.0, 1.0);\nm = ceil(m * 255.0) / 255.0;\nr /= m;\nreturn vec4(r.r, r.g, r.b, (1.0 - m));\n}\n#endif\n#ifdef USE_COLORMAP\nvec3 colormap(in sampler2D texture, in vec3 color) {\nconst float resolution = 16.0;\nconst float maxValueIndex = resolution - 1.0;\nconst float sliceWidth = 1.0 / resolution;\nconst float slicePixelWidth = sliceWidth / resolution;\nconst float sliceMarginWidth = 0.5 * slicePixelWidth;\nconst float sliceInnerWidth = sliceWidth - slicePixelWidth;\nconst float slicePixelHeight = 1.0 / resolution;\nconst float sliceMarginHeight = 0.5 * slicePixelHeight;\nconst float sliceInnerHeight = 1.0 - slicePixelHeight;\nfloat bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);\nfloat bSlice1 = bSlice0 + 1.0;\nfloat bOffset = color.b * maxValueIndex - bSlice0;\nfloat rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;\nfloat gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;\nfloat rPos0 = rSlicePos + (bSlice0 * sliceWidth);\nfloat rPos1 = rSlicePos + (bSlice1 * sliceWidth);\nvec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;\nvec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;\nreturn mix(color0, color1, bOffset);\n}\nuniform sampler2D colorMap;\n#endif\nvoid main() {\nfloat sinDirection = normalize(vWorldDirection).z;\nfloat w = max(0.0, (sinDirection - sinBottomAngle) / (1.0 - sinBottomAngle));\nvec3 colorGamma = mix(bottomColor, topColor, pow(w, exponent));\n#ifdef HDR_OUTPUT\nvec3 colorLinear = gammaToLinear(colorGamma);\ngl_FragColor = hdrEncode(10.0 * colorLinear);\n#else\n#ifdef USE_COLORMAP\ngl_FragColor.xyz = colormap(colorMap, colorGamma);\n#else\ngl_FragColor.xyz = colorGamma;\n#endif\n#endif\n}\n";
JMT.SHADERS["procedural_sky_vertex.glsl"] = "//AUTO GENERATED\nvarying vec3 vWorldDirection;\nvoid main() {\nvec3 positionW = (modelMatrix * vec4(position, 1.0)).xyz;\nvWorldDirection = positionW - cameraPosition;\ngl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["rotate_gizmo_material_fragment.glsl"] = "//AUTO GENERATED\nuniform vec3 color;\nuniform float opacity;\nuniform vec3 gizmoPosition;\nuniform float sphereRadius;\nvarying vec4 mPosition;\nvoid discardIfRayIntersectsSphere(vec3 r0, vec3 rd, vec3 s0, float sr) {\nfloat a = dot(rd, rd);\nvec3 s0_r0 = r0 - s0;\nfloat b = 2.0 * dot(rd, s0_r0);\nfloat c = dot(s0_r0, s0_r0) - (sr * sr);\nfloat delta = b * b - 4.0 * a * c;\nif (delta >= 0.0 && -b - sqrt(delta) > 0.0) {\ndiscard;\n}\n}\nvoid main() {\nvec4 outColor;\noutColor.rgb = color;\noutColor.a = opacity;\nvec3 toCamera = normalize(cameraPosition - gizmoPosition);\ndiscardIfRayIntersectsSphere(mPosition.xyz, toCamera, gizmoPosition, sphereRadius);\ngl_FragColor = outColor;\n}\n";
JMT.SHADERS["rotate_gizmo_material_vertex.glsl"] = "//AUTO GENERATED\nvec4 transformPosition() {\nreturn vec4(\nt0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\nt1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\nt2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n1.0);\n}\nvarying vec4 mPosition;\nvoid main() {\nvec4 p = vec4(position, 1.0);\nmPosition = modelMatrix * p;\nvec4 mvPosition = modelViewMatrix * p;\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["standard_material_fragment.glsl"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nfloat _g2l(in float x) {\nreturn (x <= 0.04045) ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n}\nvec3 gammaToLinear(in vec3 rgb) {\nreturn vec3(_g2l(rgb.r), _g2l(rgb.g), _g2l(rgb.b));\n}\nfloat _l2g(in float x) {\nreturn (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n}\nvec3 linearToGamma(in vec3 rgb) {\nreturn vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n}\nvec3 linearToGammaUnreal(in vec3 rgb) {\nreturn rgb / (rgb + 0.187) * 1.035;\n}\nvec3 hdrDecode(in vec4 rgbm) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = rgbm.rgb * (rgbmScale * (1.0 - rgbm.a));\nreturn r * r;\n}\n#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\nvarying vec3 vNormalW;\nvarying vec3 vPositionW;\n#endif\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\nvarying vec2 vUv;\n#endif\n#if defined(USE_BUMP_TEXTURE)\nvarying vec3 vPositionV;\nvarying vec3 vNormalV;\nuniform float bumpScale;\nuniform sampler2D bumpTexture;\nvec2 dBumpdxy() {\nvec2 texdx = dFdx(vUv);\nvec2 texdy = dFdy(vUv);\nfloat Hll = bumpScale * texture2D(bumpTexture, vUv).x;\nfloat dBx = bumpScale * texture2D(bumpTexture, vUv + texdx).x - Hll;\nfloat dBy = bumpScale * texture2D(bumpTexture, vUv + texdy).x - Hll;\nreturn vec2(dBx, dBy);\n}\nvec3 perturbNormal(in vec3 surfPos, in vec3 surfNorm) {\nvec2 dBdxy = dBumpdxy();\nvec3 vSigmaX = dFdx(surfPos);\nvec3 vSigmaY = dFdy(surfPos);\nvec3 R1 = cross(vSigmaY, surfNorm);\nvec3 R2 = cross(surfNorm, vSigmaX);\nfloat fDet = dot(vSigmaX, R1);\nvec3 vGrad = sign(fDet) * (dBdxy.x * R1 + dBdxy.y * R2);\nreturn normalize(abs(fDet) * surfNorm - vGrad);\n}\n#endif\n#ifdef USE_BASE_COLOR_TEXTURE\nuniform sampler2D baseColorTexture;\nuniform vec4 baseColorAtlasUvMod;\nuniform float alphaDiscardThreshold;\n#ifdef USE_PARALLAX_CORRECTION\n#endif\n#else\nuniform vec3 baseColor;\n#endif\nuniform float opacity;\nuniform vec4 baseColorCorrection;\nvec3 getBaseColor(out float alpha) {\n#ifdef USE_BASE_COLOR_TEXTURE\n#ifdef USE_PARALLAX_CORRECTION\n#else\nvec2 baseColorUv = vUv;\n#endif\nbaseColorUv = baseColorUv * baseColorAtlasUvMod.zw + baseColorAtlasUvMod.xy;\n#ifdef USE_ALPHA_IN_LOWER_HALF\nvec4 baseColorGamma = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 + .5 * baseColorUv.y));\nfloat textureAlpha = texture2D(baseColorTexture, vec2(baseColorUv.x, .5 * baseColorUv.y)).r;\n#else\nvec4 baseColorGamma = texture2D(baseColorTexture, baseColorUv);\nfloat textureAlpha = baseColorGamma.a;\n#endif\nvec3 baseColor = gammaToLinear(baseColorGamma.rgb);\nalpha = opacity * textureAlpha;\n#else // NOT USE_BASE_COLOR_TEXTURE\nalpha = opacity;\n#endif\nvec3 baseColorCorrected = baseColorCorrection.a * baseColor +\nbaseColorCorrection.rgb;\nreturn clamp(baseColorCorrected, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n}\n#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\nuniform sampler2D lightMap;\nvec3 getLightIntensity() {\nreturn hdrDecode(texture2D(lightMap, vUv2));\n}\n#else // NOT USE_LIGHTMAP\nvec3 getLightIntensity() {\nreturn vec3(1.0);\n}\n#endif\n#ifdef USE_ROUGHNESS_TEXTURE\nuniform sampler2D roughnessTexture;\n#else\nuniform float roughness;\n#endif\n#ifdef USE_METALLIC_TEXTURE\nuniform sampler2D metallicTexture;\n#else\nuniform float metallic;\n#endif\nvec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity,\ninout float opacity);\n#if defined(USE_DYNAMIC_LIGHT) || defined(USE_ENVMAP)\nconst float DLT = 0.001;\n#ifdef USE_ENVMAP\nuniform samplerCube envMap;\nuniform float envMipsCount;\n#ifdef HAVE_TEXTURE_LOD\n#else\nuniform samplerCube envMap2;\n#endif\n#endif\nstruct Roughness {\n#ifdef USE_DYNAMIC_LIGHT\n#endif\n#ifdef USE_ENVMAP\nfloat envFresnel; // (1.0 - roughness)^2, used for Fresnel with env map\nfloat envMipLevel0;\nfloat envMipLevel1;\nfloat envMipMixFactor;\n#endif\n};\nRoughness getRoughnessFactors() {\nRoughness r;\n#ifdef USE_ROUGHNESS_TEXTURE\nfloat roughness = texture2D(roughnessTexture, vUv).x;\n#endif // else roughness is a uniform\nfloat roughness2 = roughness * roughness;\n#ifdef USE_DYNAMIC_LIGHT\n#endif\n#ifdef USE_ENVMAP\nfloat maxMipLevel = envMipsCount - 1.0;\nfloat mipSelector = roughness * maxMipLevel;\nr.envMipLevel0 = floor(mipSelector);\nr.envMipLevel1 = min(r.envMipLevel0 + 1.0, maxMipLevel);\nr.envMipMixFactor = fract(mipSelector);\nr.envFresnel = (roughness2 - 2.0 * roughness + 1.0);\n#endif\nreturn r;\n}\n#ifdef USE_ENVMAP\n#ifdef USE_ENVMAP_PROJECT\nuniform vec3 envBoxMin;\nuniform vec3 envBoxMax;\nuniform vec3 envMapPosW;\nconst vec3 infBox = vec3(1000.0);\nvec3 cubeMapProject(vec3 reflectionW) {\nvec3 firstPlaneIntersect = (envBoxMax - vPositionW) / reflectionW;\nvec3 secondPlaneIntersect = (envBoxMin - vPositionW) / reflectionW;\nvec3 furthestPlane = max(firstPlaneIntersect, secondPlaneIntersect);\nvec3 furthestPlaneNonNeg =\nstep(0.0, -furthestPlane) * infBox + abs(furthestPlane);\nfloat distance = min(min(furthestPlaneNonNeg.x, furthestPlaneNonNeg.y),\nfurthestPlaneNonNeg.z);\n/*if (furthestPlane.x > 0.0){\ndistance = furthestPlane.x;\n}\nif (furthestPlane.y > 0.0) {\ndistance = min(distance, furthestPlane.y);\n}\nif (furthestPlane.z > 0.0) {\ndistance = min(distance, furthestPlane.z);\n}*/\nvec3 intersectionPosW = vPositionW + reflectionW * distance;\nreturn intersectionPosW - envMapPosW;\n}\n#endif // USE_ENVMAP_PROJECT\nvec3 fixSeams(vec3 vec, float mipLevel) {\nfloat scale = 1.0 - exp2(mipLevel) / 128.0;\nfloat M = max(max(abs(vec.x), abs(vec.y)), abs(vec.z));\nif (abs(vec.x) != M) vec.x *= scale;\nif (abs(vec.y) != M) vec.y *= scale;\nif (abs(vec.z) != M) vec.z *= scale;\nreturn vec;\n}\nvec3 getEnvColor(in samplerCube envMap, in Roughness roughness,\nin vec3 reflectionW) {\nvec3 reflectionNormW = normalize(reflectionW);\n#ifdef USE_ENVMAP_PROJECT\nif (envBoxMin.x != envBoxMax.x) {\nreflectionNormW = cubeMapProject(reflectionNormW);\n}\n#endif\nvec3 reflectionNormFixedW = fixSeams(reflectionNormW,\nroughness.envMipLevel0);\n#ifdef HAVE_TEXTURE_LOD\nvec4 cubeColorRaw0 = textureCubeLodEXT(envMap, reflectionNormFixedW,\nroughness.envMipLevel0);\n#else\nvec4 cubeColorRaw0 = textureCube(envMap, reflectionNormFixedW);\n#endif\nvec3 cubeColor0 = hdrDecode(cubeColorRaw0);\n#ifdef HAVE_TEXTURE_LOD\nvec4 cubeColorRaw1 = textureCubeLodEXT(envMap, reflectionNormFixedW,\nroughness.envMipLevel1);\n#else\nvec4 cubeColorRaw1 = textureCube(envMap2, reflectionNormFixedW);\n#endif\nvec3 cubeColor1 = hdrDecode(cubeColorRaw1);\nreturn mix(cubeColor0, cubeColor1, roughness.envMipMixFactor);\n}\nvec3 fresnelSchlickEnv(in vec3 specularColor, in Roughness roughness,\nin float clampCosnv, inout float opacity) {\nfloat fresnel = 1.0 - clampCosnv;\nfloat fresnel2 = fresnel * fresnel;\nfresnel *= fresnel2 * fresnel2;\nfresnel *= roughness.envFresnel;\nopacity = opacity + (1.0 - opacity) * fresnel;\nreturn specularColor + (1.0 - specularColor) * fresnel;\n}\n#endif // USE_ENVMAP\n#ifdef USE_DYNAMIC_LIGHT\n#endif // USE_DYNAMIC_LIGHT\nvec3 getSpecularColor(in vec3 baseColor, float metalic) {\nconst float dielectricF0 = 0.04;\nreturn mix(vec3(dielectricF0), baseColor, metalic);\n}\nfloat getLuminance(in vec3 color) {\nreturn 0.2126 * color.r + 0.7152 * color.g + 0.0722 * color.b;\n}\nvec4 lerpLightVisibility(in sampler2D map, in vec2 uv, in vec2 size) {\nvec2 fragAddress = uv * size + 0.5;\nvec2 weight = fract(fragAddress);\nvec2 sizeInv = 1.0 / size;\nvec2 uvlb = floor(fragAddress) * sizeInv;\nvec4 lb = texture2D(map, uvlb);\nvec4 lt = texture2D(map, uvlb + vec2(0.0, sizeInv.y));\nvec4 rb = texture2D(map, uvlb + vec2(sizeInv.x, 0.0));\nvec4 rt = texture2D(map, uvlb + vec2(sizeInv.x, sizeInv.y));\nvec4 lb_idx = floor(lb);\nvec4 lt_idx = floor(lt);\nvec4 rb_idx = floor(rb);\nvec4 rt_idx = floor(rt);\nvec4 lt_idx_smaller_eq = step(lt_idx, lb_idx);\nvec4 rb_idx_smaller_eq = step(rb_idx, lb_idx);\nvec4 rt_idx_smaller_eq = step(rt_idx, lb_idx);\nlt = clamp(lt, lb_idx, lb_idx + 0.999 * lt_idx_smaller_eq);\nrb = clamp(rb, lb_idx, lb_idx + 0.999 * rb_idx_smaller_eq);\nrt = clamp(rt, lb_idx, lb_idx + 0.999 * rt_idx_smaller_eq);\nvec4 a = mix(lb, lt, weight.y);\nvec4 b = mix(rb, rt, weight.y);\nreturn mix(a, b, weight.x);\n}\nvec3 getNormalW() {\n#ifdef USE_BUMP_TEXTURE\nvec3 normalPerturbedV = perturbNormal(-vPositionV, normalize(vNormalV));\nreturn normalize(\ninverseTransformDirection(normalPerturbedV, viewMatrix));\n#else\nreturn normalize(vNormalW);\n#endif\n}\nvec3 addSpecular(in vec3 baseColor, in vec3 totalIntensity,\ninout float opacity) {\nvec3 totalSpec = vec3(0.0, 0.0, 0.0);\n#ifdef USE_METALLIC_TEXTURE\nfloat metallic = texture2D(metallicTexture, vUv).x;\n#endif // else metallic is a uniform\nvec3 diffuseIntensity = totalIntensity * (1.0 - mix(0.04, 1.0, metallic));\nvec3 viewW = normalize(cameraPosition - vPositionW);\nvec3 normalW = getNormalW();\nfloat clampCosnv = saturate(dot(normalW, viewW));\nvec3 reflectionW = reflect(-viewW, normalW);\nvec3 specularColor = getSpecularColor(baseColor, metallic);\nRoughness roughness = getRoughnessFactors();\n#ifdef USE_ENVMAP\nvec3 envColor = getEnvColor(envMap, roughness, reflectionW);\nvec3 fresnel = fresnelSchlickEnv(specularColor, roughness,\nclampCosnv, opacity);\ntotalSpec = envColor * fresnel;\n#endif\n#ifdef USE_DYNAMIC_LIGHT\n#endif\nfloat luminance = getLuminance(totalIntensity);\nreturn (baseColor * diffuseIntensity +\ntotalSpec * mix(0.4, 1.0, luminance));\n}\n#else // NOT (USE_DYNAMIC_LIGHT or USE_ENVMAP)\nvec3 addSpecular(vec3 baseColor, in vec3 lightIntensity, in float opacity) {\nreturn baseColor * lightIntensity;\n}\n#endif\n#ifdef USE_HIGHLIGTH\nuniform vec3 highlight;\nuniform float highlightMix;\n#endif\n#if defined(HDR_OUTPUT)\nvec4 hdrEncode(in vec3 rgb) {\nconst float rgbmScale = 2.82842712;  // sqrt(8)\nvec3 r = sqrt(rgb) / rgbmScale;\nfloat m = max(max(r.r, r.g), r.b);\nm = clamp(m, 1.0 / 255.0, 1.0);\nm = ceil(m * 255.0) / 255.0;\nr /= m;\nreturn vec4(r.r, r.g, r.b, (1.0 - m));\n}\n#endif\n#ifdef USE_COLORMAP\nvec3 colormap(in sampler2D texture, in vec3 color) {\nconst float resolution = 16.0;\nconst float maxValueIndex = resolution - 1.0;\nconst float sliceWidth = 1.0 / resolution;\nconst float slicePixelWidth = sliceWidth / resolution;\nconst float sliceMarginWidth = 0.5 * slicePixelWidth;\nconst float sliceInnerWidth = sliceWidth - slicePixelWidth;\nconst float slicePixelHeight = 1.0 / resolution;\nconst float sliceMarginHeight = 0.5 * slicePixelHeight;\nconst float sliceInnerHeight = 1.0 - slicePixelHeight;\nfloat bSlice0 = min(floor(color.b * maxValueIndex), maxValueIndex - 1.0);\nfloat bSlice1 = bSlice0 + 1.0;\nfloat bOffset = color.b * maxValueIndex - bSlice0;\nfloat rSlicePos = sliceMarginWidth + color.r * sliceInnerWidth;\nfloat gSlicePos = sliceMarginHeight + color.g * sliceInnerHeight;\nfloat rPos0 = rSlicePos + (bSlice0 * sliceWidth);\nfloat rPos1 = rSlicePos + (bSlice1 * sliceWidth);\nvec3 color0 = texture2D(texture, vec2(rPos0, gSlicePos)).rgb;\nvec3 color1 = texture2D(texture, vec2(rPos1, gSlicePos)).rgb;\nreturn mix(color0, color1, bOffset);\n}\nuniform sampler2D colorMap;\n#endif\n#ifdef USE_CHROMA_KEY\nuniform vec3 chromaKeyColor;\nuniform vec3 chromaKeyDeltaCoeff;\nconst float k32 = sqrt(3.0) / 2.0;\nvec3 rgb2abi(vec3 color) {\nfloat r = color.r;\nfloat g = color.g;\nfloat b = color.b;\nreturn vec3(\nr - 0.5 * g - 0.5 * b,\nk32 * (g - b),\n0.3333 * (r + g + b));\n}\nconst float IPI2 = 0.5 / 3.1415926538;\nvec3 rgb2hci(vec3 color) {\nvec3 abi = rgb2abi(color);\nreturn vec3(\natan(abi.y, abi.x) * IPI2,\nlength(abi.xy),\nabi.z);\n}\nfloat chromaKeyShapeFn(vec3 delta, vec3 color, vec3 key) {\nvec3 diff = color - key;\nvec3 v = delta * vec3(\n0.5 - abs(abs(diff.x) - 0.5),\nabs(diff.y),\nabs(diff.z));\nfloat x = max(v.r, max(v.g, v.b));\nreturn x * x;\n}\nfloat chromaKeyEdgeFn(float a) {\nreturn clamp(.2/.5 * (a - 1.0), 0.0, 1.0);\n}\n#endif\nuniform float emissionStrength;\nuniform float exposure;\nuniform float cameraGamma;\nvoid main() {\nfloat alpha;\nvec3 baseColor = getBaseColor(alpha);\n#ifdef USE_CHROMA_KEY\nfloat dist = chromaKeyShapeFn(chromaKeyDeltaCoeff, rgb2hci(baseColor), rgb2hci(chromaKeyColor));\nalpha *= chromaKeyEdgeFn(dist);\n#endif\n#ifdef USE_BASE_COLOR_TEXTURE\nif (alpha < alphaDiscardThreshold) {\ndiscard;\n}\n#endif\nvec3 lightIntensity = getLightIntensity();\n#ifdef USE_HIGHLIGTH\nbaseColor = mix(baseColor, highlight, highlightMix);\nalpha = mix(alpha, 1.0, highlightMix);\n#endif\nvec3 diffuseSpecular = addSpecularHook(baseColor, lightIntensity, alpha);\n#ifdef USE_HEADLIGHT\nvec3 lightW = normalize(cameraPosition - vPositionW.xyz);\nfloat pointDiffuse = max(dot(normalize(vNormalW), lightW), 0.0);\ndiffuseSpecular *= pointDiffuse;\n#endif\nvec3 diffuseSpecularEmissive = diffuseSpecular + baseColor * emissionStrength;\n#ifdef HDR_OUTPUT\nif (alpha < 0.5) {\ndiscard;\n}\ngl_FragColor = hdrEncode(diffuseSpecularEmissive);\n#else // no HDR_OUTPUT\nvec3 exposedColor = pow(exposure * diffuseSpecularEmissive.xyz,\nvec3(cameraGamma));\nvec3 gammaColor =  linearToGammaUnreal(exposedColor);\n#ifdef USE_COLORMAP\ngl_FragColor.rgb = colormap(colorMap, min(gammaColor, 1.0));\n#else\ngl_FragColor.rgb = gammaColor;\n#endif\ngl_FragColor.a = alpha;\n#endif // no HDR_OUTPUT\n}\n";
//JMT.SHADERS["standard_material_vertex.glsl_"] = "//AUTO GENERATED\nconst float PI = 3.14159265358979;\nconst float RECIPROCAL_PI2 = 0.15915494;\nfloat saturate(in float a) {\nreturn clamp(a, 0.0, 1.0);\n}\nvec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {\nreturn normalize((vec4(normal, 0.0) * matrix).xyz);\n}\nvec3 sphericalDecode(in vec2 spNormal) {\nfloat theta = (spNormal.x / 254.0 + 0.5) * PI;\nfloat phi = spNormal.y * (PI / 127.0);\nfloat sinTheta = sin(theta);\nreturn vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));\n}\nvec4 transformPosition() {\nreturn vec4(\nt0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\nt1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\nt2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n1.0);\n}\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\nvarying vec2 vUv;\nuniform vec4 uvMod;\n#endif\n#ifdef USE_LIGHTMAP\nvarying vec2 vUv2;\n#endif\n#ifdef USE_BUMP_TEXTURE\nvarying vec3 vPositionV;\nvarying vec3 vNormalV;\n#endif\n#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\nvarying vec3 vNormalW;\nvarying vec3 vPositionW;\n#endif\nvoid main() {\n#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)\nvUv = uv * uvMod.zw + uvMod.xy;\n#endif\nvec4 transformedPosition = transformPosition();\nvec4 mvPosition = modelViewMatrix * transformedPosition;\n#ifdef USE_LIGHTMAP\nfloat zeroOrOne = clamp(ceil(uv2.x + uv2.y), 0.0, 1.0);\nvUv2 = uv2 * uv2Mod.zw + uv2Mod.xy * zeroOrOne;\n#endif\n#if defined(USE_BUMP_TEXTURE) || defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\nvec3 n = sphericalDecode(sphericalNormal);\nvec3 normal = vec3(\nt0.x * n.x + t0.y * n.y + t0.z * n.z,\nt1.x * n.x + t1.y * n.y + t1.z * n.z,\nt2.x * n.x + t2.y * n.y + t2.z * n.z);\n#endif\n#if defined(USE_BUMP_TEXTURE)\nvPositionV = -mvPosition.xyz;\nvNormalV = normalize(normalMatrix * normal);\n#endif\n#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)\nvNormalW = mat3(modelMatrix[0].xyz,\nmodelMatrix[1].xyz,\nmodelMatrix[2].xyz) * normal;\nvNormalW = normalize(vNormalW);\nvPositionW = (modelMatrix * transformedPosition).xyz;\n#endif\ngl_Position = projectionMatrix * mvPosition;\n}\n";
JMT.SHADERS["static_render_fragment.glsl"] = "//AUTO GENERATED\nfloat _l2g(in float x) {\nreturn (x <= 0.0031308) ? x * 12.92 : pow(x, 1.0 / 2.4) * 1.055 - 0.055;\n}\nvec3 linearToGamma(in vec3 rgb) {\nreturn vec3(_l2g(rgb.r), _l2g(rgb.g), _l2g(rgb.b));\n}\nvec3 linearToGammaUnreal(in vec3 rgb) {\nreturn rgb / (rgb + 0.187) * 1.035;\n}\nuniform sampler2D staticRender;\nuniform vec2 sizeInv;\nvoid main() {\nvec3 colorLinear = texture2D(staticRender, gl_FragCoord.xy * sizeInv).rgb;\ngl_FragColor.rgb = linearToGammaUnreal(colorLinear);\n}\n";
JMT.SHADERS["static_render_vertex.glsl"] = "//AUTO GENERATED\nvoid main() {\ngl_Position = modelViewMatrix * vec4(position, 1.0);\n}\n";
JMT.SHADERS["water.glsl"] = "//AUTO GENERATED\n#ifdef USE_NORMAL_TEXTURE\nuniform float time;\nuniform float wavesScale;\nuniform float refractionFactor;\nuniform sampler2D normalTexture;\nvec4 getNoise(in vec2 uv) {\nvec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\nvec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);\nvec2 uv2 = uv / vec2(897.0, 983.0) + vec2(time / 101.0, time / 97.0);\nvec2 uv3 = uv / vec2(991.0, 877.0) - vec2(time / 109.0, time / -113.0);\nvec4 noise = texture2D(normalTexture, uv0) +\ntexture2D(normalTexture, uv1) +\ntexture2D(normalTexture, uv2) +\ntexture2D(normalTexture, uv3);\nreturn noise * 0.5 - 1.0;\n}\nvec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity,\ninout float opacity) {\nvec3 toEyeW = cameraPosition - vPositionW;\nvec3 viewW = normalize(toEyeW);\nvec4 noise = getNoise(vPositionW.xy * wavesScale);\nvec3 normalW = normalize(noise.xyz);\nfloat clampCosnv = saturate(dot(normalW, viewW));\nRoughness roughness;\nroughness.envMipLevel0 = 0.0;\nroughness.envMipLevel1 = 0.0;\nroughness.envMipMixFactor = 0.0;\nroughness.envFresnel = 1.0;\nconst float waterF0 = 0.02;\nvec3 specularColor = vec3(waterF0);\nvec3 reflectionW = reflect(-viewW, normalW);\nvec3 refractionW = refract(-viewW, normalW, 0.75);\nvec3 reflectedEnv = getEnvColor(envMap, roughness, normalize(reflectionW));\nvec3 refractedEnv = refractionFactor *\ngetEnvColor(envMap, roughness, normalize(refractionW));\nvec3 fresnel = fresnelSchlickEnv(specularColor, roughness,\nclampCosnv, opacity);\nvec3 totalSpec = reflectedEnv * fresnel + refractedEnv * (1.0 - fresnel);\nvec3 diffuseIntensity = totalIntensity * 0.98;\nfloat luminance = getLuminance(totalIntensity);\nreturn totalSpec * mix(0.4, 1.0, luminance) + baseColor * diffuseIntensity;\n}\n#else // NOT USE_NORMAL_TEXTURE\nvec3 addSpecularHook(in vec3 baseColor, in vec3 totalIntensity,\ninout float opacity) {\nreturn baseColor * totalIntensity;\n}\n#endif\n";
JMT.SHADERS["wireframe_fragment.glsl"] = "//AUTO GENERATED\nuniform vec3 lineColor;\nuniform float lineMaxAlpha;\nuniform vec3 highlight;\nuniform float highlightMix;\nvarying vec3 vBaryCentric;\nfloat edgeFactor(){\nvec3 d = fwidth(vBaryCentric);\nvec3 r = smoothstep(vec3(0.0), d * 1.5, vBaryCentric);\nreturn min(min(r.x, r.y), r.z);\n}\nvoid main(void){\nfloat edge = edgeFactor();\nif (edge < 1.0) {\ngl_FragColor.rgb = lineColor;\ngl_FragColor.w = (1.0 - edge) * lineMaxAlpha;\n} else {\ngl_FragColor.rgb = highlight;\ngl_FragColor.w = highlightMix;\n}\n}\n";
JMT.SHADERS["wireframe_vertex.glsl"] = "//AUTO GENERATED\nvec4 transformPosition() {\nreturn vec4(\nt0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,\nt1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,\nt2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,\n1.0);\n}\nattribute float order;\nvarying vec3 vBaryCentric;\nvoid main() {\nif (order == 0.0) {\nvBaryCentric = vec3(1.0, 0.0, 0.0);\n} else if (order == 1.0) {\nvBaryCentric = vec3(0.0, 1.0, 0.0);\n} else {\nvBaryCentric = vec3(0.0, 0.0, 1.0);\n}\nvec4 transformedPosition = transformPosition();\ngl_Position = projectionMatrix * modelViewMatrix * transformedPosition;\n}\n";



JMT.SHADERS["standard_material_vertex.glsl"] =`
//AUTO GENERATED
const float PI = 3.14159265358979;
const float RECIPROCAL_PI2 = 0.15915494;
float saturate(in float a) {
	return clamp(a, 0.0, 1.0);
}

vec3 inverseTransformDirection(in vec3 normal, in mat4 matrix) {
	return normalize((vec4(normal, 0.0) * matrix).xyz);
}

vec3 sphericalDecode(in vec2 spNormal) {
	float theta = (spNormal.x / 254.0 + 0.5) * PI;
	float phi = spNormal.y * (PI / 127.0);
	float sinTheta = sin(theta);
	return vec3(sinTheta * cos(phi), sinTheta * sin(phi), cos(theta));
}


#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)
	varying vec2 vUv;
	uniform vec4 uvMod;
#endif


#ifdef USE_SKINNING

	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;

	#ifdef BONE_TEXTURE

		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;

		mat4 getBoneMatrix( const in float i ) {

			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );

			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );

			y = dy * ( y + 0.5 );

			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );

			mat4 bone = mat4( v1, v2, v3, v4 );

			return bone;

		}

	#else

		uniform mat4 boneMatrices[128];

		mat4 getBoneMatrix( const in float i ) {

			mat4 bone = boneMatrices[ int(i) ];
			return bone;

		}

	#endif

#endif

#ifdef USE_LIGHTMAP
	varying vec2 vUv2;
#endif

#ifdef USE_BUMP_TEXTURE
	varying vec3 vPositionV;
	varying vec3 vNormalV;
#endif

#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	varying vec3 vNormalW;
	varying vec3 vPositionW;
#endif



vec4 transformPosition() {
	return vec4(
		t0.x * position.x + t0.y * position.y + t0.z * position.z + t0.w,
		t1.x * position.x + t1.y * position.y + t1.z * position.z + t1.w,
		t2.x * position.x + t2.y * position.y + t2.z * position.z + t2.w,
		1.0
	);
}


#ifdef USE_SKINNING

vec4 transformPositionOfSkinning(in mat4 boneMatX, in mat4 boneMatY, in mat4 boneMatZ, in mat4 boneMatW) {

	vec3 transformed = vec3( position );

	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );

	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;

	transformed = ( bindMatrixInverse * skinned ).xyz;


	return vec4(
		t0.x * transformed.x + t0.y * transformed.y + t0.z * transformed.z + t0.w,
		t1.x * transformed.x + t1.y * transformed.y + t1.z * transformed.z + t1.w,
		t2.x * transformed.x + t2.y * transformed.y + t2.z * transformed.z + t2.w,
		1.0
	);
}

#endif


void main() {


#ifdef USE_SKINNING

	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );

	vec4 transformedPosition = transformPositionOfSkinning(boneMatX, boneMatY, boneMatZ, boneMatW);
#else

	vec4 transformedPosition = transformPosition();

#endif

#if defined(USE_BASE_COLOR_TEXTURE) || defined(USE_ROUGHNESS_TEXTURE) || defined(USE_METALLIC_TEXTURE) || defined(USE_BUMP_TEXTURE)
	vUv = uv * uvMod.zw + uvMod.xy;
#endif

	vec4 mvPosition = modelViewMatrix * transformedPosition;

#ifdef USE_LIGHTMAP
	float zeroOrOne = clamp(ceil(uv2.x + uv2.y), 0.0, 1.0);
	vUv2 = uv2 * uv2Mod.zw + uv2Mod.xy * zeroOrOne;
#endif

#if defined(USE_BUMP_TEXTURE) || defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	vec3 n = sphericalDecode(sphericalNormal);
	vec3 normal = vec3(
		t0.x * n.x + t0.y * n.y + t0.z * n.z,
		t1.x * n.x + t1.y * n.y + t1.z * n.z,
		t2.x * n.x + t2.y * n.y + t2.z * n.z
	);

	#ifdef USE_SKINNING

		mat4 skinMatrix = mat4( 0.0 );
		skinMatrix += skinWeight.x * boneMatX;
		skinMatrix += skinWeight.y * boneMatY;
		skinMatrix += skinWeight.z * boneMatZ;
		skinMatrix += skinWeight.w * boneMatW;
		skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;

		//normal = vec4( skinMatrix * vec4( normal, 0.0 ) ).xyz;

		//#ifdef USE_TANGENT
		//	objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
		//#endif

	#endif

#endif

#if defined(USE_BUMP_TEXTURE)
	vPositionV = -mvPosition.xyz;
	vNormalV = normalize(normalMatrix * normal);
#endif

#if defined(USE_ENVMAP) || defined(USE_HEADLIGHT) || defined(USE_DYNAMIC_LIGHT)
	vNormalW = mat3(modelMatrix[0].xyz,
	modelMatrix[1].xyz,
	modelMatrix[2].xyz) * normal;
	vNormalW = normalize(vNormalW);
	vPositionW = (modelMatrix * transformedPosition).xyz;
#endif

	gl_Position = projectionMatrix * mvPosition;
}


`

JMT.Shader = function (a, c) {
    this.id = a;
    this.code = c
};
var a = 0;
JMT.InlineShader = function (b) {
    JMT.Shader.call(this, "inline:" + a, b);
    a += 1
};
JMT.getShader = function (a) {
    return new JMT.Shader(a, JMT.SHADERS[a])
}

/***/ }),

/***/ "./src/renderers/shaders/createWebGLShader.js":
/*!****************************************************!*\
  !*** ./src/renderers/shaders/createWebGLShader.js ***!
  \****************************************************/
/***/ (function() {

    /**
 * Created by Kai on 2020/12/18.
 */
function a(a) {
    return a.split("\n").map(function (a, b) {
        return b + 1 + ": " + a
    }).join("\n")
}

JMT.createWebGLShader = function (b, c, d) {
    c = b.createShader(c);
    b.shaderSource(c, d);
    b.compileShader(c);
    var e = !1 === b.getShaderParameter(c, b.COMPILE_STATUS);
    if (e) {
        console.error("Shader failed to compile.");
    }
    if (e || JMT.LOG_INFO) {
        b = b.getShaderInfoLog(c)
        "" !== b && console.warn("Shader info log: ", b, a(d));
    }
    return c
}

/***/ }),

/***/ "./src/renderers/webgl/WebGLState.js":
/*!*******************************************!*\
  !*** ./src/renderers/webgl/WebGLState.js ***!
  \*******************************************/
/***/ (function() {


/**
 * Created by Kai on 2020/12/18.
 */
JMT.WebGLState = function (a, _glInstances) {
    var c = Array(16).fill(0), d = Array(16).fill(null), e = c.map(function () {
        return 0
    }), g = null, f = null, h = null, k = null, n = null, p = null, l = null, q = null, r = null, m = null, u = null, x = null, t = null, v = null, w = null, z = null;
    this.resetAttributeStates = function () {
        for (var a = 0, b = c.length; a < b; a++)c[a] = 0
    };
    this.disableAttributeStates = function () {
        for (var b = 0, d = c.length; b < d; b++)a.disableVertexAttribArray(b), c[b] = 0
    };
    this.enableAttributeArray = function (b) {
        2 !== c[b] && (a.enableVertexAttribArray(b), c[b] = 2)
    };
    this.disableAttributeArray = function (b, e) {
        if(!e){
            return
        }

        if (1 !== c[b]) {

            a.disableVertexAttribArray(b)

            c[b] = 1
        }

        if (!e) {
            console.log(b, e);
        }

        if (d[b] !== e) {

            if (2 === e.length) {

                a.vertexAttrib2fv(b, e)

            }
            else if (3 === e.length) {

                a.vertexAttrib3fv(b, e)

            }
            else if (4 === e.length) {

                a.vertexAttrib4fv(b, e)

            }

            d[b] = e
        }
    };
    this.resetAttributeDivisors = function () {
        for (var a = 0, c = e.length; a < c; a++)e[a] && (_glInstances.vertexAttribDivisorANGLE(a, 0), e[a] = 0)
    };
    this.setAttributeDivisor = function (a, c) {
        _glInstances.vertexAttribDivisorANGLE(a, c);
        e[a] = c
    };
    this.setBlending = function (b) {
        var c = b.blending;
        var bMkBlendFunc = b.mk

        if(bMkBlendFunc){
            //console.log(b);
            c = THREE.AdditiveBlending
            b.depthWrite = !1
        }

        if(c !== g){

            if(c === THREE.NoBlending){
                a.disable(a.BLEND)
            }
            else if(c === THREE.AdditiveBlending){
                a.enable(a.BLEND)
                a.blendEquation(a.FUNC_ADD)
                a.blendFunc(a.SRC_ALPHA, a.ONE)
            }
            else if(c === THREE.SubtractiveBlending){
                (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.ONE_MINUS_SRC_COLOR))
            }
            else if(c === THREE.MultiplyBlending){
                (a.enable(a.BLEND), a.blendEquation(a.FUNC_ADD), a.blendFunc(a.ZERO, a.SRC_COLOR))
            }
            else if(c === THREE.CustomBlending){
                a.enable(a.BLEND)
            }
            else {
                a.enable(a.BLEND)
                a.blendEquationSeparate(a.FUNC_ADD, a.FUNC_ADD)
                a.blendFuncSeparate(a.SRC_ALPHA, a.ONE_MINUS_SRC_ALPHA, a.ONE, a.ONE_MINUS_SRC_ALPHA)
            }

            g = c
        }

        if (c === THREE.CustomBlending) {

            c = b.blendEquation;

            var d = b.blendEquationAlpha || c, e = b.blendSrc, m = b.blendDst, q = b.blendSrcAlpha || e;

            b = b.blendDstAlpha || m;

            if (c !== f || d !== n){

                a.blendEquationSeparate(c, d)

                f = c

                n = d;

            }

            if (e !== h || m !== k || q !== p || b !== l){

                a.blendFuncSeparate(e, m, q, b)

                h = e

                k = m

                p = q

                l = b

            }
        }
        else {

            l = p = n = k = h = f = null

        }
    };
    this.setDepthTest = function (b) {
        q !== b && (b ? a.enable(a.DEPTH_TEST) : a.disable(a.DEPTH_TEST), q = b)
    };
    this.setDepthWrite = function (b) {
        r !== b && (a.depthMask(b), r = b)
    };
    this.setColorWrite = function (b) {
        m !==
        b && (a.colorMask(b, b, b, b), m = b)
    };
    this.setDoubleSided = function (b) {
        u !== b && (b ? a.disable(a.CULL_FACE) : a.enable(a.CULL_FACE), u = b)
    };
    this.setFlipSided = function (b) {
        x !== b && (b ? a.frontFace(a.CW) : a.frontFace(a.CCW), x = b)
    };
    this.setViewport = function (b, c, d, e) {
        if (t !== b || v !== c || w !== d || z !== e)a.viewport(b, c, d, e), t = b, v = c, w = d, z = e
    }
}


/***/ }),

/***/ "./src/textures/CanvasTexture.js":
/*!***************************************!*\
  !*** ./src/textures/CanvasTexture.js ***!
  \***************************************/
/***/ (function() {

/**
 * Created by Kai on 2021/2/4.
 */


class CanvasTexture extends JMT.Texture {
    constructor(imageBitmap, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(null, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)
        //this.isAnimated = !1;
        this.releaseOnLoadedToGpu = !0;
        //this.image = {data: imageBitmap, width : imageBitmap.width, height: imageBitmap.height}
        var canvas = document.getElementById("anchor-canvas");

        if (!canvas) {
            canvas = document.createElement("canvas")

            canvas.id = "anchor-canvas"
        }
        //

        canvas.width = imageBitmap.width;
        canvas.height = imageBitmap.height;
        this.width = canvas.width;
        this.height = canvas.height;
        //
        let context = canvas.getContext('2d');
        context.drawImage(imageBitmap, 0, 0, imageBitmap.width, imageBitmap.height)
        //context.fillStyle = "#ffffff";

        this.needsUpdate = !0;
        this.image = canvas
        return
        ////
        //let cellCount = 2
        //
        //let cellSize = w.width / cellCount
        //
        //for(let i = 0 ; i < cellCount * cellCount; i++ ){
        //    let row = Math.floor(i / cellCount);
        //    let col = i % cellCount;
        //    let color
        //    if(row%2){
        //        color = (i % 2) ? 'red' : 'white'
        //    }
        //    else {
        //        color = ((i+1) % 2) ? 'red' : 'white'
        //    }
        //
        //    context.beginPath()
        //    context.fillStyle = color;
        //    context.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
        //    context.closePath()
        //}
        //context.fillStyle = "yellow";
        ////context.fillRect(0, 0, w.width, w.height);
        //
        //context.font = "800 px 微软雅黑"
        //context.textAlign = 'center';
        //context.textBaseline = "middle";
        //context.shadowColor = "black";
        //context.shadowBlur = 16;
        //context.fillText('dsadasdasdad',  w.width / 2,  w.height / 2);
        //context.beginPath()
        //context.moveTo(0 , 0)
        //context.lineTo(w.width, w.height)
        //context.closePath()
        //context.stroke()
        //this.notifyLoaded()
    }
}
//
JMT.CanvasTexture = CanvasTexture

/***/ }),

/***/ "./src/textures/CompressedTexture.js":
/*!*******************************************!*\
  !*** ./src/textures/CompressedTexture.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./src/textures/Texture.js");
/**
 * Created by Kai on 2020/12/18.
 */


class CompressedTexture extends JMT.Texture {

    constructor(a, b, c, d, e, g, f, h, k, n) {
        super(null, g, f, h, k, d, e, n)

        this.image = {width: b, height: c};
        this.mipmaps = a;
        this.generateMipmaps = this.flipY = !1
    }

    clone() {
        var a = new JMT.CompressedTexture;
        JMT.Texture.prototype.clone.call(this, a);
        return a
    }
}

JMT.CompressedTexture = CompressedTexture

/***/ }),

/***/ "./src/textures/DataTexture.js":
/*!*************************************!*\
  !*** ./src/textures/DataTexture.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Texture_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Texture.js */ "./src/textures/Texture.js");
/**
 * Created by Kai on 2020/12/18.
 */


class DataTexture extends JMT.Texture {

    constructor(a, b, c, d, e, g, f, h, k, n) {
        super(null, g, f, h, k, d, e, n)
        this.image = {data: a, width: b, height: c}
    }

    clone() {
        var a = new JMT.DataTexture;
        JMT.Texture.prototype.clone.call(this, a);
        return a
    }
}


JMT.DataTexture = DataTexture

/***/ }),

/***/ "./src/textures/Texture.js":
/*!*********************************!*\
  !*** ./src/textures/Texture.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Texture": function() { return /* binding */ Texture; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */


class Texture extends THREE.EventDispatcher {
    constructor(image, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super()

        this.webFormats = this.stdExt = this.rawExt = this.name = this.id = null;

        this.isCube = !1;

        this.image = image ? image : JMT.Texture.DEFAULT_IMAGE;

        this.height = this.width = null;

        this.mipmaps = [];

        this.wrapS = wrapS ? wrapS : GLC.CLAMP_TO_EDGE;
        this.wrapT = wrapT ? wrapT : GLC.CLAMP_TO_EDGE;

        this.magFilter = magFilter ? magFilter : GLC.LINEAR;
        this.minFilter = minFilter ? minFilter : GLC.LINEAR_MIPMAP_LINEAR;

        this.anisotropy = anisotropy ? anisotropy : 1;

        this.isRgbm = this.isCutout = this.hasAlpha = this.isAnimated = !1;

        this.format = format ? format : GLC.RGBA;

        this.type = type ? type : GLC.UNSIGNED_BYTE;

        this.generateMipmaps = !0;

        this.premultiplyAlpha = !1;

        this.flipY = !0;

        this.unpackAlignment = 4;

        this._atlasEntries = null;

        this._needsUpdate = !1;

        this.releaseOnLoadedToGpu = !0;

        this.loaded = !1;

        this._loadingListeners = []

        this._loadedListeners = [];

        this.fromEditor = !1;

        this.__webglSlot = this.__webglTexture = null
    }

    sleepAnimation() {
        console.assert(!1)
    }

    wakeAnimation() {
        console.assert(!1)
    }

    get needsUpdate() {
        return this._needsUpdate
    }

    set needsUpdate(a) {
        this._needsUpdate = a
    }

    isAtlas() {
        return null !== this._atlasEntries
    }

    enableAtlas() {
        console.assert(!this.isAtlas());
        this._atlasEntries = {}
    }

    getAtlasEntry(b, c, d, e, g) {
        var f = this._atlasEntries[b];
        if (f)return f;
        console.assert(!this.loaded);
        f = new AtlasEntry(b, this, c, d, e, g);
        return this._atlasEntries[b] = f
    }

    forEachAtlasEntry(a) {
        for (var b in this._atlasEntries) {
            if (this._atlasEntries.hasOwnProperty(b)) {
                a(this._atlasEntries[b])
            }
        }
    }

    clone(a) {
        void 0 === a && (a = new JMT.Texture);
        a.isCube = this.isCube;
        a.image = this.image;
        a.mipmaps = this.mipmaps.slice(0);
        a.wrapS = this.wrapS;
        a.wrapT = this.wrapT;
        a.magFilter = this.magFilter;
        a.minFilter = this.minFilter;
        a.anisotropy = this.anisotropy;
        a.isCutout = this.isCutout;
        a.isAnimated = this.isAnimated;
        a.hasAlpha = this.hasAlpha;
        a.format = this.format;
        a.url = this.url
        a.type = this.type;
        a.generateMipmaps = this.generateMipmaps;
        a.premultiplyAlpha = this.premultiplyAlpha;
        a.flipY = this.flipY;
        a.unpackAlignment = this.unpackAlignment;
        return a
    }

    serialize() {
        var a = {
            id: this.id,
            name: this.name,
            stdExt: this.stdExt,
            webFormats: this.webFormats,
            alpha: this.hasAlpha,
            url : this.url
        };
        this.rawExt && (a.rawExt = this.rawExt);
        this.isRgbm && (a.rgbm = !0);
        this.video && (a.video = !0);
        return a
    }

    dispose() {
        this._loadingListeners = []
        this._loadedListeners = [];
        this.dispatchEvent({type: "dispose"})
    }

    addLoadingListener(callback) {
        if (!this.loaded) {
            this._loadingListeners.push(callback)
        }
    }

    addLoadedListener(callback) {
        if (this.loaded) {
            callback(this)
        }
        else {
            this._loadedListeners.push(callback)
        }
    }

    notifyLoading(){
        this.loaded = !1;
        for (var a = this._loadingListeners, c = 0; c < a.length; c += 1) {
            a[c](this);
        }
        a.length = 0
    }

    notifyLoaded() {
        this.loaded = !0;
        for (var a = this._loadedListeners, c = 0; c < a.length; c += 1) {
            a[c](this);
        }
        a.length = 0
    }
}

class AtlasEntry {
    constructor(a, c, d, e, g, f) {
        this.name = a;
        this.parentTexture = c;
        this.uvOffsetScale = new THREE.Vector4(d, e, g, f);
        this.isCutout = !1
    }

    addLoadedListener(a) {
        this.parentTexture.addLoadedListener(a)
    }

    get hasAlpha() {
        return this.parentTexture.hasAlpha
    }
}

JMT.Texture = Texture
JMT.Texture.DEFAULT_IMAGE = void 0;

/***/ }),

/***/ "./src/textures/VideoTexture.js":
/*!**************************************!*\
  !*** ./src/textures/VideoTexture.js ***!
  \**************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

class VideoTexture extends JMT.Texture {
    constructor(image, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
        super(image, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy)

        var n = this;
        this.generateMipmaps = !1;
        this.isAnimated = !0;
        this.releaseOnLoadedToGpu = !1;
        this._isPlaying = !1;
        this._pauseRequested = this._isSleeping = !1;

        function _handlePaused() {
            if (n._pauseRequested) {
                n._isPlaying = !1
                n._pauseRequested = !1
            }
            else {
                n._isSleeping = !0
            }
        };

        function _handleEnded() {
            n._isPlaying = !1;
            n._isSleeping = !1
        }

        Object.defineProperty(this, "video", {
            get: function () {
                return this.image
            }, set: function (a) {
                this.image = a;
                this._isPlaying = !a.paused && !a.ended;
                a.addEventListener("pause", _handlePaused);
                a.addEventListener("ended", _handleEnded);
                this._isSleeping && this._isPlaying && this.video.pause()
            }
        })
        Object.defineProperty(this, "muted", {
            get: function () {
                return this.video.muted
            }, set: function (a) {
                this.video.muted = a
            }
        })
        Object.defineProperty(this, "loop", {
            get: function () {
                return this.video.loop
            }, set: function (a) {
                this.video.loop = a
            }
        })
        Object.defineProperty(this, "isPlaying", {
            get: function () {
                return !this._isSleeping && this._isPlaying
            }
        })

        Object.defineProperty(this, "needsUpdate", {
            get: function () {
                return this._needsUpdate || this.isPlaying && this.video &&
                    this.video.readyState >= this.video.HAVE_CURRENT_DATA
            }, set: function (a) {
                this._needsUpdate = a
            }
        })
    }


    play() {
        var a = this;
        if (!this._isPlaying) {
            if (this._isSleeping) {
                this._isPlaying = !0;
            } else {
                
                var b = this.video
                var c = b.play();
                if (c) {

                    this._isPlaying = !0

                    c.catch(function () {
                        a._isPlaying = !1
                    })
                }
                else {
                    this._isPlaying = !b.paused && !b.ended
                }
            }
        }
    }

    pause() {
        if (this._isPlaying) {
           
            if (this._isSleeping) {
                this._isPlaying = !1
            }
            else {
                this._pauseRequested = !0
                this.video.pause()
            }
        }
    }

    sleepAnimation() {
        this._isSleeping || (this._isPlaying && this.video && this.video.pause(), this._isSleeping = !0)
    }

    wakeAnimation() {
        this._isSleeping && (this._isPlaying && this.video && this.video.play(), this._isSleeping = !1)
    }
}

JMT.VideoTexture = VideoTexture

/***/ }),

/***/ "./src/textures/WebGLTextureSlotter.js":
/*!*********************************************!*\
  !*** ./src/textures/WebGLTextureSlotter.js ***!
  \*********************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

function a() {
    this.texture = null;
    this.locked = !1;
    this.usedCount = 0
}

function b(b) {
    for (var c = [], e = 0; e < b; e += 1) {
        c[e] = new a;
    }
    return c
}

JMT.WebGLTextureSlotter = function (a) {
    var c = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS)
    var e = b(c);
    this.setSlot = function (a, b) {
        if (!a) {
            return !1
        }

        var d = a.__webglSlot;
        if (null !== d) {
            var f = e[d];
            f.usedCount += 1;
            f.locked = f.locked || b;
            return !1
        }
        for (var g = Infinity, p = 0; p < c; p += 1) {
            f = e[p]
            if (!f.locked && f.usedCount < g) {
                g = f.usedCount
                d = p
            }
        }
        if (null === d) {
            console.warn("Not enough texture units")
            d = 0
        }
        f = e[d];
        f.texture &&
        (f.texture.__webglSlot = null);
        f.texture = a;
        f.usedCount = 1;
        f.locked = b;
        a.__webglSlot = d;
        return !0
    };
    this.unlockAllSlots = function () {
        for (var a = 0; a < c; a += 1)e[a].locked = !1
    };
    this.freeSlot = function (a) {
        if (null !== a.__webglSlot) {
            var b = e[a.__webglSlot];
            a.__webglSlot = null;
            b.texture = null;
            b.locked = !1;
            b.usedCount = 0
        }
    }
};
JMT.WebGLTextureSlotterSequential = function (a) {
    var b = a.getParameter(a.MAX_TEXTURE_IMAGE_UNITS), c = 0;
    this.setSlot = function (a, d) {
        if (c === b) {
            console.warn("Not enough texture units")
            c = 0
        }
        a && (a.__webglSlot = c);
        d && (c += 1);
        return !0
    };
    this.unlockAllSlots = function () {
        c = 0
    };
    this.freeSlot = function (a) {
        a.__webglSlot = null
    }
}

/***/ }),

/***/ "./src/tools/Ruler.js":
/*!****************************!*\
  !*** ./src/tools/Ruler.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Ruler": function() { return /* binding */ Ruler; },
/* harmony export */   "RulerList": function() { return /* binding */ RulerList; }
/* harmony export */ });
/* harmony import */ var _utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/interactionDetector.js */ "./utils/interactionDetector.js");
/**
 * Created by Kai on 2020/12/3.
 */
//_vw9K



function createTexture(canvas) {

    var ctx = canvas.getContext("2d");
    ctx.font = "25px Arial"
    ctx.fillStyle = "#00ffa2"
    ctx.textAlign = "center"
    ctx.shadowColor = "black"
    ctx.shadowOffsetX = 1
    ctx.shadowOffsetY = 1
    ctx.shadowBlur = 2
    ctx.strokeStyle = "#888888"
    ctx.lineWidth = 3;

    let texture = new JMT.Texture(canvas);
    texture.width = canvas.width;
    texture.height = canvas.height;
    texture.hasAlpha = true;
    texture.minFilter = GLC.LINEAR;
    texture.loaded = !0;
    texture.needsUpdate = !0;

    return texture
}

function getDefaultRulerLabelParameter() {


    let size = 0.25
    let geometry = new THREE.PlaneBufferGeometry(size, size)
    geometry.attributes.uv.array = new Float32Array([
        1, 1,
        1, 0,
        0, 1,
        0, 0
    ])
    geometry.convertNormalsToSpherical()

    var canvas = document.getElementById("anchor-canvas");

    if (!canvas) {
        canvas = document.createElement("canvas")

        canvas.id = "anchor-canvas"
    }

    let material = new JMT.StandardMaterial;
    material.baseColorTexture = createTexture(canvas);
    material.side = THREE.DoubleSide;
    material.doubleSided = true

    return {
        geometry: geometry, // r
        material: material, // v
        texture: texture, // i
        canvas: canvas, // t
        context: ctx, // n
    }
}


class RulerLabel extends JMT.Anchor {
    constructor(scene, config) {
        super(scene, config)
        this.material.depthTest = !1

        this.visible = !1
    }

    updateText(text) {
        //let n = this.args.context,
        //    t = this.args.canvas
        //n.clearRect(0, 0, t.width, t.height)
        //n.strokeText(e, t.width / 2, t.height / 2)
        //n.fillText(e, t.width / 2, t.height / 2)
        //this.args.texture.needsUpdate = !0
        this._updateText(text)
    }

    updatePosition(pos) {
        this.position.copy(pos)

        this.updateMatrixWorld(!0);
    }
}

function createMaterial(color, opacity) {
    var c = new JMT.StandardMaterial;
    c.hideFromLightProbes = !0;
    c.baseColor.copy(new THREE.Color(color));
    c.opacity = opacity;
    c.specularOff = 1;
    c.depthTest = !1;
    c.depthWrite = !1;
    c.doubleSided = !0;
    return c
}

function createArrawMesh() {
    //var e = new THREE.CylinderGeometry(0, 3, 10, 10);
    var e = new THREE.CylinderBufferGeometry(0, .05, .2, 10, 1, !1);
    var a = new THREE.Matrix4(),
        b = new THREE.Matrix4()
    a.makeTranslation(0, -.1, 0);
    b.makeRotationX(-Math.PI / 2);
    e.applyMatrix(b.multiplyMatrices(b, a));
    var t = new THREE.Mesh(e, createMaterial(65442, .6))
    //e.translate(0, -5, 0)
    //e.rotateX(-Math.PI / 2);
    //var t = new THREE.Mesh(e, new THREE.MeshBasicMaterial({
    //    color: 65442,
    //    visible: !1,
    //    toneMapped: !1})
    //);
    t.visible = !1
    return t
}

//n.r(t);

var r, v

function setToIntersetPoint(e, t) { // a
    var r = new THREE.Matrix3()
    var v = new THREE.Vector3()
    e.position.set(0, 0, 0)
    //r.getNormalMatrix(t.object.matrixWorld)
    //v.copy(t.face.normal).applyMatrix3(r).normalize()
    v.fromArray(t.normal)
    e.lookAt(v)
    e.position.copy(new THREE.Vector3().fromArray(t.point))
    e.updateMatrixWorld(!0);
}

function getPointInLine(from, to, scalar) { // b
    var e = new THREE.Vector3();
    var t = new THREE.Vector3();

    e.copy(to);
    var v = e.sub(from)
    var a = v.length();
    v = v.normalize().multiplyScalar(a * scalar)
    t.copy(from)
    return t.add(v)
}

class RulerLine extends THREE.Object3D {
    constructor() {
        this.geometry = new THREE.Geometry()

        this.material = new THREE.LineBasicMaterial()({
            color: 65442,
            depthTest: !1,
            depthWrite: !1,
            visible: !1,
            transparent: !0,
            toneMapped: !1
        });

        this.renderOrder = 10
        this.frustumCulled = !1
        this.geometry.vertices = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ]
    }
}

class Ruler {
    constructor(btnDom, iconDom) {

        var n = this

        let canvas = UjP.viewer.webGLRenderer.domElement
        let scene = UjP.viewer.scene

        n.scene = scene


        n.btn = btnDom || document.getElementById("measure") // s
        n.ico = iconDom || document.getElementById("measureIcon") // c

        n.u = !1;
        n.enabled = !1
        n.g = new THREE.Vector3


        function onmousedown(e) { //A
            n.fromPoint.set(e.clientX, e.clientY)
        }

        function onmouseup(e) { //S
            n.toPoint.set(e.clientX, e.clientY)
            if (n.fromPoint.distanceTo(n.toPoint) < 5) {
                n.currentPoint.x = e.clientX
                n.currentPoint.y = e.clientY
                n.solve()
            }
        }

        function onmousemove(e) { //T
            n.currentPoint.x = e.clientX
            n.currentPoint.y = e.clientY;
            //var t = deQ.detectIntersect(n.currentPoint); //GkU
            let t = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(e)
            t && n._update(t)
        }

        function onmouseleave() { //E
            n.arrowCurrent.visible = !1
        }

        function ontouchstart(e) { //C
            e.preventDefault()
            n.fromPoint.set(e.touches[0].clientX, e.touches[0].clientY)
        }

        function ontouchend(e) { //D
            e.preventDefault()
            n.toPoint.set(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
            if (l.distanceTo(d) < 5) {
                n.currentPoint.x = e.changedTouches[0].clientX
                n.currentPoint.y = e.changedTouches[0].clientY
                n.solve()
            }
        }

        n.enable = function () {
            canvas.addEventListener("pointerdown", onmousedown, !1)
            canvas.addEventListener("pointermove", onmousemove, !1)
            canvas.addEventListener("pointerup", onmouseup, !1)
            canvas.addEventListener("pointerleave", onmouseleave, !1)
            canvas.addEventListener("touchstart", ontouchstart, !1)
            canvas.addEventListener("touchend", ontouchend, !1)
            n.ico.classList.add("highlight")
            n.enabled = !0


            n._addArrowMesh()

            n._addLineMesh()

            n._addLabelMesh()

            //deQ.disableMoveByClick = !0
        }

        n.disable = function () {
            canvas.removeEventListener("pointerdown", onmousedown, !1)
            canvas.removeEventListener("pointermove", onmousemove, !1)
            canvas.removeEventListener("pointerup", onmouseup, !1)
            canvas.removeEventListener("pointerleave", onmouseleave, !1)
            canvas.removeEventListener("touchstart", ontouchstart, !1)
            canvas.removeEventListener("touchend", ontouchend, !1)
            n.ico.classList.remove("highlight")
            //n.hide()
            n.enabled = !1


            n.u = !1
            n.r && n.scene.removeAuxiliaryObject(n.r);
            n.v && n.scene.removeAuxiliaryObject(n.v);
            n.cline0 && n.scene.removeAuxiliaryObject(n.cline0);
            n.cline1 && n.scene.removeAuxiliaryObject(n.cline1);

            n.r = n.v = n.cline0 = n.cline1 = null

            UjP.aniController.requestFrame()
            //deQ.disableMoveByClick = !1
        }
    }

    _addArrowMesh() {
        let n = this

        n.r = createArrawMesh()
        n.v = createArrawMesh()
        n.arrowCurrent = createArrawMesh()
        n.arrowCurrent.name = '__MT_ARROW_CUR_'

        n.scene.addAuxiliaryObject(n.r)
        n.scene.addAuxiliaryObject(n.v)
        n.scene.addAuxiliaryObject(n.arrowCurrent);

        n.currentPoint = new THREE.Vector2()
        n.fromPoint = new THREE.Vector2()
        n.toPoint = new THREE.Vector2()
    }

    _addLineMesh() {

        let n = this
        var e = new THREE.CylinderBufferGeometry(.005, .005, 1, 10, 1, !1);
        var a = new THREE.Matrix4(),
            b = new THREE.Matrix4()
        a.makeTranslation(0, -.5, 0);
        b.makeRotationX(-Math.PI / 2);
        e.applyMatrix(b.multiplyMatrices(b, a));
        n.cline0 = new THREE.Mesh(e, createMaterial(65442, .6))
        n.cline1 = new THREE.Mesh(e, createMaterial(65442, .6))
        //n.cline2 = new THREE.Mesh(e, createMaterial(65442, .6))

        n.scene.addAuxiliaryObject(n.cline0);
        n.scene.addAuxiliaryObject(n.cline1);
        n.cline0.visible = n.cline1.visible = !1


        n.y = [
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3(),
            new THREE.Vector3()
        ]
    }

    _addLabelMesh() {

        let n = this
        //const DRLP = getDefaultRulerLabelParameter

        n.labelFirst = new RulerLabel(this.scene, {
            type: "sprite",
            position: [0, 0, .5],
            height: .1,
            text: 'labelFirst',
            textColor: 'red',
            opacity: 1,
            showTitle: !0
        });
        n.labelFirst.renderOrder = 11
        //n.scene.addAuxiliaryObject(n.labelFirst);
        n.cline0.add(n.labelFirst)


        n.labelSecond = new RulerLabel(this.scene, {
            type: "sprite",
            position: [0, 0, .5],
            height: .1,
            text: 'labelSecond',
            textColor: 'red',
            opacity: 1,
            showTitle: !0
        });
        n.labelSecond.renderOrder = 11
        //n.scene.addAuxiliaryObject(n.labelSecond);
        n.cline1.add(n.labelSecond)

    }

    _update(e) {
        if (this.u) {
            setToIntersetPoint(this.v, e)
            this.v.visible = !0

            let y = this.y
            let r = this.r
            let g = this.g
            let h = this.h
            let v = this.v

            y[0].copy(r.position)
            y[1].copy(v.position).z = r.position.z
            y[2].copy(v.position);
            var e = y[0].distanceTo(y[1]);

            if (this.labelFirst) {
                let p = this.labelFirst
                p.visible = !0
                p.updateText(e.toFixed(2) + " m")
                p.updatePosition(getPointInLine(y[0], y[1], .5));
            }

            var t = y[1].distanceTo(y[2]);
            if (t > .002) {
                if (this.labelSecond) {
                    let m = this.labelSecond
                    m.visible = !0
                    m.updateText(t.toFixed(2) + " m")
                    m.updatePosition(getPointInLine(y[1], y[2], .5));
                }

                var n = y[0].z >= y[2].z ? 1 : -1;
                y[3].copy(y[1]).z -= .04 * n
                g.subVectors(y[0], y[1]).normalize()
                y[4].copy(y[3]).add(g.multiplyScalar(.04))
                y[5].copy(y[4]).z += .04 * n
            } else {
                this.labelSecond && (this.labelSecond.visible = !1)
            }

            y[5].copy(y[4].copy(y[3].copy(y[2])));

            this.solveLine()

        } else {
            this.arrowCurrent.visible = !0
            setToIntersetPoint(this.arrowCurrent, e)
        }

        UjP.aniController.requestFrame()
    }

    hide() {
        this.u = !1
        this.r.visible = !1
        this.v.visible = !1
        //this.h.visible = !1
        this.labelFirst.visible = !1
        this.labelSecond.visible = !1
        UjP.aniController.requestFrame()
    }

    // 构造线
    solveLine() {
        let h = this.h

        // let array = [].concat(this.y[0].toArray())
        //     .concat(this.y[1].toArray())
        //     .concat(this.y[2].toArray())
        //     .concat(this.y[3].toArray())
        //     .concat(this.y[4].toArray())
        //     .concat(this.y[5].toArray())
        //
        // let c = h.geometry
        // let position = c.attributes.position
        // position.array.set(array)
        // c.computeBoundingSphere()
        // position.buffer = null
        // h.needsUpdate = true
        // h.visible = !0
        // UjP.webGLRenderer.uploadNewBuffers(h)

        function _solveCline(line, p0, p1) {
            let ca = p1.clone().sub(p0)
            let l = ca.length()
            ca.normalize()
            setToIntersetPoint(line, {
                point: p0.toArray(),
                normal: ca.toArray()
            })

            let label = line.children[0]
            label.position.set(
                0,
                0,
                .5
            )

            line.scale.set(1, 1, l)
            line.updateMatrixWorld(1)


            line.visible = !0

        }

        _solveCline(this.cline0, this.y[0], this.y[2])
        // _solveCline(this.cline1, this.y[1], this.y[2])
        //_solveCline(this.cline2, this.y[0], this.y[1])


    }

    solve() {
        //var e = deQ.detectIntersect(this.currentPoint); //GkU
        let e = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(this.currentPoint)
        if (e) {
            if (!this.u) {
                this.u = !0
                this.arrowCurrent.visible = !1
                //this.h.visible = !1
                this.v.visible = !1
                //this.labelFirst.material.visible = !1
                //this.labelSecond.material.visible = !1
                setToIntersetPoint(this.r, e)
                this.r.visible = !0
            } else {
                this._update(e)
                this.u = !1
            }
        } else {
            this.hide()
        }
    }


    onclick() {
        let n = this
        n.enabled ? n.disable() : n.enable()
    }
}

class RulerList {
    constructor(btnDom, iconDom) {
        var n = this
        let canvas = UjP.viewer.webGLRenderer.domElement
        let scene = UjP.viewer.scene
        n.scene = scene
        n.rulerList = []
        n.enabled = !1
        n.isBegin = !1
        n.isSelect = !1
        n.selectOld = !1
        n.selectPoint = !1
        n.addRulerBtn = null
        n.cancelRulerBtn = null
        n.removeRulerBtn = null

        function onmousedown(e) { //A
            n.fromPoint.set(e.clientX, e.clientY)
        }

        function onmouseup(e) { //S
            n.toPoint.set(e.clientX, e.clientY)
            if (n.fromPoint.distanceTo(n.toPoint) < 5) {
                n.currentPoint.x = e.clientX
                n.currentPoint.y = e.clientY
                if (n.isBegin) {
                    n.solve()
                } else {
                    if (!n.selectOld && !n.selectPoint) {
                        n.getFinishRuler(e)
                        return false
                    }
                    if (n.selectOld && !n.selectPoint) {
                        n.getSelectPoint(e)
                        return false
                    }
                    if (n.selectOld && n.selectPoint) {
                        n.selectClick(e)
                        return false
                    }
                }

            }
        }

        function onmousemove(e) { //T
            n.currentPoint.x = e.clientX
            n.currentPoint.y = e.clientY;
            let t = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(e)
            if (n.isBegin) {
                t && n._update(t)
            } else {
                // n.getFinishRuler(e)
                n.selectPoint && n.selectPoint && n.selectPointUpdata(t)
            }

        }

        function onkeydown(e) {
            if (e.keyCode === 27 && n.cancelRulerBtn.style.display == "block") {
                n.cancelRuler()
            }
        }
        n.enable = function () {
            n.enabled = !0
            n.arrowCurrent = n._addPointMwsh()
            n.arrowCurrent.visible = !1

            let doc = window.parent.document

            n.addRulerBtn = doc.querySelector('[data-action=addRulerBtn]')

            n.addRulerBtn.style.display = "block"

            n.cancelRulerBtn = doc.querySelector('[data-action=cancelRulerBtn]')

            n.removeRulerBtn = doc.querySelector('[data-action=removeRulerBtn]')

            // 添加测量尺
            n.addRulerBtn.onclick = function () {
                n.isBegin = !0
                n.currentPoint = new THREE.Vector2()
                n.fromPoint = new THREE.Vector2()
                n.toPoint = new THREE.Vector2()
                canvas.addEventListener("pointerdown", onmousedown, !1)
                canvas.addEventListener("pointerup", onmouseup, !1)
                canvas.addEventListener("pointermove", onmousemove, !1)
                canvas.addEventListener("keydown", onkeydown, !1)
                n.addRuler()
            }
            // 取消测量
            n.cancelRulerBtn.onclick = function () {
                n.cancelRuler()
            }
            // 删除
            n.removeRulerBtn.onclick = function () {
                n.removeRuler()
            }
        }

        n.disable = function () {
            canvas.removeEventListener("pointerdown", onmousedown, !1)
            canvas.removeEventListener("pointerup", onmouseup, !1)
            canvas.removeEventListener("pointermove", onmousemove, !1)
            canvas.removeEventListener("keydown", onkeydown, !1)
            n.enabled = !1

            n.scene.removeAuxiliaryObject(n.arrowCurrent);
            n.rulerList.forEach(item => {
                item.lineList.forEach(a => {
                    n.scene.removeAuxiliaryObject(a);
                })
                item.pointMesh.forEach(a => {
                    n.scene.removeAuxiliaryObject(a);
                })

            })
            n.rulerList = []
            n.arrowCurrent = null
            n.addRulerBtn.style.display = "none"
            n.cancelRulerBtn.style.display = "none"
            n.cancelRulerBtn.style.display = "none"
            UjP.aniController.requestFrame()
        }


    }
    addRuler() {
        let that = this
        that.currentRuler = {
            lineList: [],
            positionList: [],
            pointList: [],
            labelList: [],
            pointMesh: []
        }
        that.currentLine = null
        that.currentNum = -1
        that.arrowCurrent.visible = !0
        that.rulerList.push(that.currentRuler)
        that.addRulerBtn.style.display = "none"
        that.cancelRulerBtn.style.display = "block"
    }
    cancelRuler() {
        let n = this
        n.selectOld = false
        n.selectPoint = false
        if (n.isBegin) {
            n.scene.removeAuxiliaryObject(n.currentLine)
            n.scene.removeAuxiliaryObject(n.currentLabel)
            n.currentRuler.lineList.pop()
            n.currentRuler.labelList.pop()
            n.isBegin = !1
            n.arrowCurrent.visible = !1
        }
        n.currentRuler.lineList.forEach(item => {
            item.material.baseColor.setRGB(1, 1, 1)
        })
        n.addRulerBtn.style.display = "block"
        n.removeRulerBtn.style.display = "none"
        n.cancelRulerBtn.style.display = "none"
    }
    removeRuler() {
        let n = this
        n.selectOld = false
        n.selectPoint = false
        const index1111 = n.rulerList.findIndex(item => item === n.currentRuler)
        n.rulerList.splice(index1111, 1)
        n.currentRuler.lineList.forEach(a => {
            n.scene.removeAuxiliaryObject(a);
        })
        n.currentRuler.pointMesh.forEach(a => {
            n.scene.removeAuxiliaryObject(a);
        })
        n.arrowCurrent.visible = !1
        n.addRulerBtn.style.display = "block"
        n.cancelRulerBtn.style.display = "none"
        n.removeRulerBtn.style.display = "none"
    }
    _addPointMwsh() {
        var material = createMaterial(0xFFFFFF, .6);
        var geometry = new THREE.SphereBufferGeometry(.015, 4, 16);
        var circle = new THREE.Mesh(geometry, material);
        this.scene.addAuxiliaryObject(circle);

        return circle
    }

    _addLineMesh() {
        let n = this
        var e = new THREE.CylinderBufferGeometry(.005, .005, 1, 10, 1, !1);
        var a = new THREE.Matrix4(),
            b = new THREE.Matrix4()
        a.makeTranslation(0, -.5, 0);
        b.makeRotationX(-Math.PI / 2);
        e.applyMatrix(b.multiplyMatrices(b, a));
        n.currentLine = new THREE.Mesh(e, createMaterial(65442, .6))
        n.scene.addAuxiliaryObject(n.currentLine);
        n.currentLine.visible = !1
        n.currentRuler.lineList.push(n.currentLine)
        const pos = new THREE.Vector3()
        n.currentRuler.positionList.push(pos)
    }

    _addLabelMesh() {
        let n = this
        n.currentLabel = new RulerLabel(this.scene, {
            type: "sprite",
            position: [0, 0, .5],
            height: .1,
            text: 'labelFirst',
            textColor: 'red',
            opacity: 1,
            showTitle: !0
        });
        n.currentLabel.renderOrder = 11
        n.currentLine.add(n.currentLabel)
        n.currentRuler.labelList.push(n.currentLabel)
    }

    _update(e) {
        setToIntersetPoint(this.arrowCurrent, e)
        if (this.fromArrow) {
            var e = this.fromArrow.position.distanceTo(this.arrowCurrent.position);
            let p = this.currentLabel
            p.visible = !0
            p.updateText(e.toFixed(2) + " m")
            p.updatePosition(getPointInLine(this.fromArrow.position, this.arrowCurrent.position, .5));
            this.solveLine(this.currentLine, this.fromArrow.position, this.arrowCurrent.position)
        }
        UjP.aniController.requestFrame()
    }

    hide() {
        this.fromArrow.visible = !1
        this.toArrow.visible = !1
        this.labelFirst.visible = !1
        this.labelSecond.visible = !1
        UjP.aniController.requestFrame()
    }

    // 构造线
    solveLine(a, b, c) {
        function _solveCline(line, p0, p1) {
            if (!line) return
            
            let ca = p1.clone().sub(p0)
            let l = ca.length()
            ca.normalize()
            setToIntersetPoint(line, {
                point: p0.toArray(),
                normal: ca.toArray()
            })

            let label = line.children[0]
            label.position.set(
                0,
                0,
                .5
            )

            line.scale.set(1, 1, l)
            line.updateMatrixWorld(1)


            line.visible = !0

        }

        _solveCline(a, b, c)


    }

    solve() {
        let e = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(this.currentPoint)
        if (e) {
            this._addLineMesh()
            this._addLabelMesh()
            const point = this._addPointMwsh()
            this.currentRuler.pointMesh.push(point)
            this.fromArrow = point
            setToIntersetPoint(point, e)
            this.currentNum = this.currentNum + 1
            if (this.currentNum > 0) {
                this.currentRuler.lineList[this.currentNum - 1].material.baseColor.setRGB(1, 0, 0)
            }
            this.currentRuler.positionList[this.currentNum].copy(this.fromArrow.position)
            const newPoint = new THREE.Vector2()
            newPoint.set(this.currentPoint.x, this.currentPoint.y)
            this.currentRuler.pointList.push(newPoint)
        } else {
            this.hide()
        }
    }

    // 拾取已完成的线条
    getFinishRuler(e) {
        let n = this
        const nowPoint = new THREE.Vector2()
        nowPoint.set(e.clientX, e.clientY)
        const position123 = new THREE.Vector3().fromArray((0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(nowPoint).point)
        n.selectOld = false
        n.currentRuler = null
        n.rulerList.forEach(item => {
            const index = item.positionList.findIndex(a => position123.distanceTo(a) < 0.05)
            if (index >= 0) {
                n.selectOld = true
                n.currentRuler = item
                n.addRulerBtn.style.display = "none"
                n.cancelRulerBtn.style.display = "block"
                n.removeRulerBtn.style.display = "block"
                item.lineList.forEach(aa => {
                    aa.material.baseColor.setRGB(1, 0, 0)
                })
            } else {
                item.lineList.forEach(bb => {
                    bb.material.baseColor.setRGB(1, 1, 1)
                })
            }
        })
    }

    getSelectPoint(e) {
        const nowPoint123 = new THREE.Vector2()
        nowPoint123.set(e.clientX, e.clientY)
        const position123 = new THREE.Vector3().fromArray((0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_0__.detectIntersect)(nowPoint123).point)
        const index123 = this.currentRuler.positionList.findIndex(a => position123.distanceTo(a) < 0.05)
        if (index123 == -1) {
            return false
        }
        this.selectPoint = !0
        this.currentNum = index123
        this.arrowCurrent = this.currentRuler.pointMesh[index123]
        this.currentRuler.lineList.forEach(aa => {
            aa.material.baseColor.setRGB(1, 0, 0)
        })
        if (index123 == 0) {
            this.currentRuler.lineList[0].material.baseColor.setRGB(0, 1, 0)
        } else if (index123 == (this.currentRuler.pointList.length - 1)) {
            this.currentRuler.lineList[index123 - 1].material.baseColor.setRGB(0, 1, 0)
        } else {
            this.currentRuler.lineList[index123 - 1].material.baseColor.setRGB(0, 1, 0)
            this.currentRuler.lineList[index123].material.baseColor.setRGB(0, 1, 0)
        }
    }
    selectPointUpdata(e) {
        let n = this
        if (n.currentNum == -1) {
            return false
        }

        function _selectupdata(fromPos, currLable, currLine) {
            let e = fromPos.distanceTo(n.arrowCurrent.position)
            let p = currLable
            p.visible = !0
            p.updateText(e.toFixed(2) + " m")
            p.updatePosition(getPointInLine(fromPos, n.arrowCurrent.position, .5));
            n.solveLine(currLine, fromPos, n.arrowCurrent.position)
        }
        setToIntersetPoint(n.arrowCurrent, e)
        if (n.currentNum == 0) {
            const fromPos = n.currentRuler.pointMesh[1].position
            const currLable = n.currentRuler.labelList[0]
            const currLine = n.currentRuler.lineList[0]
            _selectupdata(fromPos, currLable, currLine)
        } else if (n.currentNum == (n.currentRuler.pointList.length - 1)) {
            const fromPos = n.currentRuler.pointMesh[n.currentNum - 1].position
            const currLable = n.currentRuler.labelList[n.currentNum - 1]
            const currLine = n.currentRuler.lineList[n.currentNum - 1]
            _selectupdata(fromPos, currLable, currLine)
        } else {
            const fromPos = n.currentRuler.pointMesh[n.currentNum - 1].position
            const currLable = n.currentRuler.labelList[n.currentNum - 1]
            const currLine = n.currentRuler.lineList[n.currentNum - 1]
            _selectupdata(fromPos, currLable, currLine)

            const fromPos123 = n.currentRuler.pointMesh[n.currentNum + 1].position
            const currLable123 = n.currentRuler.labelList[n.currentNum]
            const currLine123 = n.currentRuler.lineList[n.currentNum]
            _selectupdata(fromPos123, currLable123, currLine123)
        }

        UjP.aniController.requestFrame()
    }
    selectClick(e) {
        let n = this
        n.selectPoint = !1
        this.currentRuler.pointList[n.currentNum].set(e.clientX, e.clientY)
        this.currentRuler.lineList.forEach(aa => {
            aa.material.baseColor.setRGB(1, 0, 0)
        })
    }

    onclick() {
        let n = this
        n.enabled ? n.disable() : n.enable()
    }
}

JMT.RulerList = RulerList;

/***/ }),

/***/ "./src/ui/ClickNavigator.js":
/*!**********************************!*\
  !*** ./src/ui/ClickNavigator.js ***!
  \**********************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.ClickNavigator = function (a, b, c) {
    function onPointerDown() {
        c.teleportingToPoint && c.cancelSwitchToPoint()
    }

    function onPointerMove() {
        !b.mousePressLook && c.teleportingToPoint && c.cancelSwitchToPoint()
    }

    this.onMeshClicked = function (d, e) {
        if (!(b.isOrbitEnabled() || b.isHandlingGesture())) {
            a.clickedPointToMoveTarget(e)
            c.switchToPoint(e)
        }
    };
    this.dispose = function () {
        document.removeEventListener("keydown", onPointerDown, !1);
        document.removeEventListener("mousedown", onPointerDown, !1);
        document.removeEventListener("mousemove", onPointerMove, !1);
        document.removeEventListener("touchstart", onPointerDown, !1);
        document.removeEventListener("DOMMouseScroll", onPointerDown, !1);
        document.removeEventListener("mousewheel", onPointerDown, !1)
    };
    document.addEventListener("keydown", onPointerDown, !1);
    document.addEventListener("mousedown", onPointerDown, !1);
    document.addEventListener("mousemove", onPointerMove, !1);
    document.addEventListener("touchstart", onPointerDown, !1);
    document.addEventListener("DOMMouseScroll", onPointerDown, !1);
    document.addEventListener("mousewheel", onPointerDown, !1)
}

/***/ }),

/***/ "./src/utils/AutoClearAlter.js":
/*!*************************************!*\
  !*** ./src/utils/AutoClearAlter.js ***!
  \*************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.AutoClearAlter = function (a) {
    var b, c, d, e;
    this.set = function (g, f, h) {
        console.assert(void 0 === b && void 0 === c && void 0 === d && void 0 === e);
        b = a.autoClear;
        c = a.autoClearColor;
        d = a.autoClearDepth;
        e = a.autoClearStencil;
        a.autoClear = g || f || h;
        a.autoClearColor = g;
        a.autoClearDepth = f;
        a.autoClearStencil = h
    };
    this.restore = function () {
        console.assert(void 0 !== b && void 0 !== c && void 0 !== d && void 0 !== e);
        a.autoClear = b;
        a.autoClearColor = c;
        a.autoClearDepth = d;
        a.autoClearStencil = e;
        e = d = c = b = void 0
    }
}

/***/ }),

/***/ "./src/utils/ClearColorAlter.js":
/*!**************************************!*\
  !*** ./src/utils/ClearColorAlter.js ***!
  \**************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.ClearColorAlter = function (a) {
    var lastColor = new THREE.Color, c = !1;
    this.set = function (d) {
        console.assert(!c);
        c = !0;
        //lastColor.copy(a.getClearColor());
        a.getClearColor(lastColor)
        a.setClearColor(d)
    };
    this.restore = function () {
        console.assert(c);
        c = !1;
        a.setClearColor(lastColor)
    }
}

/***/ }),

/***/ "./src/utils/ColorUtils.js":
/*!*********************************!*\
  !*** ./src/utils/ColorUtils.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ColorUtils": function() { return /* binding */ ColorUtils; }
/* harmony export */ });
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


const ColorUtils = {
    linearToGamma: function (a) {
        return .0031308 >= a ? 12.92 * a : 1.055 * Math.pow(a, 1 / 2.4) - .055
    }, gammaToLinear: function (a) {
        return .04045 >= a ? a / 12.92 : Math.pow((a + .055) / 1.055, 2.4)
    }, hdrEncode: function (a, b) {
        var c = Math.sqrt(a.r) / 2.82842712, d = Math.sqrt(a.g) / 2.82842712;
        a = Math.sqrt(a.b) / 2.82842712;
        var e = Math.max(Math.max(c, d), a);
        e = THREE.Math.clamp(e, 1 / 255, 1);
        e = Math.ceil(255 * e) / 255;
        b.setRGB(c / e, d / e, a / e);
        return 1 - e
    }
};
THREE.Color.prototype.copyGammaToLinear = void 0;
THREE.Color.prototype.copyLinearToGamma = void 0;
THREE.Color.prototype.convertLinearToGamma = void 0;
THREE.Color.prototype.convertGammaToLinear = function () {
    this.r = ColorUtils.gammaToLinear(this.r);
    this.g = ColorUtils.gammaToLinear(this.g);
    this.b = ColorUtils.gammaToLinear(this.b)
};
THREE.Color.prototype.roundChannels = function () {
    this.r = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.round)(this.r, 3);
    this.g = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.round)(this.g, 3);
    this.b = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.round)(this.b, 3);
    return this
}

/***/ }),

/***/ "./src/utils/GazeModeObserver.js":
/*!***************************************!*\
  !*** ./src/utils/GazeModeObserver.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GazeModeObserver": function() { return /* binding */ GazeModeObserver; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
/*
 Copyright (C) 2020-present M.K.
 */


class GazeModeObserver extends THREE.EventDispatcher {
    constructor() {
        super()
        this._modeEnabled = !1
    }

    enableMode() {
        this._modeEnabled = !0;
        this.dispatchEvent({type: "modeEnabled"})
    }

    disableMode() {
        this._modeEnabled = !1;
        this.dispatchEvent({type: "modeDisabled"})
    }

    modeIsEnabled() {
        return this._modeEnabled
    }
}

/***/ }),

/***/ "./src/utils/GpuRaycaster.js":
/*!***********************************!*\
  !*** ./src/utils/GpuRaycaster.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ClearColorAlter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClearColorAlter.js */ "./src/utils/ClearColorAlter.js");
/* harmony import */ var _ClearColorAlter_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ClearColorAlter_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _materials_ObjectDistanceMaterial_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../materials/ObjectDistanceMaterial.js */ "./src/materials/ObjectDistanceMaterial.js");
/**
 * Created by Kai on 2020/12/18.
 */



JMT.RaycasterConfig = function (a, b, c) {
    b = b||new THREE.Vector3(0,0,0);
    this.ray = new THREE.Ray(a, b);
    this.far = c || Infinity;
    this.ignoreVisibility = this.onlyGroundCollisions = this.respectColliderSettings = !1
};
JMT.RayIntersection = function () {
    this.distance = Infinity;
    this.point = new THREE.Vector3;
    this.object = null
};
JMT.GpuRaycaster = function (a, b) {

    function c(a, b) {
        if (!b.ignoreVisibility && !a.visible)return !1;
        var c = a.node || p;
        if (c.disableCollisions && b.respectColliderSettings || !c.ground && b.onlyGroundCollisions){
            return !1;
        }
        c = b.ray;
        if (a.matrixWorld)return !0;
        var d = a.geometry.boundingSphere;
        if (d.distanceToPoint(c.origin) > b.far || !1 === c.isIntersectionSphere(d)){
            return !1;
        }
        a = a.geometry.boundingBox;
        return a.distanceToPoint(c.origin) > b.far || !c.isIntersectionBox(a) ? !1 : !0
    }

    var d = a.createRenderTarget && a.createRenderTarget(1, 1, {
        format: GLC.RGBA,
        magFilter: GLC.NEAREST,
        minFilter: GLC.NEAREST,
        stencilBuffer: !1,
        depthBuffer: !0,
        generateMipmaps: !1
    })

    var e = new Uint8Array(4)
    var g = new JMT.AutoClearAlter(a)
    var f = new JMT.ClearColorAlter(a)
    var h = new THREE.Color(16777215)
    var k = new JMT.ObjectDistanceMaterial(!1)
    var n = new THREE.PerspectiveCamera(1, 1, b.near, b.far)
    var p = {disableCollisions: !1, ground: !1};

    this.closestIntersection = function (b, q, r) {
        if (!d) return false;
        return false;

        var m = []
        for (var l = 0; l < b.length; l += 1) {
            var p = b[l];
            console.assert(null === p.visibilityId);
            if (c(p, q)) {
                p.visibilityId = m.length
                m.push(p)
            }
        }
        if (0 === m.length)return !1;
        n.position.set(0, 0, 0);
        n.lookAt(q.ray.direction);
        n.position.copy(q.ray.origin);
        n.updateMatrixWorld();
        g.set(!0, !0, !1);
        f.set(h);
        b = a.sortObjects;
        a.sortObjects = !1;
        a.renderMeshes(m, k, n, d, !1, q.ignoreVisibility);
        a.sortObjects = b;
        f.restore();
        g.restore();
        a.readPixels(1, 1, e);
        a.setRenderTarget(null);
        b = 256 * e[0] + e[1];
        l = e[2] + e[3] / 255;
        for (p = 0; p < m.length; p += 1) {
            m[p].visibilityId = null;
        }
        if (65535 === b || l > q.far) {
            return !1;
        }
        console.assert(b < m.length);

        r.object = m[b];

        r.distance = l;

        r.direction = new THREE.Vector3().copy(q.ray.direction)

        r.point.copy(q.ray.direction).multiplyScalar(l).add(q.ray.origin);

        return !0
    }
}

/***/ }),

/***/ "./src/utils/InteractionDispatcher.js":
/*!********************************************!*\
  !*** ./src/utils/InteractionDispatcher.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _PointerEventHelper_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PointerEventHelper.js */ "./src/utils/PointerEventHelper.js");
/**
 * Created by Kai on 2020/12/18.
 */



class InteractionDispatcher {
    constructor(pointerEventDispatcher,
                collider,
                onPointerMove,
                clickListeners,
                meshClickListener,
                hoverListeners,
                gamepadMgr,
                gazePointer) {


    }
}

JMT.InteractionDispatcher = function (pointerEventDispatcher, collider, onPointerMove, clickListeners, meshClickListener, hoverListeners, gamepadMgr, gazePointer) {

    function dispatchClickEvent(a, b) { // k
        a = a ? meshClickListener : clickListeners;
        for (var c = 0; c < a.length; c += 1) {
            if (a[c](b.object, b.point, b.distance)) {
                return !0;
            }
        }
        return !1
    }

    function findIntersectionHandler() {    // n
        return collider.findIntersectionAtPosition(0, 0, !0, u)
    }

    function dispatchClickEventHandler() {  // p
        dispatchClickEvent(!1, u)
    }

    function handleClick(a, c, d) { // l
        gazePointer && gazePointer.reset();
        if(collider.findIntersectionAtPosition(a, c, !0, v)){
            return dispatchClickEvent(d, v)
        }
        else {
            return !1
        }
    }

    function onActionActivated(a) {
        gazePointer && gazePointer.reset();
        a.action === JMT.GAMEPAD_ACTION.TRIGGER && handleClick(0, 0, !1)
    }

    function dispatchHoverEvent(a, b) { // r
        for (var c = 0; c < hoverListeners.length; c += 1) {
            if (hoverListeners[c](a, b)) {
                return !0;
            }
        }
    }

    var _enabled = !1

    var lastObject = null;

    gazePointer && gazePointer.setGazeHandlers(findIntersectionHandler, dispatchClickEventHandler);

    var _pointerEventHelper = new JMT.PointerEventHelper(pointerEventDispatcher, JMT.POINTER_PRIORITY.INTERACTION_DISPATCHER);

    var _callbacks = _pointerEventHelper.callbacks;

    var u = new JMT.RayIntersection

    var v = new JMT.RayIntersection

    var _screenX = null

    var _screenY = null;

    _callbacks.onPointerMove = function (a, b) {

        console.assert(_enabled);

        if(0 !== hoverListeners.length){

            _screenX = a

            _screenY = b

            onPointerMove(_screenX, _screenY)

        }

        return !1
    };
    _callbacks.onClick = function (a, b) {
        return handleClick(a, b, !1)
    };
    _callbacks.onDoubleClick = function (a, b) {
        return handleClick(a, b, !0)
    };
    gamepadMgr.addEventListener("actionActivated", onActionActivated);

    this.handleHover = function () {

        if (_enabled && 0 !== hoverListeners.length) {

            var a = collider.findObstacleMeshAtPosition(_screenX, _screenY);

            if (null === a) {

                if (lastObject) {

                    dispatchHoverEvent(lastObject, !1)

                    lastObject = null

                }

            }
            else {

                if (a !== lastObject) {

                    lastObject && dispatchHoverEvent(lastObject, !1)

                    dispatchHoverEvent(a, !0)

                    lastObject = a
                }
            }
        }
    };

    this.enable = function () {
        _enabled = !0;
        _pointerEventHelper.enable();
        //console.assert(null === lastObject)
    };

    this.disable = function () {
        _enabled = !1;
        if(null !== lastObject){
            dispatchHoverEvent(lastObject, !1)
            lastObject = null
        }
        _pointerEventHelper.disable()
    };

    this.dispose = function () {
        this.disable();
        gamepadMgr.removeEventListener("actionActivated", onActionActivated)
    };

    this.enable()
}

/***/ }),

/***/ "./src/utils/PointerEventDispatcher.js":
/*!*********************************************!*\
  !*** ./src/utils/PointerEventDispatcher.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointerEventDispatcher": function() { return /* binding */ PointerEventDispatcher; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
function getButtonCode(a) { // c
    if (void 0 === a.button) {
        return 0;
    }
    switch (a.button) {
        case 0:
            return 0;
        case 1:
            return 1;
        case 2:
            return 2
    }
    return -1
}


class PointerEventDispatcher {

    constructor(dom, isEditor) {

        let t = this
        t._isPointerDown = !1
        t.q = -1
        //t.r = {clipX: 0, clipY: 0};
        t._pointerDownListeners = [] // k
        t._pointerUpListeners = []
        t._moveListeners = []
        t._dropListeners = []
        t._draggingListeners = []
        t.isEditor = isEditor


        function onDragging(event) {
            t.handleEvent(t._draggingListeners, event)
        }

        function onDrop(event) {
            t.handleEvent(t._dropListeners, event)
        }

        function onPointerDown(a) {   // e
            //0 !== c(a) || l || (l = !0, void 0 !== a.touches && (console.assert(0 < a.changedTouches.length), q = a.changedTouches[0].identifier), d(k, a))
            //if(0 === getButtonCode(a)){

            if (!t._isPointerDown) {

                t._isPointerDown = !0

                if (void 0 !== a.touches) {

                    console.assert(0 < a.changedTouches.length)

                    t.q = a.changedTouches[0].identifier

                }

                t.handleEvent(t._pointerDownListeners, a)
            }
            //}

        }

        function onPointerUp(a) {   // g
            //if (0 === getButtonCode(a) && l) {
            if (t._isPointerDown) {
                t._isPointerDown = !1
                t.handleEvent(t._pointerUpListeners, a)
            }
        }

        function onPointerMove(a) {
            t.handleEvent(t._moveListeners, a)
        }


        t._enabled = !1;
        t.enable = function() {
            if (!t._enabled) {
                if(isEditor){
                    dom.addEventListener('dragover', onDragging, !1)
                    dom.addEventListener('drop', onDrop, !1)
                }

                dom.addEventListener("pointerdown", onPointerDown, !1)
                dom.addEventListener("touchstart", onPointerDown, !1)
                dom.addEventListener("pointerup", onPointerUp, !1)
                dom.addEventListener("touchend", onPointerUp, !1)
                dom.addEventListener("pointermove", onPointerMove, !1)
                dom.addEventListener("touchmove", onPointerMove, !1)
                window.addEventListener("mouseup", onPointerUp, !1)
                isEditor && window.top.addEventListener("mouseup", onPointerUp, !1)
                t._enabled = !0
            }
        }

        t.disable = function() {
            if (t._enabled) {
                if(isEditor){
                    dom.removeEventListener('dragover', onDragging, !1)
                    dom.removeEventListener('drop', onDrop, !1)
                }

                dom.removeEventListener("mousedown", onPointerDown, !1)
                dom.removeEventListener("touchstart", onPointerDown, !1)
                dom.removeEventListener("mouseup", onPointerUp, !1)
                dom.removeEventListener("touchend", onPointerUp, !1)
                dom.removeEventListener("mousemove", onPointerMove, !1)
                dom.removeEventListener("touchmove", onPointerMove, !1)
                window.removeEventListener("mouseup", onPointerUp, !1)
                isEditor && window.top.removeEventListener("mouseup", onPointerUp, !1)
                t._enabled = !1
            }
        }

        t.enable()
    }


    addListener(listeners, callback, priority) {

        var d = listeners.filter(function (a) {

            return a.callback === callback

        });

        console.assert(0 !== listeners.length || 0 === d.length, "Do not add the same callback twice!");

        var c = {callback: callback, priority: priority};

        for (d = d = 0; d < listeners.length; d += 1) {

            var e = listeners[d];

            if (c.priority <= e.priority) {

                if (c.priority === e.priority) {

                    console.error("Adding two listeners with the same priority is not allowed!");

                    return

                }
                break
            }
        }
        listeners.splice(d, 0, c)
    }

    handleEvent(a, b) {    // d
        if (0 !== a.length) {
            var c = void 0 !== b.touches;
            var r = {clipX: 0, clipY: 0}
            if (!c && (document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement)) {
                r.clipX = 0
                r.clipY = 0
            }
            else {
                let t = this
                let cx, cy
                if (c) {
                    b:{
                        for (c = 0; c < b.changedTouches.length; c++) {
                            var d = b.changedTouches[c];
                            if (d.identifier === t.q) {
                                b = d;
                                break b
                            }
                        }
                        for (c = 0; c < b.touches.length; c++){
                            d = b.touches[c]
                            if (d.identifier === t.q) {
                                b = d;
                                break b
                            }
                        }
                        b = null
                    }

                    //console.assert(null !== b);
                    if (null == b)
                        return;

                    c = b.clientX;
                    b = b.clientY
                }
                else {
                    cx = b.clientX
                    cy = b.clientY;
                }

                r.clipX = cx / window.innerWidth * 2 - 1;
                r.clipY = 2 * -(cy / window.innerHeight) + 1
            }
            //b = r;
            for (c = 0; c < a.length; c++) {
                var callback = a[c].callback
                if (callback) {
                    let stopPrag = callback(r.clipX, r.clipY, b)
                    if (stopPrag) {
                        return
                    }
                }
                //if (d && !d(r.clipX, r.clipY, r)) {
                //    //if(d && !d(b, r)) {
                //        break
                //    //}
                //}
            }
        }
    }

    addPointerDropListener(callback, priority) {
        this.addListener(this._dropListeners, callback, priority)
    }

    removePointerDropListener(callback) {
        this._dropListeners = this._dropListeners.filter(function (b) {
            return b.callback !== callback
        })
    }

    addPointerDraggingListener(callback, priority) {
        this.addListener(this._draggingListeners, callback, priority)
    }

    removePointerDraggingListener(callback) {
        this._draggingListeners = this._draggingListeners.filter(function (b) {
            return b.callback !== callback
        })
    }

    addPointerDownListener(callback, priority) {
        this.addListener(this._pointerDownListeners, callback, priority)
    }

    removePointerDownListener(callback) {
        this._pointerDownListeners = this._pointerDownListeners.filter(function (b) {
            return b.callback !== callback
        })
    }

    addPointerUpListener(callback, priority) {
        this.addListener(this._pointerUpListeners, callback, priority)
    }

    removePointerUpListener(callback) {
        this._pointerUpListeners = this._pointerUpListeners.filter(function (b) {
            return b.callback !== callback
        })
    }

    addPointerMoveListener(callback, priority) {
        this.addListener(this._moveListeners, callback, priority)
    }

    removePointerMoveListener(callback) {
        this._moveListeners = this._moveListeners.filter(function (b) {
            return b.callback !== callback
        })
    }

    isEnabled() {
        return this._enabled
    }
}

JMT.PointerEventDispatcher = PointerEventDispatcher

/***/ }),

/***/ "./src/utils/PointerEventHelper.js":
/*!*****************************************!*\
  !*** ./src/utils/PointerEventHelper.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PointerEventHelper": function() { return /* binding */ PointerEventHelper; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */

class PointerEventHelper {

    constructor(pointerEventDispatcher, priorty) {

        this.pointerDown = !1   // h
        this.lastDownX = null  // k
        this.lastDownY = null  // n
        this.lastX = null   // p
        this.lastY = null   // l
        this.lastTime = null    // q

        this.hasListened = !1;

        this.callbacks = {
            onClick: ondefault,
            onDoubleClick: ondefault,
            onPointerDown: ondefault,
            onPointerUp: ondefault,
            onPointerMove: ondefault
        };

        function ondefault() {
            return !1
        }

        var t = this
        function onPointerDown(x, y, event) {
            var c = t.callbacks.onPointerDown(x, y, event);
            t.pointerDown = !0;
            t.lastDownX = x;
            t.lastDownY = y;
            return c
        }

        function onPointerUp(x, y, event) {
            var d = t.callbacks.onPointerUp(x, y);
            if (t.pointerDown) {
                var e = Date.now();
                if (null !== t.lastTime &&
                    .03 >= Math.abs(t.lastX - t.lastDownX) &&
                    .03 >= Math.abs(t.lastY - t.lastDownY) &&
                    500 >= Math.abs(t.lastTime - e) &&
                    t.callbacks.onDoubleClick !== ondefault) {

                    d = t.callbacks.onDoubleClick(x, y) || d

                }
                else {

                    d = t.callbacks.onClick(x, y, event) || d;

                }
                t.lastTime = e;
                t.lastX = x;
                t.lastY = y
            }
            return d
        }

        function onPointerMove(x, y, event) {

            var c = t.callbacks.onPointerMove(x, y, event);

            if (!(t.pointerDown && .03 >= Math.abs(x - t.lastDownX) && .03 >= Math.abs(y - t.lastDownY))) {

                t.pointerDown = !1

                t.lastTime = null

            }

            return c
        }


        this.enable = function () {
            if (!pointerEventDispatcher) {
                return
            }

            this.onEnable && this.onEnable()

            if (!this.hasListened) {
                pointerEventDispatcher.addPointerDownListener(onPointerDown, priorty)
                pointerEventDispatcher.addPointerUpListener(onPointerUp, priorty)
                pointerEventDispatcher.addPointerMoveListener(onPointerMove, priorty)


                this.hasListened = !0
            }
        };
        this.disable = function () {

            this.onDisable && this.onDisable()

            if (this.hasListened) {
                pointerEventDispatcher.removePointerDownListener(onPointerDown)
                pointerEventDispatcher.removePointerUpListener(onPointerUp)
                pointerEventDispatcher.removePointerMoveListener(onPointerMove)


                this.hasListened = !1
            }
        };


        this.enable()
    }

    isEnabled() {
        return this.hasListened
    }
}

JMT.PointerEventHelper = PointerEventHelper

/***/ }),

/***/ "./src/utils/StepsClimber.js":
/*!***********************************!*\
  !*** ./src/utils/StepsClimber.js ***!
  \***********************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.StepsClimber = function (a, b, c) {

    var d, e, g = b.cameraWorldPosition(), f = new THREE.Vector3;

    this.updateCameraHeight = function (h) {

        if (d) {

            var k = g.z - f.z;

            null !== b.cameraHeight && (b.cameraHeight += k);

            if (g.x !== f.x || g.y !== f.y) {

                e = a.distanceToGround(JMT.MAX_GROUND_SEARCH_DEPTH)

            }
            else {

                Infinity !== e && (e += k);

            }

            if (Infinity !== e) {

                if (null === b.cameraHeight) {

                    b.cameraHeight = e

                }

                k = b.cameraHeight

                if (e < k - .005 || e > k + .005) {

                    var n = 1.5 * b.camera().moveMaxSpeed;

                    k = b.cameraHeight;

                    h = Math.min(n * h, Math.abs(e - k));

                    e > k && (h = -h);

                    if (0 > h || Infinity === a.distanceToCeiling(h + JMT.MIN_DISTANCE_TO_CEILING)){

                        g.z += h

                        e += h

                        c.requestFrame()
                    }
                }
                f.copy(g)
            }

        }
    };

    this.enable = function () {

        d = !0;

        e = a.distanceToGround(JMT.MAX_GROUND_SEARCH_DEPTH);

        b.cameraHeight = Infinity !== e ? e : null;

        f.copy(g)
    };

    this.disable = function () {

        d = !1

    };

    this.isEnabled = function () {

        return d

    };

    this.enable()
}

/***/ }),

/***/ "./src/utils/Timer.js":
/*!****************************!*\
  !*** ./src/utils/Timer.js ***!
  \****************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.Timer = function () {
    this.clock = performance || Date;
    this.reset()
};
JMT.Timer.prototype = {
    constructor: JMT.Timer, reset: function () {
        this.startMS = this.clock.now()
    }, elapsedMSec: function () {
        return this.clock.now() - this.startMS
    }, elapsedSec: function () {
        return .001 * this.elapsedMSec()
    }
};
JMT.Perf = function () {
    var a = new JMT.Timer, b = [];
    this.begin = function () {
        a.reset()
    };
    this.end = function () {
        b.push(a.elapsedSec());
        if(0 === b.length % 100){
            b.sort()
            console.log("Best " + b[0] + " Median " + b[Math.floor(.5 * b.length)] + " 95 " + b[Math.floor(.95 * b.length)])
        }
    }
};
JMT.DeferringExecutor = function (a, b) {
    function c() {
        d = null;
        a()
    }

    var d = null;
    this.deferRun = function () {
        null !== d && clearTimeout(d);
        d = setTimeout(c, b)
    }
}

/***/ }),

/***/ "./src/utils/asyncFillNotIndexedGeometry.js":
/*!**************************************************!*\
  !*** ./src/utils/asyncFillNotIndexedGeometry.js ***!
  \**************************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */

function unpackVertices(packedBuf, vertexByteOffset, vertexCnt, transforms, quantVertexFactor, vertices, offset) {
    var k = 0;
    for (vertexCnt *= 3; k < vertexCnt; k += 3) {
        var x = packedBuf[k + vertexByteOffset] * quantVertexFactor,
            y = packedBuf[k + vertexByteOffset + 1] * quantVertexFactor,
            z = packedBuf[k + vertexByteOffset + 2] * quantVertexFactor;

        vertices[offset + k]     = transforms[0] * x + transforms[1] * y + transforms[2] * z + transforms[3];
        vertices[offset + k + 1] = transforms[4] * x + transforms[5] * y + transforms[6] * z + transforms[7];
        vertices[offset + k + 2] = transforms[8] * x + transforms[9] * y + transforms[10] * z + transforms[11]
    }
}

function unpackNormals(packedBuf, normalByteOffset, vertexCnt, transforms, normals, offset) {
    var g = 0;
    for (vertexCnt *= 2; g < vertexCnt; g += 2) {
        var k = (packedBuf[g + normalByteOffset] / 254 + .5) * Math.PI, 
        h = Math.PI / 127 * packedBuf[g + normalByteOffset + 1], 

        l = Math.sin(k), 
        m = l * Math.cos(h);
        h = l * Math.sin(h);
        k = Math.cos(k);
        l = transforms[0] * m + transforms[1] * h + transforms[2] * k;
        var q = transforms[4] * m + transforms[5] * h + transforms[6] * k;
        k = 2 * (Math.acos(transforms[8] * m + transforms[9] * h + transforms[10] * k) / Math.PI - .5);
        h = Math.atan2(q, l) / Math.PI;
        normals[offset + g] = JMT.Math.toSnorm8(k);
        normals[offset + g + 1] = JMT.Math.toSnorm8(h)
    }
}

//c
function canFillOwnsGpuBuffers(a) {
    return 0 !== a.instanceId || !1 === a.parent.ownsGpuBuffers
}

function d(a, b, c, d, e, f, g, k, h) {
    var l = 0;
    for (c *= 2; l < c; l += 2) {
        var m = a[l + b], q = a[l + b + 1];
        0 !== m || 0 !== q ? (k[h + l] = Math.round(m * d) + f, k[h + l + 1] = Math.round(q * e) + g) : (k[h + l] = 0, k[h + l + 1] = 0)
    }
}

function fillMeshes(mergedMeshes, b, c, d, e) {
    function f() {
        for (; k < mergedMeshes.length;) {
            var l = mergedMeshes[k];
            if (0 !== h || b(l)) {
                for (; h < l.logicalMeshes.length;) {
                    var m = l.logicalMeshes[h];
                    c(m);
                    h += 1;
                    if (g.shouldInterrupt(m.vertexCnt)) {
                        setTimeout(f, 0);
                        return
                    }
                }
                d(l);
                k += 1;
                h = 0
            }
            else {
                k += 1
            }
        }
        e()
    }

    var g = new l(5E4)
    var k = 0
    var h = 0;
    f()
}

function allocateCoreBuffers(a, b) {
    b.geometry.allocateCoreBuffers(a);
    return !0
}

//f
function allocateUv0(a, b) {
    a ? a = b.anyLogicalMeshHasUvs : (a = b.material, a = b.anyLogicalMeshHasUvs && (a.baseColorTexture || a.bumpTexture || a.roughnessTexture || a.metallicTexture));
    return a ? (b.geometry.allocateUv0(), !0) : !1
}

//h
function allocateUv1(a) {
    return a.lightMap ? (a.geometry.allocateUv1(), !0) : !1
}

//k
function fillUvs1Mod(a, b, c, d, e) {
    var f = 4 * e.instanceId;
    e = e.parent.uvs1Mod;
    e[f] = c / 65535;
    e[f + 1] = d / 65535;
    e[f + 2] = a / 65535;
    e[f + 3] = b / 65535
}

//n
function fillTransforms(a, b) {
    var c = b.parent;
    b = 4 * b.instanceId;
    var d = c.transforms0;
    d[b] = a[0];
    d[b + 1] = a[1];
    d[b + 2] = a[2];
    d[b + 3] = a[3];
    d = c.transforms1;
    d[b] = a[4];
    d[b + 1] = a[5];
    d[b + 2] = a[6];
    d[b + 3] = a[7];
    c = c.transforms2;
    c[b] = a[8];
    c[b + 1] = a[9];
    c[b + 2] = a[10];
    c[b + 3] = a[11]
}

var p = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0])

var l = function (a) {
    this.minVerticesUntilTimeCall = a;
    this.verticesCount = 0;
    this.timer = new JMT.Timer
};

l.prototype.shouldInterrupt = function (a) {
    this.verticesCount += a;
    return this.verticesCount > this.minVerticesUntilTimeCall && 10 < this.timer.elapsedMSec() ?
        (this.verticesCount = 0, this.timer.reset(), !0) : !1
};

JMT.asyncFillIndexedUv0 = function (a, mergedMeshes, d, g, k) {
    var h = new Uint16Array(a), l = new Float32Array(a);
    fillMeshes(mergedMeshes, allocateUv0.bind(null, d), function (jmtMesh) {
        if (jmtMesh.uv0InBuffers()) {
            var b = jmtMesh.geometry;
            if (!canFillOwnsGpuBuffers(b)) {
                var d = b.vertexOffset, e = b.parent;
                if (jmtMesh.quantUv0Disabled()) {
                    b = jmtMesh.uv0ByteOffset / 4;
                    var f = e.uvs0;
                    e = 0;
                    for (let a = 2 * jmtMesh.vertexCnt; e < a; e += 1)
                        f[2 * d + e] = l[e + b]
                } else {
                    b = jmtMesh.uv0ByteOffset / 2;
                    f = jmtMesh.quantUv0Factor();
                    e = e.uvs0;
                    var g = 0;
                    for (let a = 2 * jmtMesh.vertexCnt; g < a; g += 1)
                        e[2 * d + g] = h[g + b] * f
                }
            }
        }
    }, g, k)
};
JMT.asyncFillIndexedUv1 = function (a, mergedMeshes, f, g) {
        var l = new Uint16Array(a);
        fillMeshes(mergedMeshes, allocateUv1, function (jmtMesh) {
            if (jmtMesh.uv1InBuffers()) {
                var b = jmtMesh.uv1CoordUScale, 
                e = jmtMesh.uv1CoordVScale, 
                f = jmtMesh.uv1CoordUOffset, 
                g = jmtMesh.uv1CoordVOffset, 
                h = jmtMesh.geometry;
                if (h.isInstanced) {
                    fillUvs1Mod(b, e, f, g, h);
                    if (canFillOwnsGpuBuffers(h))
                        return;
                    b = e = 1;
                    f = g = 0
                }
                d(l, jmtMesh.uv1ByteOffset / 2, jmtMesh.vertexCnt, b, e, f, g, h.parent.uvs1, 2 * h.vertexOffset)
            }
        }, f, g)
    };
JMT.asyncFillIndexedCoreGeometry = function (d, mergedMeshes, k, h) {
    var l = d.faces16 ? new Uint16Array(d.faces16) : null,
    m = d.faces ? new Uint32Array(d.faces) : null, 
    q = new Int8Array(d.vertices), 
    r = new Int16Array(d.vertices),
    u = new Int32Array(d.vertices), 
    A = new Int8Array(d.normals);
    fillMeshes(mergedMeshes, allocateCoreBuffers.bind(null, !0), function (jmtMesh) {
        var f = jmtMesh.geometry, 
        g = f.parent, 
        k = new Float32Array(d.transforms, jmtMesh.transformByteOffset, 16);

        if (f.isInstanced) {
            fillTransforms(k, f);
            if (canFillOwnsGpuBuffers(f))
                return;
            k = p
        }
        switch (JMT.Math.minBytesToHold(jmtMesh.quantVertexMax)) {
            case 1:
                var h = q;
                var t = jmtMesh.vertexByteOffset;
                break;
            case 2:
                h = r;
                t = jmtMesh.vertexByteOffset / 2;
                break;
            case 4:
                h = u, t = jmtMesh.vertexByteOffset / 4
        }
        var v = f.vertexOffset;
        unpackVertices(h, t, jmtMesh.vertexCnt, k, jmtMesh.quantVertexFactor(), g.vertices, 3 * v);
        unpackNormals(A, jmtMesh.normalByteOffset, jmtMesh.vertexCnt, k, g.normals, 2 * v);
        g = g.indices;
        f = f.indexOffset;
        jmtMesh.useFaces16 ? (t = jmtMesh.faceByteOffset / 2, k = l) : (t = jmtMesh.faceByteOffset / 4, k = m);
        h = t;
        for (let eCount = t + 3 * jmtMesh.faceCnt; h < eCount; h += 1, f += 1)
            g[f] = k[h] + v
    }, k, h)
};

JMT.asyncFillNotIndexedGeometry = function (l, mergedMeshes, m, onProcess, x) {
    var q = l.faces16 ? new Uint16Array(l.faces16) : null
    var v = l.faces ? new Uint32Array(l.faces) : null
    var w = new Int8Array(l.vertices)
    var z = new Int16Array(l.vertices)
    var A = new Int32Array(l.vertices)
    var y = new Int8Array(l.normals)
    var E = new Uint16Array(l.uvs0)
    var I = new Float32Array(l.uvs0)
    var O = l.uvs1 ? new Uint16Array(l.uvs1) : null;

    fillMeshes(mergedMeshes, function (a) {
        allocateCoreBuffers(!1, a);
        allocateUv0(m, a);
        allocateUv1(a);
        return !0
    }, function (jmtMesh) {
        var f = jmtMesh.geometry
        var g = jmtMesh.geometry.parent
        var h = new Float32Array(l.transforms, jmtMesh.transformByteOffset, 16);
        var m = null

        if (jmtMesh.uv0InBuffers() && g.uvs0){
            m = g.uvs0;
        }
        if (jmtMesh.uv1InBuffers() && g.uvs1) {
            var r = g.uvs1;
            var u = jmtMesh.uv1CoordUScale;
            var t = jmtMesh.uv1CoordVScale;
            var x = jmtMesh.uv1CoordUOffset;
            var J = jmtMesh.uv1CoordVOffset
        }
        if (f.isInstanced) {
            fillTransforms(h, f);
            r && fillUvs1Mod(u, t, x, J, f);
            if (canFillOwnsGpuBuffers(f)) {
                return;
            }
            h = p;
            u = t = 1;
            x = J = 0
        }
        if (jmtMesh.useFaces16) {
            f = q;
            var L = jmtMesh.faceByteOffset / 2
        }
        else {
            f = v
            L = jmtMesh.faceByteOffset / 4;
        }
        switch (JMT.Math.minBytesToHold(jmtMesh.quantVertexMax)) {
            case 1:
                var K =
                    w;
                var M = jmtMesh.vertexByteOffset;
                break;
            case 2:
                K = z;
                M = jmtMesh.vertexByteOffset / 2;
                break;
            case 4:
                K = A
                M = jmtMesh.vertexByteOffset / 4
                break;
        }
        var R = jmtMesh.quantUv0Disabled();
        if (R){
            var F = jmtMesh.uv0ByteOffset / 4;
        }
        else {
            var P = jmtMesh.quantUv0Factor();
            F = jmtMesh.uv0ByteOffset / 2
        }
        var V = 3 * jmtMesh.geometry.vertexOffset
        var aa = 2 * jmtMesh.geometry.vertexOffset
        var U = jmtMesh.quantVertexFactor()
        var X = g.vertices;
        g = g.normals;
        var S = jmtMesh.normalByteOffset, da = jmtMesh.uv1ByteOffset / 2, ba = L;
        for (let e = L + 3 * jmtMesh.faceCnt; ba < e; ba += 1, V += 3, aa += 2) {
            L = f[ba];
            unpackVertices(K, M + 3 * L, 1, h, U, X, V);
            unpackNormals(y, S + 2 * L, 1, h, g, aa);
            if (m) {
                var ea = F + 2 * L;
                if (R){
                    for (var ia = m, la = aa, fa = 0; 2 > fa; fa += 1){
                        ia[la + fa] = I[fa + ea];
                    }
                }
                else {
                    ia = P;
                    la = m;
                    fa = aa;
                    for (var ha = 0; 2 > ha; ha += 1)la[fa + ha] = E[ha + ea] * ia
                }
            }
            r && d(O, da + 2 * L, 1, u, t, x, J, r, aa)
        }
    }, onProcess, x)
}

/***/ }),

/***/ "./teleport/HashChangeTeleport.js":
/*!****************************************!*\
  !*** ./teleport/HashChangeTeleport.js ***!
  \****************************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
/*
 Copyright (C) 2018-present M.K.
 */
JMT.HashChangeTeleport = function (a, b) {

    function onhashchange() {

        var c = JMT.urlHashGetArgument("view");

        if (c) {

            c = a.findViewByName(c)

            if (c) {

                b.switchToView(c)

                window.location.hash = JMT.urlHashRemoveArgument("view")
            }
        }
    }

    window.addEventListener("hashchange", onhashchange, !1);

    this.dispose = function () {

        window.removeEventListener("hashchange", onhashchange, !1)

    }
}

/***/ }),

/***/ "./teleport/Teleport.js":
/*!******************************!*\
  !*** ./teleport/Teleport.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


function SkyUnit(scene) {
    var _activateSky = null;
    this.activateSky = function (name) {
        //return;
        if (_activateSky) {
            if (_activateSky.name === name) {
                return;
            }
            scene.removeAuxiliaryObject(_activateSky)
        }
        var skyMesh = scene.findSkyMesh(name);

        var skyTexture = skyMesh.material.map

        if (skyTexture && !skyTexture.loaded) {
            this.activateSky(JMT.DEFAULT_SKY_NAME)
            _activateSky = skyMesh
            skyTexture.addLoadedListener(function () {
                if (_activateSky === skyMesh) {
                    scene.addAuxiliaryObject(skyMesh)
                    skyMesh.updateMatrixWorld(!0)
                }
            })
        } else {
            scene.addAuxiliaryObject(skyMesh)
            skyMesh.updateMatrixWorld(!0)
            _activateSky = skyMesh
        }
    };
    this.activeSkyName = function () {
        return _activateSky && _activateSky.name
    }
}

var c = 1 / 180;

class CameraUnit {

    constructor(position, rotation, fov) {
        this.position = position || new THREE.Vector3();
        this.rotation = rotation || new THREE.Vector2();
        this.fov = fov || 0
    }

    length() {
        return Math.sqrt(this.position.lengthSq() + this.rotation.lengthSq() + this.fov * this.fov)
    }

    multiplyScalar(a) {
        this.position.multiplyScalar(a);
        this.rotation.multiplyScalar(a);
        this.fov *= a;
        return this
    }

    divideScalar(a) {
        this.position.divideScalar(a);
        this.rotation.divideScalar(a);
        this.fov /= a;
        return this
    }

    normalize() {
        return this.divideScalar(this.length())
    }

    normalizeRotation() {
        this.rotation.x = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(this.rotation.x);
        this.rotation.y = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(this.rotation.y);
        return this
    }

    distanceTo(a) {
        var b = this.position.x - a.position.x
        var c = this.position.y - a.position.y
        var d = this.position.z - a.position.z
        var h = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(this.rotation.x - a.rotation.x)
        var k = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(this.rotation.y - a.rotation.y);
        a = this.fov - a.fov;
        return Math.sqrt(b * b + c * c + d * d + h * h + k * k + a * a)
    }

    subVectors(a, b) {
        this.position.subVectors(a.position, b.position);
        this.rotation.subVectors(a.rotation, b.rotation);
        this.fov = a.fov - b.fov;
        return this.normalizeRotation()
    }

    copy(a) {
        this.position.copy(a.position);
        this.rotation.copy(a.rotation);
        this.fov = a.fov;
        return this
    }
}

JMT.Teleport = function (scene, controls, collider, aniController) { // d, e, g, f

    function onViewChanged() { // h

        _hiddenMeshesInAllViews = [];

        for (var a = 0; a < scene.views.length; a += 1) {

            _hiddenMeshesInAllViews[scene.views[a].id] = [];

        }

        // 隐藏场景NODE
        for (a = 0; a < scene.gpuMeshes.length; a += 1) {

            var b = scene.gpuMeshes[a]

            var c = b.hideInViews;

            if (c) {

                for (var e = 0; e < c.length; e += 1) {

                    if (_hiddenMeshesInAllViews[c[e]]) {

                        _hiddenMeshesInAllViews[c[e]].push(b)

                    } else {

                        console.warn("Invalid view id in hideInViews list: '" + c[a] + "'")

                    }
                }
            }
        }
    }

    // 隐藏素材
    // TODO: 以下可以优化
    function _updateFromAssets(assets) {

        for (var b of assets) {

            var c = b.hideInViews;

            if (c) {

                for (var e = 0; e < c.length; e += 1) {

                    if (_hiddenMeshesInAllViews[c[e]]) {

                        _hiddenMeshesInAllViews[c[e]].push(b)

                    } else {

                        console.warn("Invalid view id in hideInViews list: '" + c[a] + "'")

                    }
                }
            }
        }
    }

    this.updateFromAssets = function (assets) {
        _updateFromAssets(assets)
    }

    function hide(hiddenMeshes) { // k

        for (var b = 0; b < hiddenMeshes.length; b += 1) {

            var c = hiddenMeshes[b];

            c.visible = !1;

            _hiddenMeshes.push(c)

        }
    }

    function show() { // n

        for (var a = 0; a < _hiddenMeshes.length; a += 1) {

            _hiddenMeshes[a].visible = !0;

        }

        _hiddenMeshes.length = 0

    }

    function reHide(a) { // p
        show();
        hide(a)
    }

    function solveCamera() { // l
        _camera.fov = v.fov;
        _cameraWorldPosition.copy(v.position);
        controls.setYawAngle(v.rotation.x);
        controls.setPitchAngle(v.rotation.y);
        controls.cameraPositionUpdated()
    }

    // 判断点是否有线段上
    function isPointOnLine(q, p1, p2) {
        p1 = {
            x: p1[0],
            y: p1[1]
        }
        p2 = {
            x: p2[0],
            y: p2[1]
        }
        q = {
            x: q[0],
            y: q[1]
        }
        let k1 = ((p2.y - p1.y) / (p2.x - p1.x)).toFixed(3)
        let k2 = ((q.y - p1.y) / (q.x - p1.x)).toFixed(3)
        let error = Math.abs(k2 - k1)
        if (error - 0.1 <= Number.EPSILON) {
            return true
        } else {
            return false
        }
    }

    var q = this
    var skyUnit = new SkyUnit(scene)
    var _cameraWorldPosition = controls.cameraWorldPosition() // m
    var _camera = scene.camera // u
    var _hiddenMeshesInAllViews
    var _hiddenMeshes = [] // t
    var v = new CameraUnit()
    var w = new CameraUnit()
    var _toPosition = new THREE.Vector3() // z
    var A = 0
    var y = 0
    var E = 0
    var I
    var O
    var _uniformVelocity = 0 // 匀速运行情况下的平均速度
    var _curView
    var T = !1
    //var Y = {
    //    type: "teleportStarted",
    //    view: null
    //}
    //var Q = {type: "teleportDone", view: null}
    var C = null;

    // 需要经过的视图列表，自动导览匀速前进时使用
    var _passViews = [];

    this.lastDestinationView = null;

    var B = this.teleportingToPoint = this.teleportingToView = !1
    var H = !1

    var N = function () {
        var a = new CameraUnit(controls.cameraWorldPosition());
        return function () {
            a.rotation.set(controls.getYawAngle(), controls.getPitchAngle());
            a.normalizeRotation();
            a.fov = _camera.fov;
            return a
        }
    }();

    /**
     * 自动导览更新函数
     */
    this.update = function () {

        // 加速行进,a是本次行进时间,b是到目的地的剩余距离
        function accelerateWalk(a, b) {

            // 速度增量
            var c = 0;

            // 速度为y时，已行进的距离值，如果大于或者等于剩余的行进长度，开始减速
            if (y * y / (2 * E) >= b) { // 减速过程

                // c是速度为y时的时间
                c = y / E

                // 速度为y时，行进的距离
                c = 2 * (y * c - b) / (c * c) * -a
            } else { // 加速过程
                // 加速度乘时间求瞬时速度，A是行进到一半距离时的速度，即最大速度值
                y < A && (c = a * E);
            }

            d.copy(w);

            // 当前速度
            y = THREE.Math.clamp(y + .5 * c, 0, A);

            // y是速度，a是最小计算时间单元，d是行进的位置和姿态
            d.multiplyScalar(y * a);

            y = THREE.Math.clamp(y + .5 * c, 0, A);

            // 应用相机视场角变化
            if (d.fov) {

                _camera.fov += d.fov

                _camera.updateProjectionMatrix()

            }

            // 应用相机位置变化
            _cameraWorldPosition.add(d.position);

            controls.setYawAngle(controls.getYawAngle() + d.rotation.x);

            controls.setPitchAngle(controls.getPitchAngle() + d.rotation.y)
        }

        /**
         * 匀速行进,a是本次行进时间,b是到目的地的剩余距离
         * @param {本次行进时间} a 
         * @param {到目的地的剩余距离} b 
         */
        function uniformWalk(a, b) {

            // 速度增量
            var c = 0;

            // // 速度为y时，已行进的距离值，如果大于或者等于剩余的行进长度，开始减速
            // if (y * y / (2 * E) >= b) { // 减速过程

            //     // c是速度为y时的时间
            //     c = y / E

            //     // 速度为y时，行进的距离
            //     c = 2 * (y * c - b) / (c * c) * -a
            // }
            // else { // 加速过程
            //     // 加速度乘时间求瞬时速度，A是行进到一半距离时的速度，即最大速度值
            //     y < A && (c = a * E);
            // }

            d.copy(w);
            //_uniformVelocity &&  (c = _uniformVelocity)

            // 当前速度
            //y = THREE.Math.clamp(y + .5 * c, 0, A);

            // y是速度，a是最小计算时间单元，d是行进的位置和姿态
            d.multiplyScalar(_uniformVelocity * a);

            //y = THREE.Math.clamp(y + .5 * c, 0, A);

            // 应用相机视场角变化
            if (d.fov) {

                _camera.fov += d.fov

                _camera.updateProjectionMatrix()
            }

            // 应用相机位置变化
            _cameraWorldPosition.add(d.position);

            controls.setYawAngle(controls.getYawAngle() + d.rotation.x);

            controls.setPitchAngle(controls.getPitchAngle() + d.rotation.y)
        }

        var d = new CameraUnit();

        return function (b) {

            if (q.teleportingToView || q.teleportingToPoint) {

                // b是间隔时间
                b = Math.min(b, .067);

                b = Math.max(b, c);

                // 相机当前到目标视图的距离,v是目标视图
                var d = N().distanceTo(v);

                // if (d >= 0) {
                //     console.log('Not finished!');
                // } else {
                //     console.log('finished!');
                // }

                // var d;
                // for(var i = 0; i < _passViews.length; i++){
                //     if(isPointOnLine(N(), _passViews[i].position, _passViews[i + 1].position)){

                //     }
                // }

                this.teleportingToPoint && (v.position.z = _cameraWorldPosition.z);

                var g = !0;

                if (0 !== d && !isNaN(d)) {

                    // 计算当前时间间隔内的位移（位置和姿态）,b是位移时间，d是剩余的距离
                    // 加速行进
                    if (!!_curView && !!_curView.evenMove) {
                        // 匀速运动
                        uniformWalk(b, d)
                    } else {
                        // 加速-匀速-减速运动
                        accelerateWalk(b, d)
                    }

                    if (N().distanceTo(v) > d) {

                        if (!!_curView && !!_curView.nextView && !!_curView.nextView.evenMove && !!q.isAutoRunning) {
                            q.switchToView(_curView.nextView, _curView.nextView.moveTime);
                            g = !1
                        } else {
                            solveCamera()
                        }
                    } else {
                        g = !1
                    }

                    controls.cameraPositionUpdated()
                }

                if (g) {

                    if (this.teleportingToView) {

                        if ("orbit" !== _curView.mode || T) {

                            b = controls.camera()

                            b.near = JMT.CAMERA_WALK_NEAR

                            b.updateProjectionMatrix()

                            controls.enable()
                            this.dispatchEvent({
                                type: "teleportDone",
                                view: _curView
                            })
                        } else {

                            controls.orbit.minDistance = I

                            controls.orbit.maxDistance = O

                            controls.orbit.setPanPrimary(_curView.panPrimary || !1)

                            controls.orbit.noPan = _curView.noPan || !1

                            controls.orbit.noRotate = _curView.noRotate || !1

                            controls.orbit.noPitchRotate = _curView.noPitchRotate || !1

                            controls.orbit.getMinPitchAngle = function () {
                                return -_curView.maxUpAngle
                            }

                            controls.orbit.getMaxPitchAngle = function () {
                                return -_curView.minUpAngle
                            }

                            controls.orbit.minYawAngle = -_curView.maxSideAngle

                            controls.orbit.maxYawAngle = -_curView.minSideAngle

                            controls.orbit.target.copy(_toPosition)

                            controls.orbitModeEnable()
                        }


                        skyUnit.activateSky(_curView.sky)

                        reHide(_hiddenMeshesInAllViews[_curView.id] || [])
                    }

                    this.teleportingToView = this.teleportingToPoint = !1

                }


                aniController.requestFrame()
            }

        }
    }();

    /**
     * 取消跳转到点
     */
    this.cancelSwitchToPoint = function () {

        console.assert(this.teleportingToPoint);

        this.teleportingToPoint = !1;

        this.dispatchEvent({
            type: "teleportDone",
            view: null
        })
    };

    /**
     * 取消跳转到视图
     */
    this.cancelSwitchToView = function () {
        if (!!_curView) {
            v.position.set(_cameraWorldPosition.x, _cameraWorldPosition.y, _cameraWorldPosition.z)
            v.rotation.set(controls.getYawAngle(), controls.getPitchAngle())

            // 取消自动浏览，返回到上个视图
            if (!!_curView.preView)
                _curView = _curView.preView;
            C = _curView;
            controls.enable();
            if (!!_curView.fov)
                v.fov = _curView.fov;
            this.dispatchEvent({
                type: "teleportDone",
                view: _curView
            })
        }
    }

    /**
     * 跳转到指定的坐标点
     * @param {*} point 
     */
    this.switchToPoint = function (point) {
        if (point.x !== _cameraWorldPosition.x || point.y !== _cameraWorldPosition.y) {

            _curView = null

            this.teleportingToPoint = !0

            this.teleportingToView = !1

            //Y.view = null

            this.dispatchEvent({
                type: "teleportStarted",
                view: null
            })

            if (B) {

                v.position.set(point.x, point.y, point.z)

            } else {

                v.position.set(point.x, point.y, _cameraWorldPosition.z)

            }

            var rotation = Math.atan2(-(point.x - _cameraWorldPosition.x), point.y - _cameraWorldPosition.y)

            rotation = (0,_utils_utils_js__WEBPACK_IMPORTED_MODULE_0__.normalizeRotation)(rotation)

            v.rotation.set(rotation, 0)

            v.fov = _camera.defaultFov

            if (B) {

                solveCamera()

                this.update(c);

            } else {

                w.subVectors(v, N());

                var a = w.length();

                A = 2 * JMT.CAMERA_DEFAULT_MOVE_MAX_SPEED;

                E = A / JMT.CAMERA_FULL_ACCELERATION_TIME;

                var b = JMT.TELEPORT_TO_POINT_MAX_TIME;

                if (a > (b - JMT.CAMERA_FULL_ACCELERATION_TIME) * A) {

                    A = JMT.Math.anyPositiveRootOfQuadraticEquation(1, -E * b, E * a)

                    if (null === A) {

                        b /= 2

                        E = a / (b * b)

                        A = E * b

                    }
                }

                w.normalize();

                y = 0;

                aniController.requestFrame()
            }
        }
    };

    /**
     * 跳转到指定的视图
     * @param {*} view 
     * @param {*} time 
     */
    this.switchToView = function (view, time) {

        void 0 === time && (time = JMT.TELEPORT_TO_VIEW_MAX_TIME);

        view.hideFromMenu || (C = view);

        this.lastDestinationView = _curView = view;

        this.teleportingToView = !0;

        this.teleportingToPoint = !1;

        this.dispatchEvent({
            type: "switchToView",
            view: _curView
        });

        controls.disable();

        controls.resetRollAngle();

        hide(_hiddenMeshesInAllViews[_curView.id] || []);

        if (void 0 !== _curView.rotation) {
            v.rotation.set(_curView.rotation.yaw, _curView.rotation.pitch)
        } else {
            v.rotation.set(0, 0);
        }

        v.fov = _curView.fov || _camera.defaultFov;

        if ("orbit" === _curView.mode) {

            if (void 0 !== _curView.target) {
                _toPosition.set(_curView.target.x, _curView.target.y, _curView.target.z)
            } else {
                _toPosition.set(0, 0, 0)
            }

            I = _curView.minDistance || 0

            O = _curView.maxDistance || 100

            var distance = THREE.Math.clamp(_curView.distance || 10, I, O)

            JMT.OrbitControls.computeCameraPosition(v.position, _toPosition, v.rotation.x, v.rotation.y, distance)

            var camera = controls.camera()

            camera.near = JMT.CAMERA_ORBIT_NEAR

            camera.updateProjectionMatrix()

        } else if (void 0 !== _curView.position) {

            v.position.set(_curView.position.x, _curView.position.y, _curView.position.z)

            H && collider.adjustPointToMatchCameraHeight(v.position)

        } else {

            v.position.set(0, 0, 0);

        }

        if (0 === time || B) {

            solveCamera()

            this.update(c);

        } else {

            if (_curView.sky !== skyUnit.activeSkyName()) {
                skyUnit.activateSky(JMT.DEFAULT_SKY_NAME);
            }

            w.subVectors(v, N());

            // 相机到视图的距离
            var distanceToCamera = w.length();

            // 加速度
            E = JMT.TELEPORT_TO_VIEW_ACCELERATION;

            // 行进到一半距离所需要的时间
            var d = Math.sqrt(distanceToCamera / E);

            // 如果行进到一半距离所需的时间比总跳转时间的一半还长
            //if (d > time / 2) {

            // 则强制将行进一半的时间设为总跳转时间的一半
            d = time / 2

            // 重新计算合适的加速度值
            E = distanceToCamera / (d * d)

            //}

            // 行进一半距离时的速度值
            A = E * d;

            // 计算匀速运行情况下的平均速度
            _uniformVelocity = distanceToCamera / time;

            w.normalize();

            y = 0
        }

        aniController.requestFrame()
    };

    /**
     * 跳转到指定的视图
     * @param {*} view 
     * @param {*} passViews 
     */
    this.switchToView2 = function (view, passViews) {
        _passViews = passViews.clone();

        var time = 0;
        var length = 0;
        for (var i = 0; i < _passViews.length; i++) {
            time += _passViews[i].moveTime;
            length += _passViews[i].length;
        }

        void 0 === time && (time = JMT.TELEPORT_TO_VIEW_MAX_TIME);

        view.hideFromMenu || (C = view);

        this.lastDestinationView = _curView = view;

        this.teleportingToView = !0;

        this.teleportingToPoint = !1;

        this.dispatchEvent({
            type: "switchToView",
            view: _curView
        });

        controls.disable();

        controls.resetRollAngle();

        hide(_hiddenMeshesInAllViews[_curView.id] || []);

        if (void 0 !== _curView.rotation) {
            v.rotation.set(_curView.rotation.yaw, _curView.rotation.pitch)
        } else {
            v.rotation.set(0, 0);
        }

        v.fov = _curView.fov || _camera.defaultFov;

        if ("orbit" === _curView.mode) {

            if (void 0 !== _curView.target) {
                _toPosition.set(_curView.target.x, _curView.target.y, _curView.target.z)
            } else {
                _toPosition.set(0, 0, 0)
            }

            I = _curView.minDistance || 0

            O = _curView.maxDistance || 100

            var distance = THREE.Math.clamp(_curView.distance || 10, I, O)

            JMT.OrbitControls.computeCameraPosition(v.position, _toPosition, v.rotation.x, v.rotation.y, distance)

            var camera = controls.camera()

            camera.near = JMT.CAMERA_ORBIT_NEAR

            camera.updateProjectionMatrix()

        } else if (void 0 !== _curView.position) {

            v.position.set(_curView.position.x, _curView.position.y, _curView.position.z)

            H && collider.adjustPointToMatchCameraHeight(v.position)

        } else {

            v.position.set(0, 0, 0);

        }

        if (0 === time || B) {

            solveCamera()

            this.update(c);

        } else {

            if (_curView.sky !== skyUnit.activeSkyName()) {
                skyUnit.activateSky(JMT.DEFAULT_SKY_NAME);
            }

            w.subVectors(v, N());

            // 相机到视图的距离
            var distanceToCamera = w.length();
            distanceToCamera = length;

            // 加速度
            E = JMT.TELEPORT_TO_VIEW_ACCELERATION;

            // 行进到一半距离所需要的时间
            var d = Math.sqrt(distanceToCamera / E);

            // 如果行进到一半距离所需的时间比总跳转时间的一半还长
            //if (d > time / 2) {

            // 则强制将行进一半的时间设为总跳转时间的一半
            d = time / 2

            // 重新计算合适的加速度值
            E = distanceToCamera / (d * d)

            //}

            // 行进一半距离时的速度值
            A = E * d;

            // 计算匀速运行情况下的平均速度
            _uniformVelocity = distanceToCamera / time;

            w.normalize();

            y = 0
        }

        aniController.requestFrame()
    };

    /**
     * 跳转到下一个有效视图
     * @param {*} step 
     * @param {*} time 
     * @param {*} index 
     */
    this._switchToAdjacentVisibleView = function (step, time, index = 0) {

        //var views = scene.visibleViews();

        var views = scene.visibleViewsOfTour(index);

        if (0 !== views.length) {

            if (null === C) {

                this.switchToView(views[0], views[0].moveTime);
                if (views[0].stopTime) {
                    JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS = views[0].stopTime * 1000
                }
            } else {

                var viewIndex = views.indexOf(C);

                if (-1 === viewIndex) {
                    this.switchToView(views[0], views[0].moveTime)

                    if (views[0].stopTime) {
                        JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS = views[0].stopTime * 1000
                    }
                }

                JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS = 0

                // 挂接前后视图，组成链条
                for (var i = 0; i < views.length; i++) {
                    if (i === 0) {
                        views[i].preView = views[views.length - 1];
                    } else {
                        views[i].preView = views[i - 1];
                    }

                    if (i === views.length - 1) {
                        views[i].nextView = views[0];
                    } else {
                        views[i].nextView = views[i + 1];
                    }

                    // 前一个视图到当前视图的距离
                    if (!!views[i].preView.position && !!views[i].position) {
                        // 顶视图没有position属性
                        views[i].passLength = views[i].preView.position.distanceTo(views[i].position)
                    } else {
                        views[i].passLength = 100;
                    }
                }

                var passViews = []; // 经过的视图
                var sumTime = 0;
                var sumLength = 0;
                for (var i = viewIndex + 1; i < views.length; i++) {
                    if (!!views[i].evenMove) {
                        passViews.push(views[i]);
                        sumTime += views[i].moveTime;
                        sumLength += views[i].passLength;
                        continue;
                    }

                    break;
                }

                // 平均速度
                var uniformSpeed = sumLength / sumTime;

                for (var i = 0; i < passViews.length; i++) {
                    if (passViews[i].passLength > 0) {
                        passViews[i].moveTime = passViews[i].passLength / uniformSpeed;
                    }
                }

                this.switchToView(views[(viewIndex + views.length + step) % views.length], views[(viewIndex + views.length + step) % views.length].moveTime)

                if (views[(viewIndex + views.length + step) % views.length].stopTime) {
                    JMT.AUTO_TOUR_IN_VIEW_STILL_TIME_MS = views[(viewIndex + views.length + step) % views.length].stopTime * 1000
                }
            }
        }

    };

    this.switchToPreviousVisibleView = function (time, index) {
        this._switchToAdjacentVisibleView(-1, time, index)
    };

    this.switchToNextVisibleView = function (time, index) {
        this._switchToAdjacentVisibleView(1, time, index)
    };

    this.updateHiddenMeshes = function (view) {
        onViewChanged(); // h()
        view ? reHide(_hiddenMeshesInAllViews[view.id] || []) : show();
        aniController.requestFrame()
    };

    this.activateSky = function (a) {
        skyUnit.activateSky(a.sky);
        aniController.requestFrame()
    };

    this.executeWithViewVisibilitySettings = function (view, onComplete) {
        var meshes = _hiddenMeshes.slice();
        reHide(_hiddenMeshesInAllViews[view.id] || []);
        skyUnit.activateSky(view.sky);
        onComplete();
        skyUnit.activateSky(this.lastDestinationView.sky);
        reHide(meshes)
    };

    this.onVrChange = function (isVrMode) {
        H = B = T = isVrMode;

        if (this.lastDestinationView && "orbit" === this.lastDestinationView.mode) {

            this.switchToView(this.lastDestinationView, 0)

        }
    };

    onViewChanged();

    scene.addEventListener("viewAdded", onViewChanged);
    scene.addEventListener("viewRemoved", onViewChanged);
    scene.addEventListener("skyMeshAdded", function (event) {
        skyUnit.activateSky(event.skyMesh.name);
        aniController.requestFrame()
    });
    scene.addEventListener("skyMeshRemoved", function (event) {
        if (skyUnit.activeSkyName() === event.skyMesh.name) {
            skyUnit.activateSky(JMT.DEFAULT_SKY_NAME)
            aniController.requestFrame()
        }
    })
};

JMT.Teleport.prototype = Object.create(THREE.EventDispatcher.prototype)
JMT.Teleport.prototype.constructor = JMT.Teleport

/***/ }),

/***/ "./ui/AnimateManager.js":
/*!******************************!*\
  !*** ./ui/AnimateManager.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_Tween_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/Tween.js */ "./utils/Tween.js");
/* harmony import */ var _utils_Tween_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_utils_Tween_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _effect_fire_Fire_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../effect/fire/Fire.js */ "./effect/fire/Fire.js");
/* harmony import */ var _effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../effect/FlagMesh.js */ "./effect/FlagMesh.js");
/* harmony import */ var _effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_effect_FlagMesh_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/interactionDetector.js */ "./utils/interactionDetector.js");
/**
 * Created by Kai on 2021/1/28.
 */





//import '../effect/RipplingFlagMaterial.js'

class AnimateManager {
    constructor(ui) {
        UjP.animateManager = this
        this.id = 'animateManager'
        this.hint = '动画管理'
        this.hintEnabled = ''
        this.hintDisabled = ''
        this.iconID = 'assetsIcon'
        this.iconClass = 'icon-play'
        this.opened = false
        this.itemCount = 0

        this.panel = document.getElementById('panel-bottom')

        let n = this

        this.aniDoor = {
            mesh: null,
            axisFrom: null,
            axisTo: null
        }


        function onDragStart(e) {
            //dataTransfer.setData()方法设置数据类型和拖动的数据
            //e.dataTransfer.setData("Text", e.target.src);
            n._target = e.target.parentElement

            n.disableSelect = true
        }

        function onDrag(e) {
            console.log('AnimateManager  AnimateManager  AnimateManager  AnimateManager');
            console.log('jmk>>onDrag>>' + e.dataTransfer);

            let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_3__.detectIntersect)(e)

            if (b) {

                if (n._target.children[1].id === 'addFire') {
                    n.addFire(b)
                }
                else if (b.object === n.selected) {
                    console.log(b.point);
                    n._target.children[1].innerText = b.point
                    n.updateAxis(n._target.children[1].id, b.point)
                }

                UjP.aniController.requestFrame()
            }
        }


        function onDrop(e) {
            //阻止浏览器默认打开文件的操作
            e.preventDefault();
            e.stopPropagation();


            n.disableSelect = false
            n._asset = null
            n._target = null
            n._fire = null

            UjP.aniController.requestFrame()
        }

        function onMouseDown(event) {
            //阻止浏览器默认打开文件的操作
            event.preventDefault();
            event.stopPropagation();

            if (n.selected) {
                n.selected.material.highlightMix = 0
                n.selected = null
            }

            let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_3__.detectIntersect)(event)

            if (b && b.object) {
                b.object.material.highlightMix = 0.8
                n.selected = b.object
                n.aniDoor.mesh = b.object
            }

            UjP.aniController.requestFrame()
        }

        function onDoubleClick(event) {
            //阻止浏览器默认打开文件的操作
            event.preventDefault();
            event.stopPropagation();

            if (n.selected) {

                let b = (0,_utils_interactionDetector_js__WEBPACK_IMPORTED_MODULE_3__.findIntersectionAtPosition)(event, [n.selected])

                if (b && b.object) {


                }

            }


            console.log(event);
        }

        function onFlagClick() {
            console.log(n.selected);

            let mesh = n.selected

            if (!mesh) {
                return
            }

            var meshobj = new JMT.FlagMesh()
            var pos = [2.7428780503604955, 2.356677830057201, 0.30000001192092896]

            //meshobj.position.set(ret_ins.point[0], ret_ins.point[1], ret_ins.point[2])
            //meshobj.position.set(4.744845057133162, 3.375860214233398, 1.0589401669569058)
            meshobj.position.set(pos[0], pos[1], pos[2])
            //meshobj.quaternion.set(0.70710678, 0.0, 0.0, 0.70710678)
            meshobj.rotation.set(THREE.Math.degToRad(90), THREE.Math.degToRad(180), 0)
            //meshobj.rotation.set(90)
            meshobj.setFlagSize(1, 0.5)
            meshobj.setPoleHeight(2.5)
            meshobj.updateMatrixWorld(1)
            UjP.scene.addAuxiliaryObject(meshobj)

            let interval1 = 1E3 / 30

            let clock1 = new THREE.Clock()
            let renderInterval1 = setInterval(function () {
                meshobj.update(clock1.getDelta())
                UjP.aniController.requestFrame()
            }, interval1)
            return


            //mesh.material.opacity = 0.5
            //mesh.material.needsUpdate = true

            let flagMat = new JMT.RipplingFlagMaterial()

            let ct = mesh.material.baseColorTexture

            let url = 'effect/noise.png'
            let param = {
                alpha: false,
                id: url,
                name: 'noname',
                rawExt: "png",
                stdExt: "jpg",
                url: url,
                webFormats: [
                    //"small/std", "large/dxt", "small/pvr", "small/etc1"
                ]
            }
            let loader = new JMT.TextureLoader("./",
                JMT.DETECTOR, function (a) {

                }, !0, !0, !0)
            let t = loader.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, param, !0, !0, JMT.DEFAULT_ANISOTROPY)
            // TODO: 是否从编辑模式进来？
            t.fromEditor = !0;
            flagMat.noiseMap = t
            flagMat.baseColorTexture = ct


            flagMat.setUniforms()
            mesh.material = flagMat


            let interval = 1E3 / 30

            let clock = new THREE.Clock()
            let renderInterval = setInterval(function () {
                mesh.material.update(clock.getDelta())
                UjP.aniController.requestFrame()
            }, interval)
        }

        function onPlayClick() {
            console.log(n.selected);

            let mesh = n.selected

            if (!mesh) {
                return
            }


            let timeSpan = 5E3
            let interval = 1E3 / 30

            let renderInterval = setInterval(function () {
                TWEEN.update()
            }, interval)


            let frame = timeSpan / interval


            let fro = mesh.matrixWorld
            if (!fro) {
                fro = new THREE.Matrix4().elements
            }

            let anchor = mesh.geometry.boundingSphere.center.toArray()

            let input = document.getElementById('axisFrom').innerText
            if (input) {
                input = input.split(',')
                anchor = [
                    parseFloat(input[0]),
                    parseFloat(input[1]),
                    parseFloat(input[2])
                ]
            }

            let deltaAngle = 90 / frame

            let o = {i: 0}
            var v = new TWEEN.Tween(o);
            v.to({i: frame}, timeSpan)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start().onUpdate((function () {

                    let angle = o.i * deltaAngle

                    let a = n.buildRotationMatrix(anchor, 'z', angle)

                    mesh.matrixWorld = a

                    //mesh.updateWorldMatrix(!0)

                    UjP.aniController.requestFrame()
                    //o.i += 0.1
                })).onComplete((function () {
                    clearInterval(renderInterval)
                })
            )

        }

        this.init = function () {
            UjP.Viewport.addEventListener('mousedown', onMouseDown, false)
            UjP.Viewport.addEventListener('dblclick', onDoubleClick, false)
            UjP.Viewport.addEventListener('dragover', onDrag)
            UjP.Viewport.addEventListener('drop', onDrop)
        }

        this.dispose = function () {
            UjP.Viewport.removeEventListener('mousedown', onMouseDown, false)
            UjP.Viewport.removeEventListener('dblclick', onDoubleClick, false)
            UjP.Viewport.removeEventListener('dragover', onDrag)
            UjP.Viewport.removeEventListener('drop', onDrop)
        }

        /////////////////////////////////////////////////////////////////////////////////
        //

        // Just for test
        n.onClick = function () {
            if (!this.opened) {

                this.init()

                this.panel.style.display = 'inherit'

                let ais = document.getElementsByClassName('menu-button')
                for (let i = 0; i < ais.length; i++) {
                    let ai = ais[i]
                    ai.addEventListener('dragstart', onDragStart)
                }

                document.getElementById('aniPlay').addEventListener('click', onPlayClick)
                document.getElementById('aniFlag').addEventListener('click', onFlagClick)
            }
            else {

                this.dispose()

                this.panel.style.display = 'none'

                let ais = document.getElementsByClassName('menu-button')
                for (let i = 0; i < ais.length; i++) {
                    let ai = ais[i]
                    ai.removeEventListener('dragstart', onDragStart)
                }

                document.getElementById('aniPlay').removeEventListener('click', onPlayClick)
                document.getElementById('aniFlag').removeEventListener('click', onFlagClick)
            }

            this.opened = !this.opened
        }

        let urlBase = ui.urlBase || ''
        let a = `
<div>
    <image class="menu-button" src="` + urlBase + `css/image/green-circle.png"></image>
    <span id="axisFrom"></span>
</div>
<div>
    <image class="menu-button" src="` + urlBase + `css/image/hotspot.png"></image>
    <span id="axisTo"></span>
</div>
<div>
    <image class="menu-button" src="` + urlBase + `css/image/fire.gif"></image>
    <span id="addFire"></span>
</div>
<select id="aniType">
    <option value="rotation">旋转</option>
    <option value="translate">平移</option>
</select>
<button id="aniPlay">播放</button>
<button id="aniFlag">旗帜</button>
`

        let divDom = document.createElement('div')
        divDom.innerHTML = a
        this.panel.appendChild(divDom)
    }

    updateAxis(id, point) {
        this.aniDoor[id] = point

        if (this.aniDoor.mesh && this.aniDoor.axisFrom && this.aniDoor.axisTo) {
            this.createLineMesh(this.aniDoor.axisFrom, this.aniDoor.axisTo)
        }
    }

    createLineMesh(from, to) {

        let position = [
            (from[0] + to[0]) / 2,
            (from[1] + to[1]) / 2,
            (from[2] + to[2]) / 2
        ]

        let dx = from[0] - to[0],
            dy = from[1] - to[1],
            dz = from[2] - to[2]

        let normal = new THREE.Vector3().fromArray([dx, dy, dz]).normalize()
        let euler = new JMT.Euler().setFromDirection(normal)

        if (!this._line) {
            let length = Math.sqrt(dx * dx + dy * dy + dz * dz)

            var d = new THREE.CylinderBufferGeometry(.015, .015, length, 4, 1, !1);

            this._line = new THREE.Mesh(d, getLineMaterial(new THREE.Color(65280)))

            UjP.scene.addAuxiliaryObject(this._line)
            UjP.aniController.requestFrame()
        }

        //var a = new THREE.Matrix4()
        //a.makeTranslation(position[0], position[1], position[2]);
        //a.makeRotationFromEuler(euler)
        //this._line.geometry.applyMatrix(a);

        this._line.position.fromArray(position)
        this._line.setRotationFromEuler(euler)
        this._line.direction = normal

        this._line.updateMatrixWorld(!0)
    }

    buildRotationMatrix(anchor = [0, 0, 0], axis = 'Z', angle = 90) {
        let a = new THREE.Matrix4()
        if (axis.toUpperCase() === 'Z') {
            a.makeTranslation(anchor[0], anchor[1], 0)
            let b = new THREE.Matrix4()
            b.makeRotationZ(THREE.Math.degToRad(angle))
            let c = new THREE.Matrix4()
            c.makeTranslation(-anchor[0], -anchor[1], 0)

            a.multiplyMatrices(a, b)
            a.multiplyMatrices(a, c)
        }

        return a
    }


    addFire(collision) {
        if (!this._fire) {

            let loader = new JMT.TextureLoader("./",
                JMT.DETECTOR, function (a) {
                    //UjP.aniController.requestFrame()
                }, !1, !1, !0)

            let url = 'css/image/Fire.png'

            let param = {
                alpha: true,
                id: url,
                name: '__fire_texture',
                rawExt: "png",
                stdExt: "png",
                url: url,
                webFormats: [
                    //"small/std", "large/dxt", "small/pvr", "small/etc1"
                ]
            }

            let t = loader.load(JMT.LOAD_PRIORITY.CORE_RESOURCE, param, !0, !0, JMT.DEFAULT_ANISOTROPY)
            //this._fire = new THREE.Fire(t)
            this._fire = (0,_effect_fire_Fire_js__WEBPACK_IMPORTED_MODULE_1__.createFireMesh)(t)
            UjP.scene.addAuxiliaryObject(this._fire)

            let fire = this._fire
            let interval = 1E3 / 30
            let renderInterval = setInterval(function () {
                fire.update(performance.now() / 1E3)
                UjP.aniController.requestFrame()
            }, interval)
        }
        this._fire.updatePosition(collision.point)
    }
}

function getLineMaterial(color, opacity = 1.0) {
    var c = new JMT.StandardMaterial;
    c.hideFromLightProbes = !0;
    c.baseColor.copy(color);
    c.opacity = opacity;
    c.specularOff = 1;
    c.depthTest = !1;
    c.depthWrite = !0;
    return c
}

var $ = document.getElementById


JMT.AnimateManager = AnimateManager

/***/ }),

/***/ "./ui/AssetsManager.js":
/*!*****************************!*\
  !*** ./ui/AssetsManager.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ AssetsManager; }
/* harmony export */ });
/* harmony import */ var _assets_AssetsController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../assets/AssetsController.js */ "./assets/AssetsController.js");
/**
 * Created by Kai on 2021/1/25.
 */


function AssetsManager(ui) {
    let n = this
    this.id = 'assetsManager'
    this.hint = '素材管理'
    this.hintEnabled = ''
    this.hintDisabled = ''
    this.iconID = 'assetsIcon'
    this.iconClass = 'icon-circle'
    this.panel = document.getElementById('panel-left')
    this.opened = false
    this.itemCount = 0

    this.infoPanel = document.getElementById('panel-right')

    this.viewer = UjP.viewer

    this._target = null


    ///////////////////////////////////////////////////////////////////////////////
    // below is just for test
    //this.disableSelection = function () {
    //
    //    if (!this.controller) {
    //        this.controller = UjP.assetsController
    //    }
    //
    //    this.controller.selectedAsset = null
    //
    //    //UjP.Viewport.removeEventListener('dragover', onDrag)
    //    //UjP.Viewport.removeEventListener('drop', onDrop)
    //    //
    //    //
    //    //UjP.Viewport.removeEventListener('mousemove', onMouseMove)
    //    //UjP.Viewport.removeEventListener('mousedown', onMouseDown)
    //    //UjP.Viewport.removeEventListener('mouseup', mouseup)
    //}
    //
    //this.enableSelection = function () {
    //
    //    //UjP.Viewport.addEventListener('dragover', onDrag)
    //    //UjP.Viewport.addEventListener('drop', onDrop)
    //    //
    //    //UjP.Viewport.addEventListener('mousemove', onMouseMove)
    //    //UjP.Viewport.addEventListener('mousedown', onMouseDown)
    //    //UjP.Viewport.addEventListener('mouseup', mouseup)
    //}
    //

    //
    //this.addAssetTarget = function (config, resolve) {
    //    let type = config.type,
    //        src = config.texture || config.src
    //
    //    this._target = config
    //    this._addedResolve = resolve
    //}
    //
    //
    //function mouseup(e) {
    //    if (n._dragged) {
    //        n._dragged = false
    //        n.controller.conformed(n._asset)
    //    }
    //}
    //
    //n.getAsset = function (event, config) {
    //    if (!this._asset) {
    //        let b = JMT.interactionDetector.detectIntersect(event)
    //
    //        let tag = this._target.tag || this._target
    //        if (b) {
    //            let config = {
    //                position: b.point,
    //                normal: b.normal,
    //                object: b.object,
    //                lightProbeId: b.object.lightProbe.id,
    //                radius: 0.07,
    //                color : "#4c9ed9",
    //                scale : 1,
    //                style : "sphere",
    //                width : 512,
    //                height: 512
    //            }
    //
    //            tag && (config = Object.assign(config, tag))
    //
    //            this._asset = this.controller.createAsset(config)
    //            this._addedResolve && this._addedResolve(this._asset)
    //        }
    //    }
    //
    //    return this._asset
    //}
    //
    //function onMouseDown(e) {
    //
    //    let b = JMT.interactionDetector.findIntersectionAtPosition(e, n.controller.assets)
    //
    //    if (!b) {
    //        if (isInfoShown()) {
    //            n.infoPanel.style.display = 'none'
    //        }
    //
    //        UjP.dispatchEvent({type: 'assetClick', asset: null})
    //
    //        return
    //    }
    //
    //
    //    let asset = b.object
    //
    //    if (asset.enable) {
    //        if (e.button === 0) {
    //            n.controller.selectedAsset = asset
    //        }
    //        else if (e.button === 2) {
    //            n.controller.hoveredAsset = asset
    //            n._dragged = true
    //        }
    //    }
    //
    //}
    //
    //function onMouseMove(e) {
    //    if (n.disableSelect || isInfoShown()) {
    //        return
    //    }
    //
    //
    //    if (n._dragged) {
    //        let b = JMT.interactionDetector.detectIntersect(e)
    //        if (b) {
    //            let asset = n.controller.hoveredAsset
    //            if (asset.enable) {
    //                asset.update(b.point, b.normal)
    //                UjP.aniController && UjP.aniController.requestFrame()
    //            }
    //        }
    //    }
    //    else {
    //        let asset = null
    //        let b = JMT.interactionDetector.findIntersectionAtPosition(e, n.controller.assets)
    //        if (b && b.object) {
    //            asset = b.object
    //        }
    //        n.controller.hoveredAsset = asset
    //    }
    //}
    //
    //async function onDrag(e) {
    //
    //    e.stopPropagation();
    //    //阻止浏览器默认打开文件的操作
    //    e.preventDefault();
    //
    //    //console.log(e.dataTransfer.getData("Text"));
    //
    //    let out = e.dataTransfer.items
    //
    //    if (n._target) {
    //        let asset = n.getAsset(e)
    //        if (asset) {
    //
    //            let b = JMT.interactionDetector.detectIntersect(e)
    //
    //            if (b) {
    //
    //                asset.update(b.point, b.normal)
    //
    //                UjP.aniController && UjP.aniController.requestFrame()
    //            }
    //        }
    //    }
    //    else if (out.length > 0) {
    //        out = out[0]
    //
    //        if (out.kind === 'file') {
    //            // Process all of the items.
    //            for (const item of e.dataTransfer.items) {
    //                // kind will be 'file' for file/directory entries.
    //                if (item.kind === 'file') {
    //                    const entry = await item.getAsFileSystemHandle();
    //                    if (entry.kind === 'file') {
    //                        // run code for if entry is a file
    //                    } else if (entry.kind === 'directory') {
    //                        // run code for is entry is a directory
    //                    }
    //                }
    //            }
    //        }
    //    }
    //}
    //
    //
    //function onDrop(e) {
    //    e.stopPropagation();
    //    //阻止浏览器默认打开文件的操作
    //    e.preventDefault();
    //
    //    n.controller.conformed(n._asset)
    //
    //    n.disableSelect = false
    //    n._asset = null
    //    n._target = null
    //
    //    UjP.aniController.requestFrame()
    //}
    this.init = function () {
        if (!this.controller) {
            this.controller = UjP.assetsController
        }

        //n.enableSelection()
    }

    function isInfoShown() {
        if (!ui.isInstance) {
            return false
        }
        return n.infoPanel.style.display !== 'none'
    }


    function updateUI(asset) {

        let pos = asset.asPosition
        let rot = asset.asRotation
        let sca = asset.asScale

        if (pos) {
            $('position-x').value = pos[0]
            $('position-y').value = pos[1]
            $('position-z').value = pos[2]
        }

        if (rot) {
            $('rotation-x').value = rot[0]
            $('rotation-y').value = rot[1]
            $('rotation-z').value = rot[2]
        }


        if (sca) {
            $('scale-x').value = sca[0]
            $('scale-y').value = sca[1]
            $('scale-z').value = sca[2]
        }
    }


    function createTestUI() {

        function addAsset(src, type = 'img', option = {}) {
            let imgDiv = document.createElement('div')

            let floatStr = (n.itemCount % 2) ? 'left' : 'right'

            let id = option.id || 'DEFAULT_' + type + '_' + n.itemCount

            if (type === 'flag') {
                imgDiv.tag = {
                    type: JMT.Asset.Types.Effect,
                    contentType: JMT.Asset.ContentTypes.Flag,
                    texture: src
                }
                imgDiv.innerHTML = '<img draggable=true class="asset-item" style="float:' + floatStr + ';" id="img_' + n.itemCount + '" src="' + src + '"></img>';

            } else if (type == 'anchor') {
                imgDiv.tag = {
                    type: JMT.Asset.Types.Anchor,
                    contentType: JMT.Asset.ContentTypes.PIC,
                    texture: 'css/image/Fire.png' //src
                }
                imgDiv.innerHTML = '<img draggable=true class="asset-item" style="float:' + floatStr + ';" id="img_' + n.itemCount + '" src="' + src + '"></img>';
            } else if (type === 'fire') {
                imgDiv.tag = {
                    type: JMT.Asset.Types.Effect,
                    contentType: JMT.Asset.ContentTypes.Fire,
                    texture: 'css/image/Fire.png' //src
                }
                imgDiv.innerHTML = '<img draggable=true class="asset-item" style="float:' + floatStr + ';" id="img_' + n.itemCount + '" src="' + src + '"></img>';
            } else if (type === 'coneLight') {
                imgDiv.tag = {
                    type: JMT.Asset.Types.Effect,
                    contentType: JMT.Asset.ContentTypes.ConeLight,
                    //texture:  'css/image/Fire.png' //src
                }
                imgDiv.innerHTML = '<img draggable=true class="asset-item" style="float:' + floatStr + ';" id="img_' + n.itemCount + '" src="' + src + '"></img>';

            } else if (src && type !== 'model') {
                let ext = /\.[^\.]+$/.exec(src)
                imgDiv.tag = {format: ext[0].toLowerCase(), texture: src}
                imgDiv.tag.type = JMT.Asset.Types.Image

                if (ext[0] === '.gif') {
                    imgDiv.tag = Object.assign(imgDiv.tag, option)
                    imgDiv.tag.contentType = JMT.Asset.ContentTypes.GIF
                } else if (ext[0] === '.mp4') {
                    imgDiv.tag.contentType = JMT.Asset.ContentTypes.MP4
                } else if (ext[0] === '.webm') {
                    imgDiv.tag.contentType = JMT.Asset.ContentTypes.MP4
                    imgDiv.tag.alpha = true
                } else if (ext[0] === '.mp3') {
                    imgDiv.tag.contentType = JMT.Asset.ContentTypes.MP3
                    imgDiv.tag.alpha = true
                } else {
                    imgDiv.tag.contentType = JMT.Asset.ContentTypes.PIC
                }

                imgDiv.tag.thumb = 'kkkk.jpg'

                let poster = type === 'video' ? ('poster="' + src.substr(0, src.lastIndexOf('.')) + '.preview.jpg' + '" ') : ''
                let tagName = type === 'audio' ? 'div' : type;
                imgDiv.innerHTML = '<' + tagName + ' ' + poster +
                    ' draggable=true class="asset-item" style="float:' + floatStr +
                    ';" id="img_' + n.itemCount +
                    '" src="' + src + '"></img>';
            } else if (type === 'text') {
                drawDefualtText(imgDiv, floatStr)
                imgDiv.tag = {
                    type: JMT.Asset.Types.Text
                }
            } else if (type === 'model') {
                imgDiv.tag = {
                    type: JMT.Asset.Types.Model,
                    texture: option.url,
                    scaleBase: option.scaleBase
                }
                imgDiv.innerHTML = '<img draggable=true class="asset-item" style="float:' + floatStr + ';" id="img_' + n.itemCount + '" src="' + src + '"></img>';

            }
            //imgDiv.style.display = 'flex'
            imgDiv.style['align-items'] = 'center'
            id && (imgDiv.id = id)

            n.panel.appendChild(imgDiv)
            n.itemCount++
        }

        function drawDefualtText(parent, float) {
            let canvas = document.createElement('canvas');
            canvas.classList.add('asset-item')
            canvas.setAttribute("draggable", true)
            canvas.style.float = float
            parent.appendChild(canvas)

            function draw(e) {
                if (e.panel !== n.panel) {
                    return
                }

                let w = canvas.offsetWidth;
                let h = canvas.offsetHeight;
                let ctx = canvas.getContext('2d');

                ctx.font = "20px Microsoft YaHei";
                //水平对齐方式
                ctx.textAlign = "left";
                //垂直对齐方式
                ctx.textBaseline = "middle";
                ctx.fillStyle = "white";               //设置填充颜色为紫色
                ctx.fillText('点击输入文字...', w / 2, h / 2);


                UjP.removeEventListener('panelShown', draw)
            }

            UjP.addEventListener('panelShown', draw)
        }

        function onAssetClick(e) {
            let asset = e.asset

            if (asset && !isInfoShown()) {
                n.infoPanel.style.display = 'block'
            }

        }

        function onDragStart(e) {
            //dataTransfer.setData()方法设置数据类型和拖动的数据
            //e.dataTransfer.setData("Text", e.target.src);
            n._target = e.target.parentElement

            n.controller.addAssetWithConfig(n._target.tag)

            n.disableSelect = true
        }


        n.getAssetType = function (ext) {
            switch (ext) {
                case '.jpg':
                case '.jpeg':
                case '.png':
                    return JMT.Asset.Types.Image
                case '.gif':
                    return JMT.Asset.Types.GIF
                case '.mp4':
                case '.avi':
                case '.mov':
                    return JMT.Asset.Types.Video
                default :
                    return JMT.Asset.Types.Unknown
            }
            return JMT.Asset.Types.Unknown
        }


        // Just for test
        n.onClick = function () {


            if (!n.listened) {
                UjP.viewer.addEventListener('assetClick', event => {

                    if (event.asset) {
                        updateUI(event.asset)
                        n.infoPanel.style.display = 'block'
                    } else {
                        n.infoPanel.style.display = 'none'
                    }

                })

                n.listened = !0
            }


            if (!this.opened) {


                this.init()

                //UjP.editorHooks.enableLightSelection()

                this.panel.style.display = 'inherit'

                let ais = document.getElementsByClassName('asset-item')

                for (let i = 0; i < ais.length; i++) {
                    let ai = ais[i]
                    ai.addEventListener('dragstart', onDragStart)
                }

                UjP.dispatchEvent({type: 'panelShown', panel: n.panel})

                var elementList = document.querySelectorAll('.property-item,.text');
                for (let i = 0; i < elementList.length; i++) {
                    let el = elementList[i]
                    el.children[1].onchange = n._onPropertyChange.bind(n)
                }
            } else {

                this.panel.style.display = 'none'
                let ais = document.getElementsByClassName('asset-item')

                for (let i = 0; i < ais.length; i++) {
                    let ai = ais[i]
                    ai.removeEventListener('dragstart', onDragStart)
                }
                ``
                UjP.dispatchEvent({type: 'panelHide', panel: n.panel})

                var elementList = document.querySelectorAll('.property-item,.text');
                for (let i = 0; i < elementList.length; i++) {
                    let el = elementList[i]
                    el.children[1].onchange = null
                }
                UjP.removeEventListener('assetClick', onAssetClick)

                _curProperty = null
            }
            this.opened = !this.opened
        }


        n._onPropertyChange = function (event) {
            let target = event.currentTarget

            let name = target.getAttribute('property-name')

            if (n.controller.selectedAsset) {

                let value = target.value
                if (target.type === 'checkbox') {
                    value = target.checked
                }

                if (name === 'opacity') {
                    value = value / 100
                }

                n.controller.selectedAsset[name] = value
            }
        }

        let urlBase = ui.urlBase || ''

        if (ui.isInstance) {
            //addAsset(urlBase + 'css/image/pig.png', 'model', {url: urlBase + 'data/pig.glb', scaleBase: 0.001})
            addAsset(urlBase + 'css/image/coin.jpeg')
            addAsset(urlBase + 'css/image/green-circle.png')
            addAsset(urlBase + 'css/image/giphy.gif')
            addAsset(urlBase + 'css/image/aaa.gif')
            addAsset(urlBase + 'css/image/7s.gif', "img", {"delay": [8,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4],
                            "delayImage": "css/image/7s_frame.png",
                            "dur": 0.016739999999117572,
                            "index": 16})
            
            //addAsset(urlBase + 'css/image/aaa.gif')
            // addAsset('https://obs.3dyunzhan.com/pictures/18430468-0f54-b348-4d12-feb3521019b4.gif')

            //addAsset(urlBase + 'css/image/v2_b.gif')
            //addAsset('https://obs.3dyunzhan.com/pictures/c7f77d5e-dfc5-faca-d5b2-9690305b1dec.gif')
            //addAsset('https://gss0.baidu.com/70cFfyinKgQFm2e88IuM_a/forum/w=580/sign=54dd5ce6abec8a13141a57e8c7029157/abcf77c6a7efce1b9ee7b0c3ad51f3deb58f658e.gif')
            //

            addAsset(urlBase + 'css/video/v1.mp4', 'video')
            //addAsset(urlBase + 'css/video/transparent.webm', 'video')
            //addAsset(urlBase + 'css/audio/kaichang.mp3', 'audio')
            addAsset(null, 'text')
            //addImage('css/image/Screenshot.png')
            //addImage('css/image/fov.png')
            //addImage('css/image/Screenshot.png')
            //addAsset(urlBase +'css/image/green-circle.png', 'model', {url: 'data/M00000000010101369GEM_H.glb', scale: 0.001})
            // addAsset(urlBase + 'css/image/robot.png', 'model', {
            //     //url: 'https://cdn.jimuyida.com/jmyd/M000006380402012BSN6A_H/cd7cb00e-826b-4644-93a9-c7d5f952e2c8/M000006380402012BSN6A_H.jm2',
            //     url : 'data/RobotExpressive.glb',
            //     scale: 1000
            // })
            //
            addAsset(urlBase + 'css/image/flag1.jpg', 'flag')
            addAsset(urlBase + 'css/image/fire.gif', 'fire')
            addAsset(urlBase + 'css/image/pig.png', 'anchor')
            //addAsset(urlBase + 'css/image/pig.png', 'coneLight')

        }


        let _curProperty


        let all = document.querySelectorAll('.quarter')

        function onInputChange(e) {
            let prop = e.target.id.split('-')

            _curProperty = prop[0]

            if (_curProperty === 'position') {
                let pos = [
                    parseFloat($('position-x').value),
                    parseFloat($('position-y').value),
                    parseFloat($('position-z').value)
                ]
                n.controller.selectedAsset.asPosition = pos
            } else if (_curProperty === 'rotation') {
                let rot = [
                    parseFloat($('rotation-x').value),
                    parseFloat($('rotation-y').value),
                    parseFloat($('rotation-z').value)
                ]
                n.controller.selectedAsset.asRotation = rot
            } else if (_curProperty === 'scale') {

                let sca = [
                    parseFloat($('scale-x').value),
                    parseFloat($('scale-y').value),
                    parseFloat($('scale-z').value)
                ]
                n.controller.selectedAsset.asScale = sca
            }

            UjP.aniController.requestFrame()
        }

        all.forEach(item => {
            item.onchange = onInputChange
        })

        var bh = document.getElementById('bh')
        if (bh) {
            h.addEventListener('click', upF, false);

            function upF() {
                
                //要传的值  长、宽、texture地址       难点：1、确定真正的长和宽    2、
                var wScal = n.controller.selectedAsset.asScale[0];
                var hScal = n.controller.selectedAsset.asScale[2];
                n.controller.selectedAsset.updateFrame(wScal, hScal, n.controller.selectedAsset);

                // n.controller.selectedAsset.removeHk();
            }
        }


    }

    if (ui.isInstance) {
        createTestUI()
        UjP.assetsManager = this
    }

    return this
}

JMT.AssetsManager = AssetsManager


/***/ }),

/***/ "./ui/GamepadManager.js":
/*!******************************!*\
  !*** ./ui/GamepadManager.js ***!
  \******************************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function a(a) {
    return -.7 >= a ? 0 : .7 <= a ? 1 : -1
}

function b(a, b) {
    if ("xr-standard" === a.mapping)return "left" === (a.hand ? a.hand : b) ? d : e;
    b = $jscomp.makeIterator(c);
    for (var f = b.next(); !f.done; f = b.next()) {
        f = f.value;
        var g = a;
        var h = f;
        g = h.gamepadIdPattern.test(g.id) ? void 0 !== h.gamepadLayoutMappingId ? g.mapping === h.gamepadLayoutMappingId : !0 : !1;
        if (g)return f
    }
    console.error("No matching action mapping for gamepad found", a.id);
    return null
}

JMT.GAMEPAD_ACTION = {
    TRIGGER: 0, BACKWARD: 1, FORWARD: 2, LEFT: 3, RIGHT: 4, DOWN: 5,
    UP: 6, PREVIOUS: 7, NEXT: 8
};
var c = [{
    gamepadIdPattern: /^Spatial Controller \(Spatial Interaction Source\).*$/,
    axisMapping: new Map([[2, [JMT.GAMEPAD_ACTION.PREVIOUS, JMT.GAMEPAD_ACTION.NEXT]], [3, [JMT.GAMEPAD_ACTION.UP, JMT.GAMEPAD_ACTION.DOWN]], [0, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [1, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
    buttonMapping: new Map([[1, JMT.GAMEPAD_ACTION.TRIGGER]])
}, {
    gamepadIdPattern: /Oculus Touch \(Left\)/,
    axisMapping: new Map([[0, [JMT.GAMEPAD_ACTION.LEFT,
        JMT.GAMEPAD_ACTION.RIGHT]], [1, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
    buttonMapping: new Map([[1, JMT.GAMEPAD_ACTION.TRIGGER], [3, JMT.GAMEPAD_ACTION.DOWN], [4, JMT.GAMEPAD_ACTION.UP]])
}, {
    gamepadIdPattern: /Oculus Touch \(Right\)/,
    axisMapping: new Map([[0, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [1, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
    buttonMapping: new Map([[1, JMT.GAMEPAD_ACTION.TRIGGER], [3, JMT.GAMEPAD_ACTION.NEXT], [4, JMT.GAMEPAD_ACTION.PREVIOUS]])
},
    {
        gamepadIdPattern: /OpenVR (Gamepad|Controller)/,
        axisMapping: new Map([[0, [JMT.GAMEPAD_ACTION.PREVIOUS, JMT.GAMEPAD_ACTION.NEXT]], [1, [JMT.GAMEPAD_ACTION.DOWN, JMT.GAMEPAD_ACTION.UP]]]),
        buttonMapping: new Map([[1, JMT.GAMEPAD_ACTION.TRIGGER]])
    }, {
        gamepadIdPattern: /.*/,
        gamepadLayoutMappingId: "standard",
        axisMapping: new Map([[0, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [1, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]], [2, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [3,
            [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
        buttonMapping: new Map([[0, JMT.GAMEPAD_ACTION.DOWN], [1, JMT.GAMEPAD_ACTION.NEXT], [2, JMT.GAMEPAD_ACTION.PREVIOUS], [3, JMT.GAMEPAD_ACTION.UP], [4, JMT.GAMEPAD_ACTION.TRIGGER], [5, JMT.GAMEPAD_ACTION.TRIGGER]])
    }, {
        gamepadIdPattern: /.*/,
        axisMapping: new Map([[0, [JMT.GAMEPAD_ACTION.PREVIOUS, JMT.GAMEPAD_ACTION.NEXT]], [1, [JMT.GAMEPAD_ACTION.UP, JMT.GAMEPAD_ACTION.DOWN]]]),
        buttonMapping: new Map([[0, JMT.GAMEPAD_ACTION.TRIGGER], [1, JMT.GAMEPAD_ACTION.TRIGGER],
            [2, JMT.GAMEPAD_ACTION.TRIGGER], [3, JMT.GAMEPAD_ACTION.TRIGGER]])
    }], d = {
    axisMapping: new Map([[2, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [3, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
    buttonMapping: new Map([[0, JMT.GAMEPAD_ACTION.TRIGGER], [4, JMT.GAMEPAD_ACTION.DOWN], [5, JMT.GAMEPAD_ACTION.UP]])
}, e = {
    axisMapping: new Map([[2, [JMT.GAMEPAD_ACTION.LEFT, JMT.GAMEPAD_ACTION.RIGHT]], [3, [JMT.GAMEPAD_ACTION.FORWARD, JMT.GAMEPAD_ACTION.BACKWARD]]]),
    buttonMapping: new Map([[0, JMT.GAMEPAD_ACTION.TRIGGER],
        [4, JMT.GAMEPAD_ACTION.NEXT], [5, JMT.GAMEPAD_ACTION.PREVIOUS]])
}, g = function (c, d) {
    d = b(c, d);
    this.axisMapping = d.axisMapping;
    this.buttonMapping = d.buttonMapping;
    this.axisPosition = c.axes.map(a);
    this.buttonPressed = c.buttons.map(function (a) {
        return a.pressed
    })
};
JMT.GamepadManager = function () {
    function b(a) {
        var b = a.gamepad;
        a = new g(a.gamepad);
        d.set(b.index, a)
    }

    function c(a) {
        d.delete(a.gamepad.index)
    }

    var d = new Map, e = new Map, p = new Set, l = new Set, q = {type: "actionActivated", action: null}, r = {
        type: "actionDeactivated",
        action: null
    };
    this.hasGamepads = function () {
        return 0 < d.size || 0 < e.size
    };
    this.update = function () {
        function b(b, c) {
            for (var d = 0; d < c.axes.length; ++d) {
                var e = a(c.axes[d]), f = b.axisPosition[d];
                if (e !== f) {
                    var g = b.axisMapping.get(d);
                    void 0 !== g && (-1 !== f && l.add(g[f]), -1 !== e && p.add(g[e]))
                }
                b.axisPosition[d] = e
            }
            for (d = 0; d < c.buttons.length; ++d)e = c.buttons[d].pressed, f = b.buttonPressed[d], e !== f && (g = b.buttonMapping.get(d), void 0 !== g && (f ? l.add(g) : p.add(g))), b.buttonPressed[d] = e
        }

        if (this.hasGamepads()) {
            p.clear();
            l.clear();
            var c =
                navigator.getGamepads ? navigator.getGamepads() : [];
            c = $jscomp.makeIterator(c);
            for (var f = c.next(); !f.done; f = c.next())if (f = f.value) {
                var g = d.get(f.index);
                b(g, f)
            }
            c = $jscomp.makeIterator(e);
            for (f = c.next(); !f.done; f = c.next())g = $jscomp.makeIterator(f.value), f = g.next().value, g = g.next().value, b(g, f);
            f = $jscomp.makeIterator(l);
            for (c = f.next(); !c.done; c = f.next())r.action = c.value, this.dispatchEvent(r);
            f = $jscomp.makeIterator(p);
            for (c = f.next(); !c.done; c = f.next())q.action = c.value, this.dispatchEvent(q)
        }
    };
    this.addXrGamepad =
        function (a, b) {
            b = new g(a, b);
            e.set(a, b)
        };
    this.removeXrGamepad = function (a) {
        e.delete(a)
    };
    this.removeAllXrGamepads = function () {
        e.clear()
    };
    (function () {
        if (navigator.getGamepads) {
            window.addEventListener("gamepadconnected", b);
            window.addEventListener("gamepaddisconnected", c);
            for (var a = $jscomp.makeIterator(navigator.getGamepads()), e = a.next(); !e.done; e = a.next())if (e = e.value) {
                var f = new g(e);
                d.set(e.index, f)
            }
        }
    })()
};

//THREE.EventDispatcher.prototype.apply(JMT.GamepadManager.prototype)
JMT.GamepadManager.prototype = Object.create(THREE.EventDispatcher.prototype)
JMT.GamepadManager.prototype.constructor = JMT.GamepadManager



/***/ }),

/***/ "./ui/Icons.js":
/*!*********************!*\
  !*** ./ui/Icons.js ***!
  \*********************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function a(a, b, c) {
    JMT.ICONS[a] = {name: a, value: b, fontFamily: c}
}

function b(b, c) {
    a(b, c, "FontAwesomeSolid")
}

function c(b, c) {
    a(b, c, "FontAwesomeRegular")
}

function d(b, c) {
    a(b, c, "FontAwesomeBrands")
}

JMT.ICONS = {};
b("address-book", "\uf2b9");
b("address-card", "\uf2bb");
b("area-chart", "\uf1fe");
b("arrows", "\uf0b2");
b("arrow-up", "\uf062");
b("arrow-down", "\uf063");
b("assistive-listening-systems", "\uf2a2");
b("asterisk", "\uf069");
b("audio-description", "\uf29e");
b("at", "\uf1fa");
b("bars", "\uf0c9");
b("bell", "\uf0f3");
b("book", "\uf02d");
b("bookmark", "\uf02e");
b("bullhorn", "\uf0a1");
b("calculator", "\uf1ec");
b("camera", "\uf030");
b("chart-bar", "\uf080");
b("chart-pie", "\uf200");
b("chevron-up", "\uf077");
b("chevron-down", "\uf078");
b("cloud", "\uf0c2");
b("cog", "\uf013");
b("comment", "\uf075");
c("compass", "\uf14e");
c("credit-card", "\uf09d");
b("crosshairs", "\uf05b");
b("desktop", "\uf108");
b("download", "\uf019");
b("envelope", "\uf0e0");
b("external-link", "\uf35d");
c("eye", "\uf06e");
b("eye-dropper", "\uf1fb");
b("film", "\uf008");
b("flag", "\uf024");
b("folder", "\uf07b");
b("gift", "\uf06b");
b("headphones", "\uf025");
b("highlighter", "\uf591");
b("home", "\uf015");
c("image", "\uf03e");
b("sign-in", "\uf2f6");
b("info", "\uf129");
c("lightbulb", "\uf0eb");
b("magic", "\uf0d0");
b("magnet", "\uf076");
b("map-marker", "\uf3c5");
b("map-pin", "\uf276");
b("map-signs", "\uf277");
b("paint-brush", "\uf1fc");
b("pencil", "\uf303");
b("pen", "\uf304");
b("phone", "\uf095");
b("question", "\uf128");
b("share", "\uf064");
b("share-alt", "\uf1e0");
b("shopping-cart", "\uf07a");
b("sliders", "\uf1de");
b("star", "\uf005");
c("sticky-note", "\uf249");
c("edit", "\uf044");
b("tachometer", "\uf3fd");
b("tag", "\uf02b");
b("video", "\uf03d");
b("wrench", "\uf0ad");
b("palette", "\uf53f");
b("paint-roller", "\uf5aa");
b("play", "\uf04b");
b("plus", "\uf067");
d("youtube", "\uf167");
d("vimeo", "\uf40a");
d("facebook", "\uf09a");
d("twitter", "\uf099");
d("instagram", "\uf16d");
d("linkedin", "\uf08c");
d("skype", "\uf17e");
d("whatsapp", "\uf232");
d("facebook-messenger", "\uf39f");
d("telegram", "\uf2c6");
d("slack", "\uf198")

/***/ }),

/***/ "./ui/UiEventDelegate.js":
/*!*******************************!*\
  !*** ./ui/UiEventDelegate.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ UiEventDelegate; }
/* harmony export */ });
/**
 * Created by Kai on 2021/2/23.
 */

class UiEventDelegate extends THREE.EventDispatcher {
    constructor() {
        super()

        Object.defineProperty(this, 'cover', {
            get: function(){
                return this._cover
            },
            set: function(cover){
                this._cover = cover
            }
        })
    }

    updateCover(cover) {

    }

    onResize() {

    }

    onFullScreenChange(changed) {

    }

    onPointerLockChange(changed) {

    }

    onVrChange(changed) {

    }

    setVrSupported(value) {

    }
    setFullScreenSupported() {

    }

    setPointerLockSupported() {

    }

    sceneReadyToDisplay(scene, teleport, autoTour, screenshotTaker) {

    }

    sceneLoadComplete(){

    }

    sceneLoadStarted(){

    }

    loadProgress(eventa){

    }

    contextLost(){

    }


    refresh() {

    }


    init(){

        return this
    }

    enablePlayButton(){

    }
}


/***/ }),

/***/ "./ui/UsrMsg.js":
/*!**********************!*\
  !*** ./ui/UsrMsg.js ***!
  \**********************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
JMT.USER_MSG = new function () {
    this.hideInfo = function () {
        var c = $("info-message")
        if (c) {
            c.style.display = "none"
        }
    };
    this.info = function (a, b) {
        var c = $("info-message");
        if (c) {
            c.innerHTML = a;
            c.style.display = "";
            setTimeout(this.hideInfo, b || 15E3)
        }
        else {
            console.log(a);
        }
    };
    this.error = function (a) {
        var b = $("error-message");
        if(b){
            b.innerHTML = a;
            b.style.display = "none"
        }
        else {
            console.log(b);
        }
    }
}

/***/ }),

/***/ "./utils/Detector.js":
/*!***************************!*\
  !*** ./utils/Detector.js ***!
  \***************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils/utils.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log.js */ "./utils/log.js");
/* harmony import */ var _log_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_log_js__WEBPACK_IMPORTED_MODULE_1__);
/**
 * Created by Kai on 2020/12/18.
 */



function getChromeVersion() {
    var a = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    return a ? parseInt(a[2], 10) : !1
}


JMT.Detector = function (b) {
    function c(a) {
        var c = f[a];
        if (void 0 !== c)return c;
        switch (a) {
            case "EXT_texture_filter_anisotropic":
                c = b.getExtension("EXT_texture_filter_anisotropic") || b.getExtension("MOZ_EXT_texture_filter_anisotropic") || b.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                c = b.getExtension("WEBGL_compressed_texture_s3tc") || b.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                    b.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                c = b.getExtension("WEBGL_compressed_texture_pvrtc") || b.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            case "WEBGL_compressed_texture_etc1":
                c = b.getExtension("WEBGL_compressed_texture_etc1");
                break;
            default:
                c = b.getExtension(a)
        }
        return f[a] = c
    }

    function d(a) {
        var c = b.createTexture();
        b.bindTexture(b.TEXTURE_2D, c);
        b.texImage2D(b.TEXTURE_2D, 0, b.RGBA, 2, 2, 0, b.RGBA, a, null);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MAG_FILTER, b.LINEAR);
        b.texParameteri(b.TEXTURE_2D, b.TEXTURE_MIN_FILTER, b.LINEAR);
        a = b.createFramebuffer();
        b.bindFramebuffer(b.FRAMEBUFFER, a);
        b.framebufferTexture2D(b.FRAMEBUFFER, b.COLOR_ATTACHMENT0, b.TEXTURE_2D, c, 0);
        var d = b.checkFramebufferStatus(b.FRAMEBUFFER) === b.FRAMEBUFFER_COMPLETE;
        b.deleteTexture(c);
        b.deleteFramebuffer(a);
        b.bindTexture(b.TEXTURE_2D, null);
        b.bindFramebuffer(b.FRAMEBUFFER, null);
        return d
    }

    function e(a, b) {
        a = a.toLowerCase();
        b = b.toLowerCase();
        return -1 !== a.indexOf(b)
    }

    function g(a) {
        return navigator &&
        navigator.userAgent ? e(navigator.userAgent, a) : !1
    }

    var f = {};
    this.extension = c;
    this.https = "https:" === window.location.protocol;
    this.localhost = JMT.isLocalhost();
    this.ipad = /iPad/.test(navigator.userAgent) || "MacIntel" === navigator.platform && 1 < navigator.maxTouchPoints;
    this.mobile = /mobile|ip(hone|od)|android|silk/i.test(navigator.userAgent) || this.ipad || JMT.urlHashContains("mobile");
    this.ios = /iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || this.ipad;
    this.android = /Android/.test(navigator.userAgent);
    this.inCrossOriginIframe = function () {
        var a = window.self !== window.top, b = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getOriginFromUrl)(document.referrer), c = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.getOriginFromUrl)(window.location.href);
        return a && b !== c
    }();
    this.antialiasNative = b.getContextAttributes().antialias && 1 < b.getParameter(b.SAMPLES);
    this.antialiasSamples = b.getParameter(b.SAMPLES);
    this.antialiasPostprocess = !this.mobile;
    this.floatTextures = c("OES_texture_float");
    this.floatTexturesInterpolate = c("OES_texture_float_linear");
    this.halfFloatTextures = c("OES_texture_half_float");
    this.halfFloatTexturesInterpolate = c("OES_texture_half_float_linear");
    this.standardDerivatives = c("OES_standard_derivatives");
    this.maxAnisotropy = function () {
        var a = c("EXT_texture_filter_anisotropic");
        return null !== a ? b.getParameter(a.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
    }();
    this.indexUint = c("OES_element_index_uint");
    this.instances = c("ANGLE_instanced_arrays");
    this.rendererExtensionFragDepth=c('EXT_frag_depth');
    this.fragmentPrecision = void 0 === b.getShaderPrecisionFormat || 0 < b.getShaderPrecisionFormat(b.FRAGMENT_SHADER, b.HIGH_FLOAT).precision ? "highp" : 0 < b.getShaderPrecisionFormat(b.FRAGMENT_SHADER,
        b.MEDIUM_FLOAT).precision ? "mediump" : "lowp";
    var h = 4096 > b.getParameter(b.MAX_TEXTURE_SIZE) ? "Your graphics card does not have sufficient capabilities, texture sizes 4096x4096 need to be supported." : null;
    this.missingCapabilities = h;
    this.maxRenderBufferSize = b.getParameter(b.MAX_RENDERBUFFER_SIZE);
    h = this.floatTextures ? d(b.FLOAT) : !1;
    this.floatTargets = h;
    h = this.halfFloatTextures ? d(this.halfFloatTextures.HALF_FLOAT_OES) : !1;
    this.dynamicLights = (this.halfFloatTargets = h) && this.floatTargets && this.halfFloatTexturesInterpolate;
    this.dxtTextures = function () {
        try {
            if (JMT.urlHashContains("nodxt"))return !1;
            for (var a = c("WEBGL_compressed_texture_s3tc"), d = b.getParameter(b.COMPRESSED_TEXTURE_FORMATS), e = !1, f = !1, g = 0; g < d.length; g += 1)e = e || d[g] === a.COMPRESSED_RGB_S3TC_DXT1_EXT, f = f || d[g] === a.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            return e && f
        } catch (r) {
        }
        return !1
    }();
    h = JMT.urlHashContains("nopvr") ? !1 : c("WEBGL_compressed_texture_pvrtc");
    this.pvrtcTextures = h;
    h = JMT.urlHashContains("noetc1") ? !1 : c("WEBGL_compressed_texture_etc1") && this.mobile;
    this.etc1Textures = h;
    this.astcTextures = !1;
    this.firefox = g("firefox");
    this.opera = g("opera") || g("OPR/");
    this.ie = g("msie") || (navigator && navigator.appVersion ? e(navigator.appVersion, "trident/") : !1);
    this.edge = g("edge/");
    this.safari = g("safari/") && !(g("chrome/") || g("chromium/"));
    this.mac = g("macintosh") && !this.ipad;
    this.BASIS_DECODE_WORKERS = this.safari || this.ios ? 0 : Math.min(4, navigator.hardwareConcurrency || 4);
    this.textureLod = c("EXT_shader_texture_lod") && (!this.firefox || !this.android);
    this.mirrorCubeMaps = !this.mobile || JMT.urlHashContains("mobilehi");
    this.disableTextureSlotReuse = this.mac || 83 === getChromeVersion();
    this.reportToConsole = function () {
        JMT.log("Using " + this.fragmentPrecision + " fragment precision.");
        this.dxtTextures || JMT.log("DXT textures not supported.");
        this.textureLod || JMT.log("Texture fetch level of detail not supported.");
        this.floatTextures ? (this.floatTexturesInterpolate || JMT.log("Float textures interpolation not supported."), this.floatTargets || JMT.log("Float render targets not supported")) : JMT.log("Float textures not supported.");
        this.halfFloatTextures ?
            (this.halfFloatTexturesInterpolate || JMT.log("Half float textures interpolation not supported."), this.halfFloatTargets || JMT.log("Half float render targets not supported")) : JMT.log("Half float textures not supported");
        this.antialiasNative ? JMT.log("Native anti-aliasing supported with " + this.antialiasSamples + " samples.") : JMT.log("Native anti-aliasing not supported");
        this.disableTextureSlotReuse && JMT.log("WebGL texture slot reuse disabled.");
        this.indexUint || JMT.log("Uint index not supported");
        this.instances ||
        JMT.log("Instanced geometry not supported")
    }
}


/***/ }),

/***/ "./utils/Tween.js":
/*!************************!*\
  !*** ./utils/Tween.js ***!
  \************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * Created by Kai on 2021/1/6.
 */
// aCrv
(function (global, factory) {
     true ? factory(exports) :
        0;
}(this, (function (e) {

    var i, r, v = function () {
        this._tweens = {}, this._tweensAddedDuringUpdate = {}
    }, n = Process;
    v.prototype = {
        getAll: function () {
            return Object.keys(this._tweens).map(function (e) {
                return this._tweens[e]
            }.bind(this))
        }, removeAll: function () {
            this._tweens = {}
        }, add: function (e) {
            this._tweens[e.getId()] = e, this._tweensAddedDuringUpdate[e.getId()] = e
        }, remove: function (e) {
            delete this._tweens[e.getId()], delete this._tweensAddedDuringUpdate[e.getId()]
        }, update: function (e, t) {
            var n = Object.keys(this._tweens);
            if (0 === n.length)return !1;
            for (e = void 0 !== e ? e : b.now(); n.length > 0;) {
                this._tweensAddedDuringUpdate = {};
                for (var i = 0; i < n.length; i++) {
                    var r = this._tweens[n[i]];
                    r && !1 === r.update(e) && (r._isPlaying = !1, t || delete this._tweens[n[i]])
                }
                n = Object.keys(this._tweensAddedDuringUpdate)
            }
            return !0
        }
    };
    var a, b = new v;
    b.YMB = v, b._nextId = 0, b.nextId = function () {
        return b._nextId++
    }, "undefined" == typeof self && void 0 !== n && n.hrtime ? b.now = function () {
        var e = n.hrtime();
        return 1e3 * e[0] + e[1] / 1e6
    } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? b.now = self.performance.now.bind(self.performance) : void 0 !== Date.now ? b.now = Date.now : b.now = function () {
        return (new Date).getTime()
    }, b.Tween = function (e, t) {
        this._object = e, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._yoyo = !1, this._isPlaying = !1, this._reversed = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = b.Easing.Linear.None, this._interpolationFunction = b.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onUpdateCallback = null, this._onRepeatCallback = null, this._onCompleteCallback = null, this._onStopCallback = null, this._group = t || b, this._id = b.nextId()
    }, b.Tween.prototype = {
        getId: function () {
            return this._id
        }, isPlaying: function () {
            return this._isPlaying
        }, to: function (e, t) {
            return this._valuesEnd = Object.create(e), void 0 !== t && (this._duration = t), this
        }, duration: function (e) {
            return this._duration = e, this
        }, start: function (e) {
            for (var t in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== e ? "string" === typeof e ? b.now() + parseFloat(e) : e : b.now(), this._startTime += this._delayTime, this._valuesEnd) {
                if (this._valuesEnd[t]instanceof Array) {
                    if (0 === this._valuesEnd[t].length)continue;
                    this._valuesEnd[t] = [this._object[t]].concat(this._valuesEnd[t])
                }
                void 0 !== this._object[t] && (this._valuesStart[t] = this._object[t], this._valuesStart[t]instanceof Array == !1 && (this._valuesStart[t] *= 1), this._valuesStartRepeat[t] = this._valuesStart[t] || 0)
            }
            return this
        }, stop: function () {
            return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this
        }, end: function () {
            return this.update(1 / 0), this
        }, stopChainedTweens: function () {
            for (var e = 0, t = this._chainedTweens.length; e < t; e++)this._chainedTweens[e].stop()
        }, group: function (e) {
            return this._group = e, this
        }, delay: function (e) {
            return this._delayTime = e, this
        }, repeat: function (e) {
            return this._repeat = e, this
        }, repeatDelay: function (e) {
            return this._repeatDelayTime = e, this
        }, yoyo: function (e) {
            return this._yoyo = e, this
        }, easing: function (e) {
            return this._easingFunction = e, this
        }, interpolation: function (e) {
            return this._interpolationFunction = e, this
        }, chain: function () {
            return this._chainedTweens = arguments, this
        }, onStart: function (e) {
            return this._onStartCallback = e, this
        }, onUpdate: function (e) {
            return this._onUpdateCallback = e, this
        }, onRepeat: function (e) {
            return this._onRepeatCallback = e, this
        }, onComplete: function (e) {
            return this._onCompleteCallback = e, this
        }, onStop: function (e) {
            return this._onStopCallback = e, this
        }, update: function (e) {
            var t, n, i;
            if (e < this._startTime)return !0;
            for (t in!1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0), n = (e - this._startTime) / this._duration, n = 0 === this._duration || n > 1 ? 1 : n, i = this._easingFunction(n), this._valuesEnd)if (void 0 !== this._valuesStart[t]) {
                var r = this._valuesStart[t] || 0, v = this._valuesEnd[t];
                v instanceof Array ? this._object[t] = this._interpolationFunction(v, i) : ("string" === typeof v && (v = "+" === v.charAt(0) || "-" === v.charAt(0) ? r + parseFloat(v) : parseFloat(v)), "number" == typeof v && (this._object[t] = r + (v - r) * i))
            }
            if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, n), 1 === n) {
                if (this._repeat > 0) {
                    for (t in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) {
                        if ("string" == typeof this._valuesEnd[t] && (this._valuesStartRepeat[t] = this._valuesStartRepeat[t] + parseFloat(this._valuesEnd[t])), this._yoyo) {
                            var a = this._valuesStartRepeat[t];
                            this._valuesStartRepeat[t] = this._valuesEnd[t], this._valuesEnd[t] = a
                        }
                        this._valuesStart[t] = this._valuesStartRepeat[t]
                    }
                    return this._yoyo && (this._reversed = !this._reversed), void 0 !== this._repeatDelayTime ? this._startTime = e + this._repeatDelayTime : this._startTime = e + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object), !0
                }
                null !== this._onCompleteCallback && this._onCompleteCallback(this._object);
                for (var b = 0, o = this._chainedTweens.length; b < o; b++)this._chainedTweens[b].start(this._startTime + this._duration);
                return !1
            }
            return !0
        }
    }, b.Easing = {
        Linear: {
            None: function (e) {
                return e
            }
        }, Quadratic: {
            In: function (e) {
                return e * e
            }, Out: function (e) {
                return e * (2 - e)
            }, InOut: function (e) {
                return (e *= 2) < 1 ? .5 * e * e : -.5 * (--e * (e - 2) - 1)
            }
        }, Cubic: {
            In: function (e) {
                return e * e * e
            }, Out: function (e) {
                return --e * e * e + 1
            }, InOut: function (e) {
                return (e *= 2) < 1 ? .5 * e * e * e : .5 * ((e -= 2) * e * e + 2)
            }
        }, Quartic: {
            In: function (e) {
                return e * e * e * e
            }, Out: function (e) {
                return 1 - --e * e * e * e
            }, InOut: function (e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e : -.5 * ((e -= 2) * e * e * e - 2)
            }
        }, Quintic: {
            In: function (e) {
                return e * e * e * e * e
            }, Out: function (e) {
                return --e * e * e * e * e + 1
            }, InOut: function (e) {
                return (e *= 2) < 1 ? .5 * e * e * e * e * e : .5 * ((e -= 2) * e * e * e * e + 2)
            }
        }, Sinusoidal: {
            In: function (e) {
                return 1 - Math.cos(e * Math.PI / 2)
            }, Out: function (e) {
                return Math.sin(e * Math.PI / 2)
            }, InOut: function (e) {
                return .5 * (1 - Math.cos(Math.PI * e))
            }
        }, Exponential: {
            In: function (e) {
                return 0 === e ? 0 : Math.pow(1024, e - 1)
            }, Out: function (e) {
                return 1 === e ? 1 : 1 - Math.pow(2, -10 * e)
            }, InOut: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? .5 * Math.pow(1024, e - 1) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
            }
        }, Circular: {
            In: function (e) {
                return 1 - Math.sqrt(1 - e * e)
            }, Out: function (e) {
                return Math.sqrt(1 - --e * e)
            }, InOut: function (e) {
                return (e *= 2) < 1 ? -.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
            }
        }, Elastic: {
            In: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : -Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI)
            }, Out: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : Math.pow(2, -10 * e) * Math.sin(5 * (e - .1) * Math.PI) + 1
            }, InOut: function (e) {
                return 0 === e ? 0 : 1 === e ? 1 : (e *= 2) < 1 ? -.5 * Math.pow(2, 10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (e - 1)) * Math.sin(5 * (e - 1.1) * Math.PI) + 1
            }
        }, Back: {
            In: function (e) {
                return e * e * (2.70158 * e - 1.70158)
            }, Out: function (e) {
                return --e * e * (2.70158 * e + 1.70158) + 1
            }, InOut: function (e) {
                var t = 2.5949095;
                return (e *= 2) < 1 ? e * e * ((t + 1) * e - t) * .5 : .5 * ((e -= 2) * e * ((t + 1) * e + t) + 2)
            }
        }, Bounce: {
            In: function (e) {
                return 1 - b.Easing.Bounce.Out(1 - e)
            }, Out: function (e) {
                return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
            }, InOut: function (e) {
                return e < .5 ? .5 * b.Easing.Bounce.In(2 * e) : .5 * b.Easing.Bounce.Out(2 * e - 1) + .5
            }
        }
    }, b.Interpolation = {
        Linear: function (e, t) {
            var n = e.length - 1, i = n * t, r = Math.floor(i), v = b.Interpolation.Utils.Linear;
            return t < 0 ? v(e[0], e[1], i) : t > 1 ? v(e[n], e[n - 1], n - i) : v(e[r], e[r + 1 > n ? n : r + 1], i - r)
        }, Bezier: function (e, t) {
            for (var n = 0, i = e.length - 1, r = Math.pow, v = b.Interpolation.Utils.Bernstein, a = 0; a <= i; a++)n += r(1 - t, i - a) * r(t, a) * e[a] * v(i, a);
            return n
        }, CatmullRom: function (e, t) {
            var n = e.length - 1, i = n * t, r = Math.floor(i), v = b.Interpolation.Utils.CatmullRom;
            return e[0] === e[n] ? (t < 0 && (r = Math.floor(i = n * (1 + t))), v(e[(r - 1 + n) % n], e[r], e[(r + 1) % n], e[(r + 2) % n], i - r)) : t < 0 ? e[0] - (v(e[0], e[0], e[1], e[1], -i) - e[0]) : t > 1 ? e[n] - (v(e[n], e[n], e[n - 1], e[n - 1], i - n) - e[n]) : v(e[r ? r - 1 : 0], e[r], e[n < r + 1 ? n : r + 1], e[n < r + 2 ? n : r + 2], i - r)
        }, Utils: {
            Linear: function (e, t, n) {
                return (t - e) * n + e
            }, Bernstein: function (e, t) {
                var n = b.Interpolation.Utils.Factorial;
                return n(e) / n(t) / n(e - t)
            }, Factorial: (a = [1], function (e) {
                var t = 1;
                if (a[e])return a[e];
                for (var n = e; n > 1; n--)t *= n;
                return a[e] = t, t
            }), CatmullRom: function (e, t, n, i, r) {
                var v = .5 * (n - e), a = .5 * (i - t), b = r * r;
                return (2 * t - 2 * n + v + a) * (r * b) + (-3 * t + 3 * n - 2 * v - a) * b + v * r + t
            }
        }
    }

    e.TWEEN = b
    window.TWEEN = b

    Object.defineProperty(e, "__esModule", {value: !0})

})));

function Process(e, t) {
    var n, i, r = e.exports = {};

    function v() {
        throw new Error("setTimeout has not been defined")
    }

    function a() {
        throw new Error("clearTimeout has not been defined")
    }

    function b(e) {
        if (n === setTimeout)return setTimeout(e, 0);
        if ((n === v || !n) && setTimeout)return n = setTimeout, setTimeout(e, 0);
        try {
            return n(e, 0)
        } catch (t) {
            try {
                return n.call(null, e, 0)
            } catch (t) {
                return n.call(this, e, 0)
            }
        }
    }

    !function () {
        try {
            n = "function" === typeof setTimeout ? setTimeout : v
        } catch (e) {
            n = v
        }
        try {
            i = "function" === typeof clearTimeout ? clearTimeout : a
        } catch (e) {
            i = a
        }
    }();
    var o, x = [], s = !1, c = -1;

    function u() {
        s && o && (s = !1, o.length ? x = o.concat(x) : c = -1, x.length && f())
    }

    function f() {
        if (!s) {
            var e = b(u);
            s = !0;
            for (var t = x.length; t;) {
                for (o = x, x = []; ++c < t;)o && o[c].run();
                c = -1, t = x.length
            }
            o = null, s = !1, function (e) {
                if (i === clearTimeout)return clearTimeout(e);
                if ((i === a || !i) && clearTimeout)return i = clearTimeout, clearTimeout(e);
                try {
                    i(e)
                } catch (t) {
                    try {
                        return i.call(null, e)
                    } catch (t) {
                        return i.call(this, e)
                    }
                }
            }(e)
        }
    }

    function l(e, t) {
        this.fun = e, this.array = t
    }

    function d() {
    }

    r.nextTick = function (e) {
        var t = new Array(arguments.length - 1);
        if (arguments.length > 1)for (var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n];
        x.push(new l(e, t)), 1 !== x.length || s || b(f)
    }, l.prototype.run = function () {
        this.fun.apply(null, this.array)
    }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = d, r.addListener = d, r.once = d, r.off = d, r.removeListener = d, r.removeAllListeners = d, r.emit = d, r.prependListener = d, r.prependOnceListener = d, r.listeners = function (e) {
        return []
    }, r.binding = function (e) {
        throw new Error("process.binding is not supported")
    }, r.cwd = function () {
        return "/"
    }, r.chdir = function (e) {
        throw new Error("process.chdir is not supported")
    }, r.umask = function () {
        return 0
    }
}




/***/ }),

/***/ "./utils/ajax.js":
/*!***********************!*\
  !*** ./utils/ajax.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./utils/utils.js");
/**
 * Created by Kai on 2020/12/18.
 */


function on(a, b) {
    return function (c) {
        ajaxQueue.finished(a);
        b(c)
    }
}

function decorateMethod(a) { //b

    this.method = a;

    this.binaryResult = !1;

    this.dataContentType = this.data = null;

    if ("GET" === a) {

        this.retriesLeft = JMT.RETRIES_ON_LOAD_ERROR

        this.retryDelay = .5 + Math.random()

    }
    else {

        this.retryDelay = this.retriesLeft = 0

    }
}

decorateMethod.prototype = {
    constructor: decorateMethod,
    retryScheduled: function () {
        console.assert(0 < this.retriesLeft);
        --this.retriesLeft;
        this.retryDelay *= 2
    }
};

function retry(url, method, onLoad, onError, onProgress) {
    setTimeout(function () {
        httpd(url, method, onLoad, onError, onProgress)
    }, method.retryDelay);

    method.retryScheduled()
}

function httpd(url, method, onLoad, onError, onProgress) { //d
    function onException() {
        var g = req.status || 0;

        g = "GET" === method.method && (500 <= g || 0 === g) ? 0 !== method.retriesLeft : !1;

        console.warn("Failed to " + method.method + ": " + url + " (" + req.status + ")" + (g ? ", retrying in " + method.retryDelay + "s" : ""));

        if (g) {

            retry(url, method, onLoad, onError, onProgress);

        }
        else if (void 0 !== onError) {

            try {

                var h = JSON.parse(req.responseText).message

            }

            catch (t) {

                h = void 0

            }

            onError(req.status, h)
        }
        method = req = null
    }

    var req = new XMLHttpRequest;

    void 0 !== onProgress && req.addEventListener("progress", onProgress, !1);

    req.addEventListener("load", function () {

        if (200 <= req.status && 300 > req.status || 0 === req.status) {
            if (void 0 !== onLoad) {
                if (method.binaryResult) {
                    onLoad(req.response)
                }
                else if (req.responseText) {
                    let json = {}
                    try {
                        json = JSON.parse(req.responseText)
                    }
                    catch (e) {
                        console.log(e);
                    }
                    onLoad(json)
                }
                else {
                    onLoad()
                }
            }

            method = req = null
        }
        else {
            onException()
        }

    }, !1);

    req.addEventListener("error", onException, !1);

    req.addEventListener("abort", onException, !1);

    req.open(method.method, url, !0);

    method.binaryResult && (req.responseType = "arraybuffer");

    method.dataContentType && req.setRequestHeader("Content-Type", method.dataContentType);

    //"POST" === method.method && req.setRequestHeader("X-Requested-By", "Shapespark");
    req.send(method.data)
}

function handleError(func, url, method, onload, onerror) {   // e
    function retry() {
        func(url, method, onload, onerror)
    }

    return function () {
        console.warn("Failed to get: " + url + (retry ? ", retrying in " + method.retryDelay + "s" : ""));

        if (0 < method.retriesLeft) {
            setTimeout(retry, method.retryDelay)

            method.retryScheduled()
        }
        else {
            onerror()
        }
    }
}

function getImage(url, method, onload, onerror) {
    var image = new Image;
    image.onload = function () {
        onload(image);
        image = null
    };
    image.onerror = handleError(getImage, url, method, onload, onerror);
    image.crossOrigin = "anonymous";
    image.src = url
}

function getVideo(url, method, onload, onerror) {
    var video = document.createElement("video");
    video.autoplay = !0;
    video.muted = !0;
    video.loop = !0;
    video.setAttribute("playsinline", "true");
    video.setAttribute("webkit-playsinline", "true");
    
    // video.setAttribute("x5-playsinline", "");
    // video.setAttribute("x5-video-player-type", "h5");
    // video.setAttribute("x-webkit-airplay", "allow");

    video.crossOrigin = "anonymous";
    video.onerror = handleError(getVideo, url, method, onload, onerror);
  
    video.src = url;
    if (JMT.DETECTOR.mobile) {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.onVideoDataReady)(video, function (v) {
            
            video.play().catch(function (e) {
            })
            
            onload(video);
            //video = null
        });
    }
    else {
        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.onVideoDataReady)(video, function () {
            onload(video);
            video = null
        });
        video.play().catch(function (e) {
            console.log(e);
        })
    }
    
    
}

var ajaxQueue = new function () {   //h
    function a() {
        for (d += 1; d < b.length; d += 1) {
            var a = b[d];
            if (0 < a.length) {
                for (var e = 0; e < a.length; e += 1)c[d] += 1, JMT.defer(a[e]);
                a.length = 0;
                break
            }
        }
    }

    var b = [], c = [], d = Infinity;

    (function () {
        var a = 0, d;

        for (d in JMT.LOAD_PRIORITY) {

            if (JMT.LOAD_PRIORITY.hasOwnProperty(d)) {
                a = Math.max(a, JMT.LOAD_PRIORITY[d])
            }

        }

        for (d = 0; d <= a; d += 1) {
            b[d] = []
            c[d] = 0
        }
    })();

    this.add = function (e, f) {
        e <= d ? (c[e] += 1, d = e, JMT.defer(f)) : (b[e].push(f), 0 === c[d] && a())
    };

    this.finished = function (b) {
        --c[b];
        var e = c[b];
        console.assert(0 <= e);
        b === d && 0 === e && a()
    }
}

JMT.ajaxGet = function (url, isbinary, onload, onerror, onprogress) {
    var method = new decorateMethod("GET");
    method.binaryResult = isbinary;
    httpd(url, method, onload, onerror, onprogress)
}

JMT.ajaxPost = function (url, isbinary, data, onload, onerror, onprogress) {
    var method = new decorateMethod("POST");
    method.data = data;
    method.dataContentType = isbinary;
    httpd(url, method, onload, onerror, onprogress)
}

JMT.queueAjaxGet = function (priorty, url, isbinary, onload, onerror, onprogress) {
    ajaxQueue.add(priorty, function () {
        JMT.ajaxGet(url, isbinary, on(priorty, onload), on(priorty, onerror), onprogress)
    })
}

JMT.queueImageGet = function (priorty, url, onload, onerror) {
    ajaxQueue.add(priorty, function () {
        var method = new decorateMethod("GET");
        getImage(url, method, on(priorty, onload), on(priorty, onerror))
    })
}

JMT.queueVideoGet = function (priorty, url, onload, onerror) {
    ajaxQueue.add(priorty, function () {
        var method = new decorateMethod("GET");
        getVideo(url, method, on(priorty, onload), on(priorty, onerror))
    })
}


/***/ }),

/***/ "./utils/interactionDetector.js":
/*!**************************************!*\
  !*** ./utils/interactionDetector.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detectIntersect": function() { return /* binding */ detectIntersect; },
/* harmony export */   "findIntersectionAtPosition": function() { return /* binding */ findIntersectionAtPosition; }
/* harmony export */ });
/**
 * Created by Kai on 2021/1/28.
 */


function getBBox(p1, p2, p3) {
    let xmin, ymin, zmin, xmax, ymax, zmax
    p1[0] < p2[0] ? (xmin = p1[0], xmax = p2[0]) : (xmin = p2[0], xmax = p1[0])
    p1[1] < p2[1] ? (ymin = p1[1], ymax = p2[1]) : (ymin = p2[1], ymax = p1[1])
    p1[2] < p2[2] ? (zmin = p1[2], zmax = p2[2]) : (zmin = p2[2], zmax = p1[2])

    xmin > p3[0] && (xmin = p3[0])
    ymin > p3[1] && (ymin = p3[1])
    zmin > p3[2] && (zmin = p3[2])

    xmax < p3[0] && (xmax = p3[0])
    ymax < p3[1] && (ymax = p3[1])
    zmax < p3[2] && (zmax = p3[2])

    return {
        min: [xmin, ymin, zmin],
        max: [xmax, ymax, zmax]
    }
}

function pointInTriangle(pt, p1, p2, p3) {

    //let bbox = getBBox(p1, p2, p3)
    //if(pt[0] < bbox.min[0] ||
    //    pt[1] < bbox.min[1] ||
    //    pt[2] < bbox.min[2] ||
    //    pt[0] > bbox.max[0] ||
    //    pt[1] > bbox.max[1] ||
    //    pt[2] > bbox.max[2]
    //){
    //    return false
    //}

    let s = areaOf(p1, p2, p3),
        s1 = areaOf(pt, p1, p2),
        s2 = areaOf(pt, p1, p3),
        s3 = areaOf(pt, p2, p3)

    let d = s - s1 - s2 - s3

    return d < 0.00001 && d > -0.00001
}

function cross(pt1, pt2, pt3) {

    let p1 = [pt2[0] - pt1[0], pt2[1] - pt1[1], pt2[2] - pt1[2]]
    let p2 = [pt3[0] - pt1[0], pt3[1] - pt1[1], pt3[2] - pt1[2]]

    let a = p1[1] * p2[2] - p1[2] * p2[1]
    let b = p1[2] * p2[0] - p1[0] * p2[2]
    let c = p1[0] * p2[1] - p1[1] * p2[0]

    return [a, b, c]
}

function areaOf(pt1, pt2, pt3) {

    let c = cross(pt1, pt2, pt3)

    let s = c[0] * c[0] + c[1] * c[1] + c[2] * c[2]

    return Math.sqrt(s)
}


//点乘的几何意义是可以用来表征或计算两个向量之间的夹角，以及在b向量在a向量方向上的投影
function projectToRay(point, origin, direction) {
    let ptVector = new THREE.Vector3().copy(point).sub(origin)
    let prjDist = ptVector.dot(direction)
    let prjPoint = new THREE.Vector3().copy(direction).multiplyScalar(prjDist)
    prjPoint = new THREE.Vector3().copy(origin).add(prjPoint)

    let isBetween = prjDist > 0

    return {
        distance: isBetween ? prjPoint.distanceTo(point) : 1 / 0,
        point: prjPoint
    }
}

function detectIntersect(e) {

    let x = e.x / window.innerWidth * 2 - 1;
    let y = 2 * -(e.y / window.innerHeight) + 1


    let obj = UjP.viewer.findIntersectionAtPosition(x, y)
    if (!obj) return null

    //判断findIntersectionAtPosition接口是否返回表面信息，若有直接使用
    //如果包含了face信息，直接使用该交点
    if (obj.face ) {
         return {
             point: obj.point.toArray(),
             normal: new THREE.Vector3().addVectors(obj.point, obj.face.normal.multiplyScalar(2)).toArray(),
             face: [obj.face.a, obj.face.b, obj.face.c],
             object: obj.object
         }
    }
    else {
         //geometry data info
        let position = obj.object.geometry.parent.attributes.position.array
        //let index = obj.object.geometry.parent.attributes.index.array
        
        //如果没有几何信息，可能是浏览模式释放了数据，直接使用该交点
        if (!position) {
            return {
                distance: obj.distance,
                point: obj.point.toArray(),
                normal: obj.direction.toArray(),
                face: [-1,-1,-1],
                object: obj.object
            }
        }

         // 射线法二次求交
         return _intersectTriangle(obj.object, x, y)
         //let pt = [obj.point.x, obj.point.y, obj.point.z]
         //return _dectectIntersect(pt, obj.object)
    }
    
}

function _intersectTriangle(mesh, x, y) {

    if (!mesh) {
        return null
    }

    //var raycaster = new THREE.Raycaster();
    var mouseVector = new THREE.Vector3();
    mouseVector.set(x, y, 0.5);
    //raycaster.setFromCamera( mouseVector );
    var ray = new THREE.Ray()
    let c = UjP.controls
    let camera = c.camera()

    ray.origin.setFromMatrixPosition(camera.matrixWorld);
    ray.direction.set(x, y, 0.5).unproject(camera).sub(ray.origin).normalize();

    //--------------------------------------
    if (mesh.geometry.parent) {
        let array = mesh.geometry.parent.attributes.position.array

        let index = mesh.geometry.parent.attributes.index
        var intersects = []

        if (!index) {
            let len = array.length / 9

            var vA = new THREE.Vector3()
            var vB = new THREE.Vector3()
            var vC = new THREE.Vector3()
            var point = new THREE.Vector3()

            for (let j = 0; j < len; j++) {
                let i = j * 9

                vA.set(array[i], array[i + 1], array[i + 2])
                vB.set(array[i + 3], array[i + 4], array[i + 5])
                vC.set(array[i + 6], array[i + 7], array[i + 8])

                if (mesh.geometry.parent.isInstanced) {
                    let atts = mesh.geometry.parent.attributes
                    let offset = 4 * mesh.geometry.instanceId
                    transformPosition(atts.t0.array, atts.t1.array, atts.t2.array, vA, offset)
                    transformPosition(atts.t0.array, atts.t1.array, atts.t2.array, vB, offset)
                    transformPosition(atts.t0.array, atts.t1.array, atts.t2.array, vC, offset)
                }

                let intersect = ray.intersectTriangle(vA, vB, vC, false, point);
                if (intersect === null)
                    continue

                let distance = intersect.distanceTo(ray.origin)
                //var normal = THREE.Triangle.normal(vA, vB, vC)
                var normal = new THREE.Vector3()
                THREE.Triangle.getNormal(vA, vB, vC, normal)

                // Martian
                // 防止极值导致的旋转错误，欧拉角互锁；
                // 失之毫厘，谬以千里；且撸且珍惜！
                let ROUNDING_f32 = 0.000001
                if (Math.abs(normal.x) < ROUNDING_f32) normal.x = 0
                if (Math.abs(normal.y) < ROUNDING_f32) normal.y = 0
                if (Math.abs(normal.z) < ROUNDING_f32) normal.z = 0

                var ins = {
                    distance: distance,
                    point: [intersect.x, intersect.y, intersect.z],
                    normal: [normal.x, normal.y, normal.z],
                    face: [
                        [vA.x, vA.y, vA.z],
                        [vB.x, vB.y, vB.z],
                        [vC.x, vC.y, vC.z]
                    ],
                    object: mesh
                }


                intersects.push(ins)
            }

            if (intersects.length > 0) {

                var ret_ins = intersects[0]

                for (let j = 0, len = intersects.length; j < len; j++) {

                    if (ret_ins.distance > intersects[j].distance)
                        ret_ins = intersects[j]
                }

                return ret_ins
            }
        }
    }
    //--------------------------------------

    return null
}


function transformPosition(t0, t1, t2, position, offset) {

    let x = offset,
        y = offset + 1,
        z = offset + 2,
        w = offset + 3
    let sx = t0[x] * position.x + t0[y] * position.y + t0[z] * position.z + t0[w]
    let sy = t1[x] * position.x + t1[y] * position.y + t1[z] * position.z + t1[w]
    let sz = t2[x] * position.x + t2[y] * position.y + t2[z] * position.z + t2[w]

    position.set(sx, sy, sz)
}

function _dectectIntersect(pt, mesh) {
    //let dir = obj.direction

    let array = mesh.geometry.parent.attributes.position.array

    let index = mesh.geometry.parent.attributes.index

    if (!index) {
        let len = array.length / 9

        for (let j = 0; j < len; j++) {
            let i = j * 9
            let p1 = [array[i], array[i + 1], array[i + 2]],
                p2 = [array[i + 3], array[i + 4], array[i + 5]],
                p3 = [array[i + 6], array[i + 7], array[i + 8]]

            let isIn = pointInTriangle(pt, p1, p2, p3)

            if (isIn) {
                let normal = new THREE.Vector3().fromArray(cross(p1, p2, p3)).normalize()
                return {
                    point: pt,
                    normal: normal.toArray(),
                    face: [p1, p2, p3],
                    object: mesh
                }
            }
        }

    } else {
        console.assert(true, 'indices geometry')
    }

    return null
}

//素材选择
//e          窗口坐标
//objects    需要在选择的素材列表
//justFirst  按顺序，仅找第一个
function findIntersectionAtPosition(e, objects, justFirst) {
    //传递过来的坐标已经转换过
    //let x = e.x / window.innerWidth * 2 - 1;
    //let y = 2 * -(e.y / window.innerHeight) + 1

    let x = e.x,
        y = e.y

    let c = UjP.controls
    let g = c.cameraWorldPosition()
    var a = new JMT.RaycasterConfig(g)
    var b = a.ray.direction
    let camPos = c.camera instanceof Function ? c.camera() : c.camera
    b.set(x, y, 1).unproject(camPos);
    b.sub(g).normalize();

    //TODO: Martain
    let ray = a.ray
    var intersections = []
    for (var a of objects) { // 遍历Set

        let inset = a.raycast(ray)
        if (justFirst && inset) {
            return inset
        }


        if (inset)
            intersections.push(inset)
    }

    //nearest asset
    if (intersections.length > 0) {
        intersections.sort(function (a, b) {
            return a.distance - b.distance
        })

        let ret_ins = intersections[0]
        return ret_ins
    }


    return null
}

JMT.detectIntersect = detectIntersect;


/***/ }),

/***/ "./utils/log.js":
/*!**********************!*\
  !*** ./utils/log.js ***!
  \**********************/
/***/ (function() {

/**
 * Created by Kai on 2020/12/18.
 */
function formatDateTime(dateTime) {
    function toFixedString(a, b) {

        for (a = a.toString(); a.length < b;) {

            a = "0" + a;

        }

        return a
    }

    return toFixedString(dateTime.getHours(), 2) + ":"
        + toFixedString(dateTime.getMinutes(), 2) + ":"
        + toFixedString(dateTime.getSeconds(), 2) + ","
        + toFixedString(dateTime.getMilliseconds(), 3) + " "
}

function bind(type) {

    var func = console[type].bind(console);

    console[type] = function () {

        var d = "", g = ""

        for (var f = 0; f < arguments.length; ++f) {

            g += (0 === f ? "" : " ") + arguments[f];

        }

        if (JMT.LOG_TIME) {

            d = formatDateTime(new Date)

        }

        f = d + b.toUpperCase() + " " + g;

        if (JMT.LOG_TO_SERVER) {

            JMT.ajaxPost("/log", "application/json", JSON.stringify({message: f}));

        }

        func(d + g)
    }
}



JMT.LOG_INFO = true

if (JMT.LOG_INFO) {

    JMT.log = function (a) {

        for (var b = [], c = 0; c < arguments.length; ++c) {

            b[c - 0] = arguments[c];

        }

        console.log.apply(console, $jscomp.arrayFromIterable(b))

    }
}
else {

    JMT.log = function () {
    };
}

if (JMT.LOG_TO_SERVER || JMT.LOG_TIME) {

    bind("log")

    bind("info")

    bind("warn")

    bind("error")
}

/***/ }),

/***/ "./utils/utils.js":
/*!************************!*\
  !*** ./utils/utils.js ***!
  \************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_construct": function() { return /* binding */ _construct; },
/* harmony export */   "adjustFont": function() { return /* binding */ adjustFont; },
/* harmony export */   "any": function() { return /* binding */ any; },
/* harmony export */   "anyPositiveRootOfQuadraticEquation": function() { return /* binding */ anyPositiveRootOfQuadraticEquation; },
/* harmony export */   "arrayBufferToBase64": function() { return /* binding */ arrayBufferToBase64; },
/* harmony export */   "arrayHasObjectWithUUID": function() { return /* binding */ arrayHasObjectWithUUID; },
/* harmony export */   "bufferToBase64": function() { return /* binding */ bufferToBase64; },
/* harmony export */   "cloneObject": function() { return /* binding */ cloneObject; },
/* harmony export */   "computeDevicePixelRatio": function() { return /* binding */ computeDevicePixelRatio; },
/* harmony export */   "computeNodeBoundingSphere": function() { return /* binding */ computeNodeBoundingSphere; },
/* harmony export */   "convertF0ToIOR": function() { return /* binding */ convertF0ToIOR; },
/* harmony export */   "convertIORToF0": function() { return /* binding */ convertIORToF0; },
/* harmony export */   "convertIORToReflectivity": function() { return /* binding */ convertIORToReflectivity; },
/* harmony export */   "convertReflectivityToF0": function() { return /* binding */ convertReflectivityToF0; },
/* harmony export */   "convertReflectivityToIOR": function() { return /* binding */ convertReflectivityToIOR; },
/* harmony export */   "copyProperties": function() { return /* binding */ copyProperties; },
/* harmony export */   "createTextureFromHtmlImage": function() { return /* binding */ createTextureFromHtmlImage; },
/* harmony export */   "createTextureFromHtmlVideo": function() { return /* binding */ createTextureFromHtmlVideo; },
/* harmony export */   "deepEqual": function() { return /* binding */ deepEqual; },
/* harmony export */   "defer": function() { return /* binding */ defer; },
/* harmony export */   "defineProperty": function() { return /* binding */ defineProperty; },
/* harmony export */   "disableReactivityForAllProps": function() { return /* binding */ disableReactivityForAllProps; },
/* harmony export */   "disposeMaterial": function() { return /* binding */ disposeMaterial; },
/* harmony export */   "disposeNode": function() { return /* binding */ disposeNode; },
/* harmony export */   "extend": function() { return /* binding */ extend; },
/* harmony export */   "filter": function() { return /* binding */ filter; },
/* harmony export */   "find": function() { return /* binding */ find; },
/* harmony export */   "genDataURLFromTexture": function() { return /* binding */ genDataURLFromTexture; },
/* harmony export */   "genUUID": function() { return /* binding */ genUUID; },
/* harmony export */   "getAllMeshesFromObject": function() { return /* binding */ getAllMeshesFromObject; },
/* harmony export */   "getAllTextures": function() { return /* binding */ getAllTextures; },
/* harmony export */   "getBoolFromStr": function() { return /* binding */ getBoolFromStr; },
/* harmony export */   "getDefaultCanvas": function() { return /* binding */ getDefaultCanvas; },
/* harmony export */   "getElapsedTime": function() { return /* binding */ getElapsedTime; },
/* harmony export */   "getExtension": function() { return /* binding */ getExtension; },
/* harmony export */   "getMtls": function() { return /* binding */ getMtls; },
/* harmony export */   "getOriginFromUrl": function() { return /* binding */ getOriginFromUrl; },
/* harmony export */   "getParameterByName": function() { return /* binding */ getParameterByName; },
/* harmony export */   "getSafeValue": function() { return /* binding */ getSafeValue; },
/* harmony export */   "getTextureLoader": function() { return /* binding */ getTextureLoader; },
/* harmony export */   "getTimeString": function() { return /* binding */ getTimeString; },
/* harmony export */   "getUrlbase": function() { return /* binding */ getUrlbase; },
/* harmony export */   "getViewerAssetUrl": function() { return /* binding */ getViewerAssetUrl; },
/* harmony export */   "indexOfMax": function() { return /* binding */ indexOfMax; },
/* harmony export */   "inheritPrototype": function() { return /* binding */ inheritPrototype; },
/* harmony export */   "isAbsolutePath": function() { return /* binding */ isAbsolutePath; },
/* harmony export */   "isIFramed": function() { return /* binding */ isIFramed; },
/* harmony export */   "isIOS": function() { return /* binding */ isIOS; },
/* harmony export */   "isLeftMouse": function() { return /* binding */ isLeftMouse; },
/* harmony export */   "isLocalhost": function() { return /* binding */ isLocalhost; },
/* harmony export */   "isModifierPressed": function() { return /* binding */ isModifierPressed; },
/* harmony export */   "isTouchDevice": function() { return /* binding */ isTouchDevice; },
/* harmony export */   "isVisible": function() { return /* binding */ isVisible; },
/* harmony export */   "iterateAsync": function() { return /* binding */ iterateAsync; },
/* harmony export */   "log2": function() { return /* binding */ log2; },
/* harmony export */   "mapRange": function() { return /* binding */ mapRange; },
/* harmony export */   "minBytesToHold": function() { return /* binding */ minBytesToHold; },
/* harmony export */   "mipsCount": function() { return /* binding */ mipsCount; },
/* harmony export */   "normalizeRotation": function() { return /* binding */ normalizeRotation; },
/* harmony export */   "onVideoDataReady": function() { return /* binding */ onVideoDataReady; },
/* harmony export */   "openInNewTab": function() { return /* binding */ openInNewTab; },
/* harmony export */   "preloadImage": function() { return /* binding */ preloadImage; },
/* harmony export */   "readOnlyCopy": function() { return /* binding */ readOnlyCopy; },
/* harmony export */   "removeByAttr": function() { return /* binding */ removeByAttr; },
/* harmony export */   "removeByValue": function() { return /* binding */ removeByValue; },
/* harmony export */   "removeFromArray": function() { return /* binding */ removeFromArray; },
/* harmony export */   "removeObjectsFromArrayByUUID": function() { return /* binding */ removeObjectsFromArrayByUUID; },
/* harmony export */   "resizeImage": function() { return /* binding */ resizeImage; },
/* harmony export */   "resolveText": function() { return /* binding */ resolveText; },
/* harmony export */   "round": function() { return /* binding */ round; },
/* harmony export */   "setTextContent": function() { return /* binding */ setTextContent; },
/* harmony export */   "spheresUnion": function() { return /* binding */ spheresUnion; },
/* harmony export */   "sunRotationToPosition": function() { return /* binding */ sunRotationToPosition; },
/* harmony export */   "textureNeedsPowerOfTwo": function() { return /* binding */ textureNeedsPowerOfTwo; },
/* harmony export */   "toFixedNumber": function() { return /* binding */ toFixedNumber; },
/* harmony export */   "toSnorm8": function() { return /* binding */ toSnorm8; },
/* harmony export */   "traverseMtl": function() { return /* binding */ traverseMtl; },
/* harmony export */   "urlHashContains": function() { return /* binding */ urlHashContains; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
/*
 Copyright (C) 2014-present M.K.
 */
function a(b, d, e) {
    return function () {
        if (b !== d.length) {
            e(d[b])
            defer(a(b + 1, d, e))
        }
    }
}

var PI2 = 2 * Math.PI;


JMT.LIGHT_PROBE_MIPS_COUNT = mipsCount(JMT.LIGHT_PROBE_MIN_MIP_SIZE, JMT.LIGHT_PROBE_MAX_MIP_SIZE);

JMT.defer = function (a) {
    setTimeout(a, 0)
};

function iterateAsync(b, d) {
    JMT.defer(a(0, b, d))
};

function find(a, b) {
    for (var c = 0; c < a.length; c += 1) {
        var d = a[c];
        if (b(d)){
            return d
        }
    }
};

function filter(a, b) {
    for (var c = a.length, d = [], f = 0; f < c; f += 1) {
        b(a[f]) && d.push(a[f]);
    }
    return d
};

function indexOfMax(a, b) {
    if (0 === a.length) {
        return null;
    }
    var c = 0
    var d = b ? b(a[0]) : a[0]
    for (var f = 1; f < a.length; f += 1) {
        var h = b ? b(a[f]) :
            a[f];
        h > d && (c = f, d = h)
    }
    return c
};

function any(a, b) {
    var c = a.length
    for (var d = 0; d < c; d += 1) {
        if (b(a[d]))return !0;
    }
    return !1
};

function removeFromArray(a, b) {
    a = b.indexOf(a);
    console.assert(-1 !== a);
    return b.splice(a, 1)
}

function getDefaultCanvas(){

    var canvas = document.getElementById("anchor-canvas");

    if (!canvas) {

        canvas = document.createElement("canvas")

        canvas.id = "anchor-canvas"
    }

    return canvas
}


function createTextureFromHtmlImage(image) {
    function b() {
        d.needsUpdate = !0;
        d.width = image.naturalWidth;
        d.height = image.naturalHeight;
        THREE.Math.isPowerOfTwo(d.width) && THREE.Math.isPowerOfTwo(d.height) || (d.minFilter = THREE.LinearFilter);
        d.notifyLoaded&&d.notifyLoaded()
    }

    function c() {
        b();
        e && e();
        image.onload = e
    }

    var d = new THREE.Texture;
    d.image = image;
    d.wrapS = d.wrapT = THREE.RepeatWrapping;
    d.minFilter = THREE.LinearMipmapLinearFilter;
    d.anisotropy = JMT.DEFAULT_ANISOTROPY;
    d.format = THREE.RGBFormat;
    var e = null;
    image.complete && 0 !== image.naturalHeight ? b() : (e = image.onload, image.onload = c);
    return d
}

function createTextureFromHtmlVideo(video) {
    var b = new JMT.VideoTexture;
    b.video = video;
    b.minFilter = GLC.LINEAR;
    b.anisotropy = JMT.DEFAULT_ANISOTROPY;
    b.format = GLC.RGB;
    b.generateMipmaps = !1;
    video.setAttribute("playsinline", "");
    video.setAttribute("webkit-playsinline", "");
    video.crossOrigin = "anonymous";
    JMT.onVideoDataReady(video, function (a) {
        b.width = a.videoWidth;
        b.height = a.videoHeight;
        if (THREE.Math.isPowerOfTwo(b.width) && THREE.Math.isPowerOfTwo(b.height)) {
            b.wrapS = GLC.REPEAT
            b.wrapT = GLC.REPEAT
        }
        else {
            b.wrapS = GLC.CLAMP_TO_EDGE
            b.wrapT = GLC.CLAMP_TO_EDGE
        }
        b.notifyLoaded()
    });
    return b
}


function copyProperties(a, b, e) {
    for (var c = 0; c < b.length; c += 1) {
        var d = b[c], h = a[d];
        void 0 !== h && (e[d] = h)
    }
}

function normalizeRotation(a) {
    a %= PI2;
    return a > Math.PI ? -PI2 + a : a < -Math.PI ? PI2 + a : a
}

function setTextContent(holder, value) {
    if (!holder) {
        return
    }
    if (void 0 !== holder.textContent) {
        holder.textContent = value
    }
    else if (void 0 !== holder.innerText) {
        holder.innerText = value
    }
    else {
        console.warn("textContent and innerText properties are missing")
    }
}

function getOriginFromUrl(url) {
    var b = document.createElement("a");
    b.href = url;
    return b.protocol + "//" + b.host
}

function log2(num) {
    return Math.log(num) / Math.log(2)
}

function mipsCount(a, b) {
    return log2(b) - log2(a) + 1
};

function isModifierPressed(a) {
    return a.ctrlKey || a.altKey || a.metaKey
}

function round(a, b) {
    void 0 ===
    b && (b = 3);
    return +(Math.round(a + "e+" + b) + "e-" + b)
};

function preloadImage(a) {
    var b = new Image;
    b.src = a;
    return b
}

function onVideoDataReady(video, onReady) {
    function _onReady(event) {
        if (video.readyState >= video.HAVE_CURRENT_DATA) {
            video.removeEventListener("playing", _onReady)
            video.removeEventListener("timeupdate", _onReady)
            video.removeEventListener("canplaythrough", _onReady)
			video.removeEventListener("canplay", _onReady)
            onReady(video)
        }
    }

    if (video.readyState >= video.HAVE_CURRENT_DATA || JMT.DETECTOR.mobile) {
        onReady(video)
    }
    else {
        video.addEventListener("playing", _onReady)
        video.addEventListener("timeupdate", _onReady)
        video.addEventListener("canplaythrough", _onReady)
		video.addEventListener("canplay", _onReady)
    }
}

function cloneObject(object) {
    return JSON.parse(JSON.stringify(object))
}

function readOnlyCopy(object) {
    return Object.freeze(cloneObject(object))
}

function deepEqual(a, b) {
    if (a === b) {
        return !0;
    }
    if ("object" !== typeof a || null === a || "object" !== typeof b || null === b || Object.keys(a).length !== Object.keys(b).length) {
        return !1;
    }
    for (var c = $jscomp.makeIterator(Object.keys(a)), d = c.next(); !d.done; d = c.next()) {
        d = d.value
        if (!b.hasOwnProperty(d) || !deepEqual(a[d], b[d])) {
            return !1;
        }
    }
    return !0
}


function getUrlbase(){
    //return "https://cloud.3dyunzhan.com:5001";

    if (isLocalhost()) {
        return "http://localhost:5001";
    }
    var a = window.location.hostname;

    if (a.endsWith(".3dyunzhan.com")) {
        return "https://cloud" + a.substr(a.indexOf("."))
    }
    else if (a.endsWith(".3dyunzhan.com.cn")) {
        return "https://cloud.3dyunzhan.com.cn"
    }
    else {
        return "https://cloud.3dyunzhan.com"
    }
}

function adjustFont(canvas, b, c, d) {
    var e = JMT.SPRITE_ANCHOR_FONT_SIZE
    var f = canvas.getContext("2d");
    f.font = "700 " + e + "px " + c;

    for (var g = b, k = b.length - 1, h; ;) {
        h = f.measureText(g).width;
        h += 2 * d;
        if (1024 >= h)break;
        g = b.substring(0, k) + "...";
        --k
    }
    canvas.width = h;
    canvas.height = 1.5 * e;
    f = canvas.getContext("2d");
    f.font = "700 " + e + "px " + c;
    return [f, g]
}


function getTimeString(a){
    a = new Date(a);
    var b = new Date;
    return b.getDate() === a.getDate() && b.getMonth() === a.getMonth() && b.getFullYear() === a.getFullYear() ? a.toLocaleTimeString() : a.toLocaleDateString() + " " + a.toLocaleTimeString()
}

function genUUID(){
    let mydate = new Date();
    return "jmk-" + mydate.getDay() + mydate.getHours() + mydate.getMinutes() + mydate.getSeconds() + mydate.getMilliseconds() + Math.round(Math.random() * 10000);
}

JMT.genUUID = genUUID

function isLocalhost() {
    return "localhost" === window.location.hostname || "127.0.0.1" === window.location.hostname
}

function urlHashContains(b) {

    function a() {
        var a = {}
        var b = window.location.hash;
        b && b.substring(1).split("&").forEach(function (b) {
            var c = b.indexOf("=");
            0 <= c ? a[b.substring(0, c)] = b.substring(c + 1) : a[b] = void 0
        });
        return a
    }

    return b in a()
}

function sunRotationToPosition (a, b, c) {
    a = a.findSkyMesh(JMT.EDITOR_CONTROLLED_SKY_NAME);
    c.set(0, -a.radius, 0);
    c.applyEuler(b);
    c.add(a.position)
}

function computeNodeBoundingSphere(a, b) {
    b.radius = 0;
    a.visitSubtree(function (a) {
        a.mesh && JMT.Math.spheresUnion(a.mesh.geometry.boundingSphere, b)
    })
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////
// 4sDV
window.JMK = window.JMK || {}

"use strict";
function disableReactivityForAllProps(e, t) {
    for (var n = Object.keys(e), i = 0; i < n.length; i++) {
        t.indexOf(n[i]) < 0 && Object.defineProperty(e, n[i], {configurable: !1})
    }
}

function getParameterByName(e, t) {
    t || (t = window.location.href), e = e.replace(/[[]]/g, "\$&");
    var n = new RegExp("[?&]" + e + "(=([^&#]*)|&|#|$)").exec(t);
    return n ? n[2] ? decodeURIComponent(n[2].replace(/\+/g, " ")) : "" : null
}

function inheritPrototype(e, t) {
    var n = Object.create(t.prototype);
    n.constructor = e
    e.prototype = n
}

function isLeftMouse(e) {
    return 1 === ((e = e || window.event).which || e.button)
}

function disposeNode(e) {
    e.traverse((function (e) {
        e instanceof THREE.Mesh && (e.geometry && e.geometry.dispose(), e.material && o(e.material))
    }))
}

function disposeMaterial(e) {
    if (Array.isArray(e)) {
        for (var t = 0, n = e.length; t < n; t++)o(e[t]);
    }
    else {
        e.map && e.map.dispose && e.map.dispose()
        e.lightMap && e.lightMap.dispose && e.lightMap.dispose()
        e.bumpMap && e.bumpMap.dispose && e.bumpMap.dispose()
        e.normalMap && e.normalMap.dispose && e.normalMap.dispose()
        e.specularMap && e.specularMap.dispose && e.specularMap.dispose()
        e.envMap && e.envMap.dispose && e.envMap.dispose()
        e.aoMap && e.aoMap.dispose && e.aoMap.dispose()
        e.alphaMap && e.alphaMap.dispose && e.alphaMap.dispose()
        e.displacementMap && e.displacementMap.dispose && e.displacementMap.dispose()
        e.emissiveMap && e.emissiveMap.dispose && e.emissiveMap.dispose()
        e.metalnessMap && e.metalnessMap.dispose && e.metalnessMap.dispose()
        e.roughnessMap && e.roughnessMap.dispose && e.roughnessMap.dispose();
    }
    e.dispose && e.dispose()
}

function getAllMeshesFromObject(e, t) {
    var n = [];
    return v0b("0x752") === e.type && n.push(e), n = n.concat(_.filter(e.children, (function (e) {
        n = n.concat(x(e.children))
        e.asCls = t
        return "Mesh" === e.type
    })))
}

var s, c, u, f, l, d = !1;

function genDataURLFromTexture(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 200, n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 200, i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : .8, r = !(arguments.length > 4 && void 0 !== arguments[4]) || arguments[4];

    if (!1 === d) {

        s = document.createElement("canvas")

        (c = new (THREE.lJv)({canvas: s})).outputEncoding = deQ.renderer.outputEncoding

        c.gammaFactor = deQ.renderer.gammaFactor

        f = new THREE.Scene

        u = new THREE.JwR(-t / 2, t / 2, n / 2, -n / 2, 1, 10)

        f.add(u)

        (l = new (THREE.Mesh)(new (THREE.VWx)(1, 1, 1, 1), new (THREE.oCx)({side: THREE.RYe}))).position.z = -5

        f.add(l)

        d = !0
    }

    s.width = t

    s.height = n

    u.left = -t / 2

    u.right = t / 2

    u.top = n / 2

    u.bottom = -n / 2

    u.updateProjectionMatrix()

    r ? l.scale.set(t, -n, 1) : l.scale.set(t, n, 1)

    l.material.map = e

    l.material.needsUpdate = !0

    e.needsUpdate = !0

    c.setSize(t, n)

    c.render(f, u)

    return s.toDataURL("image/jpeg", i)
}

var p = ["map", "alphaMap", "aoMap", "lightMap", "specularMap", "emissiveMap", "bumpMap", "displacementMap", "normalMap", "roughnessMap", "metalnessMap", "gradientMap"];

function getAllTextures(e) {
    var t, n = [], i = p.length;
    e.traverse((function (e) {
        if (t = e.material) {
            for (var r = 0; r < i; r++) {
                t.hasOwnProperty(p[r]) && t[p[r]] && n.push(t[p[r]])
            }
        }
    }))

    return n
}

function traverseMtl(e, t) {
    var n = [];
    e.traverse((function (e) {
        void 0 !== e.material && function e(t, n) {
            if (Array.isArray(t))for (var i = 0, r = t.length; i < r; i++)e(t[i], n); else n(t)
        }(e.material, (function (e) {
            n.indexOf(e.uuid) < 0 && (t(e), n.push(e.uuid))
        }))
    }))
}

function arrayHasObjectWithUUID(e, t) {
    for (var n = 0, i = e.length; n < i; n++)if (e[n] && e[n].hasOwnProperty("uuid") && e[n].uuid === t)return !0;
    return !1
}

function removeByValue(e, t) {
    var n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
}

function removeByAttr(e, t, n) {
    for (var i = 0, r = e.length; i < r; i++)void 0 !== e[i] && e[i][t] === n && e.splice(i, 1)
}

function removeObjectsFromArrayByUUID(e, t) {
    for (var n = 0, i = t.length; n < i; n++)void 0 !== t[n] && M(e, "uuid", t[n].uuid)
}

function getElapsedTime(e) {
    return (performance.now() - e).toFixed(2)
}

function isTouchDevice() {
    var e = " -webkit- -moz- -o- -ms- ".split(" ");
    if ("ontouchstart"in window || window.DocumentTouch && document instanceof DocumentTouch)return !0;
    var t, n = ["(", e.join("touch-enabled),("), "heartz", ")"].join("");
    return t = n, window.matchMedia(t).matches
}

function getBoolFromStr(e) {
    return "1" === e || "true" === e
}

function mapRange(e, t, n, i, r) {
    return i + (r - i) * (e - t) / (n - t)
}

function isIFramed() {
    return window.self !== window.top
}

function openInNewTab(e) {
    window.open(e, "_blank").focus()
}

function extend() {
    for (var e = 1; e < arguments.length; e++) {
        for (var t in arguments[e]) {
            arguments[e].hasOwnProperty(t) && (arguments[0][t] = arguments[e][t]);
        }
    }
    return arguments[0]
}

function convertIORToF0(e) {
    return Math.pow((1 - e) / (1 + e), 2)
}

function convertIORToReflectivity(e) {
    return function (e) {
        return Math.sqrt(e / .16)
    }(O(e))
}

function convertReflectivityToF0(e) {
    return .16 * Math.pow(e, 2)
}

function convertF0ToIOR(e) {
    var t = Math.sqrt(e);
    return (1 + t) / (1 - t)
}

function convertReflectivityToIOR(e) {
    return convertF0ToIOR(convertReflectivityToF0(e))
}

function toFixedNumber(e, t) {
    var n = Math.pow(10, t);
    return Math.round(e * n) / n
}

function computeDevicePixelRatio() {
    return window.devicePixelRatio < 1 ? 1 : Math.round(window.devicePixelRatio)
}

function isIOS() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1
}

function isAbsolutePath(e) {
    return 0 === (e = e.toLowerCase()).indexOf("http") || 0 === e.indexOf("/") || 0 === e.indexOf("\\")
}

function getExtension(e) {
    return e.split(".").pop().toLowerCase()
}

function defer() {
    var e, t, n = new Promise((function (n, i) {
        e = n, t = i
    }));
    n.resolve = e
    n.reject = t
    return n
}

function getMtls(e) {
    var t = [];
    e.traverse((function (e) {
        null != e.material && -1 === t.indexOf(e.material) && t.push(e.material)
    }))
    return t
}

window.hideElement = function (e, t) {
    if (e) {
        e.classList.add("faded"),
            t ? e.classList.add("hidden") : setTimeout((function () {
                e.classList.add("hidden")
            }), 300)
    }
}

window.showElement = function (e, t) {
    if (e) {
        e.classList.remove("hidden"),
            t ? e.classList.remove("faded") : setTimeout((function () {
                e.classList.remove("faded")
            }), 20)
    }
}


function toSnorm8(a) {
    return Math.round(127 * THREE.Math.clamp(a, -1, 1))
}

function minBytesToHold(a) {
    return 127 >= a ? 1 : 32767 >= a ? 2 : 4
}

function anyPositiveRootOfQuadraticEquation(a, c, d) {
    d = c * c - 4 * a * d;
    if (0 > d)return null;
    d = Math.sqrt(d);
    var b = (-c - d) / (2 * a);
    if (0 < b)return b;
    a = (-c + d) / (2 * a);
    return 0 < a ? a : null
}

function spheresUnion(b, c) {
    if (c.empty())c.copy(b); else {
        var d = c.center.distanceTo(b.center);
        if (b.radius > c.radius) {
            var e = b;
            b = c
        }
        else {
            e = c;
        }

        var g = (e.radius + b.radius + d) / 2;

        if (g <= e.radius) {
            c.copy(e)
        }
        else {
            d = (g - e.radius) / d

            console.assert(0 < d)


            var a = new THREE.Vector3()

            a.copy(b.center).sub(e.center).multiplyScalar(d)

            c.center.copy(e.center).add(a)

            c.radius = g
        }
    }
}

function _construct(Parent, args, Class) {

    if (_isNativeReflectConstruct()) {

        _construct = Reflect.construct;

    }
    else {
        _construct = function _construct(Parent, args, Class) {
            var a = [null];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) _setPrototypeOf(instance, Class.prototype);
            return instance;
        };
    }

    return _construct.apply(null, arguments);
}
// 判断是否能否使用 Reflect
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function () {
        }));
        return true;
    } catch (e) {
        return false;
    }
}

// 获取 o 对象的原型（__proto__）
function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
}

// 这个方法主要就是使用Object.setPrototypeOf方法使子类subClass.__proto__指向父类,实现静态方法/属性的继承
function _setPrototypeOf(o, p) {
    // 如果有Object.setPrototypeOf就调这个方法，没有就自己实现o.__proto__ = p
    _setPrototypeOf =
        Object.setPrototypeOf ||
        function _setPrototypeOf(o, p) {
            o.__proto__ = p;
            return o;
        };
    return _setPrototypeOf(o, p);
}


JMK.log = function(content){
    console.log(content)
}

function getTextureLoader(onload, onerror) {
    return new JMT.TextureLoader(
        "./",
        JMT.DETECTOR,
        function (a) {
            onload(a)
        },
        onerror,
        onerror,
        !0
    )
}

function PhrasesController() {
    var e = this;

    e.phase1Begin = defer()
    e.phase1Loaded = defer()
    e.phase2Loaded = defer()
    e.phase3Loaded = defer()

    return e
}

function arrayBufferToBase64(bytes, width = 512, height = 512, quality = 0.7) {
    for (var d = 0; d < height; ++d) {
        for (var e = 0; e < width; ++e) {
            var f = 4 * (d * width + e);
            if (d < height / 2) {
                var g = 4 * ((height - d - 1) * width + e)
                for (var h = 0; 3 > h; ++h) {
                    var k = bytes[f + h];
                    bytes[f + h] = bytes[g + h];
                    bytes[g + h] = k
                }
            }
            bytes[f + 3] = 255
        }
    }
    var array = new Uint8ClampedArray(bytes);
    var imageData = new ImageData(array, width, height);
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    canvas.getContext("2d").putImageData(imageData, 0, 0);
    return d.toDataURL("image/jpeg", quality)
}


function bufferToBase64(buffer, width, height, quality = 0.7){

    for (var d = 0; d < height; ++d) {

        for (var e = 0; e < width; ++e) {

            var f = 4 * (d * width + e);

            if (d < height / 2) {

                var g = 4 * ((height - d - 1) * width + e)

                for (var h = 0; 3 > h; ++h) {

                    var k = buffer[f + h];

                    buffer[f + h] = buffer[g + h];

                    buffer[g + h] = k

                }

            }

            buffer[f + 3] = 255

        }

    }

    var array = new Uint8ClampedArray(buffer);

    var imageData = new ImageData(array, width, height);

    var canvas = document.createElement("canvas");

    canvas.width = width;

    canvas.height = height;

    canvas.getContext("2d").putImageData(imageData, 0, 0);

    return canvas.toDataURL("image/jpeg", quality)
}


function floorPowerOfTwo(value) {

    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));

}

function ceilPowerOfTwo(value) {

    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));

}

//找到离原始值最近的一个结果
function appropriatePowerOfTwo(value) {
    let vn = floorPowerOfTwo(value)
    let vf = ceilPowerOfTwo(value)
    return Math.abs(vn - value) < Math.abs(vf - value) ? vn : vf
}

function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {


    var scale = 1;

    // handle case if texture exceeds max size

    if (image.width > maxSize || image.height > maxSize) {

        scale = maxSize / Math.max(image.width, image.height);

    }

    // only perform resize if necessary

    if (scale < 1 || needsPowerOfTwo === true) {

        // only perform resize for certain image types

        if (( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
            ( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
            ( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap )) {

            var width = appropriatePowerOfTwo(scale * image.width);
            var height = appropriatePowerOfTwo(scale * image.height);

            var canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;

            var context = canvas.getContext('2d');
            context.drawImage(image, 0, 0, width, height);

            console.warn('THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').');


            return canvas;

        }

    }

    return image;

}

//是否需要规格化纹理
function textureNeedsPowerOfTwo( texture ) {

    //if ( capabilities.isWebGL2 ) return false;

    return ( texture.wrapS !== GLC.CLAMP_TO_EDGE || texture.wrapT !== GLC.CLAMP_TO_EDGE ) ||
        ( texture.minFilter !== GLC.NEAREST && texture.minFilter !==GLC.LINEAR );

}

function getSafeValue(a, b) {
    var c = a[b];

    if (c) {

        return c;

    }

    c = [];

    return a[b] = c
}

function defineProperty(n, propertyName){
    Object.defineProperty(n, propertyName, {
        get: ()=> {
            return n['_'+propertyName]
        },
        set: t=> {
            n['_'+propertyName] = t
            n._updated && n._updated(n, propertyName)
        }
    })
}

function resolveText(canvas, text, font, d) {
    var e = JMT.SPRITE_ANCHOR_FONT_SIZE

    var f = canvas.getContext("2d");

    f.font = "700 " + e + "px " + font;

    var g = text

    for (var k = text.length - 1, h; ;) {

        h = f.measureText(g).width;

        h += 2 * d;

        if (1024 >= h) {
            break;
        }

        g = text.substring(0, k) + "...";

        --k
    }

    canvas.width = h;

    canvas.height = 1.5 * e;

    f = canvas.getContext("2d");

    f.font = "700 " + e + "px " + font;

    return [f, g]
}


//function projectVector( vector, camera ) {
//
//    return new THREE.Vector3().copy(vector).applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
//
//};
//
//function unprojectVector( vector, camera ) {
//
//    return new THREE.Vector3().copy(vector).applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );
//
//};


function isVisible(object, camera){

    camera = camera || UjP.viewer.controls.camera()

    let  frustum = new JMT.Frustum, m = new THREE.Matrix4

    m.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);

    frustum.setFromMatrix(m);

     //return !0 === frustum.intersectsObject(object)
    return _intersectsObjectFrustom(object, frustum)
}

function _intersectsObjectFrustom(object, frustum) {

    if (object.geometry && frustum.intersectsObject(object))
        return !0

    for (let i=0; i<object.children.length; i++) {

        if (_intersectsObjectFrustom(object.children[i], frustum))
            return !0
    }

    return !1
}

let getViewerAssetUrl =  function() {

    var a = function () {

        //var a = document.getElementsByTagName("script")
        //
        //for (var b = 0; b < a.length; ++b) {
        //
        //    var c = a[b].src.match(/^(.*\/)walk(\.min)?\.js$/);
        //
        //    if (c){
        //
        //        return c[1]
        //
        //    }
        //
        //}
        //
        //console.error("Cannot determine webwalk URL.");

        if(JMT.DEBUG){
            return "webwalk/"
        }
        else {

            return getOriginFromUrl(window.location.href) + "/webwalk/"
        }

    }();

    return function (b) {

        return a + b

    }

}();

JMK.PhrasesController = PhrasesController




/***/ }),

/***/ "./vendor/fullscreen.js":
/*!******************************!*\
  !*** ./vendor/fullscreen.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, exports) {

/**
 * Created by Kai on 2021/1/5.
 */

(function (global, factory) {
     true ? factory(exports) :
        0;
}(this, function (e) {
    "use strict";
    var t = "undefined" != typeof window && "undefined" !== typeof window.document ? window.document : {},
        n = e && e.exports,
        i = "undefined" != typeof Element && "ALLOW_KEYBOARD_INPUT" in Element,
        r = function () {
            for (var e, n = [
                ["requestFullscreen", "exitFullscreen", "fullscreenElement", "fullscreenEnabled", "fullscreenchange", "fullscreenerror"],
                ["webkitRequestFullscreen", "webkitExitFullscreen", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["webkitRequestFullScreen", "webkitCancelFullScreen", "webkitCurrentFullScreenElement", "webkitCancelFullScreen", "webkitfullscreenchange", "webkitfullscreenerror"],
                ["mozRequestFullScreen", "mozCancelFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozfullscreenchange", "mozfullscreenerror"],
                ["msRequestFullscreen", "msExitFullscreen", "msFullscreenElement", "msFullscreenEnabled", "MSFullscreenChange", "MSFullscreenError"]
            ], i = 0, r = n.length, v = {}; i < r; i++) if ((e = n[i]) && e[1] in t) {
                for (i = 0; i < e.length; i++) v[n[0][i]] = e[i];
                return v
            }
            return !1
        }(),
        v = {
            change: r.fullscreenchange,
            error: r.fullscreenerror
        },
        a = {
            request: function (e) {
                return new Promise(function (n, v) {
                    var a, b = r.requestFullscreen,
                        o = function () {
                            this.off("change", o),
                                n()
                        }.bind(this);
                    this.on("change", o),
                        e = e || t.documentElement,
                        a = / Version\/5\.1(?:\.\d+)? Safari\// ["test"](navigator["userAgent"]) ? e[b]() : e[b](i ? Element["ALLOW_KEYBOARD_INPUT"] : {}),
                        Promise.resolve(a).
                            catch(v)
                }.bind(this))
            },
            exit: function () {
                return new Promise(function (e) {
                    if (this.isFullscreen) {
                        var n = function () {
                            this.off("change", n),
                                e()
                        }.bind(this);
                        t[r.exitFullscreen](),
                            this.on("change", n)
                    } else e()
                }.bind(this))
            },
            toggle: function (e) {
                return this.isFullscreen ? this.exit() : this.request(e)
            },
            onchange: function (e) {
                this.on("change", e)
            },
            onerror: function (e) {
                this.on("error", e)
            },
            on: function (e, n) {
                var i = v[e];
                i && t.addEventListener(i, n, !1)
            },
            off: function (e, n) {
                var i = v[e];
                i && t.removeEventListener(i, n, !1)
            },
            raw: r
        };

    if(r){
        Object.defineProperties(a, {
            isFullscreen: {
                get: function () {
                    return Boolean(t[r.fullscreenElement])
                }
            },
            element: {
                enumerable: !0,
                get: function () {
                    return t[r.fullscreenElement]
                }
            },
            enabled: {
                enumerable: !0,
                get: function () {
                    return Boolean(t[r.fullscreenEnabled])
                }
            }
        })

        if(n) {
            e.exports = a
            e.exports.default = a
        }
        else{
            window.screenfull = a
        }
    }
    else{
        if(n){
            e.exports = false
        }
        else{
            window.screenfull = false
        }
    }
}));

/***/ }),

/***/ "./vendor/gif.js":
/*!***********************!*\
  !*** ./vendor/gif.js ***!
  \***********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Stream": function() { return /* binding */ Stream; },
/* harmony export */   "parseGIF": function() { return /* binding */ parseGIF; }
/* harmony export */ });
/**
 * Created by Kai on 2020/9/16.
 */
// Generic functions
var bitsToNum = function(ba) {
    return ba.reduce(function(s, n) { return s * 2 + n; }, 0);
};

var byteToBitArr = function(bite) {
    var a = [];
    for (var i = 7; i >= 0; i--) {
        a.push(!!(bite & (1 << i)));
    }
    return a;
};

// Stream
/**
 * @constructor
 */ // Make compiler happy.
var Stream = function(data) {
    this.data = data;
    this.len = this.data.length;
    this.pos = 0;

    this.readByte = function() {
        if (this.pos >= this.data.length) {
            throw new Error('Attempted to read past end of stream.');
        }
        return data.charCodeAt(this.pos++) & 0xFF;
    };

    this.readBytes = function(n) {
        var bytes = [];
        for (var i = 0; i < n; i++) {
            bytes.push(this.readByte());
        }
        return bytes;
    };

    this.read = function(n) {
        var s = '';
        for (var i = 0; i < n; i++) {
            s += String.fromCharCode(this.readByte());
        }
        return s;
    };

    this.readUnsigned = function() { // Little-endian.
        var a = this.readBytes(2);
        return (a[1] << 8) + a[0];
    };
};

var lzwDecode = function(minCodeSize, data) {
    // TODO: Now that the GIF parser is a bit different, maybe this should get an array of bytes instead of a String?
    var pos = 0; // Maybe this streaming thing should be merged with the Stream?

    var readCode = function(size) {
        var code = 0;
        for (var i = 0; i < size; i++) {
            if (data.charCodeAt(pos >> 3) & (1 << (pos & 7))) {
                code |= 1 << i;
            }
            pos++;
        }
        return code;
    };

    var output = [];

    var clearCode = 1 << minCodeSize;
    var eoiCode = clearCode + 1;

    var codeSize = minCodeSize + 1;

    var dict = [];

    var clear = function() {
        dict = [];
        codeSize = minCodeSize + 1;
        for (var i = 0; i < clearCode; i++) {
            dict[i] = [i];
        }
        dict[clearCode] = [];
        dict[eoiCode] = null;

    };

    var code;
    var last;

    while (true) {
        last = code;
        code = readCode(codeSize);

        if (code === clearCode) {
            clear();
            continue;
        }
        if (code === eoiCode) break;

        if (code < dict.length) {
            if (last !== clearCode) {
                dict.push(dict[last].concat(dict[code][0]));
            }
        } else {
            if (code !== dict.length) throw new Error('Invalid LZW code.');
            dict.push(dict[last].concat(dict[last][0]));
        }
        output.push.apply(output, dict[code]);

        if (dict.length === (1 << codeSize) && codeSize < 12) {
            // If we're at the last code and codeSize is 12, the next code will be a clearCode, and it'll be 12 bits long.
            codeSize++;
        }
    }

    // I don't know if this is technically an error, but some GIFs do it.
    //if (Math.ceil(pos / 8) !== data.length) throw new Error('Extraneous LZW bytes.');
    return output;
};

// The actual parsing; returns an object with properties.
var parseGIF = function(st, handler) {
    handler || (handler = {});

    // LZW (GIF-specific)
    var parseCT = function(entries) { // Each entry is 3 bytes, for RGB.
        var ct = [];
        for (var i = 0; i < entries; i++) {
            ct.push(st.readBytes(3));
        }
        return ct;
    };

    var readSubBlocks = function() {
        var size, data;
        data = '';
        do {
            size = st.readByte();
            data += st.read(size);
        } while (size !== 0);
        return data;
    };

    var parseHeader = function() {
        var hdr = {};
        hdr.sig = st.read(3);
        hdr.ver = st.read(3);
        if (hdr.sig !== 'GIF') throw new Error('Not a GIF file.'); // XXX: This should probably be handled more nicely.

        hdr.width = st.readUnsigned();
        hdr.height = st.readUnsigned();

        var bits = byteToBitArr(st.readByte());
        hdr.gctFlag = bits.shift();
        hdr.colorRes = bitsToNum(bits.splice(0, 3));
        hdr.sorted = bits.shift();
        hdr.gctSize = bitsToNum(bits.splice(0, 3));

        hdr.bgColor = st.readByte();
        hdr.pixelAspectRatio = st.readByte(); // if not 0, aspectRatio = (pixelAspectRatio + 15) / 64

        if (hdr.gctFlag) {
            hdr.gct = parseCT(1 << (hdr.gctSize + 1));
        }
        handler.hdr && handler.hdr(hdr);
    };

    var parseExt = function(block) {
        var parseGCExt = function(block) {
            var blockSize = st.readByte(); // Always 4

            var bits = byteToBitArr(st.readByte());
            block.reserved = bits.splice(0, 3); // Reserved; should be 000.
            block.disposalMethod = bitsToNum(bits.splice(0, 3));
            block.userInput = bits.shift();
            block.transparencyGiven = bits.shift();

            block.delayTime = st.readUnsigned();

            block.transparencyIndex = st.readByte();

            block.terminator = st.readByte();

            handler.gce && handler.gce(block);
        };

        var parseComExt = function(block) {
            block.comment = readSubBlocks();
            handler.com && handler.com(block);
        };

        var parsePTExt = function(block) {
            // No one *ever* uses this. If you use it, deal with parsing it yourself.
            var blockSize = st.readByte(); // Always 12
            block.ptHeader = st.readBytes(12);
            block.ptData = readSubBlocks();
            handler.pte && handler.pte(block);
        };

        var parseAppExt = function(block) {
            var parseNetscapeExt = function(block) {
                var blockSize = st.readByte(); // Always 3
                block.unknown = st.readByte(); // ??? Always 1? What is this?
                block.iterations = st.readUnsigned();
                block.terminator = st.readByte();
                handler.app && handler.app.NETSCAPE && handler.app.NETSCAPE(block);
            };

            var parseUnknownAppExt = function(block) {
                block.appData = readSubBlocks();
                // FIXME: This won't work if a handler wants to match on any identifier.
                handler.app && handler.app[block.identifier] && handler.app[block.identifier](block);
            };

            var blockSize = st.readByte(); // Always 11
            block.identifier = st.read(8);
            block.authCode = st.read(3);
            switch (block.identifier) {
                case 'NETSCAPE':
                    parseNetscapeExt(block);
                    break;
                default:
                    parseUnknownAppExt(block);
                    break;
            }
        };

        var parseUnknownExt = function(block) {
            block.data = readSubBlocks();
            handler.unknown && handler.unknown(block);
        };

        block.label = st.readByte();
        switch (block.label) {
            case 0xF9:
                block.extType = 'gce';
                parseGCExt(block);
                break;
            case 0xFE:
                block.extType = 'com';
                parseComExt(block);
                break;
            case 0x01:
                block.extType = 'pte';
                parsePTExt(block);
                break;
            case 0xFF:
                block.extType = 'app';
                parseAppExt(block);
                break;
            default:
                block.extType = 'unknown';
                parseUnknownExt(block);
                break;
        }
    };

    var parseImg = function(img) {
        var deinterlace = function(pixels, width) {
            // Of course this defeats the purpose of interlacing. And it's *probably*
            // the least efficient way it's ever been implemented. But nevertheless...

            var newPixels = new Array(pixels.length);
            var rows = pixels.length / width;
            var cpRow = function(toRow, fromRow) {
                var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
                newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
            };

            // See appendix E.
            var offsets = [0,4,2,1];
            var steps   = [8,8,4,2];

            var fromRow = 0;
            for (var pass = 0; pass < 4; pass++) {
                for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
                    cpRow(toRow, fromRow)
                    fromRow++;
                }
            }

            return newPixels;
        };

        img.leftPos = st.readUnsigned();
        img.topPos = st.readUnsigned();
        img.width = st.readUnsigned();
        img.height = st.readUnsigned();

        var bits = byteToBitArr(st.readByte());
        img.lctFlag = bits.shift();
        img.interlaced = bits.shift();
        img.sorted = bits.shift();
        img.reserved = bits.splice(0, 2);
        img.lctSize = bitsToNum(bits.splice(0, 3));

        if (img.lctFlag) {
            img.lct = parseCT(1 << (img.lctSize + 1));
        }

        img.lzwMinCodeSize = st.readByte();

        var lzwData = readSubBlocks();

        img.pixels = lzwDecode(img.lzwMinCodeSize, lzwData);

        if (img.interlaced) { // Move
            img.pixels = deinterlace(img.pixels, img.width);
        }

        handler.img && handler.img(img);
    };

    var parseBlock = function() {
        var block = {};
        block.sentinel = st.readByte();

        switch (String.fromCharCode(block.sentinel)) { // For ease of matching
            case '!':
                block.type = 'ext';
                parseExt(block);
                break;
            case ',':
                block.type = 'img';
                parseImg(block);
                break;
            case ';':
                block.type = 'eof';
                handler.eof && handler.eof(block);
                break;
            default:
                throw new Error('Unknown block: 0x' + block.sentinel.toString(16)); // TODO: Pad this with a 0.
        }

        if (block.type !== 'eof') setTimeout(parseBlock, 0);
    };

    var parse = function() {
        parseHeader();
        setTimeout(parseBlock, 0);
    };

    parse();
};

// BEGIN_NON_BOOKMARKLET_CODE
if (typeof exports !== 'undefined') {
    exports.Stream = Stream;
    exports.parseGIF = parseGIF;
}


// END_NON_BOOKMARKLET_CODE

/***/ }),

/***/ "./vendor/jquery-3.4.1.js":
/*!********************************!*\
  !*** ./vendor/jquery-3.4.1.js ***!
  \********************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./webxr/VRHeightController.js":
/*!*************************************!*\
  !*** ./webxr/VRHeightController.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VRHeightController": function() { return /* binding */ VRHeightController; }
/* harmony export */ });
/**
 * Created by Kai on 2020/12/18.
 */
function VRHeightController(a, b) {
    var c = a.cameraWorldPosition(), d, e, g;
    this.onHmdPositionUpdate = function (f) {
        d && !g && 1 < f.z && (a.cameraHeight = f.z, b.adjustPointToMatchCameraHeight(c), a.cameraPositionUpdated(), e = c.z, g = !0)
    };
    this.onTeleportDone = function () {
        d && (e = c.z)
    };
    this.updateCameraHeight = function () {
        d && (a.cameraHeight += c.z - e, e = c.z)
    };
    this.enable = function () {
        d = !0;
        a.cameraHeight = b.cameraHeightFromPoint(c);
        null === a.cameraHeight && (a.cameraHeight = JMT.VR_FALLBACK_CAMERA_HEIGHT);
        e = c.z;
        g = !1
    };
    this.disable = function () {
        d = !1;
        a.cameraHeight = null
    }
}

/***/ }),

/***/ "./webxr/VRManager.js":
/*!****************************!*\
  !*** ./webxr/VRManager.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "VRManager": function() { return /* binding */ VRManager; }
/* harmony export */ });
/* harmony import */ var _nosleep_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./nosleep.js */ "./webxr/nosleep.js");
/**
 * Created by Kai on 2020/12/18.
 */


function VRManager(a, b, c, d, e, g, f) {

    function h() {
        if (JMT.DETECTOR.ios && void 0 !== DeviceMotionEvent &&
            "function" === typeof DeviceMotionEvent.requestPermission &&
            void 0 !== DeviceOrientationEvent &&
            "function" === typeof DeviceOrientationEvent.requestPermission) {

            return new Promise(function (a, b) {

                Promise.all([DeviceMotionEvent.requestPermission(), DeviceOrientationEvent.requestPermission()]).then(function (c) {

                    "granted" === c[0] && "granted" === c[1] ? a() : b()

                }, function () {

                    b()

                })
            })
        }
        else {
            return Promise.resolve()
        }
    }

    function k() {
        q =
            null;
        z.dispose();
        m = r = x = z = null;
        b.removeAllXrGamepads();
        f(!1);
        if (w) {
            var a = w;
            w = null;
            a()
        }
    }

    function n(a) {

        for (var c = $jscomp.makeIterator(a.removed), d = c.next(); !d.done; d = c.next()) {

            d = d.value

            d.gamepad && b.removeXrGamepad(d.gamepad);

        }

        a = $jscomp.makeIterator(a.added);

        for (d = a.next(); !d.done; d = a.next()) {

            c = d.value

            c.gamepad && b.addXrGamepad(c.gamepad, c.handedness)

        }
    }

    var p = navigator.xr
    var l = c ? !c.nativeWebXR : !1
    var q
    var r
    var m
    var u = !1
    var x
    var t
    var v
    var w = null
    var z
    var A = new THREE.Matrix4
    var y = JMT.CAMERA_MIN_FAR;

    this.setCameraFar = function (a) {

        y = a;

        if (q) {

            x.depthFar = y

            q.updateRenderState(x)

        }

    };

    this.render = function (b, c, d) {
        v.set(!1, !0, !1);
        t.matrixWorld = c;
        c = t.projectionMatrix;
        for (var e = m.views, f = 0; f < e.length; ++f) {
            var g = e[f];
            A.fromArray(g.transform.inverse.matrix);
            c.fromArray(m.transform.matrix);
            A.multiply(c);
            c.fromArray(g.projectionMatrix);
            c.multiply(A);
            d(t);
            a.enableScissorTest(!0);
            g = x.baseLayer.getViewport(g);
            a.setScissor(g.x, g.y, g.width, g.height);
            z.x = g.x;
            z.y = g.y;
            z.width = g.width;
            z.height = g.height;
            a.render(b, t, z);
            a.enableScissorTest(!1)
        }
        v.restore()
    };
    this.enableVr = function (b) {

        if(p){

            if(u){

                g(!0)

                h().then(function () {

                    return b.makeXRCompatible().then(function () {

                        return navigator.xr.requestSession("immersive-vr", {requiredFeatures: ["local-floor"]})

                    }).then(function (a) {

                        q = a;

                        return q.requestReferenceSpace("local-floor")

                    }).then(function (c) {

                        r = c;

                        c = new XRWebGLLayer(q, b);

                        z = a.createFrameBufferRenderTarget(c.framebuffer);

                        x = {baseLayer: c};

                        t || (t = new THREE.PerspectiveCamera, v = new JMT.AutoClearAlter(a));

                        x.depthNear = JMT.CAMERA_WALK_NEAR;

                        x.depthFar = y;

                        q.updateRenderState(x);

                        q.addEventListener("end", k);

                        l || q.addEventListener("inputsourceschange", n);

                        g(!1);

                        f(!0)

                    }).catch(function () {

                        g(!1);

                        JMT.USER_MSG.info("Failed to enable VR mode")

                    })

                }).catch(function () {

                    g(!1);

                    JMT.USER_MSG.info("Permissions necessary for VR mode not granted")

                })

            }
            else {

                JMT.USER_MSG.info("VR device not connected")

            }
        }
        else {

            JMT.USER_MSG.info('You need a <a href="https://mozvr.com/#start" target="_blank">VR ready browser</a>.')

        }
    };

    this.disableVr = function () {

        q.end().then(function () {

            JMT.USER_MSG.hideInfo()

        }, function () {

            JMT.USER_MSG.info("Failed to exit VR mode")

        })
    };

    this.vrEnabled = function () {

        return !!r

    };

    this.vrSupport = function() {
        return u
    }


    this.requestAnimationFrame = function () {

        function a(a, b) {

            m = b.getViewerPose(r);

            if(w){

                b = w

                w = null

                b(a)

            }

        }

        return function (b) {

            w = b;

            q.requestAnimationFrame(a)

        }

    }();

    this.update = function () {

        var a = new JMT.Euler
        var b = new THREE.Vector3;

        return function () {

            if (m) {

                var c = m.transform;

                if (null !== c.orientation) {

                    a.setFromQuaternion(c.orientation, "YXZ");

                    var d = a.y;

                    a.y = -a.z;

                    a.z = d;

                    c = c.position;

                    e(a, c && b.set(c.x, -c.z, c.y, c.w))

                }
            }
        }
    }();

    if((JMT.DETECTOR.https || JMT.DETECTOR.localhost) && p){

        let onDeviceChange = function () {

            navigator.xr.isSessionSupported("immersive-vr").then(function (a) {

                u = a;

                d(a)

            })

        }

        onDeviceChange()

        navigator.xr.addEventListener("devicechange", onDeviceChange, !1)

    }
    else {

        d(!1)

    }
}

//JMK.VRManager = VRManager

/***/ }),

/***/ "./webxr/nosleep.js":
/*!**************************!*\
  !*** ./webxr/nosleep.js ***!
  \**************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_lib_jscomp_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/lib/jscomp.js */ "./src/lib/jscomp.js");
/* module decorator */ module = __webpack_require__.hmd(module);
/*

 nosleep.js
 Copyright (c) 2017, Rich Tibbett

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

 webxr-polyfill
 Copyright (c) 2017 Google
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 cardboard-vr-display
 Copyright (c) 2015-2017 Google
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 webvr-polyfill-dpdb
 Copyright (c) 2017 Google
 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.

 wglu-preserve-state
 Copyright (c) 2016, Brandon Jones.

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 */


(function (a, b) {
    a = a || window
    "object" === typeof exports && "undefined" !== "object" ? module.exports = b() : "function" === typeof define && __webpack_require__.amdO ? define(b) : a.WebXRPolyfill = b()
})(undefined, function () {
    function a() {
        var a = new H(16);
        H != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[4] = 0, a[6] = 0, a[7] = 0, a[8] = 0, a[9] = 0, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0);
        a[0] = 1;
        a[5] = 1;
        a[10] = 1;
        a[15] = 1;
        return a
    }

    function b(a) {
        a[0] = 1;
        a[1] = 0;
        a[2] = 0;
        a[3] = 0;
        a[4] = 0;
        a[5] = 1;
        a[6] = 0;
        a[7] = 0;
        a[8] = 0;
        a[9] = 0;
        a[10] = 1;
        a[11] = 0;
        a[12] = 0;
        a[13] = 0;
        a[14] = 0;
        a[15] = 1;
        return a
    }

    function c(a,
               b) {
        var c = b[0], d = b[1], e = b[2], f = b[3], g = b[4], k = b[5], h = b[6], m = b[7], ma = b[8], l = b[9], n = b[10], q = b[11], r = b[12], p = b[13], u = b[14];
        b = b[15];
        var t = c * k - d * g, ja = c * h - e * g, x = c * m - f * g, w = d * h - e * k, v = d * m - f * k, A = e * m - f * h, y = ma * p - l * r, z = ma * u - n * r, B = ma * b - q * r, C = l * u - n * p, H = l * b - q * p, F = n * b - q * u, Z = t * F - ja * H + x * C + w * B - v * z + A * y;
        if (!Z)return null;
        Z = 1 / Z;
        a[0] = (k * F - h * H + m * C) * Z;
        a[1] = (e * H - d * F - f * C) * Z;
        a[2] = (p * A - u * v + b * w) * Z;
        a[3] = (n * v - l * A - q * w) * Z;
        a[4] = (h * B - g * F - m * z) * Z;
        a[5] = (c * F - e * B + f * z) * Z;
        a[6] = (u * x - r * A - b * ja) * Z;
        a[7] = (ma * A - n * x + q * ja) * Z;
        a[8] = (g * H - k * B + m * y) * Z;
        a[9] =
            (d * B - c * H - f * y) * Z;
        a[10] = (r * v - p * x + b * t) * Z;
        a[11] = (l * x - ma * v - q * t) * Z;
        a[12] = (k * z - g * C - h * y) * Z;
        a[13] = (c * C - d * z + e * y) * Z;
        a[14] = (p * ja - r * w - u * t) * Z;
        a[15] = (ma * w - l * ja + n * t) * Z;
        return a
    }

    function d(a, b, c) {
        var d = b[0], e = b[1], f = b[2], g = b[3], k = b[4], h = b[5], m = b[6], ma = b[7], l = b[8], n = b[9], q = b[10], r = b[11], p = b[12], u = b[13], t = b[14];
        b = b[15];
        var ja = c[0], x = c[1], w = c[2], v = c[3];
        a[0] = ja * d + x * k + w * l + v * p;
        a[1] = ja * e + x * h + w * n + v * u;
        a[2] = ja * f + x * m + w * q + v * t;
        a[3] = ja * g + x * ma + w * r + v * b;
        ja = c[4];
        x = c[5];
        w = c[6];
        v = c[7];
        a[4] = ja * d + x * k + w * l + v * p;
        a[5] = ja * e + x * h + w * n + v * u;
        a[6] =
            ja * f + x * m + w * q + v * t;
        a[7] = ja * g + x * ma + w * r + v * b;
        ja = c[8];
        x = c[9];
        w = c[10];
        v = c[11];
        a[8] = ja * d + x * k + w * l + v * p;
        a[9] = ja * e + x * h + w * n + v * u;
        a[10] = ja * f + x * m + w * q + v * t;
        a[11] = ja * g + x * ma + w * r + v * b;
        ja = c[12];
        x = c[13];
        w = c[14];
        v = c[15];
        a[12] = ja * d + x * k + w * l + v * p;
        a[13] = ja * e + x * h + w * n + v * u;
        a[14] = ja * f + x * m + w * q + v * t;
        a[15] = ja * g + x * ma + w * r + v * b;
        return a
    }

    function e(a, b, c) {
        var d = b[0], e = b[1], f = b[2], g = b[3], k = d + d, h = e + e, m = f + f;
        b = d * k;
        var l = d * h;
        d *= m;
        var ma = e * h;
        e *= m;
        f *= m;
        k *= g;
        h *= g;
        g *= m;
        a[0] = 1 - (ma + f);
        a[1] = l + g;
        a[2] = d - h;
        a[3] = 0;
        a[4] = l - g;
        a[5] = 1 - (b + f);
        a[6] = e + k;
        a[7] = 0;
        a[8] =
            d + h;
        a[9] = e - k;
        a[10] = 1 - (b + ma);
        a[11] = 0;
        a[12] = c[0];
        a[13] = c[1];
        a[14] = c[2];
        a[15] = 1;
        return a
    }

    function g(a, b) {
        a[0] = b[12];
        a[1] = b[13];
        a[2] = b[14];
        return a
    }

    function f(a, b) {
        var c = b[0] + b[5] + b[10];
        0 < c ? (c = 2 * Math.sqrt(c + 1), a[3] = .25 * c, a[0] = (b[6] - b[9]) / c, a[1] = (b[8] - b[2]) / c, a[2] = (b[1] - b[4]) / c) : b[0] > b[5] && b[0] > b[10] ? (c = 2 * Math.sqrt(1 + b[0] - b[5] - b[10]), a[3] = (b[6] - b[9]) / c, a[0] = .25 * c, a[1] = (b[1] + b[4]) / c, a[2] = (b[8] + b[2]) / c) : b[5] > b[10] ? (c = 2 * Math.sqrt(1 + b[5] - b[0] - b[10]), a[3] = (b[8] - b[2]) / c, a[0] = (b[1] + b[4]) / c, a[1] = .25 * c, a[2] = (b[6] +
            b[9]) / c) : (c = 2 * Math.sqrt(1 + b[10] - b[0] - b[5]), a[3] = (b[1] - b[4]) / c, a[0] = (b[8] + b[2]) / c, a[1] = (b[6] + b[9]) / c, a[2] = .25 * c);
        return a
    }

    function h(a, b, c, d, e) {
        b = 1 / Math.tan(b / 2);
        a[0] = b / c;
        a[1] = 0;
        a[2] = 0;
        a[3] = 0;
        a[4] = 0;
        a[5] = b;
        a[6] = 0;
        a[7] = 0;
        a[8] = 0;
        a[9] = 0;
        a[11] = -1;
        a[12] = 0;
        a[13] = 0;
        a[15] = 0;
        null != e && Infinity !== e ? (c = 1 / (d - e), a[10] = (e + d) * c, a[14] = 2 * e * d * c) : (a[10] = -1, a[14] = -2 * d);
        return a
    }

    function k() {
        var a = new H(3);
        H != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0);
        return a
    }

    function n(a) {
        var b = new H(3);
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        return b
    }

    function p(a, b, c) {
        var d = new H(3);
        d[0] = a;
        d[1] = b;
        d[2] = c;
        return d
    }

    function l(a, b) {
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        return a
    }

    function q(a, b, c) {
        a[0] = b[0] + c[0];
        a[1] = b[1] + c[1];
        a[2] = b[2] + c[2];
        return a
    }

    function r(a, b, c) {
        a[0] = b[0] * c;
        a[1] = b[1] * c;
        a[2] = b[2] * c;
        return a
    }

    function m(a, b) {
        var c = b[0], d = b[1], e = b[2];
        c = c * c + d * d + e * e;
        0 < c && (c = 1 / Math.sqrt(c), a[0] = b[0] * c, a[1] = b[1] * c, a[2] = b[2] * c);
        return a
    }

    function u(a, b) {
        return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
    }

    function x(a, b, c) {
        var d = b[0], e = b[1];
        b = b[2];
        var f = c[0], g = c[1];
        c = c[2];
        a[0] =
            e * c - b * g;
        a[1] = b * f - d * c;
        a[2] = d * g - e * f;
        return a
    }

    function t(a, b, c) {
        var d = c[0], e = c[1], f = c[2], g = b[0], k = b[1];
        b = b[2];
        var h = e * b - f * k, m = f * g - d * b, l = d * k - e * g;
        c = 2 * c[3];
        a[0] = g + h * c + 2 * (e * l - f * m);
        a[1] = k + m * c + 2 * (f * h - d * l);
        a[2] = b + l * c + 2 * (d * m - e * h);
        return a
    }

    function v() {
        var a = new H(9);
        H != Float32Array && (a[1] = 0, a[2] = 0, a[3] = 0, a[5] = 0, a[6] = 0, a[7] = 0);
        a[0] = 1;
        a[4] = 1;
        a[8] = 1;
        return a
    }

    function w() {
        var a = new H(4);
        H != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0, a[3] = 0);
        return a
    }

    function z() {
        var a = new H(4);
        H != Float32Array && (a[0] = 0, a[1] = 0, a[2] = 0);
        a[3] =
            1;
        return a
    }

    function A(a, b, c) {
        var d = b[0], e = b[1], f = b[2];
        b = b[3];
        var g = c[0], k = c[1], h = c[2];
        c = c[3];
        a[0] = d * c + b * g + e * h - f * k;
        a[1] = e * c + b * k + f * g - d * h;
        a[2] = f * c + b * h + d * k - e * g;
        a[3] = b * c - d * g - e * k - f * h;
        return a
    }

    function y(a, b, c, d) {
        var e = b[0], f = b[1], g = b[2];
        b = b[3];
        var k = c[0], h = c[1], m = c[2];
        c = c[3];
        var l = e * k + f * h + g * m + b * c;
        0 > l && (l = -l, k = -k, h = -h, m = -m, c = -c);
        if (1E-6 < 1 - l) {
            var n = Math.acos(l);
            var q = Math.sin(n);
            l = Math.sin((1 - d) * n) / q;
            d = Math.sin(d * n) / q
        } else l = 1 - d;
        a[0] = l * e + d * k;
        a[1] = l * f + d * h;
        a[2] = l * g + d * m;
        a[3] = l * b + d * c;
        return a
    }

    function E(a, b) {
        var c =
            b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c * c + d * d + e * e + b * b;
        f = f ? 1 / f : 0;
        a[0] = -c * f;
        a[1] = -d * f;
        a[2] = -e * f;
        a[3] = b * f;
        return a
    }

    function I(a, b) {
        a = new Event(a, b);
        a[Oa] = {frame: b.frame, inputSource: b.inputSource};
        Object.setPrototypeOf(a, I.prototype);
        Object.defineProperty(a, "frame", {
            get: function () {
                return this[Oa].frame
            }
        });
        Object.defineProperty(a, "inputSource", {
            get: function () {
                return this[Oa].inputSource
            }
        });
        return a
    }

    function O(a, b) {
        a = new Event(a, b);
        a[Ya] = {session: b.session};
        Object.setPrototypeOf(a, O.prototype);
        Object.defineProperty(a,
            "session", {
                get: function () {
                    return this[Ya].session
                }
            });
        return a
    }

    function K(a, b) {
        a = new Event(a, b);
        a[Pa] = {session: b.session, added: b.added, removed: b.removed};
        Object.setPrototypeOf(a, K.prototype);
        Object.defineProperty(a, "session", {
            get: function () {
                return this[Pa].session
            }
        });
        Object.defineProperty(a, "added", {
            get: function () {
                return this[Pa].added
            }
        });
        Object.defineProperty(a, "removed", {
            get: function () {
                return this[Pa].removed
            }
        });
        return a
    }

    function T(a, b) {
        a = new Event(a, b);
        a[Ta] = {
            referenceSpace: b.referenceSpace, transform: b.transform ||
            null
        };
        Object.setPrototypeOf(a, T.prototype);
        Object.defineProperty(a, "referenceSpace", {
            get: function () {
                return this[Ta].referenceSpace
            }
        });
        Object.defineProperty(a, "transform", {
            get: function () {
                return this[Ta].transform
            }
        });
        return a
    }

    function Y(a, b, c) {
        function d(a, b, c) {
            return a < b ? b : a > c ? c : a
        }

        var e = b[0] * b[0], f = b[1] * b[1], g = b[2] * b[2], k = b[3] * b[3];
        "XYZ" === c ? (a[0] = Math.atan2(2 * (b[0] * b[3] - b[1] * b[2]), k - e - f + g), a[1] = Math.asin(d(2 * (b[0] * b[2] + b[1] * b[3]), -1, 1)), a[2] = Math.atan2(2 * (b[2] * b[3] - b[0] * b[1]), k + e - f - g)) : "YXZ" === c ?
            (a[0] = Math.asin(d(2 * (b[0] * b[3] - b[1] * b[2]), -1, 1)), a[1] = Math.atan2(2 * (b[0] * b[2] + b[1] * b[3]), k - e - f + g), a[2] = Math.atan2(2 * (b[0] * b[1] + b[2] * b[3]), k - e + f - g)) : "ZXY" === c ? (a[0] = Math.asin(d(2 * (b[0] * b[3] + b[1] * b[2]), -1, 1)), a[1] = Math.atan2(2 * (b[1] * b[3] - b[2] * b[0]), k - e - f + g), a[2] = Math.atan2(2 * (b[2] * b[3] - b[0] * b[1]), k - e + f - g)) : "ZYX" === c ? (a[0] = Math.atan2(2 * (b[0] * b[3] + b[2] * b[1]), k - e - f + g), a[1] = Math.asin(d(2 * (b[1] * b[3] - b[0] * b[2]), -1, 1)), a[2] = Math.atan2(2 * (b[0] * b[1] + b[2] * b[3]), k + e - f - g)) : "YZX" === c ? (a[0] = Math.atan2(2 * (b[0] * b[3] -
            b[2] * b[1]), k - e + f - g), a[1] = Math.atan2(2 * (b[1] * b[3] - b[0] * b[2]), k + e - f - g), a[2] = Math.asin(d(2 * (b[0] * b[1] + b[2] * b[3]), -1, 1))) : "XZY" === c ? (a[0] = Math.atan2(2 * (b[0] * b[3] + b[1] * b[2]), k - e + f - g), a[1] = Math.atan2(2 * (b[0] * b[2] + b[1] * b[3]), k + e - f - g), a[2] = Math.asin(d(2 * (b[2] * b[3] - b[0] * b[1]), -1, 1))) : console.log("No order given for quaternion to euler conversion.")
    }

    var Q = "undefined" !== typeof __webpack_require__.g ? __webpack_require__.g : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {};
    $jscomp.initSymbol();
    var C = Symbol("@@webxr-polyfill/EventTarget"),
        B = function () {
            this[C] = {listeners: new Map}
        };
    B.prototype.addEventListener = function (a, b) {
        if ("string" !== typeof a)throw Error("`type` must be a string");
        if ("function" !== typeof b)throw Error("`listener` must be a function");
        var c = this[C].listeners.get(a) || [];
        c.push(b);
        this[C].listeners.set(a, c)
    };
    B.prototype.removeEventListener = function (a, b) {
        if ("string" !== typeof a)throw Error("`type` must be a string");
        if ("function" !== typeof b)throw Error("`listener` must be a function");
        a = this[C].listeners.get(a) || [];
        for (var c =
            a.length; 0 <= c; c--)a[c] === b && a.pop()
    };
    B.prototype.dispatchEvent = function (a, b) {
        for (var c = this[C].listeners.get(a) || [], d = [], e = 0; e < c.length; e++)d[e] = c[e];
        c = $jscomp.makeIterator(d);
        for (d = c.next(); !d.done; d = c.next())d = d.value, d(b);
        if ("function" === typeof this["on" + a])this["on" + a](b)
    };
    var H = "undefined" !== typeof Float32Array ? Float32Array : Array;
    (function () {
        var a = k();
        return function (b, c, d, e, f, g) {
            c || (c = 3);
            d || (d = 0);
            for (e = e ? Math.min(e * c + d, b.length) : b.length; d < e; d += c)a[0] = b[d], a[1] = b[d + 1], a[2] = b[d + 2], f(a, a, g), b[d] =
                a[0], b[d + 1] = a[1], b[d + 2] = a[2];
            return b
        }
    })();
    (function () {
        var a = w();
        return function (b, c, d, e, f, g) {
            c || (c = 4);
            d || (d = 0);
            for (e = e ? Math.min(e * c + d, b.length) : b.length; d < e; d += c)a[0] = b[d], a[1] = b[d + 1], a[2] = b[d + 2], a[3] = b[d + 3], f(a, a, g), b[d] = a[0], b[d + 1] = a[1], b[d + 2] = a[2], b[d + 3] = a[3];
            return b
        }
    })();
    var N = function (a) {
        var b = new H(4);
        b[0] = a[0];
        b[1] = a[1];
        b[2] = a[2];
        b[3] = a[3];
        return b
    }, D = function (a, b) {
        a[0] = b[0];
        a[1] = b[1];
        a[2] = b[2];
        a[3] = b[3];
        return a
    }, J = function (a, b) {
        var c = b[0], d = b[1], e = b[2];
        b = b[3];
        var f = c * c + d * d + e * e + b * b;
        0 < f &&
        (f = 1 / Math.sqrt(f), a[0] = c * f, a[1] = d * f, a[2] = e * f, a[3] = b * f);
        return a
    };
    (function () {
        var a = k(), b = p(1, 0, 0), c = p(0, 1, 0);
        return function (d, e, f) {
            var g = u(e, f);
            if (-.999999 > g) {
                x(a, b, e);
                f = a[0];
                g = a[1];
                var k = a[2];
                1E-6 > Math.sqrt(f * f + g * g + k * k) && x(a, c, e);
                m(a, a);
                e = Math.PI;
                e *= .5;
                f = Math.sin(e);
                d[0] = f * a[0];
                d[1] = f * a[1];
                d[2] = f * a[2];
                d[3] = Math.cos(e);
                return d
            }
            if (.999999 < g)return d[0] = 0, d[1] = 0, d[2] = 0, d[3] = 1, d;
            x(a, e, f);
            d[0] = a[0];
            d[1] = a[1];
            d[2] = a[2];
            d[3] = 1 + g;
            return J(d, d)
        }
    })();
    (function () {
        var a = z(), b = z();
        return function (c, d, e, f, g,
                         k) {
            y(a, d, g, k);
            y(b, e, f, k);
            y(c, a, b, 2 * k * (1 - k));
            return c
        }
    })();
    (function () {
        var a = v();
        return function (b, c, d, e) {
            a[0] = d[0];
            a[3] = d[1];
            a[6] = d[2];
            a[1] = e[0];
            a[4] = e[1];
            a[7] = e[2];
            a[2] = -c[0];
            a[5] = -c[1];
            a[8] = -c[2];
            c = a[0] + a[4] + a[8];
            if (0 < c)c = Math.sqrt(c + 1), b[3] = .5 * c, c = .5 / c, b[0] = (a[5] - a[7]) * c, b[1] = (a[6] - a[2]) * c, b[2] = (a[1] - a[3]) * c; else {
                d = 0;
                a[4] > a[0] && (d = 1);
                a[8] > a[3 * d + d] && (d = 2);
                e = (d + 1) % 3;
                var f = (d + 2) % 3;
                c = Math.sqrt(a[3 * d + d] - a[3 * e + e] - a[3 * f + f] + 1);
                b[d] = .5 * c;
                c = .5 / c;
                b[3] = (a[3 * e + f] - a[3 * f + e]) * c;
                b[e] = (a[3 * e + d] + a[3 * d + e]) * c;
                b[f] =
                    (a[3 * f + d] + a[3 * d + f]) * c
            }
            return J(b, b)
        }
    })();
    if (!("DOMPointReadOnly"in window)) {
        $jscomp.initSymbol();
        var L = Symbol("@@webxr-polyfill/DOMPointReadOnly"), W = function (a, b, c, d) {
            if (1 === arguments.length)this[L] = {
                x: a.x,
                y: a.y,
                z: a.z,
                w: a.w
            }; else if (4 === arguments.length)this[L] = {
                x: a,
                y: b,
                z: c,
                w: d
            }; else throw new TypeError("Must supply either 1 or 4 arguments");
        };
        W.fromPoint = function (a) {
            return new W(a.x, a.y, a.z, a.w)
        };
        $jscomp.global.Object.defineProperties(W.prototype, {
            x: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[L].x
                }
            },
            y: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[L].y
                }
            }, z: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[L].z
                }
            }, w: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[L].w
                }
            }
        });
        window.DOMPointReadOnly = W
    }
    $jscomp.initSymbol();
    var M = Symbol("@@webxr-polyfill/XRRigidTransform"), R = function () {
        this[M] = {matrix: null, position: null, orientation: null, inverse: null};
        if (0 === arguments.length)this[M].matrix = b(new Float32Array(16)); else if (1 === arguments.length)arguments[0]instanceof Float32Array ?
            this[M].matrix = arguments[0] : (this[M].position = this._getPoint(arguments[0]), this[M].orientation = DOMPointReadOnly.fromPoint({
            x: 0,
            y: 0,
            z: 0,
            w: 1
        })); else if (2 === arguments.length)this[M].position = this._getPoint(arguments[0]), this[M].orientation = this._getPoint(arguments[1]); else throw Error("Too many arguments!");
        if (this[M].matrix) {
            var a = k();
            g(a, this[M].matrix);
            this[M].position = DOMPointReadOnly.fromPoint({x: a[0], y: a[1], z: a[2]});
            a = z();
            f(a, this[M].matrix);
            this[M].orientation = DOMPointReadOnly.fromPoint({
                x: a[0],
                y: a[1], z: a[2], w: a[3]
            })
        } else {
            this[M].matrix = b(new Float32Array(16));
            a = this[M].matrix;
            var c = this[M].orientation.x, d = this[M].orientation.y, h = this[M].orientation.z, m = this[M].orientation.w, l = new H(4);
            l[0] = c;
            l[1] = d;
            l[2] = h;
            l[3] = m;
            e(a, l, p(this[M].position.x, this[M].position.y, this[M].position.z))
        }
    };
    R.prototype._getPoint = function (a) {
        return a instanceof DOMPointReadOnly ? a : DOMPointReadOnly.fromPoint(a)
    };
    $jscomp.global.Object.defineProperties(R.prototype, {
        matrix: {
            configurable: !0, enumerable: !0, get: function () {
                return this[M].matrix
            }
        },
        position: {
            configurable: !0, enumerable: !0, get: function () {
                return this[M].position
            }
        }, orientation: {
            configurable: !0, enumerable: !0, get: function () {
                return this[M].orientation
            }
        }, inverse: {
            configurable: !0, enumerable: !0, get: function () {
                if (null === this[M].inverse) {
                    var a = b(new Float32Array(16));
                    c(a, this[M].matrix);
                    this[M].inverse = new R(a);
                    this[M].inverse[M].inverse = this
                }
                return this[M].inverse
            }
        }
    });
    $jscomp.initSymbol();
    var F = Symbol("@@webxr-polyfill/XRSpace"), P = function (a, b) {
        this[F] = {
            specialType: void 0 === a ? null : a, inputSource: void 0 ===
            b ? null : b, baseMatrix: null, inverseBaseMatrix: null, lastFrameId: -1
        }
    };
    P.prototype._ensurePoseUpdated = function (a, b) {
        b != this[F].lastFrameId && (this[F].lastFrameId = b, this._onPoseUpdate(a))
    };
    P.prototype._onPoseUpdate = function (a) {
        "viewer" == this[F].specialType && (this._baseMatrix = a.getBasePoseMatrix())
    };
    P.prototype._getSpaceRelativeTransform = function (a) {
        if (!this._inverseBaseMatrix || !a._baseMatrix)return null;
        var b = new Float32Array(16);
        d(b, this._inverseBaseMatrix, a._baseMatrix);
        return new R(b)
    };
    $jscomp.global.Object.defineProperties(P.prototype,
        {
            _specialType: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[F].specialType
                }
            }, _inputSource: {
            configurable: !0, enumerable: !0, get: function () {
                return this[F].inputSource
            }
        }, _baseMatrix: {
            configurable: !0, enumerable: !0, set: function (a) {
                this[F].baseMatrix = a;
                this[F].inverseBaseMatrix = null
            }, get: function () {
                !this[F].baseMatrix && this[F].inverseBaseMatrix && (this[F].baseMatrix = new Float32Array(16), c(this[F].baseMatrix, this[F].inverseBaseMatrix));
                return this[F].baseMatrix
            }
        }, _inverseBaseMatrix: {
            configurable: !0,
            enumerable: !0, set: function (a) {
                this[F].inverseBaseMatrix = a;
                this[F].baseMatrix = null
            }, get: function () {
                !this[F].inverseBaseMatrix && this[F].baseMatrix && (this[F].inverseBaseMatrix = new Float32Array(16), c(this[F].inverseBaseMatrix, this[F].baseMatrix));
                return this[F].inverseBaseMatrix
            }
        }
        });
    $jscomp.initSymbol();
    var V = Symbol("@@webxr-polyfill/XRReferenceSpace"), aa = ["viewer", "local", "local-floor", "bounded-floor", "unbounded"], U = function (a, c) {
        c = void 0 === c ? null : c;
        if (!aa.includes(a))throw Error("XRReferenceSpaceType must be one of " +
            aa);
        var d = P.call(this, a) || this;
        if ("bounded-floor" === a && !c)throw Error("XRReferenceSpace cannot use 'bounded-floor' type if the platform does not provide the floor level");
        "bounded-floor" !== a && "local-floor" !== a || c || (c = b(new Float32Array(16)), c[13] = 1.6);
        d._inverseBaseMatrix = c || b(new Float32Array(16));
        d[V] = {type: a, transform: c, originOffset: b(new Float32Array(16))};
        return d
    };
    $jscomp.inherits(U, P);
    U.prototype._transformBasePoseMatrix = function (a, b) {
        d(a, this._inverseBaseMatrix, b)
    };
    U.prototype._originOffsetMatrix =
        function () {
            return this[V].originOffset
        };
    U.prototype._adjustForOriginOffset = function (a) {
        var b = new Float32Array(16);
        c(b, this[V].originOffset);
        d(a, b, a)
    };
    U.prototype._getSpaceRelativeTransform = function (a) {
        a = P.prototype._getSpaceRelativeTransform.call(this, a);
        this._adjustForOriginOffset(a.matrix);
        return new XRRigidTransform(a.matrix)
    };
    U.prototype.getOffsetReferenceSpace = function (a) {
        var b = new U(this[V].type, this[V].transform, this[V].bounds);
        d(b[V].originOffset, this[V].originOffset, a.matrix);
        return b
    };
    $jscomp.initSymbol();
    var X = Symbol("@@webxr-polyfill/XR"), S = ["inline", "immersive-vr", "immersive-ar"], da = {
        inline: {
            requiredFeatures: ["viewer"],
            optionalFeatures: []
        },
        "immersive-vr": {requiredFeatures: ["viewer", "local"], optionalFeatures: []},
        "immersive-ar": {requiredFeatures: ["viewer", "local"], optionalFeatures: []}
    }, ba = function (a) {
        var b = B.call(this) || this;
        b[X] = {device: null, devicePromise: a, immersiveSession: null, inlineSessions: new Set};
        a.then(function (a) {
            b[X].device = a
        });
        return b
    };
    $jscomp.inherits(ba, B);
    ba.prototype.isSessionSupported =
        function (a) {
            var b = this;
            return $jscomp.asyncExecutePromiseGeneratorProgram(function (c) {
                return 1 == c.nextAddress ? b[X].device ? c.jumpTo(2) : c.yield(b[X].devicePromise, 2) : "inline" != a ? c.return(Promise.resolve(b[X].device.isSessionSupported(a))) : c.return(Promise.resolve(!0))
            })
        };
    ba.prototype.requestSession = function (a, b) {
        var c = this, d, e, f, g, k, h, m, l, n, q, r, p, u;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (t) {
            if (1 == t.nextAddress) {
                if (c[X].device)return t.jumpTo(2);
                if ("inline" != a)throw Error("Polyfill Error: Must call navigator.xr.isSessionSupported() with any XRSessionMode\nor navigator.xr.requestSession('inline') prior to requesting an immersive\nsession. This is a limitation specific to the WebXR Polyfill and does not apply\nto native implementations of the API.");
                return t.yield(c[X].devicePromise, 2)
            }
            if (5 != t.nextAddress) {
                if (!S.includes(a))throw new TypeError("The provided value '" + a + "' is not a valid enum value of type XRSessionMode");
                d = da[a];
                e = d.requiredFeatures.concat(b && b.requiredFeatures ? b.requiredFeatures : []);
                f = d.optionalFeatures.concat(b && b.optionalFeatures ? b.optionalFeatures : []);
                g = new Set;
                k = !1;
                h = $jscomp.makeIterator(e);
                for (m = h.next(); !m.done; m = h.next())l = m.value, c[X].device.isFeatureSupported(l) ? g.add(l) : (console.error("The required feature '" + l + "' is not supported"),
                    k = !0);
                if (k)throw new DOMException("Session does not support some required features", "NotSupportedError");
                n = $jscomp.makeIterator(f);
                for (m = n.next(); !m.done; m = n.next())q = m.value, c[X].device.isFeatureSupported(q) ? g.add(q) : console.log("The optional feature '" + q + "' is not supported");
                return t.yield(c[X].device.requestSession(a, g), 5)
            }
            r = t.yieldResult;
            p = new XRSession(c[X].device, a, r);
            "inline" == a ? c[X].inlineSessions.add(p) : c[X].immersiveSession = p;
            u = function () {
                "inline" == a ? c[X].inlineSessions.delete(p) : c[X].immersiveSession =
                    null;
                p.removeEventListener("end", u)
            };
            p.addEventListener("end", u);
            return t.return(p)
        })
    };
    if (!1 === "performance"in Q) {
        var ea = Date.now();
        var ia = function () {
            return Date.now() - ea
        }
    } else ia = function () {
        return performance.now()
    };
    var la = ia;
    $jscomp.initSymbol();
    var fa = Symbol("@@webxr-polyfill/XRPose"), ha = function (a, b) {
        this[fa] = {transform: a, emulatedPosition: b}
    };
    $jscomp.global.Object.defineProperties(ha.prototype, {
        transform: {
            configurable: !0, enumerable: !0, get: function () {
                return this[fa].transform
            }
        }, emulatedPosition: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this[fa].emulatedPosition
            }
        }
    });
    $jscomp.initSymbol();
    var ya = Symbol("@@webxr-polyfill/XRViewerPose"), Z = function (a, b, c) {
        a = ha.call(this, a, void 0 === c ? !1 : c) || this;
        a[ya] = {views: b};
        return a
    };
    $jscomp.inherits(Z, ha);
    $jscomp.global.Object.defineProperties(Z.prototype, {
        views: {
            configurable: !0, enumerable: !0, get: function () {
                return this[ya].views
            }
        }
    });
    $jscomp.initSymbol();
    var ua = Symbol("@@webxr-polyfill/XRViewport"), qa = function (a) {
        this[ua] = {target: a}
    };
    $jscomp.global.Object.defineProperties(qa.prototype,
        {
            x: {
                configurable: !0, enumerable: !0, get: function () {
                    return this[ua].target.x
                }
            }, y: {
            configurable: !0, enumerable: !0, get: function () {
                return this[ua].target.y
            }
        }, width: {
            configurable: !0, enumerable: !0, get: function () {
                return this[ua].target.width
            }
        }, height: {
            configurable: !0, enumerable: !0, get: function () {
                return this[ua].target.height
            }
        }
        });
    var xa = ["left", "right", "none"];
    $jscomp.initSymbol();
    var pa = Symbol("@@webxr-polyfill/XRView"), wa = function (a, b, c, d) {
        if (!xa.includes(c))throw Error("XREye must be one of: " + xa);
        var e =
            Object.create(null), f = new qa(e);
        this[pa] = {device: a, eye: c, viewport: f, temp: e, sessionId: d, transform: b}
    };
    wa.prototype._getViewport = function (a) {
        if (this[pa].device.getViewport(this[pa].sessionId, this.eye, a, this[pa].temp))return this[pa].viewport
    };
    $jscomp.global.Object.defineProperties(wa.prototype, {
        eye: {
            configurable: !0, enumerable: !0, get: function () {
                return this[pa].eye
            }
        }, projectionMatrix: {
            configurable: !0, enumerable: !0, get: function () {
                return this[pa].device.getProjectionMatrix(this.eye)
            }
        }, transform: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this[pa].transform
            }
        }
    });
    $jscomp.initSymbol();
    var ka = Symbol("@@webxr-polyfill/XRFrame"), Ha = 0, Ba = function (a, b, c) {
        this[ka] = {id: ++Ha, active: !1, animationFrame: !1, device: a, session: b, sessionId: c}
    };
    Ba.prototype.getViewerPose = function (a) {
        if (!this[ka].animationFrame)throw new DOMException("getViewerPose can only be called on XRFrame objects passed to XRSession.requestAnimationFrame callbacks.", "InvalidStateError");
        if (!this[ka].active)throw new DOMException("XRFrame access outside the callback that produced it is invalid.",
            "InvalidStateError");
        var b = this[ka].device, c = this[ka].session;
        c[G].viewerSpace._ensurePoseUpdated(b, this[ka].id);
        a._ensurePoseUpdated(b, this[ka].id);
        var d = a._getSpaceRelativeTransform(c[G].viewerSpace), e = [];
        c = $jscomp.makeIterator(c[G].viewSpaces);
        for (var f = c.next(); !f.done; f = c.next()) {
            f = f.value;
            f._ensurePoseUpdated(b, this[ka].id);
            var g = a._getSpaceRelativeTransform(f);
            f = new wa(b, g, f.eye, this[ka].sessionId);
            e.push(f)
        }
        return new Z(d, e, !1)
    };
    Ba.prototype.getPose = function (a, b) {
        if (!this[ka].active)throw new DOMException("XRFrame access outside the callback that produced it is invalid.",
            "InvalidStateError");
        var c = this[ka].device;
        if ("target-ray" === a._specialType || "grip" === a._specialType)return c.getInputPose(a._inputSource, b, a._specialType);
        a._ensurePoseUpdated(c, this[ka].id);
        b._ensurePoseUpdated(c, this[ka].id);
        return (a = b._getSpaceRelativeTransform(a)) ? new XRPose(a, !1) : null
    };
    $jscomp.global.Object.defineProperties(Ba.prototype, {
        session: {
            configurable: !0, enumerable: !0, get: function () {
                return this[ka].session
            }
        }
    });
    $jscomp.initSymbol();
    var Aa = Symbol("@@webxr-polyfill/XRRenderState"), ta = Object.freeze({
        depthNear: .1,
        depthFar: 1E3, inlineVerticalFieldOfView: null, baseLayer: null
    }), za = function (a) {
        a = void 0 === a ? {} : a;
        a = Object.assign({}, ta, a);
        this[Aa] = {config: a}
    };
    $jscomp.global.Object.defineProperties(za.prototype, {
        depthNear: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Aa].config.depthNear
            }
        }, depthFar: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Aa].config.depthFar
            }
        }, inlineVerticalFieldOfView: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Aa].config.inlineVerticalFieldOfView
            }
        }, baseLayer: {
            configurable: !0,
            enumerable: !0, get: function () {
                return this[Aa].config.baseLayer
            }
        }
    });
    $jscomp.initSymbol();
    var ca = Symbol("@@webxr-polyfill/polyfilled-xr-compatible");
    $jscomp.initSymbol();
    var Ca = Symbol("@@webxr-polyfill/xr-compatible");
    $jscomp.initSymbol();
    var sa = Symbol("@@webxr-polyfill/XRWebGLLayer"), Ma = Object.freeze({
        antialias: !0,
        depth: !1,
        stencil: !1,
        alpha: !0,
        multiview: !1,
        ignoreDepthValues: !1,
        framebufferScaleFactor: 1
    }), Ka = function (a, b, c) {
        c = void 0 === c ? {} : c;
        c = Object.assign({}, Ma, c);
        if (!(a instanceof Ea))throw Error("session must be a XRSession");
        if (a.ended)throw Error("InvalidStateError");
        if (b[ca] && !0 !== b[Ca])throw Error("InvalidStateError");
        var d = b.getParameter(b.FRAMEBUFFER_BINDING);
        this[sa] = {context: b, config: c, framebuffer: d, session: a}
    };
    Ka.prototype.getViewport = function (a) {
        return a._getViewport(this)
    };
    Ka.getNativeFramebufferScaleFactor = function (a) {
        if (!a)throw new TypeError("getNativeFramebufferScaleFactor must be passed a session.");
        return a[G].ended ? 0 : 1
    };
    $jscomp.global.Object.defineProperties(Ka.prototype, {
        context: {
            configurable: !0, enumerable: !0,
            get: function () {
                return this[sa].context
            }
        }, antialias: {
            configurable: !0, enumerable: !0, get: function () {
                return this[sa].config.antialias
            }
        }, ignoreDepthValues: {
            configurable: !0, enumerable: !0, get: function () {
                return !0
            }
        }, framebuffer: {
            configurable: !0, enumerable: !0, get: function () {
                return this[sa].framebuffer
            }
        }, framebufferWidth: {
            configurable: !0, enumerable: !0, get: function () {
                return this[sa].context.drawingBufferWidth
            }
        }, framebufferHeight: {
            configurable: !0, enumerable: !0, get: function () {
                return this[sa].context.drawingBufferHeight
            }
        },
        _session: {
            configurable: !0, enumerable: !0, get: function () {
                return this[sa].session
            }
        }
    });
    $jscomp.initSymbol();
    var Oa = Symbol("@@webxr-polyfill/XRInputSourceEvent");
    $jscomp.initSymbol();
    var Ya = Symbol("@@webxr-polyfill/XRSessionEvent");
    $jscomp.initSymbol();
    var Pa = Symbol("@@webxr-polyfill/XRInputSourcesChangeEvent");
    $jscomp.initSymbol();
    var G = Symbol("@@webxr-polyfill/XRSession"), La = function (a) {
        return P.call(this, a) || this
    };
    $jscomp.inherits(La, P);
    La.prototype._onPoseUpdate = function (a) {
        this._inverseBaseMatrix =
            a.getBaseViewMatrix(this._specialType)
    };
    $jscomp.global.Object.defineProperties(La.prototype, {
        eye: {
            configurable: !0, enumerable: !0, get: function () {
                return this._specialType
            }
        }
    });
    var Ea = function (a, b, c) {
        var d = B.call(this) || this;
        var e = "inline" != b, f = new za({inlineVerticalFieldOfView: e ? null : .5 * Math.PI});
        d[G] = {
            device: a,
            mode: b,
            immersive: e,
            ended: !1,
            suspended: !1,
            frameCallbacks: [],
            currentFrameCallbacks: null,
            frameHandle: 0,
            deviceFrameHandle: null,
            id: c,
            activeRenderState: f,
            pendingRenderState: null,
            viewerSpace: new U("viewer"),
            viewSpaces: [],
            currentInputSources: []
        };
        e ? d[G].viewSpaces.push(new La("left"), new La("right")) : d[G].viewSpaces.push(new La("none"));
        d[G].onDeviceFrame = function () {
            if (!d[G].ended && !d[G].suspended) {
                d[G].deviceFrameHandle = null;
                d[G].startDeviceFrameLoop();
                if (null !== d[G].pendingRenderState && (d[G].activeRenderState = new za(d[G].pendingRenderState), d[G].pendingRenderState = null, d[G].activeRenderState.baseLayer))d[G].device.onBaseLayerSet(d[G].id, d[G].activeRenderState.baseLayer);
                if (null !== d[G].activeRenderState.baseLayer) {
                    var b =
                        new Ba(a, d, d[G].id), c = d[G].currentFrameCallbacks = d[G].frameCallbacks;
                    d[G].frameCallbacks = [];
                    b[ka].active = !0;
                    b[ka].animationFrame = !0;
                    d[G].device.onFrameStart(d[G].id, d[G].activeRenderState);
                    d._checkInputSourcesChange();
                    for (var e = la(), f = 0; f < c.length; f++)try {
                        c[f].cancelled || "function" !== typeof c[f].callback || c[f].callback(e, b)
                    } catch (ib) {
                        console.error(ib)
                    }
                    d[G].currentFrameCallbacks = null;
                    b[ka].active = !1;
                    d[G].device.onFrameEnd(d[G].id)
                }
            }
        };
        d[G].startDeviceFrameLoop = function () {
            null === d[G].deviceFrameHandle &&
            (d[G].deviceFrameHandle = d[G].device.requestAnimationFrame(d[G].onDeviceFrame))
        };
        d[G].stopDeviceFrameLoop = function () {
            var a = d[G].deviceFrameHandle;
            null !== a && (d[G].device.cancelAnimationFrame(a), d[G].deviceFrameHandle = null)
        };
        d[G].onPresentationEnd = function (b) {
            b !== d[G].id ? (d[G].suspended = !1, d[G].startDeviceFrameLoop(), d.dispatchEvent("focus", {session: d})) : (d[G].ended = !0, d[G].stopDeviceFrameLoop(), a.removeEventListener("@@webxr-polyfill/vr-present-end", d[G].onPresentationEnd), a.removeEventListener("@@webxr-polyfill/vr-present-start",
                d[G].onPresentationStart), a.removeEventListener("@@webxr-polyfill/input-select-start", d[G].onSelectStart), a.removeEventListener("@@webxr-polyfill/input-select-end", d[G].onSelectEnd), d.dispatchEvent("end", O("end", {session: d})))
        };
        a.addEventListener("@@webxr-polyfill/vr-present-end", d[G].onPresentationEnd);
        d[G].onPresentationStart = function (a) {
            a !== d[G].id && (d[G].suspended = !0, d[G].stopDeviceFrameLoop(), d.dispatchEvent("blur", {session: d}))
        };
        a.addEventListener("@@webxr-polyfill/vr-present-start", d[G].onPresentationStart);
        d[G].onSelectStart = function (a) {
            a.sessionId === d[G].id && d[G].dispatchInputSourceEvent("selectstart", a.inputSource)
        };
        a.addEventListener("@@webxr-polyfill/input-select-start", d[G].onSelectStart);
        d[G].onSelectEnd = function (a) {
            a.sessionId === d[G].id && (d[G].dispatchInputSourceEvent("selectend", a.inputSource), d[G].dispatchInputSourceEvent("select", a.inputSource))
        };
        a.addEventListener("@@webxr-polyfill/input-select-end", d[G].onSelectEnd);
        d[G].onSqueezeStart = function (a) {
            a.sessionId === d[G].id && d[G].dispatchInputSourceEvent("squeezestart",
                a.inputSource)
        };
        a.addEventListener("@@webxr-polyfill/input-squeeze-start", d[G].onSqueezeStart);
        d[G].onSqueezeEnd = function (a) {
            a.sessionId === d[G].id && (d[G].dispatchInputSourceEvent("squeezeend", a.inputSource), d[G].dispatchInputSourceEvent("squeeze", a.inputSource))
        };
        a.addEventListener("@@webxr-polyfill/input-squeeze-end", d[G].onSqueezeEnd);
        d[G].dispatchInputSourceEvent = function (b, c) {
            var e = new Ba(a, d, d[G].id);
            c = I(b, {frame: e, inputSource: c});
            e[ka].active = !0;
            d.dispatchEvent(b, c);
            e[ka].active = !1
        };
        d[G].startDeviceFrameLoop();
        d.onblur = void 0;
        d.onfocus = void 0;
        d.onresetpose = void 0;
        d.onend = void 0;
        d.onselect = void 0;
        d.onselectstart = void 0;
        d.onselectend = void 0;
        return d
    };
    $jscomp.inherits(Ea, B);
    Ea.prototype.requestReferenceSpace = function (a) {
        var b = this, c, d;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (e) {
            if (1 == e.nextAddress) {
                if (b[G].ended)return e.return();
                if (!aa.includes(a))throw new TypeError("XRReferenceSpaceType must be one of " + aa);
                if (!b[G].device.doesSessionSupportReferenceSpace(b[G].id, a))throw new DOMException("The " +
                    a + " reference space is not supported by this session.", "NotSupportedError");
                return "viewer" === a ? e.return(b[G].viewerSpace) : e.yield(b[G].device.requestFrameOfReferenceTransform(a), 2)
            }
            c = e.yieldResult;
            if ("bounded-floor" === a) {
                if (!c)throw new DOMException(a + " XRReferenceSpace not supported by this device.", "NotSupportedError");
                d = b[G].device.requestStageBounds();
                if (!d)throw new DOMException(a + " XRReferenceSpace not supported by this device.", "NotSupportedError");
                throw new DOMException("The WebXR polyfill does not support the " +
                    a + " reference space yet.", "NotSupportedError");
            }
            return e.return(new U(a, c))
        })
    };
    Ea.prototype.requestAnimationFrame = function (a) {
        if (!this[G].ended) {
            var b = ++this[G].frameHandle;
            this[G].frameCallbacks.push({handle: b, callback: a, cancelled: !1});
            return b
        }
    };
    Ea.prototype.cancelAnimationFrame = function (a) {
        var b = this[G].frameCallbacks, c = b.findIndex(function (b) {
            return b && b.handle === a
        });
        -1 < c && (b[c].cancelled = !0, b.splice(c, 1));
        if (b = this[G].currentFrameCallbacks)c = b.findIndex(function (b) {
            return b && b.handle === a
        }), -1 <
        c && (b[c].cancelled = !0)
    };
    Ea.prototype.end = function () {
        var a = this;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (b) {
            if (a[G].ended)return b.return();
            a[G].immersive && (a[G].ended = !0, a[G].device.removeEventListener("@@webxr-polyfill/vr-present-start", a[G].onPresentationStart), a[G].device.removeEventListener("@@webxr-polyfill/vr-present-end", a[G].onPresentationEnd), a[G].device.removeEventListener("@@webxr-polyfill/input-select-start", a[G].onSelectStart), a[G].device.removeEventListener("@@webxr-polyfill/input-select-end",
                a[G].onSelectEnd), a.dispatchEvent("end", O("end", {session: a})));
            a[G].stopDeviceFrameLoop();
            return b.return(a[G].device.endSession(a[G].id))
        })
    };
    Ea.prototype.updateRenderState = function (a) {
        if (this[G].ended)throw Error("Can't call updateRenderState on an XRSession that has already ended.");
        if (a.baseLayer && a.baseLayer._session !== this)throw Error("Called updateRenderState with a base layer that was created by a different session.");
        if (null !== a.inlineVerticalFieldOfView && void 0 !== a.inlineVerticalFieldOfView) {
            if (this[G].immersive)throw Error("inlineVerticalFieldOfView must not be set for an XRRenderState passed to updateRenderState for an immersive session.");
            a.inlineVerticalFieldOfView = Math.min(3.13, Math.max(.01, a.inlineVerticalFieldOfView))
        }
        if (null === this[G].pendingRenderState) {
            var b = this[G].activeRenderState;
            this[G].pendingRenderState = {
                depthNear: b.depthNear,
                depthFar: b.depthFar,
                inlineVerticalFieldOfView: b.inlineVerticalFieldOfView,
                baseLayer: b.baseLayer
            }
        }
        Object.assign(this[G].pendingRenderState, a)
    };
    Ea.prototype._checkInputSourcesChange = function () {
        for (var a = [], b = [], c = this.inputSources, d = this[G].currentInputSources, e = $jscomp.makeIterator(c), f = e.next(); !f.done; f =
            e.next())f = f.value, d.includes(f) || a.push(f);
        d = $jscomp.makeIterator(d);
        for (e = d.next(); !e.done; e = d.next())e = e.value, c.includes(e) || b.push(e);
        (0 < a.length || 0 < b.length) && this.dispatchEvent("inputsourceschange", K("inputsourceschange", {
            session: this,
            added: a,
            removed: b
        }));
        this[G].currentInputSources.length = 0;
        a = $jscomp.makeIterator(c);
        for (f = a.next(); !f.done; f = a.next())this[G].currentInputSources.push(f.value)
    };
    $jscomp.global.Object.defineProperties(Ea.prototype, {
        renderState: {
            configurable: !0, enumerable: !0, get: function () {
                return this[G].activeRenderState
            }
        },
        environmentBlendMode: {
            configurable: !0, enumerable: !0, get: function () {
                return this[G].device.environmentBlendMode || "opaque"
            }
        }, inputSources: {
            configurable: !0, enumerable: !0, get: function () {
                return this[G].device.getInputSources()
            }
        }
    });
    $jscomp.initSymbol();
    var Ga = Symbol("@@webxr-polyfill/XRInputSource"), Sa = function (a) {
        this[Ga] = {impl: a, gripSpace: new P("grip", this), targetRaySpace: new P("target-ray", this)}
    };
    $jscomp.global.Object.defineProperties(Sa.prototype, {
        handedness: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Ga].impl.handedness
            }
        },
        targetRayMode: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Ga].impl.targetRayMode
            }
        }, gripSpace: {
            configurable: !0, enumerable: !0, get: function () {
                var a = this[Ga].impl.targetRayMode;
                return "gaze" === a || "screen" === a ? null : this[Ga].gripSpace
            }
        }, targetRaySpace: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Ga].targetRaySpace
            }
        }, profiles: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Ga].impl.profiles
            }
        }, gamepad: {
            configurable: !0, enumerable: !0, get: function () {
                return this[Ga].impl.gamepad
            }
        }
    });
    $jscomp.initSymbol();
    var Ta = Symbol("@@webxr-polyfill/XRReferenceSpaceEvent"), Ua = {
        XRSystem: ba,
        XRSession: Ea,
        XRSessionEvent: O,
        XRFrame: Ba,
        XRView: wa,
        XRViewport: qa,
        XRViewerPose: Z,
        XRWebGLLayer: Ka,
        XRSpace: P,
        XRReferenceSpace: U,
        XRReferenceSpaceEvent: T,
        XRInputSource: Sa,
        XRInputSourceEvent: I,
        XRInputSourcesChangeEvent: K,
        XRRenderState: za,
        XRRigidTransform: R,
        XRPose: ha
    }, Za = function (a) {
        if ("function" === typeof a.prototype.makeXRCompatible)return !1;
        a.prototype.makeXRCompatible = function () {
            this[Ca] = !0;
            return Promise.resolve()
        };
        return !0
    }, $a = function (a) {
        var b = a.prototype.getContext;
        a.prototype.getContext = function (a, c) {
            if (a = b.call(this, a, c))a[ca] = !0, c && "xrCompatible"in c && (a[Ca] = c.xrCompatible);
            return a
        }
    }, jb = function (a) {
        var b = !1;
        a = a.navigator.userAgent || a.navigator.vendor || a.opera;
        if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||
            /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,
                4)))b = !0;
        return b
    }, Va = "undefined" !== typeof window ? window : "undefined" !== typeof __webpack_require__.g ? __webpack_require__.g : "undefined" !== typeof self ? self : {}, lb = function (a) {
        return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a["default"] : a
    }(function (a, b) {
        return b = {exports: {}}, a(b, b.exports), b.exports
    }(function (a, b) {
        (function (b, c) {
            a.exports = c()
        })(Va, function () {
            function a(a, b, c, d) {
                this.gl = a;
                this.cardboardUI = b;
                this.bufferScale = c;
                this.dirtySubmitFrameBindings = d;
                this.ctxAttribs = a.getContextAttributes();
                this.instanceExt =
                    a.getExtension("ANGLE_instanced_arrays");
                this.meshHeight = this.meshWidth = 20;
                this.bufferWidth = a.drawingBufferWidth;
                this.bufferHeight = a.drawingBufferHeight;
                this.realBindFramebuffer = a.bindFramebuffer;
                this.realEnable = a.enable;
                this.realDisable = a.disable;
                this.realColorMask = a.colorMask;
                this.realClearColor = a.clearColor;
                this.realViewport = a.viewport;
                v() || (this.realCanvasWidth = Object.getOwnPropertyDescriptor(a.canvas.__proto__, "width"), this.realCanvasHeight = Object.getOwnPropertyDescriptor(a.canvas.__proto__,
                    "height"));
                this.isPatched = !1;
                this.lastBoundFramebuffer = null;
                this.stencilTest = this.scissorTest = this.blend = this.depthTest = this.cullFace = !1;
                this.viewport = [0, 0, 0, 0];
                this.colorMask = [!0, !0, !0, !0];
                this.clearColor = [0, 0, 0, 0];
                this.attribs = {position: 0, texCoord: 1};
                this.program = W(a, "attribute vec2 position;\nattribute vec3 texCoord;\nvarying vec2 vTexCoord;\nuniform vec4 viewportOffsetScale[2];\nvoid main() {\n  vec4 viewport = viewportOffsetScale[int(texCoord.z)];\n  vTexCoord = (texCoord.xy * viewport.zw) + viewport.xy;\n  gl_Position = vec4( position, 1.0, 1.0 );\n}",
                    "precision mediump float;\nuniform sampler2D diffuse;\nvarying vec2 vTexCoord;\nvoid main() {\n  gl_FragColor = texture2D(diffuse, vTexCoord);\n}", this.attribs);
                this.uniforms = aa(a, this.program);
                this.viewportOffsetScale = new Float32Array(8);
                this.setTextureBounds();
                this.vertexBuffer = a.createBuffer();
                this.indexBuffer = a.createBuffer();
                this.indexCount = 0;
                this.renderTarget = a.createTexture();
                this.framebuffer = a.createFramebuffer();
                this.stencilBuffer = this.depthBuffer = this.depthStencilBuffer = null;
                this.ctxAttribs.depth &&
                this.ctxAttribs.stencil ? this.depthStencilBuffer = a.createRenderbuffer() : this.ctxAttribs.depth ? this.depthBuffer = a.createRenderbuffer() : this.ctxAttribs.stencil && (this.stencilBuffer = a.createRenderbuffer());
                this.patch();
                this.onResize()
            }

            function b(a) {
                this.gl = a;
                this.attribs = {position: 0};
                this.program = W(a, "attribute vec2 position;\nuniform mat4 projectionMat;\nvoid main() {\n  gl_Position = projectionMat * vec4( position, -1.0, 1.0 );\n}", "precision mediump float;\nuniform vec4 color;\nvoid main() {\n  gl_FragColor = color;\n}",
                    this.attribs);
                this.uniforms = aa(a, this.program);
                this.vertexBuffer = a.createBuffer();
                this.arrowVertexCount = this.arrowOffset = this.gearVertexCount = this.gearOffset = 0;
                this.projMat = new Float32Array(16);
                this.listener = null;
                this.onResize()
            }

            function c(a) {
                this.coefficients = a
            }

            function d(a) {
                this.width = a.width || ma();
                this.height = a.height || E();
                this.widthMeters = a.widthMeters;
                this.heightMeters = a.heightMeters;
                this.bevelMeters = a.bevelMeters
            }

            function e(a, b) {
                this.viewer = T.CardboardV2;
                this.updateDeviceParams(a);
                this.distortion =
                    new c(this.viewer.distortionCoefficients);
                for (a = 0; a < b.length; a++) {
                    var d = b[a];
                    T[d.id] = new f(d)
                }
            }

            function f(a) {
                this.id = a.id;
                this.label = a.label;
                this.fov = a.fov;
                this.interLensDistance = a.interLensDistance;
                this.baselineLensDistance = a.baselineLensDistance;
                this.screenLensDistance = a.screenLensDistance;
                this.distortionCoefficients = a.distortionCoefficients;
                this.inverseCoefficients = a.inverseCoefficients
            }

            function g(a, b) {
                this.dpdb = Q;
                this.recalculateDeviceParams_();
                if (a) {
                    this.onDeviceParamsUpdated = b;
                    var c = new XMLHttpRequest,
                        d = this;
                    c.open("GET", a, !0);
                    c.addEventListener("load", function () {
                        d.loading = !1;
                        200 <= c.status && 299 >= c.status ? (d.dpdb = JSON.parse(c.response), d.recalculateDeviceParams_()) : console.error("Error loading online DPDB!")
                    });
                    c.send()
                }
            }

            function k(a) {
                this.xdpi = a.xdpi;
                this.ydpi = a.ydpi;
                this.bevelMm = a.bevelMm
            }

            function h(a, b) {
                this.set(a, b)
            }

            function m(a, b) {
                this.kFilter = a;
                this.isDebug = b;
                this.currentAccelMeasurement = new h;
                this.currentGyroMeasurement = new h;
                this.previousGyroMeasurement = new h;
                v() ? this.filterQ = new J(-1, 0,
                    0, 1) : this.filterQ = new J(1, 0, 0, 1);
                this.previousFilterQ = new J;
                this.previousFilterQ.copy(this.filterQ);
                this.accelQ = new J;
                this.isOrientationInitialized = !1;
                this.estimatedGravity = new U;
                this.measuredGravity = new U;
                this.gyroIntegralQ = new J
            }

            function l(a, b) {
                this.predictionTimeS = a;
                this.isDebug = b;
                this.previousQ = new J;
                this.previousTimestampS = null;
                this.deltaQ = new J;
                this.outQ = new J
            }

            function n(a, b, c, d) {
                this.yawOnly = c;
                this.accelerometer = new U;
                this.gyroscope = new U;
                this.filter = new m(a, d);
                this.posePredictor = new l(b, d);
                this.isFirefoxAndroid = z();
                this.isIOS = v();
                a = B();
                this.isDeviceMotionInRadians = !this.isIOS && a && 66 > a;
                this.isWithoutDeviceMotion = H() || C();
                this.filterToWorldQ = new J;
                v() ? this.filterToWorldQ.setFromAxisAngle(new U(1, 0, 0), Math.PI / 2) : this.filterToWorldQ.setFromAxisAngle(new U(1, 0, 0), -Math.PI / 2);
                this.inverseWorldToScreenQ = new J;
                this.worldToScreenQ = new J;
                this.originalPoseAdjustQ = new J;
                this.originalPoseAdjustQ.setFromAxisAngle(new U(0, 0, 1), -window.orientation * Math.PI / 180);
                this.setScreenTransform_();
                F() && this.filterToWorldQ.multiply(this.inverseWorldToScreenQ);
                this.resetQ = new J;
                this.orientationOut_ = new Float32Array(4);
                this.start()
            }

            function q() {
                this.loadIcon_();
                var a = document.createElement("div"), b = a.style;
                b.position = "fixed";
                b.top = 0;
                b.right = 0;
                b.bottom = 0;
                b.left = 0;
                b.backgroundColor = "gray";
                b.fontFamily = "sans-serif";
                b.zIndex = 1E6;
                var c = document.createElement("img");
                c.src = this.icon;
                b = c.style;
                b.marginLeft = "25%";
                b.marginTop = "25%";
                b.width = "50%";
                a.appendChild(c);
                c = document.createElement("div");
                b = c.style;
                b.textAlign = "center";
                b.fontSize = "16px";
                b.lineHeight = "24px";
                b.margin =
                    "24px 25%";
                b.width = "50%";
                c.innerHTML = "Place your phone into your Cardboard viewer.";
                a.appendChild(c);
                var d = document.createElement("div");
                b = d.style;
                b.backgroundColor = "#CFD8DC";
                b.position = "fixed";
                b.bottom = 0;
                b.width = "100%";
                b.height = "48px";
                b.padding = "14px 24px";
                b.boxSizing = "border-box";
                b.color = "#656A6B";
                a.appendChild(d);
                var e = document.createElement("div");
                e.style.float = "left";
                e.innerHTML = "No Cardboard viewer?";
                var f = document.createElement("a");
                f.href = "https://www.google.com/get/cardboard/get-cardboard/";
                f.innerHTML = "get one";
                f.target = "_blank";
                b = f.style;
                b.float = "right";
                b.fontWeight = 600;
                b.textTransform = "uppercase";
                b.borderLeft = "1px solid gray";
                b.paddingLeft = "24px";
                b.textDecoration = "none";
                b.color = "#656A6B";
                d.appendChild(e);
                d.appendChild(f);
                this.overlay = a;
                this.text = c;
                this.hide()
            }

            function r(a) {
                try {
                    this.selectedKey = localStorage.getItem("WEBVR_CARDBOARD_VIEWER")
                } catch (Ia) {
                    console.error("Failed to load viewer profile: %s", Ia)
                }
                this.selectedKey || (this.selectedKey = a || "CardboardV1");
                this.dialog = this.createDialog_(e.Viewers);
                this.root = null;
                this.onChangeCallbacks_ = []
            }

            function p(a) {
                Object.defineProperties(this, {
                    hasPosition: {writable: !1, enumerable: !0, value: a.hasPosition},
                    hasExternalDisplay: {writable: !1, enumerable: !0, value: a.hasExternalDisplay},
                    canPresent: {writable: !1, enumerable: !0, value: a.canPresent},
                    maxLayers: {writable: !1, enumerable: !0, value: a.maxLayers},
                    hasOrientation: {
                        enumerable: !0, get: function () {
                            ea("VRDisplayCapabilities.prototype.hasOrientation", "VRDisplay.prototype.getFrameData");
                            return a.hasOrientation
                        }
                    }
                })
            }

            function u(a) {
                a =
                    a || {};
                a = "wakelock"in a ? a.wakelock : !0;
                this.isPolyfilled = !0;
                this.displayId = da++;
                this.displayName = "";
                this.depthNear = .01;
                this.depthFar = 1E4;
                this.isPresenting = !1;
                Object.defineProperty(this, "isConnected", {
                    get: function () {
                        ea("VRDisplay.prototype.isConnected", "VRDisplayCapabilities.prototype.hasExternalDisplay");
                        return !1
                    }
                });
                this.capabilities = new p({
                    hasPosition: !1,
                    hasOrientation: !1,
                    hasExternalDisplay: !1,
                    canPresent: !1,
                    maxLayers: 1
                });
                this.stageParameters = null;
                this.waitingForPresent_ = !1;
                this.fullscreenErrorHandler_ =
                    this.fullscreenChangeHandler_ = this.fullscreenEventTarget_ = this.fullscreenElementCachedStyle_ = this.fullscreenWrapper_ = this.fullscreenElement_ = this.originalParent_ = this.layer_ = null;
                a && P() && (this.wakelock_ = new xa)
            }

            function t(a) {
                var b = K({}, ba);
                a = K(b, a || {});
                u.call(this, {wakelock: a.MOBILE_WAKE_LOCK});
                this.config = a;
                this.displayName = "Cardboard VRDisplay";
                this.capabilities = new p({
                    hasPosition: !1,
                    hasOrientation: !0,
                    hasExternalDisplay: !1,
                    canPresent: !0,
                    maxLayers: 1
                });
                this.stageParameters = null;
                this.bufferScale_ =
                    this.config.BUFFER_SCALE;
                this.poseSensor_ = new G(this.config);
                this.cardboardUI_ = this.distorter_ = null;
                this.dpdb_ = new g(this.config.DPDB_URL, this.onDeviceParamsUpdated_.bind(this));
                this.deviceInfo_ = new e(this.dpdb_.getDeviceParams(), a.ADDITIONAL_VIEWERS);
                this.viewerSelector_ = new r(a.DEFAULT_VIEWER);
                this.viewerSelector_.onChange(this.onViewerChanged_.bind(this));
                this.deviceInfo_.setViewer(this.viewerSelector_.getCurrentViewer());
                this.config.ROTATE_INSTRUCTIONS_DISABLED || (this.rotateInstructions_ = new q);
                v() && window.addEventListener("resize", this.onResize_.bind(this))
            }

            var x = function () {
                    function a(a, b) {
                        for (var c = 0; c < b.length; c++) {
                            var d = b[c];
                            d.enumerable = d.enumerable || !1;
                            d.configurable = !0;
                            "value"in d && (d.writable = !0);
                            Object.defineProperty(a, d.key, d)
                        }
                    }

                    return function (b, c, d) {
                        c && a(b.prototype, c);
                        d && a(b, d);
                        return b
                    }
                }(), w = function () {
                    return function (a, b) {
                        if (Array.isArray(a))return a;
                        $jscomp.initSymbol();
                        $jscomp.initSymbolIterator();
                        if (Symbol.iterator in Object(a)) {
                            var c = [], d = !0, e = !1, f = void 0;
                            try {
                                $jscomp.initSymbol();
                                $jscomp.initSymbolIterator();
                                for (var g = a[Symbol.iterator](), k; !(d = (k = g.next()).done) && (c.push(k.value), !b || c.length !== b); d = !0);
                            } catch (kb) {
                                e = !0, f = kb
                            } finally {
                                try {
                                    if (!d && g["return"])g["return"]()
                                } finally {
                                    if (e)throw f;
                                }
                            }
                            return c
                        }
                        throw new TypeError("Invalid attempt to destructure non-iterable instance");
                    }
                }(), v = function () {
                    var a = /iPad|iPhone|iPod/.test(navigator.platform);
                    return function () {
                        return a
                    }
                }(), A = function () {
                    var a = -1 !== navigator.userAgent.indexOf("Version") && -1 !== navigator.userAgent.indexOf("Android") &&
                        -1 !== navigator.userAgent.indexOf("Chrome");
                    return function () {
                        return a
                    }
                }(), y = function () {
                    var a = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                    return function () {
                        return a
                    }
                }(), z = function () {
                    var a = -1 !== navigator.userAgent.indexOf("Firefox") && -1 !== navigator.userAgent.indexOf("Android");
                    return function () {
                        return a
                    }
                }(), B = function () {
                    var a = navigator.userAgent.match(/.*Chrome\/([0-9]+)/), b = a ? parseInt(a[1], 10) : null;
                    return function () {
                        return b
                    }
                }(), C = function () {
                    var a = !1;
                    a = v() && y() && -1 !== navigator.userAgent.indexOf("13_4");
                    return function () {
                        return a
                    }
                }(), H = function () {
                    var a = !1;
                    if (65 === B()) {
                        var b = navigator.userAgent.match(/.*Chrome\/([0-9\.]*)/);
                        if (b) {
                            b = b[1].split(".");
                            b = w(b, 4);
                            var c = b[3];
                            a = 3325 === parseInt(b[2], 10) && 148 > parseInt(c, 10)
                        }
                    }
                    return function () {
                        return a
                    }
                }(), Z = function () {
                    var a = -1 !== navigator.userAgent.indexOf("R7 Build");
                    return function () {
                        return a
                    }
                }(), F = function () {
                    var a = 90 == window.orientation || -90 == window.orientation;
                    return Z() ? !a : a
                }, ma = function () {
                    return Math.max(window.screen.width, window.screen.height) * window.devicePixelRatio
                },
                E = function () {
                    return Math.min(window.screen.width, window.screen.height) * window.devicePixelRatio
                }, D = function (a) {
                    if (A())return !1;
                    if (a.requestFullscreen)a.requestFullscreen(); else if (a.webkitRequestFullscreen)a.webkitRequestFullscreen(); else if (a.mozRequestFullScreen)a.mozRequestFullScreen(); else if (a.msRequestFullscreen)a.msRequestFullscreen(); else return !1;
                    return !0
                }, I = function () {
                    if (document.exitFullscreen)document.exitFullscreen(); else if (document.webkitExitFullscreen)document.webkitExitFullscreen();
                    else if (document.mozCancelFullScreen)document.mozCancelFullScreen(); else if (document.msExitFullscreen)document.msExitFullscreen(); else return !1;
                    return !0
                }, W = function (a, b, c, d) {
                    var e = a.createShader(a.VERTEX_SHADER);
                    a.shaderSource(e, b);
                    a.compileShader(e);
                    b = a.createShader(a.FRAGMENT_SHADER);
                    a.shaderSource(b, c);
                    a.compileShader(b);
                    c = a.createProgram();
                    a.attachShader(c, e);
                    a.attachShader(c, b);
                    for (var f in d)a.bindAttribLocation(c, d[f], f);
                    a.linkProgram(c);
                    a.deleteShader(e);
                    a.deleteShader(b);
                    return c
                }, aa = function (a,
                                  b) {
                    for (var c = {}, d = a.getProgramParameter(b, a.ACTIVE_UNIFORMS), e, f = 0; f < d; f++)e = a.getActiveUniform(b, f).name.replace("[0]", ""), c[e] = a.getUniformLocation(b, e);
                    return c
                }, P = function () {
                    var a = !1, b = navigator.userAgent || navigator.vendor || window.opera;
                    if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(b) ||
                        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(b.substr(0,
                            4)))a = !0;
                    return a
                }, K = function (a, b) {
                    for (var c in b)b.hasOwnProperty(c) && (a[c] = b[c]);
                    return a
                }, ia = function (a) {
                    if (v()) {
                        var b = a.style.width, c = a.style.height;
                        a.style.width = parseInt(b) + 1 + "px";
                        a.style.height = parseInt(c) + "px";
                        setTimeout(function () {
                            a.style.width = b;
                            a.style.height = c
                        }, 100)
                    }
                    window.canvas = a
                }, M = function () {
                    function a(a, f, g, k, h, m) {
                        var l = k || null;
                        k = m.depthNear;
                        m = m.depthFar;
                        var n = Math.tan(l ? l.upDegrees * b : c), q = Math.tan(l ? l.downDegrees * b : c), r = Math.tan(l ? l.leftDegrees * b : c);
                        l = Math.tan(l ? l.rightDegrees * b :
                            c);
                        var p = 2 / (r + l), u = 2 / (n + q);
                        a[0] = p;
                        a[1] = 0;
                        a[2] = 0;
                        a[3] = 0;
                        a[4] = 0;
                        a[5] = u;
                        a[6] = 0;
                        a[7] = 0;
                        a[8] = -((r - l) * p * .5);
                        a[9] = (n - q) * u * .5;
                        a[10] = m / (k - m);
                        a[11] = -1;
                        a[12] = 0;
                        a[13] = 0;
                        a[14] = m * k / (k - m);
                        a[15] = 0;
                        a = g.orientation || d;
                        g = g.position || e;
                        q = a[0];
                        p = a[1];
                        u = a[2];
                        m = a[3];
                        var t = q + q;
                        l = p + p;
                        n = u + u;
                        a = q * t;
                        k = q * l;
                        q *= n;
                        r = p * l;
                        p *= n;
                        u *= n;
                        t *= m;
                        l *= m;
                        m *= n;
                        f[0] = 1 - (r + u);
                        f[1] = k + m;
                        f[2] = q - l;
                        f[3] = 0;
                        f[4] = k - m;
                        f[5] = 1 - (a + u);
                        f[6] = p + t;
                        f[7] = 0;
                        f[8] = q + l;
                        f[9] = p - t;
                        f[10] = 1 - (a + r);
                        f[11] = 0;
                        f[12] = g[0];
                        f[13] = g[1];
                        f[14] = g[2];
                        f[15] = 1;
                        if (h)if (g = h[0], a = h[1], h = h[2], f ===
                            f)f[12] = f[0] * g + f[4] * a + f[8] * h + f[12], f[13] = f[1] * g + f[5] * a + f[9] * h + f[13], f[14] = f[2] * g + f[6] * a + f[10] * h + f[14], f[15] = f[3] * g + f[7] * a + f[11] * h + f[15]; else {
                            k = f[0];
                            m = f[1];
                            n = f[2];
                            q = f[3];
                            r = f[4];
                            l = f[5];
                            p = f[6];
                            u = f[7];
                            t = f[8];
                            var Da = f[9];
                            var x = f[10];
                            var w = f[11];
                            f[0] = k;
                            f[1] = m;
                            f[2] = n;
                            f[3] = q;
                            f[4] = r;
                            f[5] = l;
                            f[6] = p;
                            f[7] = u;
                            f[8] = t;
                            f[9] = Da;
                            f[10] = x;
                            f[11] = w;
                            f[12] = k * g + r * a + t * h + f[12];
                            f[13] = m * g + l * a + Da * h + f[13];
                            f[14] = n * g + p * a + x * h + f[14];
                            f[15] = q * g + u * a + w * h + f[15]
                        }
                        h = f[0];
                        g = f[1];
                        a = f[2];
                        k = f[3];
                        m = f[4];
                        n = f[5];
                        q = f[6];
                        r = f[7];
                        l = f[8];
                        p = f[9];
                        u = f[10];
                        t = f[11];
                        Da = f[12];
                        x = f[13];
                        w = f[14];
                        var v = f[15], Ia = h * n - g * m, A = h * q - a * m, Fa = h * r - k * m, y = g * q - a * n, z = g * r - k * n, B = a * r - k * q, C = l * x - p * Da, H = l * w - u * Da, Z = l * v - t * Da, F = p * w - u * x, ma = p * v - t * x, E = u * v - t * w, D = Ia * E - A * ma + Fa * F + y * Z - z * H + B * C;
                        D && (D = 1 / D, f[0] = (n * E - q * ma + r * F) * D, f[1] = (a * ma - g * E - k * F) * D, f[2] = (x * B - w * z + v * y) * D, f[3] = (u * z - p * B - t * y) * D, f[4] = (q * Z - m * E - r * H) * D, f[5] = (h * E - a * Z + k * H) * D, f[6] = (w * Fa - Da * B - v * A) * D, f[7] = (l * B - u * Fa + t * A) * D, f[8] = (m * ma - n * Z + r * C) * D, f[9] = (g * Z - h * ma - k * C) * D, f[10] = (Da * z - x * Fa + v * Ia) * D, f[11] = (p * Fa - l * z - t * Ia) * D, f[12] = (n * H - m * F - q * C) * D, f[13] =
                            (h * F - g * H + a * C) * D, f[14] = (x * A - Da * y - w * Ia) * D, f[15] = (l * y - p * A + u * Ia) * D)
                    }

                    var b = Math.PI / 180, c = .25 * Math.PI, d = new Float32Array([0, 0, 0, 1]), e = new Float32Array([0, 0, 0]);
                    return function (b, c, d) {
                        if (!b || !c)return !1;
                        b.pose = c;
                        b.timestamp = c.timestamp;
                        a(b.leftProjectionMatrix, b.leftViewMatrix, c, d._getFieldOfView("left"), d._getEyeOffset("left"), d);
                        a(b.rightProjectionMatrix, b.rightViewMatrix, c, d._getFieldOfView("right"), d._getEyeOffset("right"), d);
                        return !0
                    }
                }(), O = function (a) {
                    var b = a.indexOf("://");
                    b = a.indexOf("/", -1 !== b ? b +
                    3 : 0);
                    -1 === b && (b = a.length);
                    return a.substring(0, b)
                }, N = function (a) {
                    return 1 < a.w ? (console.warn("getQuaternionAngle: w > 1"), 0) : 2 * Math.acos(a.w)
                }, ja = function () {
                    var a = {};
                    return function (b, c) {
                        void 0 === a[b] && (console.warn("webvr-polyfill: " + c), a[b] = !0)
                    }
                }(), ea = function (a, b) {
                    ja(a, a + " has been deprecated. This may not work on native WebVR displays. " + (b ? "Please use " + b + " instead." : ""))
                }, R = function (a, b, c) {
                    if (b) {
                        for (var d = [], f = null, e = 0; e < b.length; ++e) {
                            var g = b[e];
                            switch (g) {
                                case a.TEXTURE_BINDING_2D:
                                case a.TEXTURE_BINDING_CUBE_MAP:
                                    var k =
                                        b[++e];
                                    if (k < a.TEXTURE0 || k > a.TEXTURE31) {
                                        console.error("TEXTURE_BINDING_2D or TEXTURE_BINDING_CUBE_MAP must be followed by a valid texture unit");
                                        d.push(null, null);
                                        break
                                    }
                                    f || (f = a.getParameter(a.ACTIVE_TEXTURE));
                                    a.activeTexture(k);
                                    d.push(a.getParameter(g), null);
                                    break;
                                case a.ACTIVE_TEXTURE:
                                    f = a.getParameter(a.ACTIVE_TEXTURE);
                                    d.push(null);
                                    break;
                                default:
                                    d.push(a.getParameter(g))
                            }
                        }
                        c(a);
                        for (e = 0; e < b.length; ++e) {
                            g = b[e];
                            c = d[e];
                            switch (g) {
                                case a.ACTIVE_TEXTURE:
                                    break;
                                case a.ARRAY_BUFFER_BINDING:
                                    a.bindBuffer(a.ARRAY_BUFFER,
                                        c);
                                    break;
                                case a.COLOR_CLEAR_VALUE:
                                    a.clearColor(c[0], c[1], c[2], c[3]);
                                    break;
                                case a.COLOR_WRITEMASK:
                                    a.colorMask(c[0], c[1], c[2], c[3]);
                                    break;
                                case a.CURRENT_PROGRAM:
                                    a.useProgram(c);
                                    break;
                                case a.ELEMENT_ARRAY_BUFFER_BINDING:
                                    a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, c);
                                    break;
                                case a.FRAMEBUFFER_BINDING:
                                    a.bindFramebuffer(a.FRAMEBUFFER, c);
                                    break;
                                case a.RENDERBUFFER_BINDING:
                                    a.bindRenderbuffer(a.RENDERBUFFER, c);
                                    break;
                                case a.TEXTURE_BINDING_2D:
                                    k = b[++e];
                                    if (k < a.TEXTURE0 || k > a.TEXTURE31)break;
                                    a.activeTexture(k);
                                    a.bindTexture(a.TEXTURE_2D,
                                        c);
                                    break;
                                case a.TEXTURE_BINDING_CUBE_MAP:
                                    k = b[++e];
                                    if (k < a.TEXTURE0 || k > a.TEXTURE31)break;
                                    a.activeTexture(k);
                                    a.bindTexture(a.TEXTURE_CUBE_MAP, c);
                                    break;
                                case a.VIEWPORT:
                                    a.viewport(c[0], c[1], c[2], c[3]);
                                    break;
                                case a.BLEND:
                                case a.CULL_FACE:
                                case a.DEPTH_TEST:
                                case a.SCISSOR_TEST:
                                case a.STENCIL_TEST:
                                    c ? a.enable(g) : a.disable(g);
                                    break;
                                default:
                                    console.log("No GL restore behavior for 0x" + g.toString(16))
                            }
                            f && a.activeTexture(f)
                        }
                    } else c(a)
                };
            a.prototype.destroy = function () {
                var a = this.gl;
                this.unpatch();
                a.deleteProgram(this.program);
                a.deleteBuffer(this.vertexBuffer);
                a.deleteBuffer(this.indexBuffer);
                a.deleteTexture(this.renderTarget);
                a.deleteFramebuffer(this.framebuffer);
                this.depthStencilBuffer && a.deleteRenderbuffer(this.depthStencilBuffer);
                this.depthBuffer && a.deleteRenderbuffer(this.depthBuffer);
                this.stencilBuffer && a.deleteRenderbuffer(this.stencilBuffer);
                this.cardboardUI && this.cardboardUI.destroy()
            };
            a.prototype.onResize = function () {
                var a = this.gl, b = this;
                R(a, [a.RENDERBUFFER_BINDING, a.TEXTURE_BINDING_2D, a.TEXTURE0], function (a) {
                    b.realBindFramebuffer.call(a,
                        a.FRAMEBUFFER, null);
                    b.scissorTest && b.realDisable.call(a, a.SCISSOR_TEST);
                    b.realColorMask.call(a, !0, !0, !0, !0);
                    b.realViewport.call(a, 0, 0, a.drawingBufferWidth, a.drawingBufferHeight);
                    b.realClearColor.call(a, 0, 0, 0, 1);
                    a.clear(a.COLOR_BUFFER_BIT);
                    b.realBindFramebuffer.call(a, a.FRAMEBUFFER, b.framebuffer);
                    a.bindTexture(a.TEXTURE_2D, b.renderTarget);
                    a.texImage2D(a.TEXTURE_2D, 0, b.ctxAttribs.alpha ? a.RGBA : a.RGB, b.bufferWidth, b.bufferHeight, 0, b.ctxAttribs.alpha ? a.RGBA : a.RGB, a.UNSIGNED_BYTE, null);
                    a.texParameteri(a.TEXTURE_2D,
                        a.TEXTURE_MAG_FILTER, a.LINEAR);
                    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_MIN_FILTER, a.LINEAR);
                    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_S, a.CLAMP_TO_EDGE);
                    a.texParameteri(a.TEXTURE_2D, a.TEXTURE_WRAP_T, a.CLAMP_TO_EDGE);
                    a.framebufferTexture2D(a.FRAMEBUFFER, a.COLOR_ATTACHMENT0, a.TEXTURE_2D, b.renderTarget, 0);
                    b.ctxAttribs.depth && b.ctxAttribs.stencil ? (a.bindRenderbuffer(a.RENDERBUFFER, b.depthStencilBuffer), a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_STENCIL, b.bufferWidth, b.bufferHeight), a.framebufferRenderbuffer(a.FRAMEBUFFER,
                        a.DEPTH_STENCIL_ATTACHMENT, a.RENDERBUFFER, b.depthStencilBuffer)) : b.ctxAttribs.depth ? (a.bindRenderbuffer(a.RENDERBUFFER, b.depthBuffer), a.renderbufferStorage(a.RENDERBUFFER, a.DEPTH_COMPONENT16, b.bufferWidth, b.bufferHeight), a.framebufferRenderbuffer(a.FRAMEBUFFER, a.DEPTH_ATTACHMENT, a.RENDERBUFFER, b.depthBuffer)) : b.ctxAttribs.stencil && (a.bindRenderbuffer(a.RENDERBUFFER, b.stencilBuffer), a.renderbufferStorage(a.RENDERBUFFER, a.STENCIL_INDEX8, b.bufferWidth, b.bufferHeight), a.framebufferRenderbuffer(a.FRAMEBUFFER,
                        a.STENCIL_ATTACHMENT, a.RENDERBUFFER, b.stencilBuffer));
                    !a.checkFramebufferStatus(a.FRAMEBUFFER) === a.FRAMEBUFFER_COMPLETE && console.error("Framebuffer incomplete!");
                    b.realBindFramebuffer.call(a, a.FRAMEBUFFER, b.lastBoundFramebuffer);
                    b.scissorTest && b.realEnable.call(a, a.SCISSOR_TEST);
                    b.realColorMask.apply(a, b.colorMask);
                    b.realViewport.apply(a, b.viewport);
                    b.realClearColor.apply(a, b.clearColor)
                });
                if (this.cardboardUI)this.cardboardUI.onResize()
            };
            a.prototype.patch = function () {
                if (!this.isPatched) {
                    var a = this,
                        b = this.gl.canvas, c = this.gl;
                    v() || (b.width = ma() * this.bufferScale, b.height = E() * this.bufferScale, Object.defineProperty(b, "width", {
                        configurable: !0,
                        enumerable: !0,
                        get: function () {
                            return a.bufferWidth
                        },
                        set: function (c) {
                            a.bufferWidth = c;
                            a.realCanvasWidth.set.call(b, c);
                            a.onResize()
                        }
                    }), Object.defineProperty(b, "height", {
                        configurable: !0, enumerable: !0, get: function () {
                            return a.bufferHeight
                        }, set: function (c) {
                            a.bufferHeight = c;
                            a.realCanvasHeight.set.call(b, c);
                            a.onResize()
                        }
                    }));
                    this.lastBoundFramebuffer = c.getParameter(c.FRAMEBUFFER_BINDING);
                    null == this.lastBoundFramebuffer && (this.lastBoundFramebuffer = this.framebuffer, this.gl.bindFramebuffer(c.FRAMEBUFFER, this.framebuffer));
                    this.gl.bindFramebuffer = function (b, d) {
                        a.lastBoundFramebuffer = d ? d : a.framebuffer;
                        a.realBindFramebuffer.call(c, b, a.lastBoundFramebuffer)
                    };
                    this.cullFace = c.getParameter(c.CULL_FACE);
                    this.depthTest = c.getParameter(c.DEPTH_TEST);
                    this.blend = c.getParameter(c.BLEND);
                    this.scissorTest = c.getParameter(c.SCISSOR_TEST);
                    this.stencilTest = c.getParameter(c.STENCIL_TEST);
                    c.enable = function (b) {
                        switch (b) {
                            case c.CULL_FACE:
                                a.cullFace = !0;
                                break;
                            case c.DEPTH_TEST:
                                a.depthTest = !0;
                                break;
                            case c.BLEND:
                                a.blend = !0;
                                break;
                            case c.SCISSOR_TEST:
                                a.scissorTest = !0;
                                break;
                            case c.STENCIL_TEST:
                                a.stencilTest = !0
                        }
                        a.realEnable.call(c, b)
                    };
                    c.disable = function (b) {
                        switch (b) {
                            case c.CULL_FACE:
                                a.cullFace = !1;
                                break;
                            case c.DEPTH_TEST:
                                a.depthTest = !1;
                                break;
                            case c.BLEND:
                                a.blend = !1;
                                break;
                            case c.SCISSOR_TEST:
                                a.scissorTest = !1;
                                break;
                            case c.STENCIL_TEST:
                                a.stencilTest = !1
                        }
                        a.realDisable.call(c, b)
                    };
                    this.colorMask = c.getParameter(c.COLOR_WRITEMASK);
                    c.colorMask = function (b, d, f,
                                            e) {
                        a.colorMask[0] = b;
                        a.colorMask[1] = d;
                        a.colorMask[2] = f;
                        a.colorMask[3] = e;
                        a.realColorMask.call(c, b, d, f, e)
                    };
                    this.clearColor = c.getParameter(c.COLOR_CLEAR_VALUE);
                    c.clearColor = function (b, d, f, e) {
                        a.clearColor[0] = b;
                        a.clearColor[1] = d;
                        a.clearColor[2] = f;
                        a.clearColor[3] = e;
                        a.realClearColor.call(c, b, d, f, e)
                    };
                    this.viewport = c.getParameter(c.VIEWPORT);
                    c.viewport = function (b, d, f, e) {
                        a.viewport[0] = b;
                        a.viewport[1] = d;
                        a.viewport[2] = f;
                        a.viewport[3] = e;
                        a.realViewport.call(c, b, d, f, e)
                    };
                    this.isPatched = !0;
                    ia(b)
                }
            };
            a.prototype.unpatch =
                function () {
                    if (this.isPatched) {
                        var a = this.gl, b = this.gl.canvas;
                        v() || (Object.defineProperty(b, "width", this.realCanvasWidth), Object.defineProperty(b, "height", this.realCanvasHeight));
                        b.width = this.bufferWidth;
                        b.height = this.bufferHeight;
                        a.bindFramebuffer = this.realBindFramebuffer;
                        a.enable = this.realEnable;
                        a.disable = this.realDisable;
                        a.colorMask = this.realColorMask;
                        a.clearColor = this.realClearColor;
                        a.viewport = this.realViewport;
                        this.lastBoundFramebuffer == this.framebuffer && a.bindFramebuffer(a.FRAMEBUFFER, null);
                        this.isPatched = !1;
                        setTimeout(function () {
                            ia(b)
                        }, 1)
                    }
                };
            a.prototype.setTextureBounds = function (a, b) {
                a || (a = [0, 0, .5, 1]);
                b || (b = [.5, 0, .5, 1]);
                this.viewportOffsetScale[0] = a[0];
                this.viewportOffsetScale[1] = a[1];
                this.viewportOffsetScale[2] = a[2];
                this.viewportOffsetScale[3] = a[3];
                this.viewportOffsetScale[4] = b[0];
                this.viewportOffsetScale[5] = b[1];
                this.viewportOffsetScale[6] = b[2];
                this.viewportOffsetScale[7] = b[3]
            };
            a.prototype.submitFrame = function () {
                var a = this.gl, b = this, c = [];
                this.dirtySubmitFrameBindings || c.push(a.CURRENT_PROGRAM,
                    a.ARRAY_BUFFER_BINDING, a.ELEMENT_ARRAY_BUFFER_BINDING, a.TEXTURE_BINDING_2D, a.TEXTURE0);
                R(a, c, function (a) {
                    b.realBindFramebuffer.call(a, a.FRAMEBUFFER, null);
                    var c = 0, d = 0;
                    b.instanceExt && (c = a.getVertexAttrib(b.attribs.position, b.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE), d = a.getVertexAttrib(b.attribs.texCoord, b.instanceExt.VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE));
                    b.cullFace && b.realDisable.call(a, a.CULL_FACE);
                    b.depthTest && b.realDisable.call(a, a.DEPTH_TEST);
                    b.blend && b.realDisable.call(a, a.BLEND);
                    b.scissorTest &&
                    b.realDisable.call(a, a.SCISSOR_TEST);
                    b.stencilTest && b.realDisable.call(a, a.STENCIL_TEST);
                    b.realColorMask.call(a, !0, !0, !0, !0);
                    b.realViewport.call(a, 0, 0, a.drawingBufferWidth, a.drawingBufferHeight);
                    if (b.ctxAttribs.alpha || v())b.realClearColor.call(a, 0, 0, 0, 1), a.clear(a.COLOR_BUFFER_BIT);
                    a.useProgram(b.program);
                    a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, b.indexBuffer);
                    a.bindBuffer(a.ARRAY_BUFFER, b.vertexBuffer);
                    a.enableVertexAttribArray(b.attribs.position);
                    a.enableVertexAttribArray(b.attribs.texCoord);
                    a.vertexAttribPointer(b.attribs.position,
                        2, a.FLOAT, !1, 20, 0);
                    a.vertexAttribPointer(b.attribs.texCoord, 3, a.FLOAT, !1, 20, 8);
                    b.instanceExt && (0 != c && b.instanceExt.vertexAttribDivisorANGLE(b.attribs.position, 0), 0 != d && b.instanceExt.vertexAttribDivisorANGLE(b.attribs.texCoord, 0));
                    a.activeTexture(a.TEXTURE0);
                    a.uniform1i(b.uniforms.diffuse, 0);
                    a.bindTexture(a.TEXTURE_2D, b.renderTarget);
                    a.uniform4fv(b.uniforms.viewportOffsetScale, b.viewportOffsetScale);
                    a.drawElements(a.TRIANGLES, b.indexCount, a.UNSIGNED_SHORT, 0);
                    b.cardboardUI && b.cardboardUI.renderNoState();
                    b.realBindFramebuffer.call(b.gl, a.FRAMEBUFFER, b.framebuffer);
                    b.ctxAttribs.preserveDrawingBuffer || (b.realClearColor.call(a, 0, 0, 0, 0), a.clear(a.COLOR_BUFFER_BIT));
                    b.dirtySubmitFrameBindings || b.realBindFramebuffer.call(a, a.FRAMEBUFFER, b.lastBoundFramebuffer);
                    b.cullFace && b.realEnable.call(a, a.CULL_FACE);
                    b.depthTest && b.realEnable.call(a, a.DEPTH_TEST);
                    b.blend && b.realEnable.call(a, a.BLEND);
                    b.scissorTest && b.realEnable.call(a, a.SCISSOR_TEST);
                    b.stencilTest && b.realEnable.call(a, a.STENCIL_TEST);
                    b.realColorMask.apply(a,
                        b.colorMask);
                    b.realViewport.apply(a, b.viewport);
                    !b.ctxAttribs.alpha && b.ctxAttribs.preserveDrawingBuffer || b.realClearColor.apply(a, b.clearColor);
                    b.instanceExt && (0 != c && b.instanceExt.vertexAttribDivisorANGLE(b.attribs.position, c), 0 != d && b.instanceExt.vertexAttribDivisorANGLE(b.attribs.texCoord, d))
                });
                v() && (a = a.canvas, a.width != b.bufferWidth || a.height != b.bufferHeight) && (b.bufferWidth = a.width, b.bufferHeight = a.height, b.onResize())
            };
            a.prototype.updateDeviceInfo = function (a) {
                var b = this.gl, c = this;
                R(b, [b.ARRAY_BUFFER_BINDING,
                    b.ELEMENT_ARRAY_BUFFER_BINDING], function (b) {
                    var d = c.computeMeshVertices_(c.meshWidth, c.meshHeight, a);
                    b.bindBuffer(b.ARRAY_BUFFER, c.vertexBuffer);
                    b.bufferData(b.ARRAY_BUFFER, d, b.STATIC_DRAW);
                    c.indexCount || (d = c.computeMeshIndices_(c.meshWidth, c.meshHeight), b.bindBuffer(b.ELEMENT_ARRAY_BUFFER, c.indexBuffer), b.bufferData(b.ELEMENT_ARRAY_BUFFER, d, b.STATIC_DRAW), c.indexCount = d.length)
                })
            };
            a.prototype.computeMeshVertices_ = function (a, b, c) {
                for (var d = new Float32Array(2 * a * b * 5), f = c.getLeftEyeVisibleTanAngles(),
                         e = c.getLeftEyeNoLensTanAngles(), g = c.getLeftEyeVisibleScreenRect(e), k = 0, h = 0; 2 > h; h++) {
                    for (var m = 0; m < b; m++)for (var l = 0; l < a; l++, k++) {
                        var n = l / (a - 1), q = m / (b - 1), r = n, p = q, u = f[0];
                        n = u + (f[2] - u) * n;
                        u = f[3];
                        var t = u + (f[1] - u) * q;
                        q = Math.sqrt(n * n + t * t);
                        u = c.distortion.distortInverse(q);
                        t = t * u / q;
                        n = (n * u / q - e[0]) / (e[2] - e[0]);
                        q = (t - e[3]) / (e[1] - e[3]);
                        n = 2 * (g.x + n * g.width - .5);
                        q = 2 * (g.y + q * g.height - .5);
                        d[5 * k] = n;
                        d[5 * k + 1] = q;
                        d[5 * k + 2] = r;
                        d[5 * k + 3] = p;
                        d[5 * k + 4] = h
                    }
                    m = f[2] - f[0];
                    f[0] = -(m + f[0]);
                    f[2] = m - f[2];
                    m = e[2] - e[0];
                    e[0] = -(m + e[0]);
                    e[2] = m - e[2];
                    g.x =
                        1 - (g.x + g.width)
                }
                return d
            };
            a.prototype.computeMeshIndices_ = function (a, b) {
                for (var c = new Uint16Array(2 * (a - 1) * (b - 1) * 6), d = a / 2, f = b / 2, e = 0, g = 0, k = 0; 2 > k; k++)for (var h = 0; h < b; h++)for (var m = 0; m < a; m++, e++)0 != m && 0 != h && (m <= d == h <= f ? (c[g++] = e, c[g++] = e - a - 1, c[g++] = e - a, c[g++] = e - a - 1, c[g++] = e, c[g++] = e - 1) : (c[g++] = e - 1, c[g++] = e - a, c[g++] = e, c[g++] = e - a, c[g++] = e - 1, c[g++] = e - a - 1));
                return c
            };
            a.prototype.getOwnPropertyDescriptor_ = function (a, b) {
                a = Object.getOwnPropertyDescriptor(a, b);
                if (void 0 === a.get || void 0 === a.set)a.configurable = !0, a.enumerable = !0, a.get = function () {
                    return this.getAttribute(b)
                }, a.set = function (a) {
                    this.setAttribute(b, a)
                };
                return a
            };
            var V = Math.PI / 180;
            b.prototype.destroy = function () {
                var a = this.gl;
                this.listener && a.canvas.removeEventListener("click", this.listener, !1);
                a.deleteProgram(this.program);
                a.deleteBuffer(this.vertexBuffer)
            };
            b.prototype.listen = function (a, b) {
                var c = this.gl.canvas;
                this.listener = function (d) {
                    var f = c.clientWidth / 2, e = d.touches ? d.touches[0].clientX : d.clientX, g = d.touches ? d.touches[0].clientY : d.clientY;
                    e > f - 42 && e < f + 42 && g > c.clientHeight - 42 ? a(d) : 42 > e && 42 > g && b(d)
                };
                c.addEventListener("click", this.listener, !1);
                c.addEventListener("touchstart", this.listener, !1)
            };
            b.prototype.onResize = function () {
                var a = this.gl, b = this;
                R(a, [a.ARRAY_BUFFER_BINDING], function (a) {
                    function c(a, b) {
                        var c = (90 - a) * V;
                        a = Math.cos(c);
                        c = Math.sin(c);
                        f.push(.3125 * a * m + e, .3125 * c * m + m);
                        f.push(b * a * m + e, b * c * m + m)
                    }

                    function d(b, c) {
                        f.push(l + b, a.drawingBufferHeight - l - c)
                    }

                    var f = [], e = a.drawingBufferWidth / 2, g = a.drawingBufferWidth / (Math.max(screen.width, screen.height) *
                        window.devicePixelRatio) * window.devicePixelRatio, k = 4 * g / 2, h = 42 * g, m = 28 * g / 2, l = 14 * g;
                    f.push(e - k, h);
                    f.push(e - k, a.drawingBufferHeight);
                    f.push(e + k, h);
                    f.push(e + k, a.drawingBufferHeight);
                    b.gearOffset = f.length / 2;
                    for (h = 0; 6 >= h; h++) {
                        var n = 60 * h;
                        c(n, 1);
                        c(n + 12, 1);
                        c(n + 20, .75);
                        c(n + 40, .75);
                        c(n + 48, 1)
                    }
                    b.gearVertexCount = f.length / 2 - b.gearOffset;
                    b.arrowOffset = f.length / 2;
                    h = k / Math.sin(45 * V);
                    d(0, m);
                    d(m, 0);
                    d(m + h, h);
                    d(h, m + h);
                    d(h, m - h);
                    d(0, m);
                    d(m, 2 * m);
                    d(m + h, 2 * m - h);
                    d(h, m - h);
                    d(0, m);
                    d(h, m - k);
                    d(28 * g, m - k);
                    d(h, m + k);
                    d(28 * g, m + k);
                    b.arrowVertexCount =
                        f.length / 2 - b.arrowOffset;
                    a.bindBuffer(a.ARRAY_BUFFER, b.vertexBuffer);
                    a.bufferData(a.ARRAY_BUFFER, new Float32Array(f), a.STATIC_DRAW)
                })
            };
            b.prototype.render = function () {
                var a = this.gl, b = this;
                R(a, [a.CULL_FACE, a.DEPTH_TEST, a.BLEND, a.SCISSOR_TEST, a.STENCIL_TEST, a.COLOR_WRITEMASK, a.VIEWPORT, a.CURRENT_PROGRAM, a.ARRAY_BUFFER_BINDING], function (a) {
                    a.disable(a.CULL_FACE);
                    a.disable(a.DEPTH_TEST);
                    a.disable(a.BLEND);
                    a.disable(a.SCISSOR_TEST);
                    a.disable(a.STENCIL_TEST);
                    a.colorMask(!0, !0, !0, !0);
                    a.viewport(0, 0, a.drawingBufferWidth,
                        a.drawingBufferHeight);
                    b.renderNoState()
                })
            };
            b.prototype.renderNoState = function () {
                var a = this.gl;
                a.useProgram(this.program);
                a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer);
                a.enableVertexAttribArray(this.attribs.position);
                a.vertexAttribPointer(this.attribs.position, 2, a.FLOAT, !1, 8, 0);
                a.uniform4f(this.uniforms.color, 1, 1, 1, 1);
                var b = this.projMat, c = a.drawingBufferWidth, d = a.drawingBufferHeight, f = 1 / (0 - c), e = 1 / (0 - d), g = 1 / -1023.9;
                b[0] = -2 * f;
                b[1] = 0;
                b[2] = 0;
                b[3] = 0;
                b[4] = 0;
                b[5] = -2 * e;
                b[6] = 0;
                b[7] = 0;
                b[8] = 0;
                b[9] = 0;
                b[10] =
                    2 * g;
                b[11] = 0;
                b[12] = (0 + c) * f;
                b[13] = (d + 0) * e;
                b[14] = 1024.1 * g;
                b[15] = 1;
                a.uniformMatrix4fv(this.uniforms.projectionMat, !1, this.projMat);
                a.drawArrays(a.TRIANGLE_STRIP, 0, 4);
                a.drawArrays(a.TRIANGLE_STRIP, this.gearOffset, this.gearVertexCount);
                a.drawArrays(a.TRIANGLE_STRIP, this.arrowOffset, this.arrowVertexCount)
            };
            c.prototype.distortInverse = function (a) {
                for (var b = 0, c = 1, d = a - this.distort(b); 1E-4 < Math.abs(c - b);) {
                    var f = a - this.distort(c);
                    d = c - (c - b) / (f - d) * f;
                    b = c;
                    c = d;
                    d = f
                }
                return c
            };
            c.prototype.distort = function (a) {
                for (var b =
                    a * a, c = 0, d = 0; d < this.coefficients.length; d++)c = b * (c + this.coefficients[d]);
                return (c + 1) * a
            };
            var S = Math.PI / 180, L = 180 / Math.PI, U = function (a, b, c) {
                this.x = a || 0;
                this.y = b || 0;
                this.z = c || 0
            };
            U.prototype = {
                constructor: U, set: function (a, b, c) {
                    this.x = a;
                    this.y = b;
                    this.z = c;
                    return this
                }, copy: function (a) {
                    this.x = a.x;
                    this.y = a.y;
                    this.z = a.z;
                    return this
                }, length: function () {
                    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
                }, normalize: function () {
                    var a = this.length();
                    0 !== a ? this.multiplyScalar(1 / a) : this.z = this.y = this.x = 0;
                    return this
                },
                multiplyScalar: function (a) {
                    this.x *= a;
                    this.y *= a;
                    this.z *= a
                }, applyQuaternion: function (a) {
                    var b = this.x, c = this.y, d = this.z, f = a.x, e = a.y, g = a.z;
                    a = a.w;
                    var k = a * b + e * d - g * c, h = a * c + g * b - f * d, m = a * d + f * c - e * b;
                    b = -f * b - e * c - g * d;
                    this.x = k * a + b * -f + h * -g - m * -e;
                    this.y = h * a + b * -e + m * -f - k * -g;
                    this.z = m * a + b * -g + k * -e - h * -f;
                    return this
                }, dot: function (a) {
                    return this.x * a.x + this.y * a.y + this.z * a.z
                }, crossVectors: function (a, b) {
                    var c = a.x, d = a.y;
                    a = a.z;
                    var f = b.x, e = b.y;
                    b = b.z;
                    this.x = d * b - a * e;
                    this.y = a * f - c * b;
                    this.z = c * e - d * f;
                    return this
                }
            };
            var J = function (a, b, c,
                              d) {
                this.x = a || 0;
                this.y = b || 0;
                this.z = c || 0;
                this.w = void 0 !== d ? d : 1
            };
            J.prototype = {
                constructor: J, set: function (a, b, c, d) {
                    this.x = a;
                    this.y = b;
                    this.z = c;
                    this.w = d;
                    return this
                }, copy: function (a) {
                    this.x = a.x;
                    this.y = a.y;
                    this.z = a.z;
                    this.w = a.w;
                    return this
                }, setFromEulerXYZ: function (a, b, c) {
                    var d = Math.cos(a / 2), f = Math.cos(b / 2), e = Math.cos(c / 2);
                    a = Math.sin(a / 2);
                    b = Math.sin(b / 2);
                    c = Math.sin(c / 2);
                    this.x = a * f * e + d * b * c;
                    this.y = d * b * e - a * f * c;
                    this.z = d * f * c + a * b * e;
                    this.w = d * f * e - a * b * c;
                    return this
                }, setFromEulerYXZ: function (a, b, c) {
                    var d = Math.cos(a /
                        2), f = Math.cos(b / 2), e = Math.cos(c / 2);
                    a = Math.sin(a / 2);
                    b = Math.sin(b / 2);
                    c = Math.sin(c / 2);
                    this.x = a * f * e + d * b * c;
                    this.y = d * b * e - a * f * c;
                    this.z = d * f * c - a * b * e;
                    this.w = d * f * e + a * b * c;
                    return this
                }, setFromAxisAngle: function (a, b) {
                    b /= 2;
                    var c = Math.sin(b);
                    this.x = a.x * c;
                    this.y = a.y * c;
                    this.z = a.z * c;
                    this.w = Math.cos(b);
                    return this
                }, multiply: function (a) {
                    return this.multiplyQuaternions(this, a)
                }, multiplyQuaternions: function (a, b) {
                    var c = a.x, d = a.y, f = a.z;
                    a = a.w;
                    var e = b.x, g = b.y, k = b.z;
                    b = b.w;
                    this.x = c * b + a * e + d * k - f * g;
                    this.y = d * b + a * g + f * e - c * k;
                    this.z =
                        f * b + a * k + c * g - d * e;
                    this.w = a * b - c * e - d * g - f * k;
                    return this
                }, inverse: function () {
                    this.x *= -1;
                    this.y *= -1;
                    this.z *= -1;
                    this.normalize();
                    return this
                }, normalize: function () {
                    var a = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
                    0 === a ? (this.z = this.y = this.x = 0, this.w = 1) : (a = 1 / a, this.x *= a, this.y *= a, this.z *= a, this.w *= a);
                    return this
                }, slerp: function (a, b) {
                    if (0 === b)return this;
                    if (1 === b)return this.copy(a);
                    var c = this.x, d = this.y, f = this.z, e = this.w, g = e * a.w + c * a.x + d * a.y + f * a.z;
                    0 > g ? (this.w = -a.w, this.x = -a.x, this.y = -a.y, this.z = -a.z, g = -g) : this.copy(a);
                    if (1 <= g)return this.w = e, this.x = c, this.y = d, this.z = f, this;
                    a = Math.acos(g);
                    var k = Math.sqrt(1 - g * g);
                    if (.001 > Math.abs(k))return this.w = .5 * (e + this.w), this.x = .5 * (c + this.x), this.y = .5 * (d + this.y), this.z = .5 * (f + this.z), this;
                    g = Math.sin((1 - b) * a) / k;
                    b = Math.sin(b * a) / k;
                    this.w = e * g + this.w * b;
                    this.x = c * g + this.x * b;
                    this.y = d * g + this.y * b;
                    this.z = f * g + this.z * b;
                    return this
                }, setFromUnitVectors: function () {
                    var a, b;
                    return function (c, d) {
                        void 0 === a && (a = new U);
                        b = c.dot(d) + 1;
                        1E-6 > b ? (b = 0, Math.abs(c.x) > Math.abs(c.z) ?
                            a.set(-c.y, c.x, 0) : a.set(0, -c.z, c.y)) : a.crossVectors(c, d);
                        this.x = a.x;
                        this.y = a.y;
                        this.z = a.z;
                        this.w = b;
                        this.normalize();
                        return this
                    }
                }()
            };
            var qa = new d({widthMeters: .11, heightMeters: .062, bevelMeters: .004}), ua = new d({
                widthMeters: .1038,
                heightMeters: .0584,
                bevelMeters: .004
            }), T = {
                CardboardV1: new f({
                    id: "CardboardV1",
                    label: "Cardboard I/O 2014",
                    fov: 40,
                    interLensDistance: .06,
                    baselineLensDistance: .035,
                    screenLensDistance: .042,
                    distortionCoefficients: [.441, .156],
                    inverseCoefficients: [-.4410035, .42756155, -.4804439, .5460139,
                        -.58821183, .5733938, -.48303202, .33299083, -.17573841, .0651772, -.01488963, .001559834]
                }),
                CardboardV2: new f({
                    id: "CardboardV2",
                    label: "Cardboard I/O 2015",
                    fov: 60,
                    interLensDistance: .064,
                    baselineLensDistance: .035,
                    screenLensDistance: .039,
                    distortionCoefficients: [.34, .55],
                    inverseCoefficients: [-.33836704, -.18162185, .862655, -1.2462051, 1.0560602, -.58208317, .21609078, -.05444823, .009177956, -9.904169E-4, 6.183535E-5, -1.6981803E-6]
                })
            };
            e.prototype.updateDeviceParams = function (a) {
                this.device = this.determineDevice_(a) ||
                    this.device
            };
            e.prototype.getDevice = function () {
                return this.device
            };
            e.prototype.setViewer = function (a) {
                this.viewer = a;
                this.distortion = new c(this.viewer.distortionCoefficients)
            };
            e.prototype.determineDevice_ = function (a) {
                if (!a) {
                    if (v())return console.warn("Using fallback iOS device measurements."), ua;
                    console.warn("Using fallback Android device measurements.");
                    return qa
                }
                var b = .0254 / a.xdpi, c = .0254 / a.ydpi, f = ma(), e = E();
                return new d({widthMeters: b * f, heightMeters: c * e, bevelMeters: .001 * a.bevelMm})
            };
            e.prototype.getDistortedFieldOfViewLeftEye =
                function () {
                    var a = this.viewer, b = this.device, c = this.distortion, d = a.screenLensDistance, f = a.interLensDistance / 2, e = a.baselineLensDistance - b.bevelMeters, g = b.heightMeters - e;
                    b = L * Math.atan(c.distort((b.widthMeters - a.interLensDistance) / 2 / d));
                    f = L * Math.atan(c.distort(f / d));
                    e = L * Math.atan(c.distort(e / d));
                    c = L * Math.atan(c.distort(g / d));
                    return {
                        leftDegrees: Math.min(b, a.fov),
                        rightDegrees: Math.min(f, a.fov),
                        downDegrees: Math.min(e, a.fov),
                        upDegrees: Math.min(c, a.fov)
                    }
                };
            e.prototype.getLeftEyeVisibleTanAngles = function () {
                var a =
                    this.viewer, b = this.device, c = this.distortion, d = Math.tan(-S * a.fov), f = Math.tan(S * a.fov), e = Math.tan(S * a.fov), g = Math.tan(-S * a.fov), k = b.widthMeters / 4, h = b.heightMeters / 2, m = a.interLensDistance / 2 - k, l = -(a.baselineLensDistance - b.bevelMeters - h), n = a.screenLensDistance;
                a = c.distort((m - k) / n);
                b = c.distort((l + h) / n);
                k = c.distort((m + k) / n);
                c = c.distort((l - h) / n);
                h = new Float32Array(4);
                h[0] = Math.max(d, a);
                h[1] = Math.min(f, b);
                h[2] = Math.min(e, k);
                h[3] = Math.max(g, c);
                return h
            };
            e.prototype.getLeftEyeNoLensTanAngles = function () {
                var a =
                    this.viewer, b = this.device, c = this.distortion, d = new Float32Array(4), f = c.distortInverse(Math.tan(-S * a.fov)), e = c.distortInverse(Math.tan(S * a.fov)), g = c.distortInverse(Math.tan(S * a.fov));
                c = c.distortInverse(Math.tan(-S * a.fov));
                var k = b.widthMeters / 4, h = b.heightMeters / 2, m = a.interLensDistance / 2 - k;
                b = -(a.baselineLensDistance - b.bevelMeters - h);
                a = a.screenLensDistance;
                d[0] = Math.max(f, (m - k) / a);
                d[1] = Math.min(e, (b + h) / a);
                d[2] = Math.min(g, (m + k) / a);
                d[3] = Math.max(c, (b - h) / a);
                return d
            };
            e.prototype.getLeftEyeVisibleScreenRect =
                function (a) {
                    var b = this.viewer, c = this.device, d = b.screenLensDistance, f = (c.widthMeters - b.interLensDistance) / 2;
                    b = b.baselineLensDistance - c.bevelMeters;
                    var e = (a[0] * d + f) / c.widthMeters, g = (a[3] * d + b) / c.heightMeters;
                    return {
                        x: e,
                        y: g,
                        width: (a[2] * d + f) / c.widthMeters - e,
                        height: (a[1] * d + b) / c.heightMeters - g
                    }
                };
            e.prototype.getFieldOfViewLeftEye = function (a) {
                return a ? this.getUndistortedFieldOfViewLeftEye() : this.getDistortedFieldOfViewLeftEye()
            };
            e.prototype.getFieldOfViewRightEye = function (a) {
                a = this.getFieldOfViewLeftEye(a);
                return {
                    leftDegrees: a.rightDegrees,
                    rightDegrees: a.leftDegrees,
                    upDegrees: a.upDegrees,
                    downDegrees: a.downDegrees
                }
            };
            e.prototype.getUndistortedFieldOfViewLeftEye = function () {
                var a = this.getUndistortedParams_();
                return {
                    leftDegrees: L * Math.atan(a.outerDist),
                    rightDegrees: L * Math.atan(a.innerDist),
                    downDegrees: L * Math.atan(a.bottomDist),
                    upDegrees: L * Math.atan(a.topDist)
                }
            };
            e.prototype.getUndistortedViewportLeftEye = function () {
                var a = this.getUndistortedParams_(), b = this.device, c = this.viewer.screenLensDistance, d = b.width /
                    (b.widthMeters / c);
                b = b.height / (b.heightMeters / c);
                c = Math.round((a.eyePosX - a.outerDist) * d);
                var f = Math.round((a.eyePosY - a.bottomDist) * b);
                return {
                    x: c,
                    y: f,
                    width: Math.round((a.eyePosX + a.innerDist) * d) - c,
                    height: Math.round((a.eyePosY + a.topDist) * b) - f
                }
            };
            e.prototype.getUndistortedParams_ = function () {
                var a = this.viewer, b = this.device, c = a.screenLensDistance, d = a.interLensDistance / 2 / c, f = b.heightMeters / c, e = b.widthMeters / c / 2 - d;
                b = (a.baselineLensDistance - b.bevelMeters) / c;
                a = this.distortion.distortInverse(Math.tan(S * a.fov));
                return {
                    outerDist: Math.min(e, a),
                    innerDist: Math.min(d, a),
                    topDist: Math.min(f - b, a),
                    bottomDist: Math.min(b, a),
                    eyePosX: e,
                    eyePosY: b
                }
            };
            e.Viewers = T;
            var Q = {
                format: 1,
                last_updated: "2019-11-09T17:36:14Z",
                devices: [{
                    type: "android",
                    rules: [{mdmh: "asus/*/Nexus 7/*"}, {ua: "Nexus 7"}],
                    dpi: [320.8, 323],
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{mdmh: "asus/*/ASUS_X00PD/*"}, {ua: "ASUS_X00PD"}],
                    dpi: 245,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{mdmh: "asus/*/ASUS_X008D/*"}, {ua: "ASUS_X008D"}],
                    dpi: 282,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android", rules: [{mdmh: "asus/*/ASUS_Z00AD/*"},
                        {ua: "ASUS_Z00AD"}], dpi: [403, 404.6], bw: 3, ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "Google/*/Pixel 2 XL/*"}, {ua: "Pixel 2 XL"}],
                    dpi: 537.9,
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "Google/*/Pixel 3 XL/*"}, {ua: "Pixel 3 XL"}],
                    dpi: [558.5, 553.8],
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "Google/*/Pixel XL/*"}, {ua: "Pixel XL"}],
                    dpi: [537.9, 533],
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "Google/*/Pixel 3/*"}, {ua: "Pixel 3"}],
                    dpi: 442.4,
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android", rules: [{mdmh: "Google/*/Pixel 2/*"}, {ua: "Pixel 2"}],
                    dpi: 441, bw: 3, ac: 500
                }, {
                    type: "android",
                    rules: [{mdmh: "Google/*/Pixel/*"}, {ua: "Pixel"}],
                    dpi: [432.6, 436.7],
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "HTC/*/HTC6435LVW/*"}, {ua: "HTC6435LVW"}],
                    dpi: [449.7, 443.3],
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "HTC/*/HTC One XL/*"}, {ua: "HTC One XL"}],
                    dpi: [315.3, 314.6],
                    bw: 3,
                    ac: 1E3
                }, {
                    type: "android",
                    rules: [{mdmh: "htc/*/Nexus 9/*"}, {ua: "Nexus 9"}],
                    dpi: 289,
                    bw: 3,
                    ac: 500
                }, {
                    type: "android",
                    rules: [{mdmh: "HTC/*/HTC One M9/*"}, {ua: "HTC One M9"}],
                    dpi: [442.5, 443.3],
                    bw: 3,
                    ac: 500
                },
                    {
                        type: "android",
                        rules: [{mdmh: "HTC/*/HTC One_M8/*"}, {ua: "HTC One_M8"}],
                        dpi: [449.7, 447.4],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "HTC/*/HTC One/*"}, {ua: "HTC One"}],
                        dpi: 472.8,
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Huawei/*/Nexus 6P/*"}, {ua: "Nexus 6P"}],
                        dpi: [515.1, 518],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Huawei/*/BLN-L24/*"}, {ua: "HONORBLN-L24"}],
                        dpi: 480,
                        bw: 4,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "Huawei/*/BKL-L09/*"}, {ua: "BKL-L09"}],
                        dpi: 403,
                        bw: 3.47,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "LENOVO/*/Lenovo PB2-690Y/*"},
                            {ua: "Lenovo PB2-690Y"}], dpi: [457.2, 454.713], bw: 3, ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/Nexus 5X/*"}, {ua: "Nexus 5X"}],
                        dpi: [422, 419.9],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LGMS345/*"}, {ua: "LGMS345"}],
                        dpi: [221.7, 219.1],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LG-D800/*"}, {ua: "LG-D800"}],
                        dpi: [422, 424.1],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LG-D850/*"}, {ua: "LG-D850"}],
                        dpi: [537.9, 541.9],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "LGE/*/VS985 4G/*"}, {ua: "VS985 4G"}],
                        dpi: [537.9, 535.6], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/Nexus 5/*"}, {ua: "Nexus 5 B"}],
                        dpi: [442.4, 444.8],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/Nexus 4/*"}, {ua: "Nexus 4"}],
                        dpi: [319.8, 318.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LG-P769/*"}, {ua: "LG-P769"}],
                        dpi: [240.6, 247.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LGMS323/*"}, {ua: "LGMS323"}],
                        dpi: [206.6, 204.6],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "LGE/*/LGLS996/*"}, {ua: "LGLS996"}],
                        dpi: [403.4, 401.5],
                        bw: 3,
                        ac: 1E3
                    },
                    {
                        type: "android",
                        rules: [{mdmh: "Micromax/*/4560MMX/*"}, {ua: "4560MMX"}],
                        dpi: [240, 219.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Micromax/*/A250/*"}, {ua: "Micromax A250"}],
                        dpi: [480, 446.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Micromax/*/Micromax AQ4501/*"}, {ua: "Micromax AQ4501"}],
                        dpi: 240,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/G5/*"}, {ua: "Moto G (5) Plus"}],
                        dpi: [403.4, 403],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/DROID RAZR/*"}, {ua: "DROID RAZR"}],
                        dpi: [368.1, 256.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT830C/*"}, {ua: "XT830C"}],
                        dpi: [254, 255.9],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1021/*"}, {ua: "XT1021"}],
                        dpi: [254, 256.7],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1023/*"}, {ua: "XT1023"}],
                        dpi: [254, 256.7],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1028/*"}, {ua: "XT1028"}],
                        dpi: [326.6, 327.6],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1034/*"}, {ua: "XT1034"}],
                        dpi: [326.6, 328.4],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1053/*"}, {ua: "XT1053"}], dpi: [315.3, 316.1], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1562/*"}, {ua: "XT1562"}],
                        dpi: [403.4, 402.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/Nexus 6/*"}, {ua: "Nexus 6 B"}],
                        dpi: [494.3, 489.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1063/*"}, {ua: "XT1063"}],
                        dpi: [295, 296.6],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1064/*"}, {ua: "XT1064"}],
                        dpi: [295, 295.6],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "motorola/*/XT1092/*"},
                            {ua: "XT1092"}], dpi: [422, 424.1], bw: 3, ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/XT1095/*"}, {ua: "XT1095"}],
                        dpi: [422, 423.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "motorola/*/G4/*"}, {ua: "Moto G (4)"}],
                        dpi: 401,
                        bw: 4,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/A0001/*"}, {ua: "A0001"}],
                        dpi: [403.4, 401],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE E1001/*"}, {ua: "ONE E1001"}],
                        dpi: [442.4, 441.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "OnePlus/*/ONE E1003/*"}, {ua: "ONE E1003"}], dpi: [442.4,
                            441.4], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE E1005/*"}, {ua: "ONE E1005"}],
                        dpi: [442.4, 441.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE A2001/*"}, {ua: "ONE A2001"}],
                        dpi: [391.9, 405.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE A2003/*"}, {ua: "ONE A2003"}],
                        dpi: [391.9, 405.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE A2005/*"}, {ua: "ONE A2005"}],
                        dpi: [391.9, 405.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "OnePlus/*/ONEPLUS A3000/*"}, {ua: "ONEPLUS A3000"}],
                        dpi: 401, bw: 3, ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A3003/*"}, {ua: "ONEPLUS A3003"}],
                        dpi: 401,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A3010/*"}, {ua: "ONEPLUS A3010"}],
                        dpi: 401,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A5000/*"}, {ua: "ONEPLUS A5000 "}],
                        dpi: [403.411, 399.737],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONE A5010/*"}, {ua: "ONEPLUS A5010"}],
                        dpi: [403, 400],
                        bw: 2,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "OnePlus/*/ONEPLUS A6000/*"}, {ua: "ONEPLUS A6000"}],
                        dpi: 401, bw: 3, ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6003/*"}, {ua: "ONEPLUS A6003"}],
                        dpi: 401,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6010/*"}, {ua: "ONEPLUS A6010"}],
                        dpi: 401,
                        bw: 2,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OnePlus/*/ONEPLUS A6013/*"}, {ua: "ONEPLUS A6013"}],
                        dpi: 401,
                        bw: 2,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "OPPO/*/X909/*"}, {ua: "X909"}],
                        dpi: [442.4, 444.1],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "samsung/*/GT-I9082/*"}, {ua: "GT-I9082"}], dpi: [184.7, 185.4],
                        bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G360P/*"}, {ua: "SM-G360P"}],
                        dpi: [196.7, 205.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/Nexus S/*"}, {ua: "Nexus S"}],
                        dpi: [234.5, 229.8],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/GT-I9300/*"}, {ua: "GT-I9300"}],
                        dpi: [304.8, 303.9],
                        bw: 5,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-T230NU/*"}, {ua: "SM-T230NU"}],
                        dpi: 216,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SGH-T399/*"}, {ua: "SGH-T399"}],
                        dpi: [217.7, 231.4],
                        bw: 3,
                        ac: 1E3
                    },
                    {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SGH-M919/*"}, {ua: "SGH-M919"}],
                        dpi: [440.8, 437.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N9005/*"}, {ua: "SM-N9005"}],
                        dpi: [386.4, 387],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SAMSUNG-SM-N900A/*"}, {ua: "SAMSUNG-SM-N900A"}],
                        dpi: [386.4, 387.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/GT-I9500/*"}, {ua: "GT-I9500"}],
                        dpi: [442.5, 443.3],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "samsung/*/GT-I9505/*"}, {ua: "GT-I9505"}], dpi: 439.4, bw: 4,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G900F/*"}, {ua: "SM-G900F"}],
                        dpi: [415.6, 431.6],
                        bw: 5,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G900M/*"}, {ua: "SM-G900M"}],
                        dpi: [415.6, 431.6],
                        bw: 5,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G800F/*"}, {ua: "SM-G800F"}],
                        dpi: 326.8,
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G906S/*"}, {ua: "SM-G906S"}],
                        dpi: [562.7, 572.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/GT-I9300/*"}, {ua: "GT-I9300"}],
                        dpi: [306.7, 304.8],
                        bw: 5,
                        ac: 1E3
                    },
                    {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-T535/*"}, {ua: "SM-T535"}],
                        dpi: [142.6, 136.4],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N920C/*"}, {ua: "SM-N920C"}],
                        dpi: [515.1, 518.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N920P/*"}, {ua: "SM-N920P"}],
                        dpi: [386.3655, 390.144],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N920W8/*"}, {ua: "SM-N920W8"}],
                        dpi: [515.1, 518.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/GT-I9300I/*"}, {ua: "GT-I9300I"}],
                        dpi: [304.8, 305.8],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/GT-I9195/*"}, {ua: "GT-I9195"}],
                        dpi: [249.4, 256.7],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SPH-L520/*"}, {ua: "SPH-L520"}],
                        dpi: [249.4, 255.9],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SAMSUNG-SGH-I717/*"}, {ua: "SAMSUNG-SGH-I717"}],
                        dpi: 285.8,
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SPH-D710/*"}, {ua: "SPH-D710"}],
                        dpi: [217.7, 204.2],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "samsung/*/GT-N7100/*"}, {ua: "GT-N7100"}], dpi: 265.1, bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SCH-I605/*"}, {ua: "SCH-I605"}],
                        dpi: 265.1,
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/Galaxy Nexus/*"}, {ua: "Galaxy Nexus"}],
                        dpi: [315.3, 314.2],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N910H/*"}, {ua: "SM-N910H"}],
                        dpi: [515.1, 518],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-N910C/*"}, {ua: "SM-N910C"}],
                        dpi: [515.2, 520.2],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G130M/*"}, {ua: "SM-G130M"}],
                        dpi: [165.9, 164.8],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G928I/*"}, {ua: "SM-G928I"}],
                        dpi: [515.1, 518.4],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G920F/*"}, {ua: "SM-G920F"}],
                        dpi: 580.6,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G920P/*"}, {ua: "SM-G920P"}],
                        dpi: [522.5, 577],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G925F/*"}, {ua: "SM-G925F"}],
                        dpi: 580.6,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G925V/*"}, {ua: "SM-G925V"}],
                        dpi: [522.5, 576.6],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G930F/*"}, {ua: "SM-G930F"}], dpi: 576.6, bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G935F/*"}, {ua: "SM-G935F"}],
                        dpi: 533,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G950F/*"}, {ua: "SM-G950F"}],
                        dpi: [562.707, 565.293],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G955U/*"}, {ua: "SM-G955U"}],
                        dpi: [522.514, 525.762],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G955F/*"}, {ua: "SM-G955F"}],
                        dpi: [522.514, 525.762],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "samsung/*/SM-G960F/*"},
                            {ua: "SM-G960F"}], dpi: [569.575, 571.5], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G9600/*"}, {ua: "SM-G9600"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G960T/*"}, {ua: "SM-G960T"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G960N/*"}, {ua: "SM-G960N"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G960U/*"}, {ua: "SM-G960U"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "samsung/*/SM-G9608/*"},
                            {ua: "SM-G9608"}], dpi: [569.575, 571.5], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G960FD/*"}, {ua: "SM-G960FD"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G960W/*"}, {ua: "SM-G960W"}],
                        dpi: [569.575, 571.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G965F/*"}, {ua: "SM-G965F"}],
                        dpi: 529,
                        bw: 2,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Sony/*/C6903/*"}, {ua: "C6903"}],
                        dpi: [442.5, 443.3],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android", rules: [{mdmh: "Sony/*/D6653/*"}, {ua: "D6653"}],
                        dpi: [428.6, 427.6], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Sony/*/E6653/*"}, {ua: "E6653"}],
                        dpi: [428.6, 425.7],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Sony/*/E6853/*"}, {ua: "E6853"}],
                        dpi: [403.4, 401.9],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Sony/*/SGP321/*"}, {ua: "SGP321"}],
                        dpi: [224.7, 224.1],
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "TCT/*/ALCATEL ONE TOUCH Fierce/*"}, {ua: "ALCATEL ONE TOUCH Fierce"}],
                        dpi: [240, 247.5],
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android", rules: [{mdmh: "THL/*/thl 5000/*"}, {ua: "thl 5000"}],
                        dpi: [480, 443.3], bw: 3, ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Fly/*/IQ4412/*"}, {ua: "IQ4412"}],
                        dpi: 307.9,
                        bw: 3,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "ZTE/*/ZTE Blade L2/*"}, {ua: "ZTE Blade L2"}],
                        dpi: 240,
                        bw: 3,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "BENEVE/*/VR518/*"}, {ua: "VR518"}],
                        dpi: 480,
                        bw: 3,
                        ac: 500
                    }, {type: "ios", rules: [{res: [640, 960]}], dpi: [325.1, 328.4], bw: 4, ac: 1E3}, {
                        type: "ios",
                        rules: [{res: [640, 1136]}],
                        dpi: [317.1, 320.2],
                        bw: 3,
                        ac: 1E3
                    }, {type: "ios", rules: [{res: [750, 1334]}], dpi: 326.4, bw: 4, ac: 1E3}, {
                        type: "ios", rules: [{
                            res: [1242,
                                2208]
                        }], dpi: [453.6, 458.4], bw: 4, ac: 1E3
                    }, {type: "ios", rules: [{res: [1125, 2001]}], dpi: [410.9, 415.4], bw: 4, ac: 1E3}, {
                        type: "ios",
                        rules: [{res: [1125, 2436]}],
                        dpi: 458,
                        bw: 4,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "Huawei/*/EML-L29/*"}, {ua: "EML-L29"}],
                        dpi: 428,
                        bw: 3.45,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "Nokia/*/Nokia 7.1/*"}, {ua: "Nokia 7.1"}],
                        dpi: [432, 431.9],
                        bw: 3,
                        ac: 500
                    }, {type: "ios", rules: [{res: [1242, 2688]}], dpi: 458, bw: 4, ac: 1E3}, {
                        type: "android", rules: [{mdmh: "samsung/*/SM-G570M/*"}, {ua: "SM-G570M"}], dpi: 320, bw: 3.684,
                        ac: 1E3
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G970F/*"}, {ua: "SM-G970F"}],
                        dpi: 438,
                        bw: 2.281,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G973F/*"}, {ua: "SM-G973F"}],
                        dpi: 550,
                        bw: 2.002,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G975F/*"}, {ua: "SM-G975F"}],
                        dpi: 522,
                        bw: 2.054,
                        ac: 500
                    }, {
                        type: "android",
                        rules: [{mdmh: "samsung/*/SM-G977F/*"}, {ua: "SM-G977F"}],
                        dpi: 505,
                        bw: 2.334,
                        ac: 500
                    }, {type: "ios", rules: [{res: [828, 1792]}], dpi: 326, bw: 5, ac: 500}]
            };
            g.prototype.getDeviceParams = function () {
                return this.deviceParams
            };
            g.prototype.recalculateDeviceParams_ = function () {
                var a = this.calcDeviceParams_();
                if (a) {
                    if (this.deviceParams = a, this.onDeviceParamsUpdated)this.onDeviceParamsUpdated(this.deviceParams)
                } else console.error("Failed to recalculate device parameters.")
            };
            g.prototype.calcDeviceParams_ = function () {
                var a = this.dpdb;
                if (!a)return console.error("DPDB not available."), null;
                if (1 != a.format)return console.error("DPDB has unexpected format version."), null;
                if (!a.devices || !a.devices.length)return console.error("DPDB does not have a devices section."),
                    null;
                var b = navigator.userAgent || navigator.vendor || window.opera, c = ma(), d = E();
                if (!a.devices)return console.error("DPDB has no devices section."), null;
                for (var f = 0; f < a.devices.length; f++) {
                    var e = a.devices[f];
                    if (!e.rules)console.warn("Device[" + f + "] has no rules section."); else if ("ios" != e.type && "android" != e.type)console.warn("Device[" + f + "] has invalid type."); else if (v() == ("ios" == e.type)) {
                        for (var g = !1, h = 0; h < e.rules.length; h++)if (this.ruleMatches_(e.rules[h], b, c, d)) {
                            g = !0;
                            break
                        }
                        if (g)return new k({
                            xdpi: e.dpi[0] ||
                            e.dpi, ydpi: e.dpi[1] || e.dpi, bevelMm: e.bw
                        })
                    }
                }
                console.warn("No DPDB device match.");
                return null
            };
            g.prototype.ruleMatches_ = function (a, b, c, d) {
                if (!a.ua && !a.res)return !1;
                a.ua && "SM" === a.ua.substring(0, 2) && (a.ua = a.ua.substring(0, 7));
                if (a.ua && 0 > b.indexOf(a.ua))return !1;
                if (a.res) {
                    if (!a.res[0] || !a.res[1])return !1;
                    b = a.res[0];
                    a = a.res[1];
                    if (Math.min(c, d) != Math.min(b, a) || Math.max(c, d) != Math.max(b, a))return !1
                }
                return !0
            };
            h.prototype.set = function (a, b) {
                this.sample = a;
                this.timestampS = b
            };
            h.prototype.copy = function (a) {
                this.set(a.sample,
                    a.timestampS)
            };
            m.prototype.addAccelMeasurement = function (a, b) {
                this.currentAccelMeasurement.set(a, b)
            };
            m.prototype.addGyroMeasurement = function (a, b) {
                this.currentGyroMeasurement.set(a, b);
                a = b - this.previousGyroMeasurement.timestampS;
                isNaN(a) || .001 >= a || 1 < a || this.run_();
                this.previousGyroMeasurement.copy(this.currentGyroMeasurement)
            };
            m.prototype.run_ = function () {
                if (this.isOrientationInitialized) {
                    var a = this.gyroToQuaternionDelta_(this.currentGyroMeasurement.sample, this.currentGyroMeasurement.timestampS - this.previousGyroMeasurement.timestampS);
                    this.gyroIntegralQ.multiply(a);
                    this.filterQ.copy(this.previousFilterQ);
                    this.filterQ.multiply(a);
                    a = new J;
                    a.copy(this.filterQ);
                    a.inverse();
                    this.estimatedGravity.set(0, 0, -1);
                    this.estimatedGravity.applyQuaternion(a);
                    this.estimatedGravity.normalize();
                    this.measuredGravity.copy(this.currentAccelMeasurement.sample);
                    this.measuredGravity.normalize();
                    a = new J;
                    a.setFromUnitVectors(this.estimatedGravity, this.measuredGravity);
                    a.inverse();
                    this.isDebug && console.log("Delta: %d deg, G_est: (%s, %s, %s), G_meas: (%s, %s, %s)",
                        L * N(a), this.estimatedGravity.x.toFixed(1), this.estimatedGravity.y.toFixed(1), this.estimatedGravity.z.toFixed(1), this.measuredGravity.x.toFixed(1), this.measuredGravity.y.toFixed(1), this.measuredGravity.z.toFixed(1));
                    var b = new J;
                    b.copy(this.filterQ);
                    b.multiply(a);
                    this.filterQ.slerp(b, 1 - this.kFilter);
                    this.previousFilterQ.copy(this.filterQ)
                } else this.accelQ = this.accelToQuaternion_(this.currentAccelMeasurement.sample), this.previousFilterQ.copy(this.accelQ), this.isOrientationInitialized = !0
            };
            m.prototype.getOrientation =
                function () {
                    return this.filterQ
                };
            m.prototype.accelToQuaternion_ = function (a) {
                var b = new U;
                b.copy(a);
                b.normalize();
                a = new J;
                a.setFromUnitVectors(new U(0, 0, -1), b);
                a.inverse();
                return a
            };
            m.prototype.gyroToQuaternionDelta_ = function (a, b) {
                var c = new J, d = new U;
                d.copy(a);
                d.normalize();
                c.setFromAxisAngle(d, a.length() * b);
                return c
            };
            l.prototype.getPrediction = function (a, b, c) {
                if (!this.previousTimestampS)return this.previousQ.copy(a), this.previousTimestampS = c, a;
                var d = new U;
                d.copy(b);
                d.normalize();
                b = b.length();
                if (b < 20 *
                    S)return this.isDebug && console.log("Moving slowly, at %s deg/s: no prediction", (L * b).toFixed(1)), this.outQ.copy(a), this.previousQ.copy(a), this.outQ;
                this.deltaQ.setFromAxisAngle(d, b * this.predictionTimeS);
                this.outQ.copy(this.previousQ);
                this.outQ.multiply(this.deltaQ);
                this.previousQ.copy(a);
                this.previousTimestampS = c;
                return this.outQ
            };
            n.prototype.getPosition = function () {
                return null
            };
            n.prototype.getOrientation = function () {
                var a = void 0;
                if (this.isWithoutDeviceMotion && this._deviceOrientationQ) {
                    this.deviceOrientationFixQ =
                        this.deviceOrientationFixQ || function () {
                            var a = (new J).setFromAxisAngle(new U(0, 0, -1), 0), b = new J;
                            -90 === window.orientation ? b.setFromAxisAngle(new U(0, 1, 0), Math.PI / -2) : b.setFromAxisAngle(new U(0, 1, 0), Math.PI / 2);
                            return a.multiply(b)
                        }();
                    this.deviceOrientationFilterToWorldQ = this.deviceOrientationFilterToWorldQ || function () {
                            var a = new J;
                            a.setFromAxisAngle(new U(1, 0, 0), -Math.PI / 2);
                            return a
                        }();
                    a = this._deviceOrientationQ;
                    var b = new J;
                    b.copy(a);
                    b.multiply(this.deviceOrientationFilterToWorldQ);
                    b.multiply(this.resetQ);
                    b.multiply(this.worldToScreenQ);
                    b.multiplyQuaternions(this.deviceOrientationFixQ, b);
                    this.yawOnly && (b.x = 0, b.z = 0, b.normalize());
                    this.orientationOut_[0] = b.x;
                    this.orientationOut_[1] = b.y;
                    this.orientationOut_[2] = b.z;
                    this.orientationOut_[3] = b.w;
                    return this.orientationOut_
                }
                a = this.filter.getOrientation();
                a = this.posePredictor.getPrediction(a, this.gyroscope, this.previousTimestampS);
                b = new J;
                b.copy(this.filterToWorldQ);
                b.multiply(this.resetQ);
                b.multiply(a);
                b.multiply(this.worldToScreenQ);
                this.yawOnly && (b.x = 0,
                    b.z = 0, b.normalize());
                this.orientationOut_[0] = b.x;
                this.orientationOut_[1] = b.y;
                this.orientationOut_[2] = b.z;
                this.orientationOut_[3] = b.w;
                return this.orientationOut_
            };
            n.prototype.resetPose = function () {
                this.resetQ.copy(this.filter.getOrientation());
                this.resetQ.x = 0;
                this.resetQ.y = 0;
                this.resetQ.z *= -1;
                this.resetQ.normalize();
                F() && this.resetQ.multiply(this.inverseWorldToScreenQ);
                this.resetQ.multiply(this.originalPoseAdjustQ)
            };
            n.prototype.onDeviceOrientation_ = function (a) {
                this._deviceOrientationQ = this._deviceOrientationQ ||
                    new J;
                var b = a.alpha, c = a.beta;
                a = a.gamma;
                b = (b || 0) * Math.PI / 180;
                c = (c || 0) * Math.PI / 180;
                a = (a || 0) * Math.PI / 180;
                this._deviceOrientationQ.setFromEulerYXZ(c, b, -a)
            };
            n.prototype.onDeviceMotion_ = function (a) {
                this.updateDeviceMotion_(a)
            };
            n.prototype.updateDeviceMotion_ = function (a) {
                var b = a.accelerationIncludingGravity, c = a.rotationRate;
                a = a.timeStamp / 1E3;
                var d = a - this.previousTimestampS;
                0 > d ? ja("fusion-pose-sensor:invalid:non-monotonic", "Invalid timestamps detected: non-monotonic timestamp from devicemotion") : .001 >= d ||
                1 < d ? ja("fusion-pose-sensor:invalid:outside-threshold", "Invalid timestamps detected: Timestamp from devicemotion outside expected range.") : (this.accelerometer.set(-b.x, -b.y, -b.z), c && (Z() ? this.gyroscope.set(-c.beta, c.alpha, c.gamma) : this.gyroscope.set(c.alpha, c.beta, c.gamma), this.isDeviceMotionInRadians || this.gyroscope.multiplyScalar(Math.PI / 180), this.filter.addGyroMeasurement(this.gyroscope, a)), this.filter.addAccelMeasurement(this.accelerometer, a));
                this.previousTimestampS = a
            };
            n.prototype.onOrientationChange_ =
                function (a) {
                    this.setScreenTransform_()
                };
            n.prototype.onMessage_ = function (a) {
                (a = a.data) && a.type && "devicemotion" === a.type.toLowerCase() && this.updateDeviceMotion_(a.deviceMotionEvent)
            };
            n.prototype.setScreenTransform_ = function () {
                this.worldToScreenQ.set(0, 0, 0, 1);
                switch (window.orientation) {
                    case 90:
                        this.worldToScreenQ.setFromAxisAngle(new U(0, 0, 1), -Math.PI / 2);
                        break;
                    case -90:
                        this.worldToScreenQ.setFromAxisAngle(new U(0, 0, 1), Math.PI / 2)
                }
                this.inverseWorldToScreenQ.copy(this.worldToScreenQ);
                this.inverseWorldToScreenQ.inverse()
            };
            n.prototype.start = function () {
                this.onDeviceMotionCallback_ = this.onDeviceMotion_.bind(this);
                this.onOrientationChangeCallback_ = this.onOrientationChange_.bind(this);
                this.onMessageCallback_ = this.onMessage_.bind(this);
                this.onDeviceOrientationCallback_ = this.onDeviceOrientation_.bind(this);
                var a;
                if (a = v()) {
                    a = window.self !== window.top;
                    var b = O(document.referrer), c = O(window.location.href);
                    a = a && b !== c
                }
                a && window.addEventListener("message", this.onMessageCallback_);
                window.addEventListener("orientationchange", this.onOrientationChangeCallback_);
                this.isWithoutDeviceMotion ? window.addEventListener("deviceorientation", this.onDeviceOrientationCallback_) : window.addEventListener("devicemotion", this.onDeviceMotionCallback_)
            };
            n.prototype.stop = function () {
                window.removeEventListener("devicemotion", this.onDeviceMotionCallback_);
                window.removeEventListener("deviceorientation", this.onDeviceOrientationCallback_);
                window.removeEventListener("orientationchange", this.onOrientationChangeCallback_);
                window.removeEventListener("message", this.onMessageCallback_)
            };
            var Ka = new U(1, 0, 0), X = new U(0, 0, 1), la = new J;
            la.setFromAxisAngle(Ka, -Math.PI / 2);
            la.multiply((new J).setFromAxisAngle(X, Math.PI / 2));
            var G = function () {
                function a(b) {
                    if (!(this instanceof a))throw new TypeError("Cannot call a class as a function");
                    this.config = b;
                    this.fusionSensor = this.sensor = null;
                    this._out = new Float32Array(4);
                    this.api = null;
                    this.errors = [];
                    this._sensorQ = new J;
                    this._outQ = new J;
                    this._onSensorRead = this._onSensorRead.bind(this);
                    this._onSensorError = this._onSensorError.bind(this);
                    this.init()
                }

                x(a,
                    [{
                        key: "init", value: function () {
                            var a = null;
                            try {
                                a = new RelativeOrientationSensor({
                                    frequency: 60,
                                    referenceFrame: "screen"
                                }), a.addEventListener("error", this._onSensorError)
                            } catch (Fa) {
                                this.errors.push(Fa), "SecurityError" === Fa.name ? (console.error("Cannot construct sensors due to the Feature Policy"), console.warn('Attempting to fall back using "devicemotion"; however this will fail in the future without correct permissions.'), this.useDeviceMotion()) : "ReferenceError" === Fa.name ? this.useDeviceMotion() : console.error(Fa)
                            }
                            a &&
                            (this.api = "sensor", this.sensor = a, this.sensor.addEventListener("reading", this._onSensorRead), this.sensor.start())
                        }
                    }, {
                        key: "useDeviceMotion", value: function () {
                            this.api = "devicemotion";
                            this.fusionSensor = new n(this.config.K_FILTER, this.config.PREDICTION_TIME_S, this.config.YAW_ONLY, this.config.DEBUG);
                            this.sensor && (this.sensor.removeEventListener("reading", this._onSensorRead), this.sensor.removeEventListener("error", this._onSensorError), this.sensor = null)
                        }
                    }, {
                        key: "getOrientation", value: function () {
                            if (this.fusionSensor)return this.fusionSensor.getOrientation();
                            if (!this.sensor || !this.sensor.quaternion)return this._out[0] = this._out[1] = this._out[2] = 0, this._out[3] = 1, this._out;
                            var a = this.sensor.quaternion;
                            this._sensorQ.set(a[0], a[1], a[2], a[3]);
                            a = this._outQ;
                            a.copy(la);
                            a.multiply(this._sensorQ);
                            this.config.YAW_ONLY && (a.x = a.z = 0, a.normalize());
                            this._out[0] = a.x;
                            this._out[1] = a.y;
                            this._out[2] = a.z;
                            this._out[3] = a.w;
                            return this._out
                        }
                    }, {
                        key: "_onSensorError", value: function (a) {
                            this.errors.push(a.error);
                            "NotAllowedError" === a.error.name ? console.error("Permission to access sensor was denied") :
                                "NotReadableError" === a.error.name ? console.error("Sensor could not be read") : console.error(a.error);
                            this.useDeviceMotion()
                        }
                    }, {
                        key: "_onSensorRead", value: function () {
                        }
                    }]);
                return a
            }();
            q.prototype.show = function (a) {
                a || this.overlay.parentElement ? a && (this.overlay.parentElement && this.overlay.parentElement != a && this.overlay.parentElement.removeChild(this.overlay), a.appendChild(this.overlay)) : document.body.appendChild(this.overlay);
                this.overlay.style.display = "block";
                a = this.overlay.querySelector("img").style;
                F() ?
                    (a.width = "20%", a.marginLeft = "40%", a.marginTop = "3%") : (a.width = "50%", a.marginLeft = "25%", a.marginTop = "25%")
            };
            q.prototype.hide = function () {
                this.overlay.style.display = "none"
            };
            q.prototype.showTemporarily = function (a, b) {
                this.show(b);
                this.timer = setTimeout(this.hide.bind(this), a)
            };
            q.prototype.disableShowTemporarily = function () {
                clearTimeout(this.timer)
            };
            q.prototype.update = function () {
                this.disableShowTemporarily();
                !F() && P() ? this.show() : this.hide()
            };
            q.prototype.loadIcon_ = function () {
                this.icon = "data:image/svg+xml," +
                    encodeURIComponent("<svg width='198' height='240' viewBox='0 0 198 240' xmlns='http://www.w3.org/2000/svg'><g fill='none' fill-rule='evenodd'><path d='M149.625 109.527l6.737 3.891v.886c0 .177.013.36.038.549.01.081.02.162.027.242.14 1.415.974 2.998 2.105 3.999l5.72 5.062.081-.09s4.382-2.53 5.235-3.024l25.97 14.993v54.001c0 .771-.386 1.217-.948 1.217-.233 0-.495-.076-.772-.236l-23.967-13.838-.014.024-27.322 15.775-.85-1.323c-4.731-1.529-9.748-2.74-14.951-3.61a.27.27 0 0 0-.007.024l-5.067 16.961-7.891 4.556-.037-.063v27.59c0 .772-.386 1.217-.948 1.217-.232 0-.495-.076-.772-.236l-42.473-24.522c-.95-.549-1.72-1.877-1.72-2.967v-1.035l-.021.047a5.111 5.111 0 0 0-1.816-.399 5.682 5.682 0 0 0-.546.001 13.724 13.724 0 0 1-1.918-.041c-1.655-.153-3.2-.6-4.404-1.296l-46.576-26.89.005.012-10.278-18.75c-1.001-1.827-.241-4.216 1.698-5.336l56.011-32.345a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.659 3.227 1.853l.005-.003.227.413-.006.004a9.63 9.63 0 0 0 1.477 2.018l.277.27c1.914 1.85 4.468 2.801 7.113 2.801 1.949 0 3.948-.517 5.775-1.572.013 0 7.319-4.219 7.319-4.219a4.194 4.194 0 0 1 2.099-.572c1.326 0 2.572.658 3.226 1.853l3.25 5.928.022-.018 6.785 3.917-.105-.182 46.881-26.965m0-1.635c-.282 0-.563.073-.815.218l-46.169 26.556-5.41-3.124-3.005-5.481c-.913-1.667-2.699-2.702-4.66-2.703-1.011 0-2.02.274-2.917.792a3825 3825 0 0 1-7.275 4.195l-.044.024a9.937 9.937 0 0 1-4.957 1.353c-2.292 0-4.414-.832-5.976-2.342l-.252-.245a7.992 7.992 0 0 1-1.139-1.534 1.379 1.379 0 0 0-.06-.122l-.227-.414a1.718 1.718 0 0 0-.095-.154c-.938-1.574-2.673-2.545-4.571-2.545-1.011 0-2.02.274-2.917.792L3.125 155.502c-2.699 1.559-3.738 4.94-2.314 7.538l10.278 18.75c.177.323.448.563.761.704l46.426 26.804c1.403.81 3.157 1.332 5.072 1.508a15.661 15.661 0 0 0 2.146.046 4.766 4.766 0 0 1 .396 0c.096.004.19.011.283.022.109 1.593 1.159 3.323 2.529 4.114l42.472 24.522c.524.302 1.058.455 1.59.455 1.497 0 2.583-1.2 2.583-2.852v-26.562l7.111-4.105a1.64 1.64 0 0 0 .749-.948l4.658-15.593c4.414.797 8.692 1.848 12.742 3.128l.533.829a1.634 1.634 0 0 0 2.193.531l26.532-15.317L193 192.433c.523.302 1.058.455 1.59.455 1.497 0 2.583-1.199 2.583-2.852v-54.001c0-.584-.312-1.124-.818-1.416l-25.97-14.993a1.633 1.633 0 0 0-1.636.001c-.606.351-2.993 1.73-4.325 2.498l-4.809-4.255c-.819-.725-1.461-1.933-1.561-2.936a7.776 7.776 0 0 0-.033-.294 2.487 2.487 0 0 1-.023-.336v-.886c0-.584-.312-1.123-.817-1.416l-6.739-3.891a1.633 1.633 0 0 0-.817-.219' fill='#455A64'/><path d='M96.027 132.636l46.576 26.891c1.204.695 1.979 1.587 2.242 2.541l-.01.007-81.374 46.982h-.001c-1.654-.152-3.199-.6-4.403-1.295l-46.576-26.891 83.546-48.235' fill='#FAFAFA'/><path d='M63.461 209.174c-.008 0-.015 0-.022-.002-1.693-.156-3.228-.609-4.441-1.309l-46.576-26.89a.118.118 0 0 1 0-.203l83.546-48.235a.117.117 0 0 1 .117 0l46.576 26.891c1.227.708 2.021 1.612 2.296 2.611a.116.116 0 0 1-.042.124l-.021.016-81.375 46.981a.11.11 0 0 1-.058.016zm-50.747-28.303l46.401 26.79c1.178.68 2.671 1.121 4.32 1.276l81.272-46.922c-.279-.907-1.025-1.73-2.163-2.387l-46.517-26.857-83.313 48.1z' fill='#607D8B'/><path d='M148.327 165.471a5.85 5.85 0 0 1-.546.001c-1.894-.083-3.302-1.038-3.145-2.132a2.693 2.693 0 0 0-.072-1.105l-81.103 46.822c.628.058 1.272.073 1.918.042.182-.009.364-.009.546-.001 1.894.083 3.302 1.038 3.145 2.132l79.257-45.759' fill='#FFF'/><path d='M69.07 211.347a.118.118 0 0 1-.115-.134c.045-.317-.057-.637-.297-.925-.505-.61-1.555-1.022-2.738-1.074a5.966 5.966 0 0 0-.535.001 14.03 14.03 0 0 1-1.935-.041.117.117 0 0 1-.103-.092.116.116 0 0 1 .055-.126l81.104-46.822a.117.117 0 0 1 .171.07c.104.381.129.768.074 1.153-.045.316.057.637.296.925.506.61 1.555 1.021 2.739 1.073.178.008.357.008.535-.001a.117.117 0 0 1 .064.218l-79.256 45.759a.114.114 0 0 1-.059.016zm-3.405-2.372c.089 0 .177.002.265.006 1.266.056 2.353.488 2.908 1.158.227.274.35.575.36.882l78.685-45.429c-.036 0-.072-.001-.107-.003-1.267-.056-2.354-.489-2.909-1.158-.282-.34-.402-.724-.347-1.107a2.604 2.604 0 0 0-.032-.91L63.846 208.97a13.91 13.91 0 0 0 1.528.012c.097-.005.194-.007.291-.007z' fill='#607D8B'/><path d='M2.208 162.134c-1.001-1.827-.241-4.217 1.698-5.337l56.011-32.344c1.939-1.12 4.324-.546 5.326 1.281l.232.41a9.344 9.344 0 0 0 1.47 2.021l.278.27c3.325 3.214 8.583 3.716 12.888 1.23l7.319-4.22c1.94-1.119 4.324-.546 5.325 1.282l3.25 5.928-83.519 48.229-10.278-18.75z' fill='#FAFAFA'/><path d='M12.486 181.001a.112.112 0 0 1-.031-.005.114.114 0 0 1-.071-.056L2.106 162.19c-1.031-1.88-.249-4.345 1.742-5.494l56.01-32.344a4.328 4.328 0 0 1 2.158-.588c1.415 0 2.65.702 3.311 1.882.01.008.018.017.024.028l.227.414a.122.122 0 0 1 .013.038 9.508 9.508 0 0 0 1.439 1.959l.275.266c1.846 1.786 4.344 2.769 7.031 2.769 1.977 0 3.954-.538 5.717-1.557a.148.148 0 0 1 .035-.013l7.284-4.206a4.321 4.321 0 0 1 2.157-.588c1.427 0 2.672.716 3.329 1.914l3.249 5.929a.116.116 0 0 1-.044.157l-83.518 48.229a.116.116 0 0 1-.059.016zm49.53-57.004c-.704 0-1.41.193-2.041.557l-56.01 32.345c-1.882 1.086-2.624 3.409-1.655 5.179l10.221 18.645 83.317-48.112-3.195-5.829c-.615-1.122-1.783-1.792-3.124-1.792a4.08 4.08 0 0 0-2.04.557l-7.317 4.225a.148.148 0 0 1-.035.013 11.7 11.7 0 0 1-5.801 1.569c-2.748 0-5.303-1.007-7.194-2.835l-.278-.27a9.716 9.716 0 0 1-1.497-2.046.096.096 0 0 1-.013-.037l-.191-.347a.11.11 0 0 1-.023-.029c-.615-1.123-1.783-1.793-3.124-1.793z' fill='#607D8B'/><path d='M42.434 155.808c-2.51-.001-4.697-1.258-5.852-3.365-1.811-3.304-.438-7.634 3.059-9.654l12.291-7.098a7.599 7.599 0 0 1 3.789-1.033c2.51 0 4.697 1.258 5.852 3.365 1.811 3.304.439 7.634-3.059 9.654l-12.291 7.098a7.606 7.606 0 0 1-3.789 1.033zm13.287-20.683a7.128 7.128 0 0 0-3.555.971l-12.291 7.098c-3.279 1.893-4.573 5.942-2.883 9.024 1.071 1.955 3.106 3.122 5.442 3.122a7.13 7.13 0 0 0 3.556-.97l12.291-7.098c3.279-1.893 4.572-5.942 2.883-9.024-1.072-1.955-3.106-3.123-5.443-3.123z' fill='#607D8B'/><path d='M149.588 109.407l6.737 3.89v.887c0 .176.013.36.037.549.011.081.02.161.028.242.14 1.415.973 2.998 2.105 3.999l7.396 6.545c.177.156.358.295.541.415 1.579 1.04 2.95.466 3.062-1.282.049-.784.057-1.595.023-2.429l-.003-.16v-1.151l25.987 15.003v54c0 1.09-.77 1.53-1.72.982l-42.473-24.523c-.95-.548-1.72-1.877-1.72-2.966v-34.033' fill='#FAFAFA'/><path d='M194.553 191.25c-.257 0-.54-.085-.831-.253l-42.472-24.521c-.981-.567-1.779-1.943-1.779-3.068v-34.033h.234v34.033c0 1.051.745 2.336 1.661 2.866l42.473 24.521c.424.245.816.288 1.103.122.285-.164.442-.52.442-1.002v-53.933l-25.753-14.868.003 1.106c.034.832.026 1.654-.024 2.439-.054.844-.396 1.464-.963 1.746-.619.309-1.45.173-2.28-.373a5.023 5.023 0 0 1-.553-.426l-7.397-6.544c-1.158-1.026-1.999-2.625-2.143-4.076a9.624 9.624 0 0 0-.027-.238 4.241 4.241 0 0 1-.038-.564v-.82l-6.68-3.856.117-.202 6.738 3.89.058.034v.954c0 .171.012.351.036.533.011.083.021.165.029.246.138 1.395.948 2.935 2.065 3.923l7.397 6.545c.173.153.35.289.527.406.758.499 1.504.63 2.047.359.49-.243.786-.795.834-1.551.05-.778.057-1.591.024-2.417l-.004-.163v-1.355l.175.1 25.987 15.004.059.033v54.068c0 .569-.198.996-.559 1.204a1.002 1.002 0 0 1-.506.131' fill='#607D8B'/><path d='M145.685 163.161l24.115 13.922-25.978 14.998-1.462-.307c-6.534-2.17-13.628-3.728-21.019-4.616-4.365-.524-8.663 1.096-9.598 3.62a2.746 2.746 0 0 0-.011 1.928c1.538 4.267 4.236 8.363 7.995 12.135l.532.845-25.977 14.997-24.115-13.922 75.518-43.6' fill='#FFF'/><path d='M94.282 220.818l-.059-.033-24.29-14.024.175-.101 75.577-43.634.058.033 24.29 14.024-26.191 15.122-.045-.01-1.461-.307c-6.549-2.174-13.613-3.725-21.009-4.614a13.744 13.744 0 0 0-1.638-.097c-3.758 0-7.054 1.531-7.837 3.642a2.62 2.62 0 0 0-.01 1.848c1.535 4.258 4.216 8.326 7.968 12.091l.016.021.526.835.006.01.064.102-.105.061-25.977 14.998-.058.033zm-23.881-14.057l23.881 13.788 24.802-14.32c.546-.315.846-.489 1.017-.575l-.466-.74c-3.771-3.787-6.467-7.881-8.013-12.168a2.851 2.851 0 0 1 .011-2.008c.815-2.199 4.203-3.795 8.056-3.795.557 0 1.117.033 1.666.099 7.412.891 14.491 2.445 21.041 4.621.836.175 1.215.254 1.39.304l25.78-14.884-23.881-13.788-75.284 43.466z' fill='#607D8B'/><path d='M167.23 125.979v50.871l-27.321 15.773-6.461-14.167c-.91-1.996-3.428-1.738-5.624.574a10.238 10.238 0 0 0-2.33 4.018l-6.46 21.628-27.322 15.774v-50.871l75.518-43.6' fill='#FFF'/><path d='M91.712 220.567a.127.127 0 0 1-.059-.016.118.118 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.519-43.6a.117.117 0 0 1 .175.101v50.871c0 .041-.023.08-.059.1l-27.321 15.775a.118.118 0 0 1-.094.01.12.12 0 0 1-.071-.063l-6.46-14.168c-.375-.822-1.062-1.275-1.934-1.275-1.089 0-2.364.686-3.5 1.881a10.206 10.206 0 0 0-2.302 3.972l-6.46 21.627a.118.118 0 0 1-.054.068L91.77 220.551a.12.12 0 0 1-.058.016zm.117-50.92v50.601l27.106-15.65 6.447-21.583a10.286 10.286 0 0 1 2.357-4.065c1.18-1.242 2.517-1.954 3.669-1.954.969 0 1.731.501 2.146 1.411l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M168.543 126.213v50.87l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.624.574a10.248 10.248 0 0 0-2.33 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6' fill='#FFF'/><path d='M93.025 220.8a.123.123 0 0 1-.059-.015.12.12 0 0 1-.058-.101v-50.871c0-.042.023-.08.058-.101l75.518-43.6a.112.112 0 0 1 .117 0c.036.02.059.059.059.1v50.871a.116.116 0 0 1-.059.101l-27.321 15.774a.111.111 0 0 1-.094.01.115.115 0 0 1-.071-.062l-6.46-14.168c-.375-.823-1.062-1.275-1.935-1.275-1.088 0-2.363.685-3.499 1.881a10.19 10.19 0 0 0-2.302 3.971l-6.461 21.628a.108.108 0 0 1-.053.067l-27.322 15.775a.12.12 0 0 1-.058.015zm.117-50.919v50.6l27.106-15.649 6.447-21.584a10.293 10.293 0 0 1 2.357-4.065c1.179-1.241 2.516-1.954 3.668-1.954.969 0 1.732.502 2.147 1.412l6.407 14.051 27.152-15.676v-50.601l-75.284 43.466z' fill='#607D8B'/><path d='M169.8 177.083l-27.322 15.774-6.46-14.168c-.91-1.995-3.428-1.738-5.625.574a10.246 10.246 0 0 0-2.329 4.019l-6.461 21.627-27.321 15.774v-50.87l75.518-43.6v50.87z' fill='#FAFAFA'/><path d='M94.282 220.917a.234.234 0 0 1-.234-.233v-50.871c0-.083.045-.161.117-.202l75.518-43.601a.234.234 0 1 1 .35.202v50.871a.233.233 0 0 1-.116.202l-27.322 15.775a.232.232 0 0 1-.329-.106l-6.461-14.168c-.36-.789-.992-1.206-1.828-1.206-1.056 0-2.301.672-3.415 1.844a10.099 10.099 0 0 0-2.275 3.924l-6.46 21.628a.235.235 0 0 1-.107.136l-27.322 15.774a.23.23 0 0 1-.116.031zm.233-50.969v50.331l26.891-15.525 6.434-21.539a10.41 10.41 0 0 1 2.384-4.112c1.201-1.265 2.569-1.991 3.753-1.991 1.018 0 1.818.526 2.253 1.48l6.354 13.934 26.982-15.578v-50.331l-75.051 43.331z' fill='#607D8B'/><path d='M109.894 199.943c-1.774 0-3.241-.725-4.244-2.12a.224.224 0 0 1 .023-.294.233.233 0 0 1 .301-.023c.78.547 1.705.827 2.75.827 1.323 0 2.754-.439 4.256-1.306 5.311-3.067 9.631-10.518 9.631-16.611 0-1.927-.442-3.56-1.278-4.724a.232.232 0 0 1 .323-.327c1.671 1.172 2.591 3.381 2.591 6.219 0 6.242-4.426 13.863-9.865 17.003-1.574.908-3.084 1.356-4.488 1.356zm-2.969-1.542c.813.651 1.82.877 2.968.877h.001c1.321 0 2.753-.327 4.254-1.194 5.311-3.067 9.632-10.463 9.632-16.556 0-1.979-.463-3.599-1.326-4.761.411 1.035.625 2.275.625 3.635 0 6.243-4.426 13.883-9.865 17.023-1.574.909-3.084 1.317-4.49 1.317-.641 0-1.243-.149-1.799-.341z' fill='#607D8B'/><path d='M113.097 197.23c5.384-3.108 9.748-10.636 9.748-16.814 0-2.051-.483-3.692-1.323-4.86-1.784-1.252-4.374-1.194-7.257.47-5.384 3.108-9.748 10.636-9.748 16.814 0 2.051.483 3.692 1.323 4.86 1.784 1.252 4.374 1.194 7.257-.47' fill='#FAFAFA'/><path d='M108.724 198.614c-1.142 0-2.158-.213-3.019-.817-.021-.014-.04.014-.055-.007-.894-1.244-1.367-2.948-1.367-4.973 0-6.242 4.426-13.864 9.865-17.005 1.574-.908 3.084-1.363 4.49-1.363 1.142 0 2.158.309 3.018.913a.23.23 0 0 1 .056.056c.894 1.244 1.367 2.972 1.367 4.997 0 6.243-4.426 13.783-9.865 16.923-1.574.909-3.084 1.276-4.49 1.276zm-2.718-1.109c.774.532 1.688.776 2.718.776 1.323 0 2.754-.413 4.256-1.28 5.311-3.066 9.631-10.505 9.631-16.598 0-1.909-.434-3.523-1.255-4.685-.774-.533-1.688-.799-2.718-.799-1.323 0-2.755.441-4.256 1.308-5.311 3.066-9.631 10.506-9.631 16.599 0 1.909.434 3.517 1.255 4.679z' fill='#607D8B'/><path d='M149.318 114.262l-9.984 8.878 15.893 11.031 5.589-6.112-11.498-13.797' fill='#FAFAFA'/><path d='M169.676 120.84l-9.748 5.627c-3.642 2.103-9.528 2.113-13.147.024-3.62-2.089-3.601-5.488.041-7.591l9.495-5.608-6.729-3.885-81.836 47.071 45.923 26.514 3.081-1.779c.631-.365.869-.898.618-1.39-2.357-4.632-2.593-9.546-.683-14.262 5.638-13.92 24.509-24.815 48.618-28.07 8.169-1.103 16.68-.967 24.704.394.852.145 1.776.008 2.407-.357l3.081-1.778-25.825-14.91' fill='#FAFAFA'/><path d='M113.675 183.459a.47.47 0 0 1-.233-.062l-45.924-26.515a.468.468 0 0 1 .001-.809l81.836-47.071a.467.467 0 0 1 .466 0l6.729 3.885a.467.467 0 0 1-.467.809l-6.496-3.75-80.9 46.533 44.988 25.973 2.848-1.644c.192-.111.62-.409.435-.773-2.416-4.748-2.658-9.814-.7-14.65 2.806-6.927 8.885-13.242 17.582-18.263 8.657-4.998 19.518-8.489 31.407-10.094 8.198-1.107 16.79-.97 24.844.397.739.125 1.561.007 2.095-.301l2.381-1.374-25.125-14.506a.467.467 0 0 1 .467-.809l25.825 14.91a.467.467 0 0 1 0 .809l-3.081 1.779c-.721.417-1.763.575-2.718.413-7.963-1.351-16.457-1.486-24.563-.392-11.77 1.589-22.512 5.039-31.065 9.977-8.514 4.916-14.456 11.073-17.183 17.805-1.854 4.578-1.623 9.376.666 13.875.37.725.055 1.513-.8 2.006l-3.081 1.78a.476.476 0 0 1-.234.062' fill='#455A64'/><path d='M153.316 128.279c-2.413 0-4.821-.528-6.652-1.586-1.818-1.049-2.82-2.461-2.82-3.975 0-1.527 1.016-2.955 2.861-4.02l9.493-5.607a.233.233 0 1 1 .238.402l-9.496 5.609c-1.696.979-2.628 2.263-2.628 3.616 0 1.34.918 2.608 2.585 3.571 3.549 2.049 9.343 2.038 12.914-.024l9.748-5.628a.234.234 0 0 1 .234.405l-9.748 5.628c-1.858 1.072-4.296 1.609-6.729 1.609' fill='#607D8B'/><path d='M113.675 182.992l-45.913-26.508M113.675 183.342a.346.346 0 0 1-.175-.047l-45.913-26.508a.35.35 0 1 1 .35-.607l45.913 26.508a.35.35 0 0 1-.175.654' fill='#455A64'/><path d='M67.762 156.484v54.001c0 1.09.77 2.418 1.72 2.967l42.473 24.521c.95.549 1.72.11 1.72-.98v-54.001' fill='#FAFAFA'/><path d='M112.727 238.561c-.297 0-.62-.095-.947-.285l-42.473-24.521c-1.063-.613-1.895-2.05-1.895-3.27v-54.001a.35.35 0 1 1 .701 0v54.001c0 .96.707 2.18 1.544 2.663l42.473 24.522c.344.198.661.243.87.122.206-.119.325-.411.325-.799v-54.001a.35.35 0 1 1 .7 0v54.001c0 .655-.239 1.154-.675 1.406a1.235 1.235 0 0 1-.623.162' fill='#455A64'/><path d='M112.86 147.512h-.001c-2.318 0-4.499-.522-6.142-1.471-1.705-.984-2.643-2.315-2.643-3.749 0-1.445.952-2.791 2.68-3.788l12.041-6.953c1.668-.962 3.874-1.493 6.212-1.493 2.318 0 4.499.523 6.143 1.472 1.704.984 2.643 2.315 2.643 3.748 0 1.446-.952 2.791-2.68 3.789l-12.042 6.952c-1.668.963-3.874 1.493-6.211 1.493zm12.147-16.753c-2.217 0-4.298.497-5.861 1.399l-12.042 6.952c-1.502.868-2.33 1.998-2.33 3.182 0 1.173.815 2.289 2.293 3.142 1.538.889 3.596 1.378 5.792 1.378h.001c2.216 0 4.298-.497 5.861-1.399l12.041-6.953c1.502-.867 2.33-1.997 2.33-3.182 0-1.172-.814-2.288-2.292-3.142-1.539-.888-3.596-1.377-5.793-1.377z' fill='#607D8B'/><path d='M165.63 123.219l-5.734 3.311c-3.167 1.828-8.286 1.837-11.433.02-3.147-1.817-3.131-4.772.036-6.601l5.734-3.31 11.397 6.58' fill='#FAFAFA'/><path d='M154.233 117.448l9.995 5.771-4.682 2.704c-1.434.827-3.352 1.283-5.399 1.283-2.029 0-3.923-.449-5.333-1.263-1.29-.744-2-1.694-2-2.674 0-.991.723-1.955 2.036-2.713l5.383-3.108m0-.809l-5.734 3.31c-3.167 1.829-3.183 4.784-.036 6.601 1.568.905 3.623 1.357 5.684 1.357 2.077 0 4.159-.46 5.749-1.377l5.734-3.311-11.397-6.58M145.445 179.667c-1.773 0-3.241-.85-4.243-2.245-.067-.092-.057-.275.023-.356.08-.081.207-.12.3-.055.781.548 1.706.812 2.751.811 1.322 0 2.754-.446 4.256-1.313 5.31-3.066 9.631-10.522 9.631-16.615 0-1.927-.442-3.562-1.279-4.726a.235.235 0 0 1 .024-.301.232.232 0 0 1 .3-.027c1.67 1.172 2.59 3.38 2.59 6.219 0 6.242-4.425 13.987-9.865 17.127-1.573.908-3.083 1.481-4.488 1.481zM142.476 178c.814.651 1.82 1.002 2.969 1.002 1.322 0 2.753-.452 4.255-1.32 5.31-3.065 9.631-10.523 9.631-16.617 0-1.98-.463-3.63-1.325-4.793.411 1.035.624 2.26.624 3.62 0 6.242-4.425 13.875-9.865 17.015-1.573.909-3.084 1.376-4.489 1.376a5.49 5.49 0 0 1-1.8-.283z' fill='#607D8B'/><path d='M148.648 176.704c5.384-3.108 9.748-10.636 9.748-16.813 0-2.052-.483-3.693-1.322-4.861-1.785-1.252-4.375-1.194-7.258.471-5.383 3.108-9.748 10.636-9.748 16.813 0 2.051.484 3.692 1.323 4.86 1.785 1.253 4.374 1.195 7.257-.47' fill='#FAFAFA'/><path d='M144.276 178.276c-1.143 0-2.158-.307-3.019-.911a.217.217 0 0 1-.055-.054c-.895-1.244-1.367-2.972-1.367-4.997 0-6.241 4.425-13.875 9.865-17.016 1.573-.908 3.084-1.369 4.489-1.369 1.143 0 2.158.307 3.019.91a.24.24 0 0 1 .055.055c.894 1.244 1.367 2.971 1.367 4.997 0 6.241-4.425 13.875-9.865 17.016-1.573.908-3.084 1.369-4.489 1.369zm-2.718-1.172c.773.533 1.687.901 2.718.901 1.322 0 2.754-.538 4.256-1.405 5.31-3.066 9.631-10.567 9.631-16.661 0-1.908-.434-3.554-1.256-4.716-.774-.532-1.688-.814-2.718-.814-1.322 0-2.754.433-4.256 1.3-5.31 3.066-9.631 10.564-9.631 16.657 0 1.91.434 3.576 1.256 4.738z' fill='#607D8B'/><path d='M150.72 172.361l-.363-.295a24.105 24.105 0 0 0 2.148-3.128 24.05 24.05 0 0 0 1.977-4.375l.443.149a24.54 24.54 0 0 1-2.015 4.46 24.61 24.61 0 0 1-2.19 3.189M115.917 191.514l-.363-.294a24.174 24.174 0 0 0 2.148-3.128 24.038 24.038 0 0 0 1.976-4.375l.443.148a24.48 24.48 0 0 1-2.015 4.461 24.662 24.662 0 0 1-2.189 3.188M114 237.476V182.584 237.476' fill='#607D8B'/><g><path d='M81.822 37.474c.017-.135-.075-.28-.267-.392-.327-.188-.826-.21-1.109-.045l-6.012 3.471c-.131.076-.194.178-.191.285.002.132.002.461.002.578v.043l-.007.128-6.591 3.779c-.001 0-2.077 1.046-2.787 5.192 0 0-.912 6.961-.898 19.745.015 12.57.606 17.07 1.167 21.351.22 1.684 3.001 2.125 3.001 2.125.331.04.698-.027 1.08-.248l75.273-43.551c1.808-1.069 2.667-3.719 3.056-6.284 1.213-7.99 1.675-32.978-.275-39.878-.196-.693-.51-1.083-.868-1.282l-2.086-.79c-.727.028-1.416.467-1.534.535L82.032 37.072l-.21.402' fill='#FFF'/><path d='M144.311 1.701l2.085.79c.358.199.672.589.868 1.282 1.949 6.9 1.487 31.887.275 39.878-.39 2.565-1.249 5.215-3.056 6.284L69.21 93.486a1.78 1.78 0 0 1-.896.258l-.183-.011c0 .001-2.782-.44-3.003-2.124-.56-4.282-1.151-8.781-1.165-21.351-.015-12.784.897-19.745.897-19.745.71-4.146 2.787-5.192 2.787-5.192l6.591-3.779.007-.128v-.043c0-.117 0-.446-.002-.578-.003-.107.059-.21.191-.285l6.012-3.472a.98.98 0 0 1 .481-.11c.218 0 .449.053.627.156.193.112.285.258.268.392l.211-.402 60.744-34.836c.117-.068.806-.507 1.534-.535m0-.997l-.039.001c-.618.023-1.283.244-1.974.656l-.021.012-60.519 34.706a2.358 2.358 0 0 0-.831-.15c-.365 0-.704.084-.98.244l-6.012 3.471c-.442.255-.699.69-.689 1.166l.001.15-6.08 3.487c-.373.199-2.542 1.531-3.29 5.898l-.006.039c-.009.07-.92 7.173-.906 19.875.014 12.62.603 17.116 1.172 21.465l.002.015c.308 2.355 3.475 2.923 3.836 2.98l.034.004c.101.013.204.019.305.019a2.77 2.77 0 0 0 1.396-.392l75.273-43.552c1.811-1.071 2.999-3.423 3.542-6.997 1.186-7.814 1.734-33.096-.301-40.299-.253-.893-.704-1.527-1.343-1.882l-.132-.062-2.085-.789a.973.973 0 0 0-.353-.065' fill='#455A64'/><path d='M128.267 11.565l1.495.434-56.339 32.326' fill='#FFF'/><path d='M74.202 90.545a.5.5 0 0 1-.25-.931l18.437-10.645a.499.499 0 1 1 .499.864L74.451 90.478l-.249.067M75.764 42.654l-.108-.062.046-.171 5.135-2.964.17.045-.045.171-5.135 2.964-.063.017M70.52 90.375V46.421l.063-.036L137.84 7.554v43.954l-.062.036L70.52 90.375zm.25-43.811v43.38l66.821-38.579V7.985L70.77 46.564z' fill='#607D8B'/><path d='M86.986 83.182c-.23.149-.612.384-.849.523l-11.505 6.701c-.237.139-.206.252.068.252h.565c.275 0 .693-.113.93-.252L87.7 83.705c.237-.139.428-.253.425-.256a11.29 11.29 0 0 1-.006-.503c0-.274-.188-.377-.418-.227l-.715.463' fill='#607D8B'/><path d='M75.266 90.782H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.236-.138.615-.371.844-.519l.715-.464a.488.488 0 0 1 .266-.089c.172 0 .345.13.345.421 0 .214.001.363.003.437l.006.004-.004.069c-.003.075-.003.075-.486.356l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.108.866-.234l11.505-6.702c.168-.098.294-.173.361-.214-.004-.084-.004-.218-.004-.437l-.095-.171-.131.049-.714.463c-.232.15-.616.386-.854.525l-11.505 6.702-.029.018z' fill='#607D8B'/><path d='M75.266 89.871H74.7c-.2 0-.316-.056-.346-.166-.03-.11.043-.217.215-.317l11.505-6.702c.258-.151.694-.268.993-.268h.565c.2 0 .316.056.346.166.03.11-.043.217-.215.317l-11.505 6.702a2.282 2.282 0 0 1-.992.268zm-.6-.25l.034.001h.566c.252 0 .649-.107.866-.234l11.505-6.702.03-.018-.035-.001h-.565c-.252 0-.649.108-.867.234l-11.505 6.702-.029.018zM74.37 90.801v-1.247 1.247' fill='#607D8B'/><path d='M68.13 93.901c-.751-.093-1.314-.737-1.439-1.376-.831-4.238-1.151-8.782-1.165-21.352-.015-12.784.897-19.745.897-19.745.711-4.146 2.787-5.192 2.787-5.192l74.859-43.219c.223-.129 2.487-1.584 3.195.923 1.95 6.9 1.488 31.887.275 39.878-.389 2.565-1.248 5.215-3.056 6.283L69.21 93.653c-.382.221-.749.288-1.08.248 0 0-2.781-.441-3.001-2.125-.561-4.281-1.152-8.781-1.167-21.351-.014-12.784.898-19.745.898-19.745.71-4.146 2.787-5.191 2.787-5.191l6.598-3.81.871-.119 6.599-3.83.046-.461L68.13 93.901' fill='#FAFAFA'/><path d='M68.317 94.161l-.215-.013h-.001l-.244-.047c-.719-.156-2.772-.736-2.976-2.292-.568-4.34-1.154-8.813-1.168-21.384-.014-12.654.891-19.707.9-19.777.725-4.231 2.832-5.338 2.922-5.382l6.628-3.827.87-.119 6.446-3.742.034-.334a.248.248 0 0 1 .273-.223.248.248 0 0 1 .223.272l-.059.589-6.752 3.919-.87.118-6.556 3.785c-.031.016-1.99 1.068-2.666 5.018-.007.06-.908 7.086-.894 19.702.014 12.539.597 16.996 1.161 21.305.091.691.689 1.154 1.309 1.452a1.95 1.95 0 0 1-.236-.609c-.781-3.984-1.155-8.202-1.17-21.399-.014-12.653.891-19.707.9-19.777.725-4.231 2.832-5.337 2.922-5.382-.004.001 74.444-42.98 74.846-43.212l.028-.017c.904-.538 1.72-.688 2.36-.433.555.221.949.733 1.172 1.52 2.014 7.128 1.46 32.219.281 39.983-.507 3.341-1.575 5.515-3.175 6.462L69.335 93.869a2.023 2.023 0 0 1-1.018.292zm-.147-.507c.293.036.604-.037.915-.217l75.273-43.551c1.823-1.078 2.602-3.915 2.934-6.106 1.174-7.731 1.731-32.695-.268-39.772-.178-.631-.473-1.032-.876-1.192-.484-.193-1.166-.052-1.921.397l-.034.021-74.858 43.218c-.031.017-1.989 1.069-2.666 5.019-.007.059-.908 7.085-.894 19.702.015 13.155.386 17.351 1.161 21.303.09.461.476.983 1.037 1.139.114.025.185.037.196.039h.001z' fill='#455A64'/><path d='M69.317 68.982c.489-.281.885-.056.885.505 0 .56-.396 1.243-.885 1.525-.488.282-.884.057-.884-.504 0-.56.396-1.243.884-1.526' fill='#FFF'/><path d='M68.92 71.133c-.289 0-.487-.228-.487-.625 0-.56.396-1.243.884-1.526a.812.812 0 0 1 .397-.121c.289 0 .488.229.488.626 0 .56-.396 1.243-.885 1.525a.812.812 0 0 1-.397.121m.794-2.459a.976.976 0 0 0-.49.147c-.548.317-.978 1.058-.978 1.687 0 .486.271.812.674.812a.985.985 0 0 0 .491-.146c.548-.317.978-1.057.978-1.687 0-.486-.272-.813-.675-.813' fill='#8097A2'/><path d='M68.92 70.947c-.271 0-.299-.307-.299-.439 0-.491.361-1.116.79-1.363a.632.632 0 0 1 .303-.096c.272 0 .301.306.301.438 0 .491-.363 1.116-.791 1.364a.629.629 0 0 1-.304.096m.794-2.086a.812.812 0 0 0-.397.121c-.488.283-.884.966-.884 1.526 0 .397.198.625.487.625a.812.812 0 0 0 .397-.121c.489-.282.885-.965.885-1.525 0-.397-.199-.626-.488-.626' fill='#8097A2'/><path d='M69.444 85.35c.264-.152.477-.031.477.272 0 .303-.213.67-.477.822-.263.153-.477.031-.477-.271 0-.302.214-.671.477-.823' fill='#FFF'/><path d='M69.23 86.51c-.156 0-.263-.123-.263-.337 0-.302.214-.671.477-.823a.431.431 0 0 1 .214-.066c.156 0 .263.124.263.338 0 .303-.213.67-.477.822a.431.431 0 0 1-.214.066m.428-1.412c-.1 0-.203.029-.307.09-.32.185-.57.618-.57.985 0 .309.185.524.449.524a.63.63 0 0 0 .308-.09c.32-.185.57-.618.57-.985 0-.309-.185-.524-.45-.524' fill='#8097A2'/><path d='M69.23 86.322l-.076-.149c0-.235.179-.544.384-.661l.12-.041.076.151c0 .234-.179.542-.383.66l-.121.04m.428-1.038a.431.431 0 0 0-.214.066c-.263.152-.477.521-.477.823 0 .214.107.337.263.337a.431.431 0 0 0 .214-.066c.264-.152.477-.519.477-.822 0-.214-.107-.338-.263-.338' fill='#8097A2'/><path d='M139.278 7.769v43.667L72.208 90.16V46.493l67.07-38.724' fill='#455A64'/><path d='M72.083 90.375V46.421l.063-.036 67.257-38.831v43.954l-.062.036-67.258 38.831zm.25-43.811v43.38l66.821-38.579V7.985L72.333 46.564z' fill='#607D8B'/></g><path d='M125.737 88.647l-7.639 3.334V84l-11.459 4.713v8.269L99 100.315l13.369 3.646 13.368-15.314' fill='#455A64'/></g></svg>")
            };
            r.prototype.show = function (a) {
                this.root = a;
                a.appendChild(this.dialog);
                this.dialog.querySelector("#" + this.selectedKey).checked = !0;
                this.dialog.style.display = "block"
            };
            r.prototype.hide = function () {
                this.root && this.root.contains(this.dialog) && this.root.removeChild(this.dialog);
                this.dialog.style.display = "none"
            };
            r.prototype.getCurrentViewer = function () {
                return e.Viewers[this.selectedKey]
            };
            r.prototype.getSelectedKey_ = function () {
                var a = this.dialog.querySelector("input[name=field]:checked");
                return a ? a.id : null
            };
            r.prototype.onChange =
                function (a) {
                    this.onChangeCallbacks_.push(a)
                };
            r.prototype.fireOnChange_ = function (a) {
                for (var b = 0; b < this.onChangeCallbacks_.length; b++)this.onChangeCallbacks_[b](a)
            };
            r.prototype.onSave_ = function () {
                if ((this.selectedKey = this.getSelectedKey_()) && e.Viewers[this.selectedKey]) {
                    this.fireOnChange_(e.Viewers[this.selectedKey]);
                    try {
                        localStorage.setItem("WEBVR_CARDBOARD_VIEWER", this.selectedKey)
                    } catch (Da) {
                        console.error("Failed to save viewer profile: %s", Da)
                    }
                    this.hide()
                } else console.error("ViewerSelector.onSave_: this should never happen!")
            };
            r.prototype.createDialog_ = function (a) {
                var b = document.createElement("div");
                b.classList.add("webvr-polyfill-viewer-selector");
                b.style.display = "none";
                var c = document.createElement("div"), d = c.style;
                d.position = "fixed";
                d.left = 0;
                d.top = 0;
                d.width = "100%";
                d.height = "100%";
                d.background = "rgba(0, 0, 0, 0.3)";
                c.addEventListener("click", this.hide.bind(this));
                var f = document.createElement("div");
                d = f.style;
                d.boxSizing = "border-box";
                d.position = "fixed";
                d.top = "24px";
                d.left = "50%";
                d.marginLeft = "-140px";
                d.width = "280px";
                d.padding =
                    "24px";
                d.overflow = "hidden";
                d.background = "#fafafa";
                d.fontFamily = "'Roboto', sans-serif";
                d.boxShadow = "0px 5px 20px #666";
                f.appendChild(this.createH1_("Select your viewer"));
                for (var e in a)f.appendChild(this.createChoice_(e, a[e].label));
                f.appendChild(this.createButton_("Save", this.onSave_.bind(this)));
                b.appendChild(c);
                b.appendChild(f);
                return b
            };
            r.prototype.createH1_ = function (a) {
                var b = document.createElement("h1"), c = b.style;
                c.color = "black";
                c.fontSize = "20px";
                c.fontWeight = "bold";
                c.marginTop = 0;
                c.marginBottom =
                    "24px";
                b.innerHTML = a;
                return b
            };
            r.prototype.createChoice_ = function (a, b) {
                var c = document.createElement("div");
                c.style.marginTop = "8px";
                c.style.color = "black";
                var d = document.createElement("input");
                d.style.fontSize = "30px";
                d.setAttribute("id", a);
                d.setAttribute("type", "radio");
                d.setAttribute("value", a);
                d.setAttribute("name", "field");
                var f = document.createElement("label");
                f.style.marginLeft = "4px";
                f.setAttribute("for", a);
                f.innerHTML = b;
                c.appendChild(d);
                c.appendChild(f);
                return c
            };
            r.prototype.createButton_ = function (a,
                                                  b) {
                var c = document.createElement("button");
                c.innerHTML = a;
                a = c.style;
                a.float = "right";
                a.textTransform = "uppercase";
                a.color = "#1094f7";
                a.fontSize = "14px";
                a.letterSpacing = 0;
                a.border = 0;
                a.background = "none";
                a.marginTop = "16px";
                c.addEventListener("click", b);
                return c
            };
            var Y = "undefined" !== typeof window ? window : "undefined" !== typeof Va ? Va : "undefined" !== typeof self ? self : {}, xa = function (a) {
                    return a && a.__esModule && Object.prototype.hasOwnProperty.call(a, "default") ? a["default"] : a
                }(function (a, b) {
                    return b = {exports: {}}, a(b,
                        b.exports), b.exports
                }(function (a, b) {
                    (function (b, c) {
                        a.exports = c()
                    })(Y, function () {
                        return function (a) {
                            function b(d) {
                                if (c[d])return c[d].exports;
                                var f = c[d] = {i: d, l: !1, exports: {}};
                                a[d].call(f.exports, f, f.exports, b);
                                f.l = !0;
                                return f.exports
                            }

                            var c = {};
                            b.m = a;
                            b.c = c;
                            b.d = function (a, c, d) {
                                b.o(a, c) || Object.defineProperty(a, c, {configurable: !1, enumerable: !0, get: d})
                            };
                            b.n = function (a) {
                                var c = a && a.__esModule ? function () {
                                    return a["default"]
                                } : function () {
                                    return a
                                };
                                b.d(c, "a", c);
                                return c
                            };
                            b.o = function (a, b) {
                                return Object.prototype.hasOwnProperty.call(a,
                                    b)
                            };
                            b.p = "";
                            return b(b.s = 0)
                        }([function (a, b, c) {
                            var d = function () {
                                function a(a, b) {
                                    for (var c = 0; c < b.length; c++) {
                                        var d = b[c];
                                        d.enumerable = d.enumerable || !1;
                                        d.configurable = !0;
                                        "value"in d && (d.writable = !0);
                                        Object.defineProperty(a, d.key, d)
                                    }
                                }

                                return function (b, c, d) {
                                    c && a(b.prototype, c);
                                    d && a(b, d);
                                    return b
                                }
                            }(), f = c(1), e = "undefined" !== typeof navigator && 10 > parseFloat(("" + (/CPU.*OS ([0-9_]{3,4})[0-9_]{0,1}|(CPU like).*AppleWebKit.*Mobile/i.exec(navigator.userAgent) || [0, ""])[1]).replace("undefined", "3_2").replace("_", ".").replace("_",
                                    "")) && !window.MSStream;
                            b = function () {
                                function a() {
                                    if (!(this instanceof a))throw new TypeError("Cannot call a class as a function");
                                    e ? this.noSleepTimer = null : (this.noSleepVideo = document.createElement("video"), this.noSleepVideo.setAttribute("playsinline", ""), this.noSleepVideo.setAttribute("src", f), this.noSleepVideo.addEventListener("timeupdate", function (a) {
                                        .5 < this.noSleepVideo.currentTime && (this.noSleepVideo.currentTime = Math.random())
                                    }.bind(this)))
                                }

                                d(a, [{
                                    key: "enable", value: function () {
                                        e ? (this.disable(),
                                            this.noSleepTimer = window.setInterval(function () {
                                                window.location.href = "/";
                                                window.setTimeout(window.stop, 0)
                                            }, 15E3)) : this.noSleepVideo.play()
                                    }
                                }, {
                                    key: "disable", value: function () {
                                        e ? this.noSleepTimer && (window.clearInterval(this.noSleepTimer), this.noSleepTimer = null) : this.noSleepVideo.pause()
                                    }
                                }]);
                                return a
                            }();
                            a.exports = b
                        }, function (a, b, c) {
                            a.exports = "data:video/mp4;base64,AAAAIGZ0eXBtcDQyAAACAGlzb21pc28yYXZjMW1wNDEAAAAIZnJlZQAACKBtZGF0AAAC8wYF///v3EXpvebZSLeWLNgg2SPu73gyNjQgLSBjb3JlIDE0MiByMjQ3OSBkZDc5YTYxIC0gSC4yNjQvTVBFRy00IEFWQyBjb2RlYyAtIENvcHlsZWZ0IDIwMDMtMjAxNCAtIGh0dHA6Ly93d3cudmlkZW9sYW4ub3JnL3gyNjQuaHRtbCAtIG9wdGlvbnM6IGNhYmFjPTEgcmVmPTEgZGVibG9jaz0xOjA6MCBhbmFseXNlPTB4MToweDExMSBtZT1oZXggc3VibWU9MiBwc3k9MSBwc3lfcmQ9MS4wMDowLjAwIG1peGVkX3JlZj0wIG1lX3JhbmdlPTE2IGNocm9tYV9tZT0xIHRyZWxsaXM9MCA4eDhkY3Q9MCBjcW09MCBkZWFkem9uZT0yMSwxMSBmYXN0X3Bza2lwPTEgY2hyb21hX3FwX29mZnNldD0wIHRocmVhZHM9NiBsb29rYWhlYWRfdGhyZWFkcz0xIHNsaWNlZF90aHJlYWRzPTAgbnI9MCBkZWNpbWF0ZT0xIGludGVybGFjZWQ9MCBibHVyYXlfY29tcGF0PTAgY29uc3RyYWluZWRfaW50cmE9MCBiZnJhbWVzPTMgYl9weXJhbWlkPTIgYl9hZGFwdD0xIGJfYmlhcz0wIGRpcmVjdD0xIHdlaWdodGI9MSBvcGVuX2dvcD0wIHdlaWdodHA9MSBrZXlpbnQ9MzAwIGtleWludF9taW49MzAgc2NlbmVjdXQ9NDAgaW50cmFfcmVmcmVzaD0wIHJjX2xvb2thaGVhZD0xMCByYz1jcmYgbWJ0cmVlPTEgY3JmPTIwLjAgcWNvbXA9MC42MCBxcG1pbj0wIHFwbWF4PTY5IHFwc3RlcD00IHZidl9tYXhyYXRlPTIwMDAwIHZidl9idWZzaXplPTI1MDAwIGNyZl9tYXg9MC4wIG5hbF9ocmQ9bm9uZSBmaWxsZXI9MCBpcF9yYXRpbz0xLjQwIGFxPTE6MS4wMACAAAAAOWWIhAA3//p+C7v8tDDSTjf97w55i3SbRPO4ZY+hkjD5hbkAkL3zpJ6h/LR1CAABzgB1kqqzUorlhQAAAAxBmiQYhn/+qZYADLgAAAAJQZ5CQhX/AAj5IQADQGgcIQADQGgcAAAACQGeYUQn/wALKCEAA0BoHAAAAAkBnmNEJ/8ACykhAANAaBwhAANAaBwAAAANQZpoNExDP/6plgAMuSEAA0BoHAAAAAtBnoZFESwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBnqVEJ/8ACykhAANAaBwAAAAJAZ6nRCf/AAsoIQADQGgcIQADQGgcAAAADUGarDRMQz/+qZYADLghAANAaBwAAAALQZ7KRRUsK/8ACPkhAANAaBwAAAAJAZ7pRCf/AAsoIQADQGgcIQADQGgcAAAACQGe60Qn/wALKCEAA0BoHAAAAA1BmvA0TEM//qmWAAy5IQADQGgcIQADQGgcAAAAC0GfDkUVLCv/AAj5IQADQGgcAAAACQGfLUQn/wALKSEAA0BoHCEAA0BoHAAAAAkBny9EJ/8ACyghAANAaBwAAAANQZs0NExDP/6plgAMuCEAA0BoHAAAAAtBn1JFFSwr/wAI+SEAA0BoHCEAA0BoHAAAAAkBn3FEJ/8ACyghAANAaBwAAAAJAZ9zRCf/AAsoIQADQGgcIQADQGgcAAAADUGbeDRMQz/+qZYADLkhAANAaBwAAAALQZ+WRRUsK/8ACPghAANAaBwhAANAaBwAAAAJAZ+1RCf/AAspIQADQGgcAAAACQGft0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bm7w0TEM//qmWAAy4IQADQGgcAAAAC0Gf2kUVLCv/AAj5IQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHAAAAAkBn/tEJ/8ACykhAANAaBwAAAANQZvgNExDP/6plgAMuSEAA0BoHCEAA0BoHAAAAAtBnh5FFSwr/wAI+CEAA0BoHAAAAAkBnj1EJ/8ACyghAANAaBwhAANAaBwAAAAJAZ4/RCf/AAspIQADQGgcAAAADUGaJDRMQz/+qZYADLghAANAaBwAAAALQZ5CRRUsK/8ACPkhAANAaBwhAANAaBwAAAAJAZ5hRCf/AAsoIQADQGgcAAAACQGeY0Qn/wALKSEAA0BoHCEAA0BoHAAAAA1Bmmg0TEM//qmWAAy5IQADQGgcAAAAC0GehkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGepUQn/wALKSEAA0BoHAAAAAkBnqdEJ/8ACyghAANAaBwAAAANQZqsNExDP/6plgAMuCEAA0BoHCEAA0BoHAAAAAtBnspFFSwr/wAI+SEAA0BoHAAAAAkBnulEJ/8ACyghAANAaBwhAANAaBwAAAAJAZ7rRCf/AAsoIQADQGgcAAAADUGa8DRMQz/+qZYADLkhAANAaBwhAANAaBwAAAALQZ8ORRUsK/8ACPkhAANAaBwAAAAJAZ8tRCf/AAspIQADQGgcIQADQGgcAAAACQGfL0Qn/wALKCEAA0BoHAAAAA1BmzQ0TEM//qmWAAy4IQADQGgcAAAAC0GfUkUVLCv/AAj5IQADQGgcIQADQGgcAAAACQGfcUQn/wALKCEAA0BoHAAAAAkBn3NEJ/8ACyghAANAaBwhAANAaBwAAAANQZt4NExC//6plgAMuSEAA0BoHAAAAAtBn5ZFFSwr/wAI+CEAA0BoHCEAA0BoHAAAAAkBn7VEJ/8ACykhAANAaBwAAAAJAZ+3RCf/AAspIQADQGgcAAAADUGbuzRMQn/+nhAAYsAhAANAaBwhAANAaBwAAAAJQZ/aQhP/AAspIQADQGgcAAAACQGf+UQn/wALKCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHCEAA0BoHAAACiFtb292AAAAbG12aGQAAAAA1YCCX9WAgl8AAAPoAAAH/AABAAABAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAGGlvZHMAAAAAEICAgAcAT////v7/AAAF+XRyYWsAAABcdGtoZAAAAAPVgIJf1YCCXwAAAAEAAAAAAAAH0AAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAEAAAAAAygAAAMoAAAAAACRlZHRzAAAAHGVsc3QAAAAAAAAAAQAAB9AAABdwAAEAAAAABXFtZGlhAAAAIG1kaGQAAAAA1YCCX9WAgl8AAV+QAAK/IFXEAAAAAAAtaGRscgAAAAAAAAAAdmlkZQAAAAAAAAAAAAAAAFZpZGVvSGFuZGxlcgAAAAUcbWluZgAAABR2bWhkAAAAAQAAAAAAAAAAAAAAJGRpbmYAAAAcZHJlZgAAAAAAAAABAAAADHVybCAAAAABAAAE3HN0YmwAAACYc3RzZAAAAAAAAAABAAAAiGF2YzEAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAygDKAEgAAABIAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY//8AAAAyYXZjQwFNQCj/4QAbZ01AKOyho3ySTUBAQFAAAAMAEAAr8gDxgxlgAQAEaO+G8gAAABhzdHRzAAAAAAAAAAEAAAA8AAALuAAAABRzdHNzAAAAAAAAAAEAAAABAAAB8GN0dHMAAAAAAAAAPAAAAAEAABdwAAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAADqYAAAAAQAAF3AAAAABAAAAAAAAAAEAAAu4AAAAAQAAOpgAAAABAAAXcAAAAAEAAAAAAAAAAQAAC7gAAAABAAA6mAAAAAEAABdwAAAAAQAAAAAAAAABAAALuAAAAAEAAC7gAAAAAQAAF3AAAAABAAAAAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAEEc3RzegAAAAAAAAAAAAAAPAAAAzQAAAAQAAAADQAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAAPAAAADQAAAA0AAAARAAAADwAAAA0AAAANAAAAEQAAAA8AAAANAAAADQAAABEAAAANAAAADQAAAQBzdGNvAAAAAAAAADwAAAAwAAADZAAAA3QAAAONAAADoAAAA7kAAAPQAAAD6wAAA/4AAAQXAAAELgAABEMAAARcAAAEbwAABIwAAAShAAAEugAABM0AAATkAAAE/wAABRIAAAUrAAAFQgAABV0AAAVwAAAFiQAABaAAAAW1AAAFzgAABeEAAAX+AAAGEwAABiwAAAY/AAAGVgAABnEAAAaEAAAGnQAABrQAAAbPAAAG4gAABvUAAAcSAAAHJwAAB0AAAAdTAAAHcAAAB4UAAAeeAAAHsQAAB8gAAAfjAAAH9gAACA8AAAgmAAAIQQAACFQAAAhnAAAIhAAACJcAAAMsdHJhawAAAFx0a2hkAAAAA9WAgl/VgIJfAAAAAgAAAAAAAAf8AAAAAAAAAAAAAAABAQAAAAABAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAACsm1kaWEAAAAgbWRoZAAAAADVgIJf1YCCXwAArEQAAWAAVcQAAAAAACdoZGxyAAAAAAAAAABzb3VuAAAAAAAAAAAAAAAAU3RlcmVvAAAAAmNtaW5mAAAAEHNtaGQAAAAAAAAAAAAAACRkaW5mAAAAHGRyZWYAAAAAAAAAAQAAAAx1cmwgAAAAAQAAAidzdGJsAAAAZ3N0c2QAAAAAAAAAAQAAAFdtcDRhAAAAAAAAAAEAAAAAAAAAAAACABAAAAAArEQAAAAAADNlc2RzAAAAAAOAgIAiAAIABICAgBRAFQAAAAADDUAAAAAABYCAgAISEAaAgIABAgAAABhzdHRzAAAAAAAAAAEAAABYAAAEAAAAABxzdHNjAAAAAAAAAAEAAAABAAAAAQAAAAEAAAAUc3RzegAAAAAAAAAGAAAAWAAAAXBzdGNvAAAAAAAAAFgAAAOBAAADhwAAA5oAAAOtAAADswAAA8oAAAPfAAAD5QAAA/gAAAQLAAAEEQAABCgAAAQ9AAAEUAAABFYAAARpAAAEgAAABIYAAASbAAAErgAABLQAAATHAAAE3gAABPMAAAT5AAAFDAAABR8AAAUlAAAFPAAABVEAAAVXAAAFagAABX0AAAWDAAAFmgAABa8AAAXCAAAFyAAABdsAAAXyAAAF+AAABg0AAAYgAAAGJgAABjkAAAZQAAAGZQAABmsAAAZ+AAAGkQAABpcAAAauAAAGwwAABskAAAbcAAAG7wAABwYAAAcMAAAHIQAABzQAAAc6AAAHTQAAB2QAAAdqAAAHfwAAB5IAAAeYAAAHqwAAB8IAAAfXAAAH3QAAB/AAAAgDAAAICQAACCAAAAg1AAAIOwAACE4AAAhhAAAIeAAACH4AAAiRAAAIpAAACKoAAAiwAAAItgAACLwAAAjCAAAAFnVkdGEAAAAObmFtZVN0ZXJlbwAAAHB1ZHRhAAAAaG1ldGEAAAAAAAAAIWhkbHIAAAAAAAAAAG1kaXJhcHBsAAAAAAAAAAAAAAAAO2lsc3QAAAAzqXRvbwAAACtkYXRhAAAAAQAAAABIYW5kQnJha2UgMC4xMC4yIDIwMTUwNjExMDA="
                        }])
                    })
                })),
                da = 1E3, fa = [0, 0, .5, 1], pa = [.5, 0, .5, 1], ya = window.requestAnimationFrame, ha = window.cancelAnimationFrame;
            u.prototype.getFrameData = function (a) {
                return M(a, this._getPose(), this)
            };
            u.prototype.getPose = function () {
                ea("VRDisplay.prototype.getPose", "VRDisplay.prototype.getFrameData");
                return this._getPose()
            };
            u.prototype.resetPose = function () {
                ea("VRDisplay.prototype.resetPose");
                return this._resetPose()
            };
            u.prototype.getImmediatePose = function () {
                ea("VRDisplay.prototype.getImmediatePose", "VRDisplay.prototype.getFrameData");
                return this._getPose()
            };
            u.prototype.requestAnimationFrame = function (a) {
                return ya(a)
            };
            u.prototype.cancelAnimationFrame = function (a) {
                return ha(a)
            };
            u.prototype.wrapForFullscreen = function (a) {
                if (v())return a;
                this.fullscreenWrapper_ || (this.fullscreenWrapper_ = document.createElement("div"), this.fullscreenWrapper_.setAttribute("style", ["height: " + Math.min(screen.height, screen.width) + "px !important", "top: 0 !important; left: 0 !important; right: 0 !important; border: 0; margin: 0; padding: 0; z-index: 999999 !important; position: fixed"].join("; ") +
                    ";"), this.fullscreenWrapper_.classList.add("webvr-polyfill-fullscreen-wrapper"));
                if (this.fullscreenElement_ == a)return this.fullscreenWrapper_;
                this.fullscreenElement_ && (this.originalParent_ ? this.originalParent_.appendChild(this.fullscreenElement_) : this.fullscreenElement_.parentElement.removeChild(this.fullscreenElement_));
                this.fullscreenElement_ = a;
                (this.originalParent_ = a.parentElement) || document.body.appendChild(a);
                this.fullscreenWrapper_.parentElement || (a = this.fullscreenElement_.parentElement, a.insertBefore(this.fullscreenWrapper_,
                    this.fullscreenElement_), a.removeChild(this.fullscreenElement_));
                this.fullscreenWrapper_.insertBefore(this.fullscreenElement_, this.fullscreenWrapper_.firstChild);
                this.fullscreenElementCachedStyle_ = this.fullscreenElement_.getAttribute("style");
                this.fullscreenElement_ && this.fullscreenElement_.setAttribute("style", ["position: absolute; top: 0; left: 0", "width: " + Math.max(screen.width, screen.height) + "px", "height: " + Math.min(screen.height, screen.width) + "px", "border: 0; margin: 0; padding: 0"].join("; ") +
                    ";");
                return this.fullscreenWrapper_
            };
            u.prototype.removeFullscreenWrapper = function () {
                if (this.fullscreenElement_) {
                    var a = this.fullscreenElement_;
                    this.fullscreenElementCachedStyle_ ? a.setAttribute("style", this.fullscreenElementCachedStyle_) : a.removeAttribute("style");
                    this.fullscreenElementCachedStyle_ = this.fullscreenElement_ = null;
                    var b = this.fullscreenWrapper_.parentElement;
                    this.fullscreenWrapper_.removeChild(a);
                    this.originalParent_ === b ? b.insertBefore(a, this.fullscreenWrapper_) : this.originalParent_ && this.originalParent_.appendChild(a);
                    b.removeChild(this.fullscreenWrapper_);
                    return a
                }
            };
            u.prototype.requestPresent = function (a) {
                var b = this.isPresenting, c = this;
                a instanceof Array || (ea("VRDisplay.prototype.requestPresent with non-array argument", "an array of VRLayers as the first argument"), a = [a]);
                return new Promise(function (d, f) {
                    if (c.capabilities.canPresent)if (0 == a.length || a.length > c.capabilities.maxLayers)f(Error("Invalid number of layers.")); else {
                        var e = a[0];
                        if (e.source) {
                            var g = e.leftBounds || fa, k = e.rightBounds || pa;
                            if (b) {
                                var h = c.layer_;
                                h.source !== e.source && (h.source = e.source);
                                for (e = 0; 4 > e; e++)h.leftBounds[e] = g[e], h.rightBounds[e] = k[e];
                                c.wrapForFullscreen(c.layer_.source);
                                c.updatePresent_();
                                d()
                            } else {
                                c.layer_ = {
                                    predistorted: e.predistorted,
                                    source: e.source,
                                    leftBounds: g.slice(0),
                                    rightBounds: k.slice(0)
                                };
                                c.waitingForPresent_ = !1;
                                if (c.layer_ && c.layer_.source) {
                                    var m = c.wrapForFullscreen(c.layer_.source);
                                    c.addFullscreenListeners_(m, function () {
                                        c.isPresenting = m === (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement ||
                                            document.msFullscreenElement);
                                        c.isPresenting ? (screen.orientation && screen.orientation.lock && screen.orientation.lock("landscape-primary").catch(function (a) {
                                            console.error("screen.orientation.lock() failed due to", a.message)
                                        }), c.waitingForPresent_ = !1, c.beginPresent_(), d()) : (screen.orientation && screen.orientation.unlock && screen.orientation.unlock(), c.removeFullscreenWrapper(), c.disableWakeLock(), c.endPresent_(), c.removeFullscreenListeners_());
                                        c.fireVRDisplayPresentChange_()
                                    }, function () {
                                        c.waitingForPresent_ &&
                                        (c.removeFullscreenWrapper(), c.removeFullscreenListeners_(), c.disableWakeLock(), c.waitingForPresent_ = !1, c.isPresenting = !1, f(Error("Unable to present.")))
                                    });
                                    if (D(m))c.enableWakeLock(), c.waitingForPresent_ = !0; else if (v() || A())c.enableWakeLock(), c.isPresenting = !0, c.beginPresent_(), c.fireVRDisplayPresentChange_(), d()
                                }
                                c.waitingForPresent_ || v() || (I(), f(Error("Unable to present.")))
                            }
                        } else d()
                    } else f(Error("VRDisplay is not capable of presenting."))
                })
            };
            u.prototype.exitPresent = function () {
                var a = this.isPresenting,
                    b = this;
                this.isPresenting = !1;
                this.layer_ = null;
                this.disableWakeLock();
                return new Promise(function (c, d) {
                    a ? (!I() && v() && (b.endPresent_(), b.fireVRDisplayPresentChange_()), A() && (b.removeFullscreenWrapper(), b.removeFullscreenListeners_(), b.endPresent_(), b.fireVRDisplayPresentChange_()), c()) : d(Error("Was not presenting to VRDisplay."))
                })
            };
            u.prototype.getLayers = function () {
                return this.layer_ ? [this.layer_] : []
            };
            u.prototype.fireVRDisplayPresentChange_ = function () {
                var a = new CustomEvent("vrdisplaypresentchange", {detail: {display: this}});
                window.dispatchEvent(a)
            };
            u.prototype.fireVRDisplayConnect_ = function () {
                var a = new CustomEvent("vrdisplayconnect", {detail: {display: this}});
                window.dispatchEvent(a)
            };
            u.prototype.addFullscreenListeners_ = function (a, b, c) {
                this.removeFullscreenListeners_();
                this.fullscreenEventTarget_ = a;
                this.fullscreenChangeHandler_ = b;
                this.fullscreenErrorHandler_ = c;
                b && (document.fullscreenEnabled ? a.addEventListener("fullscreenchange", b, !1) : document.webkitFullscreenEnabled ? a.addEventListener("webkitfullscreenchange", b, !1) : document.mozFullScreenEnabled ?
                    document.addEventListener("mozfullscreenchange", b, !1) : document.msFullscreenEnabled && a.addEventListener("msfullscreenchange", b, !1));
                c && (document.fullscreenEnabled ? a.addEventListener("fullscreenerror", c, !1) : document.webkitFullscreenEnabled ? a.addEventListener("webkitfullscreenerror", c, !1) : document.mozFullScreenEnabled ? document.addEventListener("mozfullscreenerror", c, !1) : document.msFullscreenEnabled && a.addEventListener("msfullscreenerror", c, !1))
            };
            u.prototype.removeFullscreenListeners_ = function () {
                if (this.fullscreenEventTarget_) {
                    var a =
                        this.fullscreenEventTarget_;
                    if (this.fullscreenChangeHandler_) {
                        var b = this.fullscreenChangeHandler_;
                        a.removeEventListener("fullscreenchange", b, !1);
                        a.removeEventListener("webkitfullscreenchange", b, !1);
                        document.removeEventListener("mozfullscreenchange", b, !1);
                        a.removeEventListener("msfullscreenchange", b, !1)
                    }
                    this.fullscreenErrorHandler_ && (b = this.fullscreenErrorHandler_, a.removeEventListener("fullscreenerror", b, !1), a.removeEventListener("webkitfullscreenerror", b, !1), document.removeEventListener("mozfullscreenerror",
                        b, !1), a.removeEventListener("msfullscreenerror", b, !1));
                    this.fullscreenErrorHandler_ = this.fullscreenChangeHandler_ = this.fullscreenEventTarget_ = null
                }
            };
            u.prototype.enableWakeLock = function () {
                this.wakelock_ && this.wakelock_.enable()
            };
            u.prototype.disableWakeLock = function () {
                this.wakelock_ && this.wakelock_.disable()
            };
            u.prototype.beginPresent_ = function () {
            };
            u.prototype.endPresent_ = function () {
            };
            u.prototype.submitFrame = function (a) {
            };
            u.prototype.getEyeParameters = function (a) {
                return null
            };
            var ba = {
                ADDITIONAL_VIEWERS: [],
                DEFAULT_VIEWER: "",
                MOBILE_WAKE_LOCK: !0,
                DEBUG: !1,
                DPDB_URL: "https://dpdb.webvr.rocks/dpdb.json",
                K_FILTER: .98,
                PREDICTION_TIME_S: .04,
                CARDBOARD_UI_DISABLED: !1,
                ROTATE_INSTRUCTIONS_DISABLED: !1,
                YAW_ONLY: !1,
                BUFFER_SCALE: .5,
                DIRTY_SUBMIT_FRAME_BINDINGS: !1
            };
            t.prototype = Object.create(u.prototype);
            t.prototype._getPose = function () {
                return {
                    position: null,
                    orientation: this.poseSensor_.getOrientation(),
                    linearVelocity: null,
                    linearAcceleration: null,
                    angularVelocity: null,
                    angularAcceleration: null
                }
            };
            t.prototype._resetPose = function () {
                this.poseSensor_.resetPose &&
                this.poseSensor_.resetPose()
            };
            t.prototype._getFieldOfView = function (a) {
                if ("left" == a)a = this.deviceInfo_.getFieldOfViewLeftEye(); else if ("right" == a)a = this.deviceInfo_.getFieldOfViewRightEye(); else return console.error("Invalid eye provided: %s", a), null;
                return a
            };
            t.prototype._getEyeOffset = function (a) {
                if ("left" == a)a = [.5 * -this.deviceInfo_.viewer.interLensDistance, 0, 0]; else if ("right" == a)a = [.5 * this.deviceInfo_.viewer.interLensDistance, 0, 0]; else return console.error("Invalid eye provided: %s", a), null;
                return a
            };
            t.prototype.getEyeParameters = function (a) {
                var b = this._getEyeOffset(a), c = this._getFieldOfView(a);
                a = {
                    offset: b,
                    renderWidth: .5 * this.deviceInfo_.device.width * this.bufferScale_,
                    renderHeight: this.deviceInfo_.device.height * this.bufferScale_
                };
                Object.defineProperty(a, "fieldOfView", {
                    enumerable: !0, get: function () {
                        ea("VRFieldOfView", "VRFrameData's projection matrices");
                        return c
                    }
                });
                return a
            };
            t.prototype.onDeviceParamsUpdated_ = function (a) {
                this.config.DEBUG && console.log("DPDB reported that device params were updated.");
                this.deviceInfo_.updateDeviceParams(a);
                this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_)
            };
            t.prototype.updateBounds_ = function () {
                this.layer_ && this.distorter_ && (this.layer_.leftBounds || this.layer_.rightBounds) && this.distorter_.setTextureBounds(this.layer_.leftBounds, this.layer_.rightBounds)
            };
            t.prototype.beginPresent_ = function () {
                var c = this.layer_.source.getContext("webgl");
                c || (c = this.layer_.source.getContext("experimental-webgl"));
                c || (c = this.layer_.source.getContext("webgl2"));
                c && (this.layer_.predistorted ?
                this.config.CARDBOARD_UI_DISABLED || (c.canvas.width = ma() * this.bufferScale_, c.canvas.height = E() * this.bufferScale_, this.cardboardUI_ = new b(c)) : (this.config.CARDBOARD_UI_DISABLED || (this.cardboardUI_ = new b(c)), this.distorter_ = new a(c, this.cardboardUI_, this.config.BUFFER_SCALE, this.config.DIRTY_SUBMIT_FRAME_BINDINGS), this.distorter_.updateDeviceInfo(this.deviceInfo_)), this.cardboardUI_ && this.cardboardUI_.listen(function (a) {
                    this.viewerSelector_.show(this.layer_.source.parentElement);
                    a.stopPropagation();
                    a.preventDefault()
                }.bind(this), function (a) {
                    this.exitPresent();
                    a.stopPropagation();
                    a.preventDefault()
                }.bind(this)), this.rotateInstructions_ && (F() && P() ? this.rotateInstructions_.showTemporarily(3E3, this.layer_.source.parentElement) : this.rotateInstructions_.update()), this.orientationHandler = this.onOrientationChange_.bind(this), window.addEventListener("orientationchange", this.orientationHandler), this.vrdisplaypresentchangeHandler = this.updateBounds_.bind(this), window.addEventListener("vrdisplaypresentchange",
                    this.vrdisplaypresentchangeHandler), this.fireVRDisplayDeviceParamsChange_())
            };
            t.prototype.endPresent_ = function () {
                this.distorter_ && (this.distorter_.destroy(), this.distorter_ = null);
                this.cardboardUI_ && (this.cardboardUI_.destroy(), this.cardboardUI_ = null);
                this.rotateInstructions_ && this.rotateInstructions_.hide();
                this.viewerSelector_.hide();
                window.removeEventListener("orientationchange", this.orientationHandler);
                window.removeEventListener("vrdisplaypresentchange", this.vrdisplaypresentchangeHandler)
            };
            t.prototype.updatePresent_ =
                function () {
                    this.endPresent_();
                    this.beginPresent_()
                };
            t.prototype.submitFrame = function (a) {
                if (this.distorter_)this.updateBounds_(), this.distorter_.submitFrame(); else if (this.cardboardUI_ && this.layer_) {
                    (a = this.layer_.source.getContext("webgl")) || (a = this.layer_.source.getContext("experimental-webgl"));
                    a || (a = this.layer_.source.getContext("webgl2"));
                    a = a.canvas;
                    if (a.width != this.lastWidth || a.height != this.lastHeight)this.cardboardUI_.onResize();
                    this.lastWidth = a.width;
                    this.lastHeight = a.height;
                    this.cardboardUI_.render()
                }
            };
            t.prototype.onOrientationChange_ = function (a) {
                this.viewerSelector_.hide();
                this.rotateInstructions_ && this.rotateInstructions_.update();
                this.onResize_()
            };
            t.prototype.onResize_ = function (a) {
                this.layer_ && ((a = this.layer_.source.getContext("webgl")) || (a = this.layer_.source.getContext("experimental-webgl")), a || (a = this.layer_.source.getContext("webgl2")), a.canvas.setAttribute("style", "position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; border: 0; margin: 0; padding: 0px; box-sizing: content-box;"),
                    ia(a.canvas))
            };
            t.prototype.onViewerChanged_ = function (a) {
                this.deviceInfo_.setViewer(a);
                this.distorter_ && this.distorter_.updateDeviceInfo(this.deviceInfo_);
                this.fireVRDisplayDeviceParamsChange_()
            };
            t.prototype.fireVRDisplayDeviceParamsChange_ = function () {
                var a = new CustomEvent("vrdisplaydeviceparamschange", {
                    detail: {
                        vrdisplay: this,
                        deviceInfo: this.deviceInfo_
                    }
                });
                window.dispatchEvent(a)
            };
            t.VRFrameData = function () {
                this.leftProjectionMatrix = new Float32Array(16);
                this.leftViewMatrix = new Float32Array(16);
                this.rightProjectionMatrix =
                    new Float32Array(16);
                this.rightViewMatrix = new Float32Array(16);
                this.pose = null
            };
            t.VRDisplay = u;
            return t
        })
    })), oa = function (a) {
        var b = B.call(this) || this;
        b.global = a;
        b.onWindowResize = b.onWindowResize.bind(b);
        b.global.window.addEventListener("resize", b.onWindowResize);
        b.environmentBlendMode = "opaque";
        return b
    };
    $jscomp.inherits(oa, B);
    oa.prototype.onBaseLayerSet = function (a, b) {
        throw Error("Not implemented");
    };
    oa.prototype.isSessionSupported = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.isFeatureSupported =
        function (a) {
            throw Error("Not implemented");
        };
    oa.prototype.requestSession = function (a, b) {
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (a) {
            throw Error("Not implemented");
        })
    };
    oa.prototype.requestAnimationFrame = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.onFrameStart = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.onFrameEnd = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.doesSessionSupportReferenceSpace = function (a, b) {
        throw Error("Not implemented");
    };
    oa.prototype.requestStageBounds =
        function () {
            throw Error("Not implemented");
        };
    oa.prototype.requestFrameOfReferenceTransform = function (a, b) {
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (a) {
            return a.return(void 0)
        })
    };
    oa.prototype.cancelAnimationFrame = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.endSession = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.getViewport = function (a, b, c, d) {
        throw Error("Not implemented");
    };
    oa.prototype.getProjectionMatrix = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.getBasePoseMatrix =
        function () {
            throw Error("Not implemented");
        };
    oa.prototype.getBaseViewMatrix = function (a) {
        throw Error("Not implemented");
    };
    oa.prototype.getInputSources = function () {
        throw Error("Not implemented");
    };
    oa.prototype.getInputPose = function (a, b, c) {
        throw Error("Not implemented");
    };
    oa.prototype.onWindowResize = function () {
        this.onWindowResize()
    };
    var ab = {
        mapping: "xr-standard",
        displayProfiles: {"Oculus Quest": ["oculus-touch-v2", "oculus-touch", "generic-trigger-squeeze-thumbstick"]},
        profiles: ["oculus-touch", "generic-trigger-squeeze-thumbstick"],
        axes: {length: 4, 0: null, 1: null, 2: 0, 3: 1},
        buttons: {length: 7, 0: 1, 1: 2, 2: null, 3: 0, 4: 3, 5: 4, 6: null},
        gripTransform: {position: [0, -.02, .04, 1], orientation: [.11 * Math.PI, 0, 0, 1]}
    }, Wa = {
        mapping: "xr-standard",
        profiles: ["microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
        buttons: {length: 4, 0: 1, 1: 0, 2: 2, 3: 4},
        gripTransform: {position: [0, -.02, .04, 1], orientation: [.11 * Math.PI, 0, 0, 1]}
    }, mb = {
        "Daydream Controller": {
            mapping: "", profiles: ["google-daydream", "generic-trigger-touchpad"], buttons: {
                length: 3, 0: null, 1: null,
                2: 0
            }
        },
        "Gear VR Controller": {
            mapping: "xr-standard",
            profiles: ["samsung-gearvr", "generic-trigger-touchpad"],
            buttons: {length: 3, 0: 1, 1: null, 2: 0},
            gripTransform: {orientation: [.11 * Math.PI, 0, 0, 1]}
        },
        "HTC Vive Focus Controller": {
            mapping: "xr-standard",
            profiles: ["htc-vive-focus", "generic-trigger-touchpad"],
            buttons: {length: 3, 0: 1, 1: null, 2: 0}
        },
        "Oculus Go Controller": {
            mapping: "xr-standard",
            profiles: ["oculus-go", "generic-trigger-touchpad"],
            buttons: {length: 3, 0: 1, 1: null, 2: 0},
            gripTransform: {
                orientation: [.11 * Math.PI, 0,
                    0, 1]
            }
        },
        "Oculus Touch (Right)": ab,
        "Oculus Touch (Left)": ab,
        "OpenVR Gamepad": {
            mapping: "xr-standard",
            profiles: ["htc-vive", "generic-trigger-squeeze-touchpad"],
            displayProfiles: {
                "HTC Vive": ["htc-vive", "generic-trigger-squeeze-touchpad"],
                "HTC Vive DVT": ["htc-vive", "generic-trigger-squeeze-touchpad"],
                "Valve Index": ["valve-index", "generic-trigger-squeeze-touchpad-thumbstick"]
            },
            buttons: {length: 3, 0: 1, 1: 2, 2: 0},
            gripTransform: {position: [0, 0, .05, 1]},
            targetRayTransform: {orientation: [-.08 * Math.PI, 0, 0, 1]},
            userAgentOverrides: {
                Firefox: {
                    axes: {
                        invert: [1,
                            3]
                    }
                }
            }
        },
        "Spatial Controller (Spatial Interaction Source) 045E-065A": Wa,
        "Spatial Controller (Spatial Interaction Source) 045E-065D": {
            mapping: "xr-standard",
            profiles: ["samsung-odyssey", "microsoft-mixed-reality", "generic-trigger-squeeze-touchpad-thumbstick"],
            buttons: {length: 4, 0: 1, 1: 0, 2: 2, 3: 4},
            gripTransform: {position: [0, -.02, .04, 1], orientation: [.11 * Math.PI, 0, 0, 1]}
        },
        "Windows Mixed Reality (Right)": Wa,
        "Windows Mixed Reality (Left)": Wa
    }, bb = p(.155, -.465, -.15), nb = p(-.155, -.465, -.15), ob = p(0, 0, -.25), pb = p(0, 0,
        .05), cb = p(-.08, .14, .08), db = 180 / Math.PI, Ja = function () {
        this.hand = "right";
        this.headElbowOffset = bb;
        this.controllerQ = z();
        this.lastControllerQ = z();
        this.headQ = z();
        this.headPos = k();
        this.elbowPos = k();
        this.wristPos = k();
        this.lastTime = this.time = null;
        this.rootQ = z();
        this.position = k()
    };
    Ja.prototype.setHandedness = function (a) {
        this.hand != a && (this.hand = a, this.headElbowOffset = "left" == this.hand ? nb : bb)
    };
    Ja.prototype.update = function (a, b) {
        this.time = la();
        a && (D(this.lastControllerQ, this.controllerQ), D(this.controllerQ, a));
        b && (g(this.headPos, b), f(this.headQ, b));
        a = this.getHeadYawOrientation_();
        b = this.quatAngle_(this.lastControllerQ, this.controllerQ);
        .61 < b / ((this.time - this.lastTime) / 1E3) ? y(this.rootQ, this.rootQ, a, Math.min(b / .175, 1)) : D(this.rootQ, a);
        a = p(0, 0, -1);
        t(a, a, this.controllerQ);
        a = u(a, [0, 1, 0]);
        a = this.clamp_((a - .12) / .87, 0, 1);
        var c = N(this.rootQ);
        E(c, c);
        A(c, c, this.controllerQ);
        b = this.elbowPos;
        l(b, this.headPos);
        q(b, b, this.headElbowOffset);
        var d = n(cb);
        r(d, d, a);
        q(b, b, d);
        d = this.quatAngle_(c, z()) * db;
        var e = (1 - Math.pow(d /
                180, 4)) * (.4 + .24 * a);
        d = z();
        y(d, d, c, e);
        e = E(z(), d);
        c = N(c);
        A(c, c, e);
        e = this.wristPos;
        l(e, pb);
        t(e, e, d);
        q(e, e, ob);
        t(e, e, c);
        q(e, e, b);
        b = n(cb);
        r(b, b, a);
        q(this.position, this.wristPos, b);
        t(this.position, this.position, this.rootQ);
        this.lastTime = this.time
    };
    Ja.prototype.getPosition = function () {
        return this.position
    };
    Ja.prototype.getHeadYawOrientation_ = function () {
        var a = k();
        Y(a, this.headQ, "YXZ");
        var b = z(), c = a[1] * db;
        a = .5 * Math.PI / 180;
        var d = 0 * a;
        c *= a;
        var f = 0 * a;
        a = Math.sin(d);
        d = Math.cos(d);
        var e = Math.sin(c);
        c = Math.cos(c);
        var g =
            Math.sin(f);
        f = Math.cos(f);
        b[0] = a * c * f - d * e * g;
        b[1] = d * e * f + a * c * g;
        b[2] = d * c * g - a * e * f;
        b[3] = d * c * f + a * e * g;
        return b
    };
    Ja.prototype.clamp_ = function (a, b, c) {
        return Math.min(Math.max(a, b), c)
    };
    Ja.prototype.quatAngle_ = function (a, b) {
        var c = [0, 0, -1], d = [0, 0, -1];
        t(c, c, a);
        t(d, d, b);
        a = p(c[0], c[1], c[2]);
        d = p(d[0], d[1], d[2]);
        m(a, a);
        m(d, d);
        d = u(a, d);
        d = 1 < d ? 0 : -1 > d ? Math.PI : Math.acos(d);
        return d
    };
    $jscomp.initSymbol();
    var va = Symbol("@@webxr-polyfill/XRRemappedGamepad"), eb = {pressed: !1, touched: !1, value: 0};
    Object.freeze(eb);
    var Xa = function (b,
                       c, d) {
        d || (d = {});
        if (d.userAgentOverrides)for (var f in d.userAgentOverrides)if (navigator.userAgent.includes(f)) {
            f = d.userAgentOverrides[f];
            for (var g in f)g in d ? Object.assign(d[g], f[g]) : d[g] = f[g];
            break
        }
        g = Array(d.axes && d.axes.length ? d.axes.length : b.axes.length);
        f = Array(d.buttons && d.buttons.length ? d.buttons.length : b.buttons.length);
        var k = null;
        if (d.gripTransform) {
            var h = d.gripTransform.orientation || [0, 0, 0, 1];
            k = a();
            e(k, J(h, h), d.gripTransform.position || [0, 0, 0])
        }
        h = null;
        if (d.targetRayTransform) {
            var m = d.targetRayTransform.orientation ||
                [0, 0, 0, 1];
            h = a();
            e(h, J(m, m), d.targetRayTransform.position || [0, 0, 0])
        }
        m = d.profiles;
        d.displayProfiles && c.displayName in d.displayProfiles && (m = d.displayProfiles[c.displayName]);
        this[va] = {
            gamepad: b,
            map: d,
            profiles: m || [b.id],
            mapping: d.mapping || b.mapping,
            axes: g,
            buttons: f,
            gripTransform: k,
            targetRayTransform: h
        };
        this._update()
    };
    Xa.prototype._update = function () {
        for (var a = this[va].gamepad, b = this[va].map, c = this[va].axes, d = 0; d < c.length; ++d)c[d] = b.axes && d in b.axes ? null === b.axes[d] ? 0 : a.axes[b.axes[d]] : a.axes[d];
        if (b.axes &&
            b.axes.invert) {
            d = $jscomp.makeIterator(b.axes.invert);
            for (var f = d.next(); !f.done; f = d.next())f = f.value, f < c.length && (c[f] *= -1)
        }
        c = this[va].buttons;
        for (d = 0; d < c.length; ++d)c[d] = b.buttons && d in b.buttons ? null === b.buttons[d] ? eb : a.buttons[b.buttons[d]] : a.buttons[d]
    };
    $jscomp.global.Object.defineProperties(Xa.prototype, {
        id: {
            configurable: !0, enumerable: !0, get: function () {
                return ""
            }
        }, _profiles: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].profiles
            }
        }, index: {
            configurable: !0, enumerable: !0, get: function () {
                return -1
            }
        },
        connected: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].gamepad.connected
            }
        }, timestamp: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].gamepad.timestamp
            }
        }, mapping: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].mapping
            }
        }, axes: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].axes
            }
        }, buttons: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].buttons
            }
        }, hapticActuators: {
            configurable: !0, enumerable: !0, get: function () {
                return this[va].gamepad.hapticActuators
            }
        }
    });
    var Na = function (b, c, d, f) {
        d = void 0 === d ? 0 : d;
        f = void 0 === f ? -1 : f;
        this.polyfill = b;
        this.display = c;
        this.gamepad = this.nativeGamepad = null;
        this.inputSource = new Sa(this);
        this.lastPosition = k();
        this.emulatedPosition = !1;
        this.basePoseMatrix = a();
        this.outputMatrix = a();
        this.primaryButtonIndex = d;
        this.primaryActionPressed = !1;
        this.primarySqueezeButtonIndex = f;
        this.primarySqueezeActionPressed = !1;
        this.handedness = "";
        this.targetRayMode = "gaze";
        this.armModel = null
    };
    Na.prototype.updateFromGamepad = function (a) {
        this.nativeGamepad !==
        a && (this.gamepad = (this.nativeGamepad = a) ? new Xa(a, this.display, mb[a.id]) : null);
        this.handedness = "" === a.hand ? "none" : a.hand;
        this.gamepad && this.gamepad._update();
        a.pose ? (this.targetRayMode = "tracked-pointer", this.emulatedPosition = !a.pose.hasPosition) : "" === a.hand && (this.targetRayMode = "gaze", this.emulatedPosition = !1)
    };
    Na.prototype.updateBasePoseMatrix = function () {
        if (this.nativeGamepad && this.nativeGamepad.pose) {
            var a = this.nativeGamepad.pose, b = a.position, c = a.orientation;
            if (!b && !c)return;
            b ? (this.lastPosition[0] =
                b[0], this.lastPosition[1] = b[1], this.lastPosition[2] = b[2]) : a.hasPosition ? b = this.lastPosition : (this.armModel || (this.armModel = new Ja), this.armModel.setHandedness(this.nativeGamepad.hand), this.armModel.update(c, this.polyfill.getBasePoseMatrix()), b = this.armModel.getPosition());
            e(this.basePoseMatrix, c, b)
        } else a = this.basePoseMatrix, b = this.polyfill.getBasePoseMatrix(), a[0] = b[0], a[1] = b[1], a[2] = b[2], a[3] = b[3], a[4] = b[4], a[5] = b[5], a[6] = b[6], a[7] = b[7], a[8] = b[8], a[9] = b[9], a[10] = b[10], a[11] = b[11], a[12] = b[12], a[13] =
            b[13], a[14] = b[14], a[15] = b[15];
        return this.basePoseMatrix
    };
    Na.prototype.getXRPose = function (a, b) {
        this.updateBasePoseMatrix();
        switch (b) {
            case "target-ray":
                a._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
                this.gamepad && this.gamepad[va].targetRayTransform && d(this.outputMatrix, this.outputMatrix, this.gamepad[va].targetRayTransform);
                break;
            case "grip":
                if (!this.nativeGamepad || !this.nativeGamepad.pose)return null;
                a._transformBasePoseMatrix(this.outputMatrix, this.basePoseMatrix);
                this.gamepad &&
                this.gamepad[va].gripTransform && d(this.outputMatrix, this.outputMatrix, this.gamepad[va].gripTransform);
                break;
            default:
                return null
        }
        a._adjustForOriginOffset(this.outputMatrix);
        return new XRPose(new XRRigidTransform(this.outputMatrix), this.emulatedPosition)
    };
    $jscomp.global.Object.defineProperties(Na.prototype, {
        profiles: {
            configurable: !0,
            enumerable: !0,
            get: function () {
                return this.gamepad ? this.gamepad._profiles : []
            }
        }
    });
    var fb = {highRefreshRate: !0}, gb = {oculus: 1, openvr: 1, "spatial controller (spatial interaction source)": 1},
        qb = 0, rb = function (a, b, c) {
            c = void 0 === c ? {} : c;
            this.mode = a;
            this.enabledFeatures = b;
            this.outputContext = null;
            this.immersive = "immersive-vr" == a || "immersive-ar" == a;
            this.baseLayer = this.ended = null;
            this.id = ++qb;
            this.modifiedCanvasLayer = !1;
            this.outputContext && (this.renderContext = this.outputContext.canvas.getContext(c.renderContextType || "2d"))
        }, na = function (b, c) {
            var d = c.capabilities.canPresent;
            var f = oa.call(this, b) || this;
            f.display = c;
            f.frame = new b.VRFrameData;
            f.sessions = new Map;
            f.immersiveSession = null;
            f.canPresent =
                d;
            f.baseModelMatrix = a();
            f.gamepadInputSources = {};
            f.tempVec3 = new Float32Array(3);
            f.onVRDisplayPresentChange = f.onVRDisplayPresentChange.bind(f);
            b.window.addEventListener("vrdisplaypresentchange", f.onVRDisplayPresentChange);
            f.CAN_USE_GAMEPAD = b.navigator && "getGamepads"in b.navigator;
            f.HAS_BITMAP_SUPPORT = !(!b.ImageBitmapRenderingContext || !b.createImageBitmap);
            return f
        };
    $jscomp.inherits(na, oa);
    na.prototype.onBaseLayerSet = function (a, b) {
        var c = this, d = this.sessions.get(a), f = b.context.canvas;
        if (d.immersive) {
            a =
                this.display.getEyeParameters("left");
            var e = this.display.getEyeParameters("right");
            f.width = 2 * Math.max(a.renderWidth, e.renderWidth);
            f.height = Math.max(a.renderHeight, e.renderHeight);
            this.display.requestPresent([{source: f, attributes: fb}]).then(function () {
                c.global.document.body.contains(f) || (d.modifiedCanvasLayer = !0, c.global.document.body.appendChild(f), f.style.display = "block", f.style.position = "absolute", f.style.width = f.style.height = "1px", f.style.top = f.style.left = "0px");
                d.baseLayer = b
            })
        } else d.baseLayer =
            b
    };
    na.prototype.isSessionSupported = function (a) {
        return "immersive-ar" == a || "immersive-vr" == a && !1 === this.canPresent ? !1 : !0
    };
    na.prototype.isFeatureSupported = function (a) {
        switch (a) {
            case "viewer":
                return !0;
            case "local":
                return !0;
            case "local-floor":
                return !0;
            case "bounded":
                return !1;
            case "unbounded":
                return !1;
            default:
                return !1
        }
    };
    na.prototype.requestSession = function (a, b) {
        var c = this, d, f, e;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (g) {
            if (1 == g.nextAddress) {
                if (!c.isSessionSupported(a))return g.return(Promise.reject());
                d = "immersive-vr" == a;
                if (!d)return g.jumpTo(2);
                f = c.global.document.createElement("canvas");
                f.getContext("webgl");
                return g.yield(c.display.requestPresent([{source: f, attributes: fb}]), 2)
            }
            e = new rb(a, b, {renderContextType: c.HAS_BITMAP_SUPPORT ? "bitmaprenderer" : "2d"});
            c.sessions.set(e.id, e);
            d && (c.immersiveSession = e, c.dispatchEvent("@@webxr-polyfill/vr-present-start", e.id));
            return g.return(Promise.resolve(e.id))
        })
    };
    na.prototype.requestAnimationFrame = function (a) {
        return this.display.requestAnimationFrame(a)
    };
    na.prototype.getPrimaryButtonIndex = function (a) {
        var b = 0, c = a.id.toLowerCase(), d;
        for (d in gb)if (c.includes(d)) {
            b = gb[d];
            break
        }
        return Math.min(b, a.buttons.length - 1)
    };
    na.prototype.onFrameStart = function (a, b) {
        this.display.depthNear = b.depthNear;
        this.display.depthFar = b.depthFar;
        this.display.getFrameData(this.frame);
        a = this.sessions.get(a);
        if (a.immersive && this.CAN_USE_GAMEPAD) {
            var c = this.gamepadInputSources;
            this.gamepadInputSources = {};
            for (var d = this.global.navigator.getGamepads(), f = 0; f < d.length; ++f) {
                var e = d[f];
                if (e && 0 < e.displayId) {
                    var g = c[f];
                    g || (g = new Na(this, this.display, this.getPrimaryButtonIndex(e)));
                    g.updateFromGamepad(e);
                    this.gamepadInputSources[f] = g;
                    if (-1 != g.primaryButtonIndex) {
                        var k = e.buttons[g.primaryButtonIndex].pressed;
                        k && !g.primaryActionPressed ? this.dispatchEvent("@@webxr-polyfill/input-select-start", {
                            sessionId: a.id,
                            inputSource: g.inputSource
                        }) : !k && g.primaryActionPressed && this.dispatchEvent("@@webxr-polyfill/input-select-end", {
                            sessionId: a.id,
                            inputSource: g.inputSource
                        });
                        g.primaryActionPressed =
                            k
                    }
                    -1 != g.primarySqueezeButtonIndex && ((e = e.buttons[g.primarySqueezeButtonIndex].pressed) && !g.primarySqueezeActionPressed ? this.dispatchEvent("@@webxr-polyfill/input-squeeze-start", {
                        sessionId: a.id,
                        inputSource: g.inputSource
                    }) : !e && g.primarySqueezeActionPressed && this.dispatchEvent("@@webxr-polyfill/input-squeeze-end", {
                        sessionId: a.id,
                        inputSource: g.inputSource
                    }), g.primarySqueezeActionPressed = e)
                }
            }
        }
        !a.immersive && a.baseLayer && (a = a.baseLayer.context.canvas, h(this.frame.leftProjectionMatrix, b.inlineVerticalFieldOfView,
            a.width / a.height, b.depthNear, b.depthFar))
    };
    na.prototype.onFrameEnd = function (a) {
        a = this.sessions.get(a);
        if (!a.ended && a.baseLayer) {
            if (a.outputContext && (!a.immersive || this.display.capabilities.hasExternalDisplay)) {
                var b = a.baseLayer.context.canvas, c = a.immersive && this.display.capabilities.hasExternalDisplay ? b.width / 2 : b.width, d = b.height, f = a.outputContext.canvas, e = f.width;
                f = f.height;
                var g = a.renderContext;
                this.HAS_BITMAP_SUPPORT ? b.transferToImageBitmap ? g.transferFromImageBitmap(b.transferToImageBitmap()) :
                    this.global.createImageBitmap(b, 0, 0, c, d, {resizeWidth: e, resizeHeight: f}).then(function (a) {
                        return g.transferFromImageBitmap(a)
                    }) : g.drawImage(b, 0, 0, c, d, 0, 0, e, f)
            }
            a.immersive && a.baseLayer && this.display.submitFrame()
        }
    };
    na.prototype.cancelAnimationFrame = function (a) {
        this.display.cancelAnimationFrame(a)
    };
    na.prototype.endSession = function (a) {
        var b = this, c;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (d) {
            c = b.sessions.get(a);
            if (c.ended)return d.return();
            if (c.immersive)return d.return(b.display.exitPresent());
            c.ended = !0;
            d.jumpToEnd()
        })
    };
    na.prototype.doesSessionSupportReferenceSpace = function (a, b) {
        a = this.sessions.get(a);
        return a.ended ? !1 : a.enabledFeatures.has(b)
    };
    na.prototype.requestStageBounds = function () {
        if (this.display.stageParameters) {
            var a = this.display.stageParameters.sizeX, b = this.display.stageParameters.sizeZ, c = [];
            c.push(-a / 2);
            c.push(-b / 2);
            c.push(a / 2);
            c.push(-b / 2);
            c.push(a / 2);
            c.push(b / 2);
            c.push(-a / 2);
            c.push(b / 2);
            return c
        }
        return null
    };
    na.prototype.requestFrameOfReferenceTransform = function (a, b) {
        var c =
            this;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (b) {
            return ("local-floor" === a || "bounded-floor" === a) && c.display.stageParameters && c.display.stageParameters.sittingToStandingTransform ? b.return(c.display.stageParameters.sittingToStandingTransform) : b.return(null)
        })
    };
    na.prototype.getProjectionMatrix = function (a) {
        if ("left" === a)return this.frame.leftProjectionMatrix;
        if ("right" === a)return this.frame.rightProjectionMatrix;
        if ("none" === a)return this.frame.leftProjectionMatrix;
        throw Error("eye must be of type 'left' or 'right'");
    };
    na.prototype.getViewport = function (a, b, c, d) {
        a = this.sessions.get(a);
        var f = c.context.canvas;
        c = f.width;
        f = f.height;
        if (!a.immersive)return d.x = d.y = 0, d.width = c, d.height = f, !0;
        if ("left" === b || "none" === b)d.x = 0; else if ("right" === b)d.x = c / 2; else return !1;
        d.y = 0;
        d.width = c / 2;
        d.height = f;
        return !0
    };
    na.prototype.getBasePoseMatrix = function () {
        var a = this.frame.pose, b = a.position;
        a = a.orientation;
        if (!b && !a)return this.baseModelMatrix;
        b || (b = this.tempVec3, b[0] = b[1] = b[2] = 0);
        e(this.baseModelMatrix, a, b);
        return this.baseModelMatrix
    };
    na.prototype.getBaseViewMatrix = function (a) {
        if ("left" === a || "none" === a)return this.frame.leftViewMatrix;
        if ("right" === a)return this.frame.rightViewMatrix;
        throw Error("eye must be of type 'left' or 'right'");
    };
    na.prototype.getInputSources = function () {
        var a = [], b;
        for (b in this.gamepadInputSources)a.push(this.gamepadInputSources[b].inputSource);
        return a
    };
    na.prototype.getInputPose = function (a, b, c) {
        if (!b)return null;
        for (var d in this.gamepadInputSources) {
            var f = this.gamepadInputSources[d];
            if (f.inputSource ===
                a)return f.getXRPose(b, c)
        }
        return null
    };
    na.prototype.onWindowResize = function () {
    };
    na.prototype.onVRDisplayPresentChange = function (a) {
        var b = this;
        this.display.isPresenting || this.sessions.forEach(function (a) {
            if (a.immersive && !a.ended) {
                if (a.modifiedCanvasLayer) {
                    var c = a.baseLayer.context.canvas;
                    document.body.removeChild(c);
                    c.setAttribute("style", "")
                }
                b.immersiveSession === a && (b.immersiveSession = null);
                b.dispatchEvent("@@webxr-polyfill/vr-present-end", a.id)
            }
        })
    };
    $jscomp.global.Object.defineProperties(na.prototype,
        {
            depthNear: {
                configurable: !0, enumerable: !0, get: function () {
                    return this.display.depthNear
                }, set: function (a) {
                    this.display.depthNear = a
                }
            }, depthFar: {
            configurable: !0, enumerable: !0, get: function () {
                return this.display.depthFar
            }, set: function (a) {
                this.display.depthFar = a
            }
        }
        });
    var hb = function (a, b) {
        b = new lb(b || {});
        a = na.call(this, a, b) || this;
        a.display = b;
        a.frame = {
            rightViewMatrix: new Float32Array(16),
            leftViewMatrix: new Float32Array(16),
            rightProjectionMatrix: new Float32Array(16),
            leftProjectionMatrix: new Float32Array(16),
            pose: null,
            timestamp: null
        };
        return a
    };
    $jscomp.inherits(hb, na);
    var sb = 0, tb = function (a, b) {
        this.mode = a;
        this.enabledFeatures = b;
        this.baseLayer = this.ended = null;
        this.id = ++sb
    }, ra = function (b) {
        b = oa.call(this, b) || this;
        b.sessions = new Map;
        b.projectionMatrix = a();
        b.identityMatrix = a();
        return b
    };
    $jscomp.inherits(ra, oa);
    ra.prototype.onBaseLayerSet = function (a, b) {
        this.sessions.get(a).baseLayer = b
    };
    ra.prototype.isSessionSupported = function (a) {
        return "inline" == a
    };
    ra.prototype.isFeatureSupported = function (a) {
        switch (a) {
            case "viewer":
                return !0;
            default:
                return !1
        }
    };
    ra.prototype.requestSession = function (a, b) {
        var c = this, d;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (f) {
            if (!c.isSessionSupported(a))return f.return(Promise.reject());
            d = new tb(a, b);
            c.sessions.set(d.id, d);
            return f.return(Promise.resolve(d.id))
        })
    };
    ra.prototype.requestAnimationFrame = function (a) {
        return window.requestAnimationFrame(a)
    };
    ra.prototype.cancelAnimationFrame = function (a) {
        window.cancelAnimationFrame(a)
    };
    ra.prototype.onFrameStart = function (a, b) {
        a = this.sessions.get(a);
        a.baseLayer && (a = a.baseLayer.context.canvas, h(this.projectionMatrix, b.inlineVerticalFieldOfView, a.width / a.height, b.depthNear, b.depthFar))
    };
    ra.prototype.onFrameEnd = function (a) {
    };
    ra.prototype.endSession = function (a) {
        var b = this, c;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (d) {
            c = b.sessions.get(a);
            c.ended = !0;
            d.jumpToEnd()
        })
    };
    ra.prototype.doesSessionSupportReferenceSpace = function (a, b) {
        a = this.sessions.get(a);
        return a.ended ? !1 : a.enabledFeatures.has(b)
    };
    ra.prototype.requestStageBounds = function () {
        return null
    };
    ra.prototype.requestFrameOfReferenceTransform = function (a, b) {
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (a) {
            return a.return(null)
        })
    };
    ra.prototype.getProjectionMatrix = function (a) {
        return this.projectionMatrix
    };
    ra.prototype.getViewport = function (a, b, c, d) {
        this.sessions.get(a);
        b = c.context.canvas;
        a = b.width;
        b = b.height;
        d.x = d.y = 0;
        d.width = a;
        d.height = b;
        return !0
    };
    ra.prototype.getBasePoseMatrix = function () {
        return this.identityMatrix
    };
    ra.prototype.getBaseViewMatrix = function (a) {
        return this.identityMatrix
    };
    ra.prototype.getInputSources = function () {
        return []
    };
    ra.prototype.getInputPose = function (a, b, c) {
        return null
    };
    ra.prototype.onWindowResize = function () {
    };
    var ub = function (a) {
        var b, c;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (d) {
            switch (d.nextAddress) {
                case 1:
                    b = null;
                    if (!("getVRDisplays"in a.navigator)) {
                        d.jumpTo(2);
                        break
                    }
                    d.setCatchFinallyBlocks(3);
                    return d.yield(a.navigator.getVRDisplays(), 5);
                case 5:
                    (c = d.yieldResult) && c.length && (b = new na(a, c[0]));
                    d.leaveTryBlock(2);
                    break;
                case 3:
                    d.enterCatchBlock();
                case 2:
                    return d.return(b)
            }
        })
    }, vb = function (a, b) {
        var c, d;
        return $jscomp.asyncExecutePromiseGeneratorProgram(function (f) {
            return 1 == f.nextAddress ? b.webvr ? f.yield(ub(a), 3) : f.jumpTo(2) : 2 != f.nextAddress && (c = f.yieldResult) ? f.return(c) : (d = jb(a)) && b.cardboard || !d && b.allowCardboardOnDesktop ? (a.VRFrameData || (a.VRFrameData = function () {
                this.rightViewMatrix = new Float32Array(16);
                this.leftViewMatrix = new Float32Array(16);
                this.rightProjectionMatrix = new Float32Array(16);
                this.leftProjectionMatrix = new Float32Array(16);
                this.pose = null
            }), f.return(new hb(a, b.cardboardConfig))) : f.return(new ra(a))
        })
    }, wb = {
        global: Q,
        webvr: !0,
        cardboard: !0,
        cardboardConfig: null,
        allowCardboardOnDesktop: !1
    }, Qa = ["navigator", "HTMLCanvasElement", "WebGLRenderingContext"], Ra = function (a) {
        a = void 0 === a ? {} : a;
        this.config = Object.freeze(Object.assign({}, wb, a));
        this.global = this.config.global;
        this.nativeWebXR = "xr"in this.global.navigator;
        this.injected = !1;
        this.nativeWebXR ? this._injectCompatibilityShims(this.global) : this._injectPolyfill(this.global)
    };
    Ra.prototype._injectPolyfill =
        function (a) {
            if (!Qa.every(function (b) {
                    return !!a[b]
                }))throw Error("Global must have the following attributes : " + Qa);
            for (var b = $jscomp.makeIterator(Object.keys(Ua)), c = b.next(); !c.done; c = b.next())c = c.value, void 0 !== a[c] ? console.warn(c + " already defined on global.") : a[c] = Ua[c];
            Za(a.WebGLRenderingContext) && ($a(a.HTMLCanvasElement), a.OffscreenCanvas && $a(a.OffscreenCanvas), a.WebGL2RenderingContext && Za(a.WebGL2RenderingContext), window.isSecureContext || console.warn("WebXR Polyfill Warning:\nThis page is not running in a secure context (https:// or localhost)!\nThis means that although the page may be able to use the WebXR Polyfill it will\nnot be able to use native WebXR implementations, and as such will not be able to\naccess dedicated VR or AR hardware, and will not be able to take advantage of\nany performance improvements a native WebXR implementation may offer. Please\nhost this content on a secure origin for the best user experience.\n"));
            this.injected = !0;
            this._patchNavigatorXR()
        };
    Ra.prototype._patchNavigatorXR = function () {
        var a = vb(this.global, this.config);
        this.xr = new Ua.XRSystem(a);
        Object.defineProperty(this.global.navigator, "xr", {value: this.xr, configurable: !0})
    };
    Ra.prototype._injectCompatibilityShims = function (a) {
        if (!Qa.every(function (b) {
                return !!a[b]
            }))throw Error("Global must have the following attributes : " + Qa);
        if (a.navigator.xr && "supportsSession"in a.navigator.xr && !("isSessionSupported"in a.navigator.xr)) {
            var b = a.navigator.xr.supportsSession;
            a.navigator.xr.isSessionSupported = function (a) {
                return b.call(this, a).then(function () {
                    return !0
                }).catch(function () {
                    return !1
                })
            };
            a.navigator.xr.supportsSession = function (a) {
                console.warn("navigator.xr.supportsSession() is deprecated. Please call navigator.xr.isSessionSupported() instead and check the boolean value returned when the promise resolves.");
                return b.call(this, a)
            }
        }
    };
    return Ra
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	!function() {
/******/ 		__webpack_require__.amdO = {};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.hmd = function(module) {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: function() {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
!function() {
"use strict";
/*!*************************!*\
  !*** ./index.editor.js ***!
  \*************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _vendor_jquery_3_4_1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./vendor/jquery-3.4.1.js */ "./vendor/jquery-3.4.1.js");
/* harmony import */ var _vendor_jquery_3_4_1_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_vendor_jquery_3_4_1_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _vendor_fullscreen_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vendor/fullscreen.js */ "./vendor/fullscreen.js");
/* harmony import */ var _vendor_fullscreen_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_vendor_fullscreen_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _src_App_editor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/App.editor.js */ "./src/App.editor.js");
/* harmony import */ var _SceneLoadConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./SceneLoadConfig.js */ "./SceneLoadConfig.js");
/* harmony import */ var _SceneLoadConfig_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_SceneLoadConfig_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _ui_AssetsManager_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui/AssetsManager.js */ "./ui/AssetsManager.js");
/* harmony import */ var _ui_AnimateManager_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ui/AnimateManager.js */ "./ui/AnimateManager.js");
/* harmony import */ var _src_extend_j3dExtends_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/extend/j3dExtends.js */ "./src/extend/j3dExtends.js");
/**
 * Created by Kai on 2021/2/22.
 */

//import './src/lib/three.js'
//import './vendor/three.js-r130/build/three.js'
//import './vendor/__three-new/build/three.js'

//import './Config.js'
//import './src/lib/querystring.js'



//编辑模式
//import Editor from './src/App.editor.js'//编辑模式
JMT.Editor = _src_App_editor_js__WEBPACK_IMPORTED_MODULE_2__.Editor

//import UI from './ui/UI.js'
//JMT.UiEventDelegate = UI
;




}();
window.JMK = __webpack_exports__["default"];
/******/ })()
;
//# sourceMappingURL=editor.js.map